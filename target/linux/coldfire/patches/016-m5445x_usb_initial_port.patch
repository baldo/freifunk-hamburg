From 6694c72448723499ce8a8603b4830bbd9d2fa0df Mon Sep 17 00:00:00 2001
From: Bruce Schmid <duck@freescale.com>
Date: Tue, 20 Nov 2007 11:06:14 -0700
Subject: [PATCH] USB: initial port

LTIBName: m5445x-usb-initial-port
Signed-off-by: Duck <duck@freescale.com>
---
 arch/m68k/coldfire/usb.c            |  182 +++
 arch/m68k/coldfire/usb/Makefile     |   28 +
 arch/m68k/coldfire/usb/otg_cmn.c    |  106 ++
 arch/m68k/coldfire/usb/otg_device.c |   89 ++
 arch/m68k/coldfire/usb/otg_host.c   |   68 +
 arch/m68k/coldfire/usb/otg_otg.c    |   96 ++
 arch/m68k/coldfire/usb/xcvr.c       |  156 ++
 drivers/usb/Kconfig                 |    1 +
 drivers/usb/Makefile                |    2 +
 drivers/usb/core/usb.c              |    2 +-
 drivers/usb/gadget/Kconfig          |   43 +-
 drivers/usb/gadget/Makefile         |    1 +
 drivers/usb/gadget/ether.c          |    3 +
 drivers/usb/gadget/fsl_usb2_udc.h   |  194 +---
 drivers/usb/gadget/gadget_chips.h   |    7 +
 drivers/usb/gadget/mcf5445x_udc.c   | 2758 +++++++++++++++++++++++++++++++++++
 drivers/usb/host/Kconfig            |   21 +-
 drivers/usb/host/ehci-arc.c         |  431 ++++++
 drivers/usb/host/ehci-fsl.h         |   28 +-
 drivers/usb/host/ehci-hcd.c         |    5 +
 drivers/usb/host/ehci-mem.c         |    9 +-
 drivers/usb/host/ehci.h             |   22 +
 drivers/usb/otg/Makefile            |    5 +
 drivers/usb/otg/fsl_otg.c           | 1515 +++++++++++++++++++
 drivers/usb/otg/fsl_otg.h           |  139 ++
 drivers/usb/otg/otg_fsm.c           |  381 +++++
 drivers/usb/otg/otg_fsm.h           |  170 +++
 include/asm-m68k/mcf5445x_usb.h     |    3 +-
 include/linux/fsl_devices.h         |   42 +-
 include/linux/usb/fsl_usb2.h        |  464 ++++++
 include/linux/usb/fsl_xcvr.h        |   42 +
 31 files changed, 6809 insertions(+), 204 deletions(-)
 create mode 100644 arch/m68k/coldfire/usb.c
 create mode 100644 arch/m68k/coldfire/usb/Makefile
 create mode 100644 arch/m68k/coldfire/usb/otg_cmn.c
 create mode 100644 arch/m68k/coldfire/usb/otg_device.c
 create mode 100644 arch/m68k/coldfire/usb/otg_host.c
 create mode 100644 arch/m68k/coldfire/usb/otg_otg.c
 create mode 100644 arch/m68k/coldfire/usb/xcvr.c
 create mode 100644 drivers/usb/gadget/mcf5445x_udc.c
 create mode 100644 drivers/usb/host/ehci-arc.c
 create mode 100644 drivers/usb/otg/Makefile
 create mode 100644 drivers/usb/otg/fsl_otg.c
 create mode 100644 drivers/usb/otg/fsl_otg.h
 create mode 100644 drivers/usb/otg/otg_fsm.c
 create mode 100644 drivers/usb/otg/otg_fsm.h
 create mode 100644 include/linux/usb/fsl_usb2.h
 create mode 100644 include/linux/usb/fsl_xcvr.h

--- /dev/null
+++ b/arch/m68k/coldfire/usb.c
@@ -0,0 +1,182 @@
+/*
+ *
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+struct fsl_xcvr_ops *xc_ops[3] = { NULL };
+
+void fsl_usb_enable_clk(void)
+{
+}
+EXPORT_SYMBOL(fsl_usb_enable_clk);
+
+void fsl_usb_disable_clk(void)
+{
+}
+EXPORT_SYMBOL(fsl_usb_disable_clk);
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	pr_debug("%s ctrlr=%d\n", __FUNCTION__, xcvr_ops->ctrlr);
+	xc_ops[xcvr_ops->ctrlr] = xcvr_ops;
+
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_usb_xcvr_unregister(enum fsl_usb_ctrlr ctrlr)
+{
+	pr_debug("%s ctrlr=%d\n", __FUNCTION__, ctrlr);
+	xc_ops[ctrlr] = NULL;
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * DDD fix this comment:
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id;
+struct platform_device *host_pdev_register(struct resource *res, int n_res,
+					  struct fsl_usb2_platform_data *config)
+{
+	struct platform_device *pdev;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		printk(KERN_ERR "usb: can't register %s Host, %ld\n",
+		       config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platform_data pointer ourselves.
+	 */
+	pdev->dev.platform_data = config;
+
+	printk(KERN_INFO "usb: %s Host registered\n", config->name);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	instance_id++;
+
+	return pdev;
+}
+
+
+int fsl_usb_mem_init(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no MEM resource.\n");
+		return -ENODEV;
+	}
+
+	pdata->r_start = res->start;
+	pdata->r_len = res->end - res->start + 1;
+	pr_debug("%s: MEM resource start=0x%x  len=0x%x\n", pdata->name,
+		 res->start, pdata->r_len);
+
+	if (!request_mem_region(pdata->r_start, pdata->r_len, "OTG")) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		return -EBUSY;
+	}
+	pdata->regs = ioremap(pdata->r_start, pdata->r_len);
+	pr_debug("ioremapped to 0x%p\n", pdata->regs);
+
+	if (pdata->regs == NULL) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		release_mem_region(pdata->r_start, pdata->r_len);
+		return -EFAULT;
+	}
+
+	pr_debug("%s: success\n", __FUNCTION__);
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	pr_debug("%s xceiv=0x%p\n", __FUNCTION__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	pr_debug("%s xceiv=0x%p  x=0x%p\n", __FUNCTION__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+#endif
--- /dev/null
+++ b/arch/m68k/coldfire/usb/Makefile
@@ -0,0 +1,28 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+ifneq ($(CONFIG_USB_EHCI_HCD),)
+	obj-y	+= otg_host.o
+endif
+
+ifneq ($(CONFIG_USB_GADGET_MCF5445X),)
+	obj-y	+= otg_device.o
+endif
+
+ifneq ($(strip $(CONFIG_USB_GADGET_MCF5445X) $(CONFIG_USB_EHCI_HCD)),)
+	obj-y	+= otg_cmn.o
+endif
+
+ifneq ($(CONFIG_USB_OTG),)
+	obj-y	+= otg_otg.o
+endif
+
+
+# USB Transceiver driver:
+ifneq ($(strip $(CONFIG_USB) $(CONFIG_USB_GADGET_MCF5445X)),)
+	obj-y	+= xcvr.o
+endif
+
--- /dev/null
+++ b/arch/m68k/coldfire/usb/otg_cmn.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/system.h>
+#include <asm/coldfire.h>
+
+extern void fsl_usb_enable_clk(void);
+extern void fsl_usb_disable_clk(void);
+extern int fsl_usb_mem_init(struct platform_device *pdev);
+
+extern struct fsl_xcvr_ops *xc_ops[];
+
+static int otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	struct fsl_xcvr_ops *xops = xc_ops[USB_CTRLR_OTG];
+	int rc;
+
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __FUNCTION__, pdev, pdata);
+
+	if (!xops) {
+		printk(KERN_ERR "OTG transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+
+	if (!otg_used) {
+		/* request_mem_region and ioremap registers */
+		rc = fsl_usb_mem_init(pdev);
+		if (rc)
+			return rc;
+
+		fsl_usb_enable_clk();
+
+		if (xops->init)
+			xops->init(pdev);
+	}
+
+	otg_used++;
+	pr_debug("%s: success\n", __FUNCTION__);
+	return 0;
+}
+
+void usbotg_uninit(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	pr_debug("%s\n", __FUNCTION__);
+
+	otg_used--;
+	if (!otg_used) {
+		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+			pdata->xcvr_ops->uninit(pdev);
+
+		iounmap(pdata->regs);
+		release_mem_region(pdata->r_start, pdata->r_len);
+
+		pdata->regs = NULL;
+		pdata->r_start = pdata->r_len = 0;
+
+		fsl_usb_disable_clk();
+	}
+}
+
+struct fsl_usb2_platform_data mxc_otg_config = {
+	.name            = "OTG",
+	.platform_init   = usbotg_init,
+	.platform_uninit = usbotg_uninit,
+	.es              = 1,
+	.big_endian_mmio = 1,
+	.big_endian_desc = 1,
+	.le_setup_buf    = 1,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+	.max_ep_nr       = 4,		/* DDD read from a register ? */
+	.phy_mode	 = FSL_USB2_PHY_ULPI, /* DDD redundant with xcvr_type */
+};
--- /dev/null
+++ b/arch/m68k/coldfire/usb/otg_device.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/otg.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/system.h>
+#include <asm/coldfire.h>
+
+#define USB_OTGREGS_BASE MCF_REG32(0xFC0B0000)
+#define INT_USB		(64 + 64 + 47)	/* INTC1:47 16.2.9.1 */
+#define INT_UOCSR	(64 + 64 + 53)	/* INTC1:53 16.2.9.1 */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct fsl_usb2_platform_data mxc_otg_config;
+
+struct platform_device otg_udc_device;
+
+/*!
+ * OTG Gadget device
+ */
+
+static void usb_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+static u64 udc_dmamask = ~(u32) 0;
+static struct resource otg_udc_resources[] = {
+	[0] = {
+		.start = (u32) (&USB_OTGREGS_BASE),
+		.end   = (u32) (&USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_USB,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+
+struct platform_device otg_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = usb_release,
+		.dma_mask          = &udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &mxc_otg_config,
+		},
+	.resource = otg_udc_resources,
+	.num_resources = ARRAY_SIZE(otg_udc_resources),
+};
+
+static int __init udc_init(void)
+{
+	int rc __attribute((unused));
+
+	rc = platform_device_register(&otg_udc_device);
+	if (rc)
+		printk(KERN_ERR "usb: can't register OTG Gadget, rc=%d\n", rc);
+	else
+		printk(KERN_INFO "usb: OTG Gadget registered\n");
+	return rc;
+}
+
+subsys_initcall(udc_init);
--- /dev/null
+++ b/arch/m68k/coldfire/usb/otg_host.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <asm/system.h>
+#include <asm/mcfsim.h>
+
+#define USB_OTGREGS_BASE MCF_REG32(0xFC0B0000)
+#define INT_USB		(64 + 64 + 47)	/* INTC1:47 16.2.9.1 */
+#define INT_UOCSR	(64 + 64 + 53)	/* INTC1:53 16.2.9.1 */
+
+struct platform_device *otg_host_device;
+
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct fsl_usb2_platform_data mxc_otg_config;
+
+/*!
+ * OTG host config
+ */
+static struct resource otg_host_resources[] = {
+	[0] = {
+		.start = (u32) (&USB_OTGREGS_BASE),
+		.end   = (u32) (&USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_USB,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int __init otg_host_init(void)
+{
+	otg_host_device = host_pdev_register(otg_host_resources,
+					     ARRAY_SIZE(otg_host_resources),
+					     &mxc_otg_config);
+	return 0;
+}
+
+subsys_initcall(otg_host_init);
--- /dev/null
+++ b/arch/m68k/coldfire/usb/otg_otg.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * platform_device registration for ULPI OTG device
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+
+#include <asm/mcfsim.h>
+
+#define USB_OTGREGS_BASE MCF_REG32(0xFC0B0000)
+#define INT_USB		(64 + 64 + 47)	/* INTC1:47 16.2.9.1 */
+#define INT_UOCSR	(64 + 64 + 53)	/* INTC1:53 16.2.9.1 */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct fsl_usb2_platform_data mxc_otg_config;
+
+static void otg_otg_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+/* *INDENT-OFF* */
+static struct resource otg_otg_resources[] = {
+	[0] = {
+		.start = (u32) (&USB_OTGREGS_BASE),
+		.end   = (u32) (&USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_USB,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*!
+ * OTG device
+ */
+static u64 otg_otg_dmamask = ~(u32) 0;
+static struct platform_device otg_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id   = -1,
+	.dev  = {
+		.release           = otg_otg_release,
+		.dma_mask          = &otg_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &mxc_otg_config,
+	},
+	.resource = otg_otg_resources,
+	.num_resources = ARRAY_SIZE(otg_otg_resources),
+};
+/* *INDENT-ON* */
+
+static int __init mx31_otg_otg_init(void)
+{
+	int rc = 0;
+
+	pr_debug("register OTG otg res=0x%p, size=%d\n",
+		 otg_otg_device.resource, otg_otg_device.num_resources);
+
+	rc = platform_device_register(&otg_otg_device);
+	if (rc) {
+		pr_debug("can't register ULPI OTG dvc, %d\n", rc);
+	} else {
+		printk(KERN_INFO "usb: OTG ULPI transceiver registered\n");
+		pr_debug("otg_otg_device=0x%p  resources=0x%p.\n",
+			 &otg_otg_device, otg_otg_device.resource);
+	}
+
+	return rc;
+}
+
+subsys_initcall(mx31_otg_otg_init);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("ULPI OTG device registration");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/arch/m68k/coldfire/usb/xcvr.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/usb/fsl_usb2.h>
+
+#include <asm/mcfsim.h>
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+extern void fsl_usb_xcvr_unregister(enum fsl_usb_ctrlr ctrlr);
+
+#define MCF_SCM_BCR		MCF_REG32(0xFC040024)
+#define MCF_SCM_BCR_GBR		(1 << 9)	/* global bursts for read */
+#define MCF_SCM_BCR_GBW		(1 << 8)	/* global bursts for write */
+#define MCF_SCM_BCR_SBE_ALL	(0xff << 0)	/* slave burst enable */
+
+
+#ifdef ULPI_DEBUG
+void print_ulpi_regs(void)
+{
+	pr_debug("MCF_SCM_BCR=0x%08lx  MCF_CCM_MISCCR=0x%08x  "
+		 "MCF_GPIO_PAR_DMA=0x%08x  MCF_GPIO_PAR_USB=08%08x  "
+		 "MCF_GPIO_PAR_FEC=08%08x\n",
+		 MCF_SCM_BCR, MCF_CCM_MISCCR, MCF_GPIO_PAR_DMA,
+		 MCF_GPIO_PAR_USB, MCF_GPIO_PAR_FEC);
+}
+EXPORT_SYMBOL(print_ulpi_regs);
+#endif
+
+
+static void xcvr_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *this = pdata->xcvr_ops;
+	struct fsl_usb_host_regs *regs = pdata->regs;
+
+	pr_debug("%s: ctrlr=%d  pdata=0x%p  regs=0x%p\n", __FUNCTION__,
+		 this->ctrlr, pdata, pdata->regs);
+
+	/* enable USB read, write and slave bursts */
+	MCF_SCM_BCR = MCF_SCM_BCR_GBR | MCF_SCM_BCR_GBW | MCF_SCM_BCR_SBE_ALL;
+
+	/* Use external clock source if PLL isn't a multiple of 60MHz */
+	MCF_CCM_MISCCR &= ~MCF_CCM_MISCCR_USBSRC;
+
+	/* Initialize the USB Clock: use USB input clock */
+	MCF_GPIO_PAR_DMA = (MCF_GPIO_PAR_DMA & MCF_GPIO_PAR_DMA_DREQ1_MASK) |
+			   MCF_GPIO_PAR_DMA_DREQ1_USB_CLKIN;
+
+	switch (this->xcvr_type) {
+	case PORTSCX_PTS_ULPI:
+		/* Enable the required ULPI signals */
+		MCF_GPIO_PAR_DMA = (MCF_GPIO_PAR_DMA &
+				    MCF_GPIO_PAR_DMA_DACK1_MASK) |
+				    MCF_GPIO_PAR_DMA_DACK1_ULPI_DIR;
+
+		MCF_GPIO_PAR_USB = MCF_GPIO_PAR_USB_VBUSEN_ULPI_NXT |
+				   MCF_GPIO_PAR_USB_VBUSOC_ULPI_STP;
+
+		MCF_GPIO_PAR_FEC = (MCF_GPIO_PAR_FEC &
+				    MCF_GPIO_PAR_FEC_FEC0_MASK) |
+				    MCF_GPIO_PAR_FEC_FEC0_RMII_ULPI;
+		break;
+	case PORTSCX_PTS_ONCHIP:
+		/* Enable VBUS_EN and VBUS_OC signals */
+		MCF_GPIO_PAR_USB = MCF_GPIO_PAR_USB_VBUSEN_VBUSEN |
+				   MCF_GPIO_PAR_USB_VBUSOC_VBUSOC;
+
+		/* Setup USB_VBUS_OC signal to be active-low */
+		MCF_CCM_MISCCR |= MCF_CCM_MISCCR_USBOC;
+
+		break;
+	}
+
+	pr_debug("&regs->portsc1=0x%p  old portsc1=0x%x \n", &regs->portsc1,
+		 regs->portsc1);
+
+	regs->portsc1 &= ~PORTSCX_PTS_MASK;
+	regs->portsc1 |= this->xcvr_type;
+
+	/*
+	 * need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	regs->usbcmd |= USB_CMD_CTRL_RESET;
+
+	/*
+	 * allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(10);
+
+	pr_debug("DDD %s: done.  portsc1=0x%x\n", __FUNCTION__, regs->portsc1);
+}
+
+static void xcvr_uninit(struct platform_device *pdev)
+{
+	pr_debug("%s: pdev=0x%p\n", __FUNCTION__, pdev);
+}
+
+
+struct fsl_xcvr_ops xcvr_ops_otg = {
+	.ctrlr          = USB_CTRLR_OTG,
+	.init           = xcvr_init,
+	.uninit         = xcvr_uninit,
+
+#ifdef CONFIG_USB_M5445X_ULPI
+	.xcvr_type      = PORTSCX_PTS_ULPI,
+#elif defined CONFIG_USB_M5445X_FSLS
+	.xcvr_type      = PORTSCX_PTS_ONCHIP,
+#else
+#error "Invalid USB transceiver selection."
+#endif
+};
+
+static int __init usb_xcvr_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&xcvr_ops_otg);
+
+	pr_debug("%s done\n", __FUNCTION__);
+	return 0;
+}
+
+static void __exit usb_xcvr_exit(void)
+{
+	fsl_usb_xcvr_unregister(USB_CTRLR_OTG);
+}
+
+module_init(usb_xcvr_init);
+module_exit(usb_xcvr_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("External ULPI xcvr driver");
+MODULE_LICENSE("GPL");
+
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -55,6 +55,7 @@ config USB_ARCH_HAS_EHCI
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
+	default y if M54455
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -32,3 +32,5 @@ obj-$(CONFIG_USB)		+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_USB_OTG)		+= otg/
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -52,7 +52,7 @@ static int nousb;	/* Disable USB when bu
 struct workqueue_struct *ksuspend_usb_wq;
 
 #ifdef	CONFIG_USB_SUSPEND
-static int usb_autosuspend_delay = 2;		/* Default delay value,
+static int usb_autosuspend_delay = -1;		/* Default delay value,
 						 * in seconds */
 module_param_named(autosuspend, usb_autosuspend_delay, int, 0644);
 MODULE_PARM_DESC(autosuspend, "default autosuspend delay");
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -231,6 +231,26 @@ config SUPERH_BUILT_IN_M66592
 	   However, this problem is improved if change a value of
 	   NET_IP_ALIGN to 4.
 
+config USB_GADGET_MCF5445X
+	boolean "MCF5445X USB Device Controller"
+	depends on M54455 && USB_M5445X_ULPI
+	select USB_GADGET_DUALSPEED
+	help
+	   Freescale's MCF5445X processors include
+	   an integrated device controller (as part of the OTG module).
+	   It has four programmable, bidirectional endpoints,
+	   including endpoint 0.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "mcf5445_udc" and force all
+	   gadget drivers to also be dynamically linked.
+
+config USB_MCF5445X
+	tristate
+	depends on USB_GADGET_MCF5445X
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_GADGET_GOKU
 	boolean "Toshiba TC86C001 'Goku-S'"
 	depends on PCI
@@ -285,17 +305,6 @@ config USB_OMAP
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
-config USB_OTG
-	boolean "OTG Support"
-	depends on USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD
-	help
-	   The most notable feature of USB OTG is support for a
-	   "Dual-Role" device, which can act as either a device
-	   or a host.  The initial role choice can be changed
-	   later, when two dual-role devices talk to each other.
-
-	   Select this only if your OMAP board has a Mini-AB connector.
-
 config USB_GADGET_S3C2410
 	boolean "S3C2410 USB Device Controller"
 	depends on ARCH_S3C2410
@@ -369,6 +378,18 @@ config USB_DUMMY_HCD
 
 endchoice
 
+config USB_OTG
+	boolean "OTG Support"
+	depends on (USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD) || \
+		   (USB_GADGET_MCF5445X && USB_M5445X_ULPI)
+	help
+	   The most notable feature of USB OTG is support for a
+	   "Dual-Role" device, which can act as either a device
+	   or a host.  The initial role choice can be changed
+	   later, when two dual-role devices talk to each other.
+
+	   Select this only if your OMAP board has a Mini-AB connector.
+
 config USB_GADGET_DUALSPEED
 	bool
 	depends on USB_GADGET
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_USB_AT91)		+= at91_udc.o
 obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
 obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
+obj-$(CONFIG_USB_MCF5445X)	+= mcf5445x_udc.o
 
 #
 # USB gadget drivers
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -287,6 +287,9 @@ MODULE_PARM_DESC(host_addr, "Host Ethern
 #define	DEV_CONFIG_CDC
 #endif
 
+#ifdef CONFIG_USB_GADGET_MCF5445X
+#define DEV_CONFIG_CDC
+#endif
 
 /*-------------------------------------------------------------------------*/
 
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -83,16 +83,6 @@ struct usb_dr_host {
 	u32 endptctrl[6];	/* Endpoint Control Registers */
 };
 
- /* non-EHCI USB system interface registers (Big Endian) */
-struct usb_sys_interface {
-	u32 snoop1;
-	u32 snoop2;
-	u32 age_cnt_thresh;	/* Age Count Threshold Register */
-	u32 pri_ctrl;		/* Priority Control Register */
-	u32 si_ctrl;		/* System Interface Control Register */
-	u8 res[236];
-	u32 control;		/* General Purpose Control Register */
-};
 
 /* ep0 transfer state */
 #define WAIT_FOR_SETUP          0
@@ -101,10 +91,6 @@ struct usb_sys_interface {
 #define WAIT_FOR_OUT_STATUS     3
 #define DATA_STATE_RECV         4
 
-/* Device Controller Capability Parameter register */
-#define DCCPARAMS_DC				0x00000080
-#define DCCPARAMS_DEN_MASK			0x0000001f
-
 /* Frame Index Register Bit Masks */
 #define	USB_FRINDEX_MASKS			0x3fff
 /* USB CMD  Register Bit Masks */
@@ -180,172 +166,6 @@ struct usb_sys_interface {
 /* endpoint list address bit masks */
 #define USB_EP_LIST_ADDRESS_MASK              0xfffff800
 
-/* PORTSCX  Register Bit Masks */
-#define  PORTSCX_CURRENT_CONNECT_STATUS       0x00000001
-#define  PORTSCX_CONNECT_STATUS_CHANGE        0x00000002
-#define  PORTSCX_PORT_ENABLE                  0x00000004
-#define  PORTSCX_PORT_EN_DIS_CHANGE           0x00000008
-#define  PORTSCX_OVER_CURRENT_ACT             0x00000010
-#define  PORTSCX_OVER_CURRENT_CHG             0x00000020
-#define  PORTSCX_PORT_FORCE_RESUME            0x00000040
-#define  PORTSCX_PORT_SUSPEND                 0x00000080
-#define  PORTSCX_PORT_RESET                   0x00000100
-#define  PORTSCX_LINE_STATUS_BITS             0x00000C00
-#define  PORTSCX_PORT_POWER                   0x00001000
-#define  PORTSCX_PORT_INDICTOR_CTRL           0x0000C000
-#define  PORTSCX_PORT_TEST_CTRL               0x000F0000
-#define  PORTSCX_WAKE_ON_CONNECT_EN           0x00100000
-#define  PORTSCX_WAKE_ON_CONNECT_DIS          0x00200000
-#define  PORTSCX_WAKE_ON_OVER_CURRENT         0x00400000
-#define  PORTSCX_PHY_LOW_POWER_SPD            0x00800000
-#define  PORTSCX_PORT_FORCE_FULL_SPEED        0x01000000
-#define  PORTSCX_PORT_SPEED_MASK              0x0C000000
-#define  PORTSCX_PORT_WIDTH                   0x10000000
-#define  PORTSCX_PHY_TYPE_SEL                 0xC0000000
-
-/* bit 11-10 are line status */
-#define  PORTSCX_LINE_STATUS_SE0              0x00000000
-#define  PORTSCX_LINE_STATUS_JSTATE           0x00000400
-#define  PORTSCX_LINE_STATUS_KSTATE           0x00000800
-#define  PORTSCX_LINE_STATUS_UNDEF            0x00000C00
-#define  PORTSCX_LINE_STATUS_BIT_POS          10
-
-/* bit 15-14 are port indicator control */
-#define  PORTSCX_PIC_OFF                      0x00000000
-#define  PORTSCX_PIC_AMBER                    0x00004000
-#define  PORTSCX_PIC_GREEN                    0x00008000
-#define  PORTSCX_PIC_UNDEF                    0x0000C000
-#define  PORTSCX_PIC_BIT_POS                  14
-
-/* bit 19-16 are port test control */
-#define  PORTSCX_PTC_DISABLE                  0x00000000
-#define  PORTSCX_PTC_JSTATE                   0x00010000
-#define  PORTSCX_PTC_KSTATE                   0x00020000
-#define  PORTSCX_PTC_SEQNAK                   0x00030000
-#define  PORTSCX_PTC_PACKET                   0x00040000
-#define  PORTSCX_PTC_FORCE_EN                 0x00050000
-#define  PORTSCX_PTC_BIT_POS                  16
-
-/* bit 27-26 are port speed */
-#define  PORTSCX_PORT_SPEED_FULL              0x00000000
-#define  PORTSCX_PORT_SPEED_LOW               0x04000000
-#define  PORTSCX_PORT_SPEED_HIGH              0x08000000
-#define  PORTSCX_PORT_SPEED_UNDEF             0x0C000000
-#define  PORTSCX_SPEED_BIT_POS                26
-
-/* bit 28 is parallel transceiver width for UTMI interface */
-#define  PORTSCX_PTW                          0x10000000
-#define  PORTSCX_PTW_8BIT                     0x00000000
-#define  PORTSCX_PTW_16BIT                    0x10000000
-
-/* bit 31-30 are port transceiver select */
-#define  PORTSCX_PTS_UTMI                     0x00000000
-#define  PORTSCX_PTS_ULPI                     0x80000000
-#define  PORTSCX_PTS_FSLS                     0xC0000000
-#define  PORTSCX_PTS_BIT_POS                  30
-
-/* otgsc Register Bit Masks */
-#define  OTGSC_CTRL_VUSB_DISCHARGE            0x00000001
-#define  OTGSC_CTRL_VUSB_CHARGE               0x00000002
-#define  OTGSC_CTRL_OTG_TERM                  0x00000008
-#define  OTGSC_CTRL_DATA_PULSING              0x00000010
-#define  OTGSC_STS_USB_ID                     0x00000100
-#define  OTGSC_STS_A_VBUS_VALID               0x00000200
-#define  OTGSC_STS_A_SESSION_VALID            0x00000400
-#define  OTGSC_STS_B_SESSION_VALID            0x00000800
-#define  OTGSC_STS_B_SESSION_END              0x00001000
-#define  OTGSC_STS_1MS_TOGGLE                 0x00002000
-#define  OTGSC_STS_DATA_PULSING               0x00004000
-#define  OTGSC_INTSTS_USB_ID                  0x00010000
-#define  OTGSC_INTSTS_A_VBUS_VALID            0x00020000
-#define  OTGSC_INTSTS_A_SESSION_VALID         0x00040000
-#define  OTGSC_INTSTS_B_SESSION_VALID         0x00080000
-#define  OTGSC_INTSTS_B_SESSION_END           0x00100000
-#define  OTGSC_INTSTS_1MS                     0x00200000
-#define  OTGSC_INTSTS_DATA_PULSING            0x00400000
-#define  OTGSC_INTR_USB_ID                    0x01000000
-#define  OTGSC_INTR_A_VBUS_VALID              0x02000000
-#define  OTGSC_INTR_A_SESSION_VALID           0x04000000
-#define  OTGSC_INTR_B_SESSION_VALID           0x08000000
-#define  OTGSC_INTR_B_SESSION_END             0x10000000
-#define  OTGSC_INTR_1MS_TIMER                 0x20000000
-#define  OTGSC_INTR_DATA_PULSING              0x40000000
-
-/* USB MODE Register Bit Masks */
-#define  USB_MODE_CTRL_MODE_IDLE              0x00000000
-#define  USB_MODE_CTRL_MODE_DEVICE            0x00000002
-#define  USB_MODE_CTRL_MODE_HOST              0x00000003
-#define  USB_MODE_CTRL_MODE_RSV               0x00000001
-#define  USB_MODE_SETUP_LOCK_OFF              0x00000008
-#define  USB_MODE_STREAM_DISABLE              0x00000010
-/* Endpoint Flush Register */
-#define EPFLUSH_TX_OFFSET		      0x00010000
-#define EPFLUSH_RX_OFFSET		      0x00000000
-
-/* Endpoint Setup Status bit masks */
-#define  EP_SETUP_STATUS_MASK                 0x0000003F
-#define  EP_SETUP_STATUS_EP0		      0x00000001
-
-/* ENDPOINTCTRLx  Register Bit Masks */
-#define  EPCTRL_TX_ENABLE                     0x00800000
-#define  EPCTRL_TX_DATA_TOGGLE_RST            0x00400000	/* Not EP0 */
-#define  EPCTRL_TX_DATA_TOGGLE_INH            0x00200000	/* Not EP0 */
-#define  EPCTRL_TX_TYPE                       0x000C0000
-#define  EPCTRL_TX_DATA_SOURCE                0x00020000	/* Not EP0 */
-#define  EPCTRL_TX_EP_STALL                   0x00010000
-#define  EPCTRL_RX_ENABLE                     0x00000080
-#define  EPCTRL_RX_DATA_TOGGLE_RST            0x00000040	/* Not EP0 */
-#define  EPCTRL_RX_DATA_TOGGLE_INH            0x00000020	/* Not EP0 */
-#define  EPCTRL_RX_TYPE                       0x0000000C
-#define  EPCTRL_RX_DATA_SINK                  0x00000002	/* Not EP0 */
-#define  EPCTRL_RX_EP_STALL                   0x00000001
-
-/* bit 19-18 and 3-2 are endpoint type */
-#define  EPCTRL_EP_TYPE_CONTROL               0
-#define  EPCTRL_EP_TYPE_ISO                   1
-#define  EPCTRL_EP_TYPE_BULK                  2
-#define  EPCTRL_EP_TYPE_INTERRUPT             3
-#define  EPCTRL_TX_EP_TYPE_SHIFT              18
-#define  EPCTRL_RX_EP_TYPE_SHIFT              2
-
-/* SNOOPn Register Bit Masks */
-#define  SNOOP_ADDRESS_MASK                   0xFFFFF000
-#define  SNOOP_SIZE_ZERO                      0x00	/* snooping disable */
-#define  SNOOP_SIZE_4KB                       0x0B	/* 4KB snoop size */
-#define  SNOOP_SIZE_8KB                       0x0C
-#define  SNOOP_SIZE_16KB                      0x0D
-#define  SNOOP_SIZE_32KB                      0x0E
-#define  SNOOP_SIZE_64KB                      0x0F
-#define  SNOOP_SIZE_128KB                     0x10
-#define  SNOOP_SIZE_256KB                     0x11
-#define  SNOOP_SIZE_512KB                     0x12
-#define  SNOOP_SIZE_1MB                       0x13
-#define  SNOOP_SIZE_2MB                       0x14
-#define  SNOOP_SIZE_4MB                       0x15
-#define  SNOOP_SIZE_8MB                       0x16
-#define  SNOOP_SIZE_16MB                      0x17
-#define  SNOOP_SIZE_32MB                      0x18
-#define  SNOOP_SIZE_64MB                      0x19
-#define  SNOOP_SIZE_128MB                     0x1A
-#define  SNOOP_SIZE_256MB                     0x1B
-#define  SNOOP_SIZE_512MB                     0x1C
-#define  SNOOP_SIZE_1GB                       0x1D
-#define  SNOOP_SIZE_2GB                       0x1E	/* 2GB snoop size */
-
-/* pri_ctrl Register Bit Masks */
-#define  PRI_CTRL_PRI_LVL1                    0x0000000C
-#define  PRI_CTRL_PRI_LVL0                    0x00000003
-
-/* si_ctrl Register Bit Masks */
-#define  SI_CTRL_ERR_DISABLE                  0x00000010
-#define  SI_CTRL_IDRC_DISABLE                 0x00000008
-#define  SI_CTRL_RD_SAFE_EN                   0x00000004
-#define  SI_CTRL_RD_PREFETCH_DISABLE          0x00000002
-#define  SI_CTRL_RD_PREFEFETCH_VAL            0x00000001
-
-/* control Register Bit Masks */
-#define  USB_CTRL_IOENB                       0x00000004
-#define  USB_CTRL_ULPI_INT0EN                 0x00000001
 
 /* Endpoint Queue Head data struct
  * Rem: all the variables of qh are LittleEndian Mode
@@ -477,7 +297,10 @@ struct fsl_udc {
 	unsigned int irq;
 
 	struct usb_ctrlrequest local_setup_buff;
-	spinlock_t lock;
+	spinlock_t lock;		/* udc lock */
+	struct fsl_usb2_platform_data *pdata;
+	u32 xcvr_type;
+
 	struct otg_transceiver *transceiver;
 	unsigned softconnect:1;
 	unsigned vbus_active:1;
@@ -514,7 +337,7 @@ struct fsl_udc {
 #define DBG(fmt, args...) 	printk(KERN_DEBUG "[%s]  " fmt "\n", \
 				__FUNCTION__, ## args)
 #else
-#define DBG(fmt, args...)	do{}while(0)
+#define DBG(fmt, args...)	do {} while (0)
 #endif
 
 #if 0
@@ -548,7 +371,7 @@ static void dump_msg(const char *label, 
 #ifdef VERBOSE
 #define VDBG		DBG
 #else
-#define VDBG(stuff...)	do{}while(0)
+#define VDBG(stuff...)	do {} while (0)
 #endif
 
 #define ERR(stuff...)		pr_err("udc: " stuff)
@@ -573,11 +396,14 @@ static void dump_msg(const char *label, 
 #define ep_maxpacket(EP)	((EP)->ep.maxpacket)
 #define ep_is_in(EP)	( (ep_index(EP) == 0) ? (EP->udc->ep0_dir == \
 			USB_DIR_IN ):((EP)->desc->bEndpointAddress \
-			& USB_DIR_IN)==USB_DIR_IN)
+			& USB_DIR_IN) == USB_DIR_IN)
 #define get_ep_by_pipe(udc, pipe)	((pipe == 1)? &udc->eps[0]: \
 					&udc->eps[pipe])
 #define get_pipe_by_windex(windex)	((windex & USB_ENDPOINT_NUMBER_MASK) \
 					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
 #define get_pipe_by_ep(EP)	(ep_index(EP) * 2 + ep_is_in(EP))
 
+/* Bulk only class request */
+#define USB_BULK_RESET_REQUEST          0xff
+
 #endif
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -147,6 +147,11 @@
 #define	gadget_is_m66592(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_MCF5445X
+#define gadget_is_mcf5445x(g)	!strcmp("fsl-usb2-udc", (g)->name)
+#else
+#define gadget_is_mcf5445x(g)	0
+#endif
 
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
@@ -212,5 +217,7 @@ static inline int usb_gadget_controller_
 		return 0x20;
 	else if (gadget_is_m66592(gadget))
 		return 0x21;
+	else if (gadget_is_mcf5445x(gadget))
+		return 0x22;
 	return -ENOENT;
 }
--- /dev/null
+++ b/drivers/usb/gadget/mcf5445x_udc.c
@@ -0,0 +1,2758 @@
+/*
+ * Copyright Freescale Semiconductor, Inc. 2006-2007
+ *
+ *      Based on mpc_udc.c code
+ *      of Li Yang and Jiang Bo (Freescale Semiconductor, Inc.)
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ***************************************************************************
+ * Changes:
+ *   v0.004	30 July 2007		Duck
+ *   		mcf5445x port
+ *   v0.003	27 October 2006		Andrey Butok
+ *		Added M5329EVB support (without external transceiver).
+ *   v0.002	29 September 2006	Andrey Butok
+ *		Some little changes. Added OTG support.
+ *   v0.001	12 July 2006		Andrey Butok
+ *   		Initial Release - developed on uClinux with 2.6.17.1 kernel.
+ *   		Based on mpc_udc.c code
+ *   		of Li Yang and Jiang Bo (Freescale Semiconductor, Inc.)
+ *
+ */
+
+#define DEBUG
+#undef VERBOSE
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/usb/otg.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/usb/fsl_usb2.h>
+#include <linux/pm.h>
+
+#include <asm/byteorder.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+#include <asm/mcfsim.h>
+#include <asm/cacheflush.h>
+
+#include "fsl_usb2_udc.h"
+
+#define	DRIVER_DESC	"Freescale High-Speed USB SoC Device Controller driver"
+#define	DRIVER_AUTHOR	"Freescale Semiconductor Inc."
+#define	DRIVER_VERSION	"30 July 2007"
+
+#define cpu_to_hc32(x)	(x)
+#define hc32_to_cpu(x)	(x)
+
+static int udc_suspend(struct fsl_udc *udc);
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static const char driver_name[] = "fsl-usb2-udc";
+static const char driver_desc[] = DRIVER_DESC;
+
+volatile static struct fsl_usb_device_regs *dr_regs;
+volatile static struct usb_sys_interface *usb_sys_regs;
+
+/* it is initialized in probe()  */
+static struct fsl_udc *udc_controller;
+
+static const struct usb_endpoint_descriptor
+fsl_ep0_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	0,
+	.bmAttributes =		USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
+};
+
+static int fsl_udc_suspend(struct device *dev, pm_message_t state);
+static int fsl_udc_resume(struct device *dev);
+static void fsl_ep_fifo_flush(struct usb_ep *_ep);
+
+/********************************************************************
+ *	Internal Used Function
+********************************************************************/
+/*-----------------------------------------------------------------
+ * done() - retire a request; caller blocked irqs
+ * @status : request status to be set, only works when
+ *	request is still in progress.
+ *--------------------------------------------------------------*/
+static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
+{
+	struct fsl_udc *udc = NULL;
+	unsigned char stopped = ep->stopped;
+
+	udc = (struct fsl_udc *)ep->udc;
+
+	pr_debug("udc: req=0x%p\n", req);
+	if (req->head) {
+		pr_debug("udc: freeing head=0x%p\n", req->head);
+		dma_pool_free(udc->td_pool, req->head, req->head->td_dma);
+	}
+
+	/* the req->queue pointer is used by ep_queue() func, in which
+	 * the request will be added into a udc_ep->queue 'd tail
+	 * so here the req will be dropped from the ep->queue
+	 */
+	list_del_init(&req->queue);
+
+	/* req.status should be set as -EINPROGRESS in ep_queue() */
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	pr_debug("udc: req=0x%p  mapped=%x\n", req, req->mapped);
+
+	if (req->mapped) {
+		pr_debug("udc: calling dma_unmap_single(buf,%s)  req=0x%p  "
+			 "a=0x%x  len=%d\n",
+			 ep_is_in(ep) ? "to_dvc" : "from_dvc",
+			 req, req->req.dma, req->req.length);
+
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+				 req->req.dma, req->req.length, ep_is_in(ep) ?
+				 DMA_TO_DEVICE : DMA_FROM_DEVICE);
+
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+		pr_debug("udc: req=0x%p set req.dma=0x%x\n", req, req->req.dma);
+	} else {
+		if ((req->req.length != 0)
+		    && (req->req.dma != DMA_ADDR_INVALID)) {
+			pr_debug("udc: calling dma_sync_single_for_cpu(buf,%s) "
+				 "req=0x%p  dma=0x%x  len=%d\n",
+				 ep_is_in(ep) ? "to_dvc" : "from_dvc", req,
+				 req->req.dma, req->req.length);
+
+			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+						req->req.dma, req->req.length,
+						ep_is_in(ep) ? DMA_TO_DEVICE :
+						DMA_FROM_DEVICE);
+		}
+	}
+
+	if (status && (status != -ESHUTDOWN)) {
+		pr_debug("udc: complete %s req 0c%p stat %d len %u/%u\n",
+			 ep->ep.name, &req->req, status,
+			 req->req.actual, req->req.length);
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+	spin_unlock(&ep->udc->lock);
+
+	/* this complete() should a func implemented by gadget layer,
+	 * eg fsg->bulk_in_complete() */
+	if (req->req.complete) {
+		pr_debug("udc: calling gadget's complete()  req=0x%p\n", req);
+		req->req.complete(&ep->ep, &req->req);
+		pr_debug("udc: back from gadget's complete()\n");
+	}
+
+	spin_lock(&ep->udc->lock);
+	ep->stopped = stopped;
+}
+
+/*
+ * nuke(): delete all requests related to this ep
+ * called with spinlock held
+ *--------------------------------------------------------------*/
+static void nuke(struct fsl_ep *ep, int status)
+{
+	ep->stopped = 1;
+
+	/* Flush fifo */
+	fsl_ep_fifo_flush(&ep->ep);
+
+	/* Whether this eq has request linked */
+	while (!list_empty(&ep->queue)) {
+		struct fsl_req *req = NULL;
+
+		req = list_entry(ep->queue.next, struct fsl_req, queue);
+		done(ep, req, status);
+	}
+}
+
+/*------------------------------------------------------------------
+	Internal Hardware related function
+ ------------------------------------------------------------------*/
+
+static int dr_controller_setup(struct fsl_udc *udc)
+{
+	unsigned int tmp;
+	unsigned int __attribute((unused)) ctrl = 0;
+	unsigned long timeout;
+	struct fsl_usb2_platform_data *pdata;
+
+#define FSL_UDC_RESET_TIMEOUT 1000
+
+	/* before here, make sure dr_regs has been initialized */
+	if (!udc)
+		return -EINVAL;
+	pdata = udc->pdata;
+
+	/* Stop and reset the usb controller */
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp |= USB_CMD_CTRL_RESET;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	/* Wait for reset to complete */
+	timeout = jiffies + FSL_UDC_RESET_TIMEOUT;
+	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+		if (time_after(jiffies, timeout)) {
+			ERR("udc reset timeout! \n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+	}
+
+	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp &= ~0x3;	/* clear mode bits */
+	tmp |= USB_MODE_CTRL_MODE_DEVICE;
+	/* Disable Setup Lockout */
+	tmp |= USB_MODE_SETUP_LOCK_OFF;
+	if (pdata->es)
+		tmp |= USBMODE_ES;
+	fsl_writel(tmp, &dr_regs->usbmode);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+
+	/* Clear the setup status */
+	fsl_writel(0, &dr_regs->usbsts);
+
+	tmp = udc->ep_qh_dma;
+	tmp &= USB_EP_LIST_ADDRESS_MASK;
+	fsl_writel(tmp, &dr_regs->endpointlistaddr);
+
+	/*
+	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
+		(int)udc->ep_qh, (int)tmp,
+		fsl_readl(&dr_regs->endpointlistaddr));
+	*/
+
+
+	if (pdata->have_sysif_regs) {
+		/* Config control enable i/o output, cpu endian register */
+		ctrl = __raw_readl(&usb_sys_regs->control);
+		ctrl |= USB_CTRL_IOENB;
+		__raw_writel(ctrl, &usb_sys_regs->control);
+	}
+
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	/* Turn on cache snooping hardware, since some PowerPC platforms
+	 * wholly rely on hardware to deal with cache coherent. */
+
+	if (pdata->have_sysif_regs) {
+		/* Setup Snooping for all the 4GB space */
+		tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop1);
+		tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop2);
+	}
+#endif
+
+	return 0;
+}
+
+static void pullup_enable(struct fsl_udc *udc)
+{
+	u32 temp;
+
+	unsigned short ccm = fsl_readw(&MCF_CCM_UOCSR);
+	ccm |= MCF_CCM_UOCSR_BVLD;
+	ccm &= ~MCF_CCM_UOCSR_SEND;
+	fsl_writew(ccm, &MCF_CCM_UOCSR);
+
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+
+	fsl_writel(temp, &dr_regs->usbintr);
+
+	/* Set controller to Run */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_RUN_STOP;
+	fsl_writel(temp, &dr_regs->usbcmd);
+
+#ifdef NEVER /* DDD FIXME: we want this? */
+	if (!udc->transceiver)
+		*((u16 *)(MCF_FBCS1_CSAR)) &= ~0x1; /* Enable pullup register */
+#endif
+}
+
+static void pullup_disable(struct fsl_udc *udc)
+{
+	unsigned int tmp;
+	unsigned short ccm;
+
+	VDBG();
+	/* disable all INTRs */
+	fsl_writel(0, &dr_regs->usbintr);
+
+	ccm = fsl_readw(&MCF_CCM_UOCSR);
+	ccm &= ~MCF_CCM_UOCSR_BVLD;
+	fsl_writew(ccm, &MCF_CCM_UOCSR);
+
+	/* set controller to Stop */
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+#ifdef NEVER /* DDD FIXME: we want this? */
+	if (!udc->transceiver)
+		*((u16 *)(MCF_FBCS1_CSAR)) |= 0x1; /* Disable pullup register */
+#endif
+
+}
+
+static void dr_controller_run(struct fsl_udc *udc)
+{
+	VDBG();
+	pullup_enable(udc);
+	udc->stopped = 0;
+}
+
+static void dr_controller_stop(struct fsl_udc *udc)
+{
+	pullup_disable(udc);
+	udc->stopped = 1;
+	udc->gadget.b_hnp_enable = 0;
+	udc->gadget.a_hnp_support = 0;
+	udc->gadget.a_alt_hnp_support = 0;
+}
+
+void dr_ep_setup(unsigned char ep_num, unsigned char dir, unsigned char ep_type)
+{
+	unsigned int tmp_epctrl = 0;
+
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir) {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_TX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_TX_EP_TYPE_SHIFT);
+	} else {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_RX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_RX_EP_TYPE_SHIFT);
+	}
+
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+static void dr_ep_change_stall(unsigned char ep_num, unsigned char dir,
+			       int value)
+{
+	u32 tmp_epctrl = 0;
+
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+
+	if (value) {
+		/* set the stall bit */
+		if (dir)
+			tmp_epctrl |= EPCTRL_TX_EP_STALL;
+		else
+			tmp_epctrl |= EPCTRL_RX_EP_STALL;
+	} else {
+		/* clear the stall bit and reset data toggle */
+		if (dir) {
+			tmp_epctrl &= ~EPCTRL_TX_EP_STALL;
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		} else {
+			tmp_epctrl &= ~EPCTRL_RX_EP_STALL;
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		}
+	}
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+/* Get stall status of a specific ep
+   Return: 0: not stalled; 1:stalled */
+static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
+{
+	u32 epctrl;
+
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir)
+		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
+	else
+		return (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;
+}
+
+/********************************************************************
+	Internal Structure Build up functions
+********************************************************************/
+
+/*------------------------------------------------------------------
+* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH
+ * @zlt: Zero Length Termination Select (1: disable; 0: enable)
+ * @mult: Mult field
+ ------------------------------------------------------------------*/
+static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,
+		unsigned char dir, unsigned char ep_type,
+		unsigned int max_pkt_len,
+		unsigned int zlt, unsigned char mult)
+{
+	struct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];
+	unsigned int tmp = 0;
+
+	/* set the Endpoint Capabilites in QH */
+	switch (ep_type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		/* Interrupt On Setup (IOS). for control ep  */
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| EP_QUEUE_HEAD_IOS;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| (mult << EP_QUEUE_HEAD_MULT_POS);
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		tmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;
+		break;
+	default:
+		VDBG("error ep type is %d", ep_type);
+		return;
+	}
+	if (zlt)
+		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
+	p_QH->max_pkt_length = cpu_to_hc32(tmp);
+
+	return;
+}
+
+/* Setup qh structure and ep register for ep0. */
+static void ep0_setup(struct fsl_udc *udc)
+{
+	/* the intialization of an ep includes: fields in QH, Regs,
+	 * fsl_ep struct */
+	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	dr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
+	dr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
+
+	return;
+
+}
+
+/***********************************************************************
+		Endpoint Management Functions
+***********************************************************************/
+
+/*-------------------------------------------------------------------------
+ * when configurations are set, or when interface settings change
+ * for example the do_set_interface() in gadget layer,
+ * the driver will enable or disable the relevant endpoints
+ * ep0 doesn't use this routine. It is always enabled.
+-------------------------------------------------------------------------*/
+static int fsl_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
+	unsigned short max = 0;
+	unsigned char mult = 0, zlt;
+	int retval = -EINVAL;
+	unsigned long flags = 0;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+
+	/* catch various bogus parameters */
+	if (!_ep || !desc || ep->desc
+			|| (desc->bDescriptorType != USB_DT_ENDPOINT))
+		return -EINVAL;
+
+	udc = ep->udc;
+
+	if (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))
+		return -ESHUTDOWN;
+
+	max = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Disable automatic zlp generation.  Driver is reponsible to indicate
+	 * explicitly through req->req.zero.  This is needed to enable multi-td
+	 * request. */
+	zlt = 1;
+
+	/* Assume the max packet size from gadget is always correct */
+	switch (desc->bmAttributes & 0x03) {
+	case USB_ENDPOINT_XFER_CONTROL:
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		/* mult = 0.  Execute N Transactions as demonstrated by
+		 * the USB variable length packet protocol where N is
+		 * computed using the Maximum Packet Length (dQH) and
+		 * the Total Bytes field (dTD) */
+		mult = 0;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		/* Calculate transactions needed for high bandwidth iso */
+		mult = (unsigned char)(1 + ((max >> 11) & 0x03));
+		max = max & 0x8ff;	/* bit 0~10 */
+		/* 3 transactions at most */
+		if (mult > 3)
+			goto en_done;
+		break;
+	default:
+		goto en_done;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+	ep->ep.maxpacket = max;
+	ep->desc = desc;
+	ep->stopped = 0;
+
+	/* Controller related setup */
+	/* Init EPx Queue Head (Ep Capabilites field in QH
+	 * according to max, zlt, mult) */
+	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					?  USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK),
+			max, zlt, mult);
+
+	/* Init endpoint ctrl register */
+	dr_ep_setup((unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					? USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	retval = 0;
+
+	VDBG("enabled %s (ep%d%s) maxpacket %d", ep->ep.name,
+			ep->desc->bEndpointAddress & 0x0f,
+			(desc->bEndpointAddress & USB_DIR_IN)
+				? "in" : "out", max);
+en_done:
+	return retval;
+}
+
+/*---------------------------------------------------------------------
+ * @ep : the ep being unconfigured. May not be ep0
+ * Any pending and uncomplete req will complete with status (-ESHUTDOWN)
+*---------------------------------------------------------------------*/
+static int fsl_ep_disable(struct usb_ep *_ep)
+{
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
+	unsigned long flags = 0;
+	u32 epctrl;
+	int ep_num;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	if (!_ep || !ep->desc) {
+		pr_debug("udc: %s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	/* disable ep on controller */
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	udc = (struct fsl_udc *)ep->udc;
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* nuke all pending requests (does flush) */
+	nuke(ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	pr_debug("udc: disabled %s OK\n", _ep->name);
+	return 0;
+}
+
+/*---------------------------------------------------------------------
+ * allocate a request object used by this endpoint
+ * the main operation is to insert the req->queue to the eq->queue
+ * Returns the request, or null if one could not be allocated
+*---------------------------------------------------------------------*/
+static struct usb_request *
+fsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct fsl_req *req = NULL;
+
+	req = kzalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	pr_debug("udc: req=0x%p   set req.dma=0x%x\n", req, req->req.dma);
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct fsl_req *req;
+
+	req = container_of(_req, struct fsl_req, req);
+	pr_debug("udc: req=0x%p\n", req);
+
+	if (_req)
+		kfree(req);
+}
+
+/*-------------------------------------------------------------------------*/
+static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
+{
+	int i = ep_index(ep) * 2 + ep_is_in(ep);
+	u32 temp, bitmask, tmp_stat;
+	struct ep_queue_head *dQH = &ep->udc->ep_qh[i];
+
+	pr_debug("udc: queue req=0x%p to ep index %d\n", req, i);
+
+	bitmask = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+
+	/* check if the pipe is empty */
+	if (!(list_empty(&ep->queue))) {
+		/* Add td to the end */
+		struct fsl_req *lastreq;
+		lastreq = list_entry(ep->queue.prev, struct fsl_req, queue);
+		lastreq->tail->next_td_ptr =
+			cpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);
+		/* Read prime bit, if 1 goto done */
+		if (fsl_readl(&dr_regs->endpointprime) & bitmask)
+			goto out;
+
+		do {
+			/* Set ATDTW bit in USBCMD */
+			temp = fsl_readl(&dr_regs->usbcmd);
+			fsl_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+			/* Read correct status bit */
+			tmp_stat = fsl_readl(&dr_regs->endptstatus) & bitmask;
+
+		} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
+
+		/* Write ATDTW bit to 0 */
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+		if (tmp_stat)
+			goto out;
+	}
+
+	/* Write dQH next pointer and terminate bit to 0 */
+	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
+	dQH->next_dtd_ptr = cpu_to_hc32(temp);
+
+	/* Clear active and halt bit */
+	temp = cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+			| EP_QUEUE_HEAD_STATUS_HALT));
+	dQH->size_ioc_int_sts &= temp;
+
+	/* Prime endpoint by writing 1 to ENDPTPRIME */
+	temp = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+	fsl_writel(temp, &dr_regs->endpointprime);
+out:
+	return 0;
+}
+
+/* Fill in the dTD structure
+ * @req: request that the transfer belongs to
+ * @length: return actually data length of the dTD
+ * @dma: return dma address of the dTD
+ * @is_last: return flag if it is the last dTD of the request
+ * return: pointer to the built dTD */
+static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
+		dma_addr_t *dma, int *is_last)
+{
+	u32 swap_temp;
+	struct ep_td_struct *dtd;
+
+	/* how big will this transfer be? */
+	*length = min(req->req.length - req->req.actual,
+			(unsigned)EP_MAX_LENGTH_TRANSFER);
+
+	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_KERNEL, dma);
+	if (dtd == NULL)
+		return dtd;
+
+	dtd->td_dma = *dma;
+	/* Clear reserved field */
+	swap_temp = hc32_to_cpu(dtd->size_ioc_sts);
+	swap_temp &= ~DTD_RESERVED_FIELDS;
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
+
+	/* Init all of buffer page pointers */
+	swap_temp = (u32) (req->req.dma + req->req.actual);
+	dtd->buff_ptr0 = cpu_to_hc32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);
+
+	req->req.actual += *length;
+
+	/* zlp is needed if req->req.zero is set */
+	if (req->req.zero) {
+		if (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)
+			*is_last = 1;
+		else
+			*is_last = 0;
+	} else if (req->req.length == req->req.actual)
+		*is_last = 1;
+	else
+		*is_last = 0;
+
+	if ((*is_last) == 0)
+		VDBG("multi-dtd request!\n");
+	/* Fill in the transfer size; set active bit */
+	swap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);
+
+	/* Enable interrupt for the last dtd of a request */
+	if (*is_last && !req->req.no_interrupt)
+		swap_temp |= DTD_IOC;
+
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
+
+	mb();
+
+	VDBG("length = %d address= 0x%x", *length, (int)*dma);
+
+	return dtd;
+}
+
+/* Generate dtd chain for a request */
+static int fsl_req_to_dtd(struct fsl_req *req)
+{
+	unsigned	count;
+	int		is_last;
+	int		is_first = 1;
+	struct ep_td_struct	*last_dtd = NULL, *dtd;
+	dma_addr_t dma;
+
+	do {
+		dtd = fsl_build_dtd(req, &count, &dma, &is_last);
+		if (dtd == NULL)
+			return -ENOMEM;
+
+		if (is_first) {
+			is_first = 0;
+			req->head = dtd;
+		} else {
+			last_dtd->next_td_ptr = hc32_to_cpu(dma);
+			last_dtd->next_td_virt = dtd;
+		}
+		last_dtd = dtd;
+
+		req->dtd_count++;
+	} while (!is_last);
+
+	dtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);
+
+	req->tail = dtd;
+
+	return 0;
+}
+
+/* queues (submits) an I/O request to an endpoint */
+static int
+fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req = container_of(_req, struct fsl_req, req);
+	struct fsl_udc *udc;
+	unsigned long flags;
+	int is_iso = 0;
+
+	/* catch various bogus parameters */
+	if (!_req || !req->req.complete || !req->req.buf
+			|| !list_empty(&req->queue)) {
+		VDBG("%s, bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	if (!_ep || (!ep->desc && ep_index(ep))) {
+		VDBG("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+		if (req->req.length > ep->ep.maxpacket)
+			return -EMSGSIZE;
+		is_iso = 1;
+	}
+
+	udc = ep->udc;
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	req->ep = ep;
+
+	/* map virtual address to hardware */
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+					req->req.buf,
+					req->req.length, ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 1;
+	} else {
+		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length,
+					ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 0;
+	}
+
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->dtd_count = 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* build dtds and push them to device queue */
+	if (!fsl_req_to_dtd(req)) {
+		fsl_queue_td(ep, req);
+	} else {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -ENOMEM;
+	}
+
+	/* Update ep0 state */
+	if ((ep_index(ep) == 0))
+		udc->ep0_state = DATA_STATE_XMIT;
+
+	/* irq handler advances the queue */
+	if (req != NULL)
+		list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+/* dequeues (cancels, unlinks) an I/O request from an endpoint */
+static int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req;
+	unsigned long flags;
+	int ep_num, stopped, ret = 0;
+	u32 epctrl;
+
+	if (!_ep || !_req)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	stopped = ep->stopped;
+
+	/* Stop the ep before we deal with the queue */
+	ep->stopped = 1;
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* The request is in progress, or completed but not dequeued */
+	if (ep->queue.next == &req->queue) {
+		_req->status = -ECONNRESET;
+		fsl_ep_fifo_flush(_ep);	/* flush current transfer */
+
+		/* The request isn't the last request in this ep queue */
+		if (req->queue.next != &ep->queue) {
+			struct ep_queue_head *qh;
+			struct fsl_req *next_req;
+
+			qh = ep->qh;
+			next_req = list_entry(req->queue.next, struct fsl_req,
+					queue);
+
+			/* Point the QH to the first TD of next request */
+			fsl_writel((u32) next_req->head, &qh->curr_dtd_ptr);
+		}
+
+		/* The request hasn't been processed, patch up the TD chain */
+	} else {
+		struct fsl_req *prev_req;
+
+		prev_req = list_entry(req->queue.prev, struct fsl_req, queue);
+		fsl_writel(fsl_readl(&req->tail->next_td_ptr),
+				&prev_req->tail->next_td_ptr);
+
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	/* Enable EP */
+out:	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl |= EPCTRL_TX_ENABLE;
+	else
+		epctrl |= EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	ep->stopped = stopped;
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------
+ * modify the endpoint halt feature
+ * @ep: the non-isochronous endpoint being stalled
+ * @value: 1--set halt  0--clear halt
+ * Returns zero, or a negative error code.
+*----------------------------------------------------------------*/
+static int fsl_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct fsl_ep *ep = NULL;
+	unsigned long flags = 0;
+	int status = -EOPNOTSUPP;	/* operation not supported */
+	unsigned char ep_dir = 0, ep_num = 0;
+	struct fsl_udc *udc = NULL;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	udc = ep->udc;
+	if (!_ep || !ep->desc) {
+		status = -EINVAL;
+		goto out;
+	}
+
+	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+		status = -EOPNOTSUPP;
+		goto out;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		status = -EAGAIN;
+		goto out;
+	}
+
+	status = 0;
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+	ep_num = (unsigned char)(ep_index(ep));
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	dr_ep_change_stall(ep_num, ep_dir, value);
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	if (ep_index(ep) == 0) {
+		udc->ep0_state = WAIT_FOR_SETUP;
+		udc->ep0_dir = 0;
+	}
+out:
+	VDBG(" %s %s halt stat %d", ep->ep.name,
+			value ?  "set" : "clear", status);
+
+	return status;
+}
+
+static void fsl_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct fsl_ep *ep;
+	int ep_num, ep_dir;
+	u32 bits;
+	unsigned long timeout;
+#define FSL_UDC_FLUSH_TIMEOUT 1000
+
+	if (!_ep) {
+		return;
+	} else {
+		ep = container_of(_ep, struct fsl_ep, ep);
+		if (!ep->desc)
+			return;
+	}
+	ep_num = ep_index(ep);
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+
+	if (ep_num == 0)
+		bits = (1 << 16) | 1;
+	else if (ep_dir == USB_SEND)
+		bits = 1 << (16 + ep_num);
+	else
+		bits = 1 << ep_num;
+
+	timeout = jiffies + FSL_UDC_FLUSH_TIMEOUT;
+	do {
+		fsl_writel(bits, &dr_regs->endptflush);
+
+		/* Wait until flush complete */
+		while (fsl_readl(&dr_regs->endptflush)) {
+			if (time_after(jiffies, timeout)) {
+				ERR("ep flush timeout\n");
+				return;
+			}
+			cpu_relax();
+		}
+		/* See if we need to flush again */
+	} while (fsl_readl(&dr_regs->endptstatus) & bits);
+}
+
+static struct usb_ep_ops fsl_ep_ops = {
+	.enable = fsl_ep_enable,
+	.disable = fsl_ep_disable,
+
+	.alloc_request = fsl_alloc_request,
+	.free_request = fsl_free_request,
+
+	.queue = fsl_ep_queue,
+	.dequeue = fsl_ep_dequeue,
+
+	.set_halt = fsl_ep_set_halt,
+	.fifo_flush = fsl_ep_fifo_flush,	/* flush fifo */
+};
+
+/*-------------------------------------------------------------------------
+		Gadget Driver Layer Operations
+-------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------
+ * Get the current frame number (from DR frame_index Reg )
+ *----------------------------------------------------------------------*/
+static int fsl_get_frame(struct usb_gadget *gadget)
+{
+	return (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
+}
+
+/*-----------------------------------------------------------------------
+ * Tries to wake up the host connected to this gadget
+ -----------------------------------------------------------------------*/
+static int fsl_wakeup(struct usb_gadget *gadget)
+{
+	struct fsl_udc *udc = container_of(gadget, struct fsl_udc, gadget);
+	u32 portsc;
+
+	/* Remote wakeup feature not enabled by host */
+	if (!udc->remote_wakeup)
+		return -ENOTSUPP;
+
+	portsc = fsl_readl(&dr_regs->portsc1);
+	/* not suspended? */
+	if (!(portsc & PORTSCX_PORT_SUSPEND))
+		return 0;
+	/* trigger force resume */
+	portsc |= PORTSCX_PORT_FORCE_RESUME;
+	fsl_writel(portsc, &dr_regs->portsc1);
+	return 0;
+}
+
+static int can_pullup(struct fsl_udc *udc)
+{
+	return udc->driver && udc->softconnect && udc->vbus_active;
+}
+
+/*
+ * Notify controller that VBUS is powered, Called by whatever
+ * detects VBUS sessions
+ * @param gadger    gadger pointer
+ * @param is_active is active?
+ * @return Returns zero on success , or a negative error code
+ */
+static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct fsl_udc	*udc;
+	unsigned long	flags;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+	spin_lock_irqsave(&udc->lock, flags);
+
+	pr_debug("udc: VBUS %s\n", is_active ? "on" : "off");
+	udc->vbus_active = (is_active != 0);
+
+	if (can_pullup(udc)) {
+		pullup_enable(udc);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+	} else {
+		pullup_disable(udc);
+		udc_controller->usb_state = USB_STATE_NOTATTACHED;
+	}
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
+/* constrain controller's VBUS power usage
+ * This call is used by gadget drivers during SET_CONFIGURATION calls,
+ * reporting how much power the device may consume.  For example, this
+ * could affect how quickly batteries are recharged.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+#ifdef CONFIG_USB_OTG
+	struct fsl_udc *udc;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+
+	if (udc->transceiver)
+		return otg_set_power(udc->transceiver, mA);
+#endif
+	return -ENOTSUPP;
+}
+
+/*
+ * Change Data+ pullup status
+ * this func is used by usb_gadget_connect/disconnet
+ */
+static int fsl_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct fsl_udc *udc;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+	udc->softconnect = (is_on != 0);
+	if (can_pullup(udc))
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+	else
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+
+	return 0;
+}
+
+/* defined in usb_gadget.h */
+static struct usb_gadget_ops fsl_gadget_ops = {
+	.get_frame = fsl_get_frame,
+	.wakeup = fsl_wakeup,
+	.vbus_session = fsl_vbus_session,
+	.vbus_draw = fsl_vbus_draw,
+	.pullup = fsl_pullup,
+};
+
+/* Set protocol stall on ep0, protocol stall will automatically be cleared
+   on new transaction */
+static void ep0stall(struct fsl_udc *udc)
+{
+	u32 tmp;
+
+	/* must set tx and rx to stall at the same time */
+	tmp = fsl_readl(&dr_regs->endptctrl[0]);
+	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
+	fsl_writel(tmp, &dr_regs->endptctrl[0]);
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->ep0_dir = 0;
+}
+
+/* Prime a status phase for ep0 */
+static int ep0_prime_status(struct fsl_udc *udc, int direction)
+{
+	struct fsl_req *req = udc->status_req;
+	struct fsl_ep *ep;
+	int status = 0;
+
+	if (direction == EP_DIR_IN)
+		udc->ep0_dir = USB_DIR_IN;
+	else
+		udc->ep0_dir = USB_DIR_OUT;
+
+	ep = &udc->eps[0];
+	udc->ep0_state = WAIT_FOR_OUT_STATUS;
+
+	req->ep = ep;
+	req->req.length = 0;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+
+	if (fsl_req_to_dtd(req) == 0)
+		status = fsl_queue_td(ep, req);
+	else
+		return -ENOMEM;
+
+	if (status)
+		ERR("Can't queue ep0 status request \n");
+	list_add_tail(&req->queue, &ep->queue);
+
+	return status;
+}
+
+static inline int udc_reset_ep_queue(struct fsl_udc *udc, u8 pipe)
+{
+	struct fsl_ep *ep = get_ep_by_pipe(udc, pipe);
+
+	if (!ep->name)
+		return 0;
+
+	nuke(ep, -ESHUTDOWN);
+
+	return 0;
+}
+
+/*
+ * ch9 Set address
+ */
+static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
+{
+	/* Save the new address to device struct */
+	udc->device_address = (u8) value;
+	/* Update usb state */
+	udc->usb_state = USB_STATE_ADDRESS;
+	/* Status phase */
+	if (ep0_prime_status(udc, EP_DIR_IN))
+		ep0stall(udc);
+}
+
+/*
+ * ch9 Get status
+ */
+static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,
+			 u16 index, u16 length)
+{
+	u16 tmp = 0;		/* Status, cpu endian */
+
+	struct fsl_req *req;
+	struct fsl_ep *ep;
+	int status = 0;
+
+	ep = &udc->eps[0];
+
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		/* Get device status */
+		tmp = 1 << USB_DEVICE_SELF_POWERED;
+		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		/* Get interface status */
+		/* We don't have interface information in udc driver */
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* Get endpoint status */
+		struct fsl_ep *target_ep;
+
+		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
+
+		/* stall if endpoint doesn't exist */
+		if (!target_ep->desc)
+			goto stall;
+		tmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))
+				<< USB_ENDPOINT_HALT;
+	}
+
+	udc->ep0_dir = USB_DIR_IN;
+	/* Borrow the per device status_req */
+	req = udc->status_req;
+	/* Fill in the reqest structure */
+	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
+	req->ep = ep;
+	req->req.length = 2;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+
+	/* prime the data phase */
+	if ((fsl_req_to_dtd(req) == 0))
+		status = fsl_queue_td(ep, req);
+	else			/* no mem */
+		goto stall;
+
+	if (status) {
+		ERR("Can't respond to getstatus request \n");
+		goto stall;
+	}
+	list_add_tail(&req->queue, &ep->queue);
+	udc->ep0_state = DATA_STATE_XMIT;
+	return;
+stall:
+	ep0stall(udc);
+}
+
+static void ch9setconfig(struct fsl_udc *udc, u16 value, u16 index,
+			 u16 length)
+{
+	pr_debug("udc: 1 calling gadget driver->setup\n");
+	udc->ep0_dir = USB_DIR_IN;
+	if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff) >= 0) {
+		/* gadget layer deal with the status phase */
+		udc->usb_state = USB_STATE_CONFIGURED;
+		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+		pr_debug("udc: ep0_state now WAIT_FOR_OUT_STATUS\n");
+	}
+}
+
+static void setup_received_irq(struct fsl_udc *udc,
+			       struct usb_ctrlrequest *setup)
+{
+	u32 tmp;
+	u16 ptc = 0;		/* port test control */
+	int handled = 1;	/* set to zero if we do not handle the message,
+				   and should pass it to the gadget driver */
+
+	/*
+	 * gadget drivers expect the setup pkt to be in wire format,
+	 * so leave it alone and make local copies of stuff we need.
+	 */
+	u16 wValue = le16_to_cpu(setup->wValue);
+	u16 wIndex = le16_to_cpu(setup->wIndex);
+	u16 wLength = le16_to_cpu(setup->wLength);
+
+
+	pr_debug("udc: request=0x%x\n", setup->bRequest);
+
+	udc_reset_ep_queue(udc, 0);
+
+	/* We asume setup only occurs on EP0 */
+	if (setup->bRequestType & USB_DIR_IN)
+		udc->ep0_dir = USB_DIR_IN;
+	else
+		udc->ep0_dir = USB_DIR_OUT;
+
+	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
+		/* handle class requests */
+		switch (setup->bRequest) {
+
+		case USB_BULK_RESET_REQUEST:
+			udc->ep0_dir = USB_DIR_IN;
+			if (udc->driver->setup(&udc->gadget,
+					       &udc->local_setup_buff) >= 0) {
+				udc->ep0_state = WAIT_FOR_SETUP;
+				pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
+			}
+			break;
+
+		default:
+			handled = 0;
+			break;
+		}
+	} else if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		/* handle standard requests */
+		switch (setup->bRequest) {
+
+		case USB_REQ_GET_STATUS:
+			if ((setup->
+			     bRequestType & (USB_DIR_IN | USB_TYPE_STANDARD))
+			    != (USB_DIR_IN | USB_TYPE_STANDARD))
+				break;
+			ch9getstatus(udc, setup->bRequestType, wValue, wIndex,
+				     wLength);
+			break;
+
+		case USB_REQ_SET_ADDRESS:
+			if (setup->bRequestType !=
+			    (USB_DIR_OUT | USB_TYPE_STANDARD |
+			     USB_RECIP_DEVICE))
+				break;
+			ch9setaddress(udc, wValue, wIndex, wLength);
+			break;
+
+		case USB_REQ_SET_CONFIGURATION:
+			if (setup->bRequestType !=
+			    (USB_DIR_OUT | USB_TYPE_STANDARD |
+			     USB_RECIP_DEVICE))
+				break;
+			/* gadget layer take over the status phase */
+			ch9setconfig(udc, wValue, wIndex, wLength);
+			break;
+		case USB_REQ_SET_INTERFACE:
+			if (setup->bRequestType !=
+			    (USB_DIR_OUT | USB_TYPE_STANDARD |
+			     USB_RECIP_INTERFACE))
+				break;
+			udc->ep0_dir = USB_DIR_IN;
+			if (udc->driver->setup(&udc->gadget,
+					       &udc->local_setup_buff) >= 0)
+				/* gadget layer take over the status phase */
+				break;
+			/* Requests with no data phase */
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			{	/* status transaction */
+				int rc = -EOPNOTSUPP;
+
+				if ((setup->bRequestType & USB_TYPE_MASK) !=
+				    USB_TYPE_STANDARD)
+					break;
+
+				/* we only support set/clear feature for
+				 * endpoint */
+				if (setup->bRequestType == USB_RECIP_ENDPOINT) {
+					int dir = (wIndex & 0x0080) ?
+					    EP_DIR_IN : EP_DIR_OUT;
+					int num = (wIndex & 0x000f);
+					struct fsl_ep *ep;
+
+					if (wValue != 0
+					    || wLength != 0
+					    || (num * 2 + dir) > udc->max_ep)
+						break;
+					ep = &udc->eps[num * 2 + dir];
+
+					if (setup->bRequest ==
+					    USB_REQ_SET_FEATURE) {
+						pr_debug("udc: udc: SET_FEATURE"
+							 " doing set_halt\n");
+						rc = fsl_ep_set_halt(&ep-> ep,
+								     1);
+					} else {
+						pr_debug("udc: CLEAR_FEATURE"
+							 " doing clear_halt\n");
+						rc = fsl_ep_set_halt(&ep-> ep,
+								     0);
+					}
+
+				} else if (setup->bRequestType ==
+					   USB_RECIP_DEVICE) {
+					if (setup->bRequest ==
+					    USB_REQ_SET_FEATURE) {
+						ptc = wIndex >> 8;
+						rc = 0;
+					}
+					if (!udc->gadget.is_otg)
+						break;
+					else if (setup->bRequest ==
+						 USB_DEVICE_B_HNP_ENABLE)
+						udc->gadget.b_hnp_enable = 1;
+					else if (setup->bRequest ==
+						 USB_DEVICE_A_HNP_SUPPORT)
+						udc->gadget.a_hnp_support = 1;
+					else if (setup->bRequest ==
+						 USB_DEVICE_A_ALT_HNP_SUPPORT)
+						udc->gadget.a_alt_hnp_support =
+						    1;
+					rc = 0;
+				}
+				if (rc == 0) {
+					/* send status only if
+					 * fsl_ep_set_halt success */
+					if (ep0_prime_status(udc, EP_DIR_IN))
+						ep0stall(udc);
+				}
+				break;
+			}
+		default:
+			handled = 0;
+			break;
+		}
+	} else {
+		/* vendor requests */
+		handled = 0;
+	}
+
+	if (!handled) {
+		if (udc->driver->setup(&udc->gadget, &udc->local_setup_buff)
+		    != 0) {
+			ep0stall(udc);
+		} else if (setup->bRequestType & USB_DIR_IN) {
+			udc->ep0_state = DATA_STATE_XMIT;
+			pr_debug("udc: ep0_state now DATA_STATE_XMIT\n");
+		} else {
+			udc->ep0_state = DATA_STATE_RECV;
+			pr_debug("udc: ep0_state now DATA_STATE_RECV\n");
+		}
+	}
+
+	if (ptc) {
+		tmp =fsl_readl(&dr_regs->portsc1) | ptc << 16;
+		fsl_writel(tmp, &dr_regs->portsc1);
+		pr_debug("udc: switch to test mode.\n");
+	}
+}
+
+/* Process request for Data or Status phase of ep0
+ * prime status phase if needed */
+static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
+		struct fsl_req *req)
+{
+	if (udc->usb_state == USB_STATE_ADDRESS) {
+		/* Set the new address */
+		u32 new_address = (u32) udc->device_address;
+		fsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
+				&dr_regs->deviceaddr);
+	}
+
+	done(ep0, req, 0);
+
+	switch (udc->ep0_state) {
+	case DATA_STATE_XMIT:
+		/* receive status phase */
+		if (ep0_prime_status(udc, EP_DIR_OUT))
+			ep0stall(udc);
+		break;
+	case DATA_STATE_RECV:
+		/* send status phase */
+		if (ep0_prime_status(udc, EP_DIR_IN))
+			ep0stall(udc);
+		break;
+	case WAIT_FOR_OUT_STATUS:
+		udc->ep0_state = WAIT_FOR_SETUP;
+		break;
+	case WAIT_FOR_SETUP:
+		ERR("Unexpect ep0 packets \n");
+		break;
+	default:
+		ep0stall(udc);
+		break;
+	}
+}
+
+/* Tripwire mechanism to ensure a setup packet payload is extracted without
+ * being corrupted by another incoming setup packet */
+static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
+{
+	u32 temp;
+	struct ep_queue_head *qh;
+	struct fsl_usb2_platform_data *pdata = udc->pdata;
+
+	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
+
+	/* Clear bit in ENDPTSETUPSTAT */
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
+
+	/* while a hazard exists when setup package arrives */
+	do {
+		/* Set Setup Tripwire */
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
+
+		/* Copy the setup packet to local buffer */
+		if (pdata->le_setup_buf) {
+			u32 *p = (u32 *)buffer_ptr;
+			u32 *s = (u32 *)qh->setup_buffer;
+			
+			/* Convert little endian setup buffer to CPU endian */
+			*p++ = le32_to_cpu(*s++);
+			*p = le32_to_cpu(*s);
+		} else {
+			memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+		}
+	} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
+
+	/* Clear Setup Tripwire */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	fsl_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
+}
+
+/* process-ep_req(): free the completed Tds for this req */
+static int process_ep_req(struct fsl_udc *udc, int pipe,
+		struct fsl_req *curr_req)
+{
+	struct ep_td_struct *curr_td;
+	int	td_complete, actual, remaining_length, j, tmp;
+	int	status = 0;
+	int	errors = 0;
+	struct  ep_queue_head *curr_qh = &udc->ep_qh[pipe];
+	int direction = pipe % 2;
+
+	curr_td = curr_req->head;
+	td_complete = 0;
+	actual = curr_req->req.length;
+
+	for (j = 0; j < curr_req->dtd_count; j++) {
+		remaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)
+					& DTD_PACKET_SIZE)
+				>> DTD_LENGTH_BIT_POS;
+		actual -= remaining_length;
+
+		(errors = hc32_to_cpu(curr_td->size_ioc_sts) & DTD_ERROR_MASK);
+		if (errors) {
+			if (errors & DTD_STATUS_HALTED) {
+				ERR("dTD error %08x QH=%d\n", errors, pipe);
+				/* Clear the errors and Halt condition */
+				tmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp &= ~errors;
+				curr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);
+				status = -EPIPE;
+				/* FIXME: continue with next queued TD? */
+
+				break;
+			}
+			if (errors & DTD_STATUS_DATA_BUFF_ERR) {
+				VDBG("Transfer overflow");
+				status = -EPROTO;
+				break;
+			} else if (errors & DTD_STATUS_TRANSACTION_ERR) {
+				VDBG("ISO error");
+				status = -EILSEQ;
+				break;
+			} else
+				ERR("Unknown error has occured (0x%x)!\r\n",
+					errors);
+
+		} else if (hc32_to_cpu(curr_td->size_ioc_sts) &
+					DTD_STATUS_ACTIVE) {
+			VDBG("Request not complete");
+			status = REQ_UNCOMPLETE;
+			return status;
+		} else if (remaining_length) {
+			if (direction) {
+				VDBG("Transmit dTD remaining length not zero");
+				status = -EPROTO;
+				break;
+			} else {
+				td_complete++;
+				break;
+			}
+		} else {
+			td_complete++;
+			VDBG("dTD transmitted successful ");
+		}
+
+		if (j != curr_req->dtd_count - 1)
+			curr_td = curr_td->next_td_virt;
+	}
+
+	if (status)
+		return status;
+
+	curr_req->req.actual = actual;
+
+	return 0;
+}
+
+/* Process a DTD completion interrupt */
+static void dtd_complete_irq(struct fsl_udc *udc)
+{
+	u32 bit_pos;
+	int i, ep_num, direction, bit_mask, status;
+	struct fsl_ep *curr_ep;
+	struct fsl_req *curr_req, *temp_req;
+
+	/* Clear the bits in the register */
+	bit_pos = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(bit_pos, &dr_regs->endptcomplete);
+
+	if (!bit_pos)
+		return;
+
+	for (i = 0; i < udc->max_ep * 2; i++) {
+		ep_num = i >> 1;
+		direction = i % 2;
+
+		bit_mask = 1 << (ep_num + 16 * direction);
+
+		if (!(bit_pos & bit_mask))
+			continue;
+
+		curr_ep = get_ep_by_pipe(udc, i);
+
+		/* If the ep is configured */
+		if (curr_ep->name == NULL) {
+			WARN("Invalid EP?");
+			continue;
+		}
+
+		/* process the req queue until an uncomplete request */
+		list_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,
+				queue) {
+			status = process_ep_req(udc, i, curr_req);
+
+			VDBG("status of process_ep_req= %d, ep = %d",
+					status, ep_num);
+			if (status == REQ_UNCOMPLETE)
+				break;
+			/* write back status to req */
+			curr_req->req.status = status;
+
+			if (ep_num == 0) {
+				ep0_req_complete(udc, curr_ep, curr_req);
+				break;
+			} else {
+				done(curr_ep, curr_req, status);
+			}
+		}
+	}
+}
+
+/* Process a port change interrupt */
+static void port_change_irq(struct fsl_udc *udc)
+{
+	u32 speed;
+
+	VDBG("portsc=0x%x", fsl_readl(&dr_regs->portsc1) );
+	if (udc->bus_reset)
+		udc->bus_reset = 0;
+
+	/* Bus resetting is finished */
+	if (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
+		/* Get the speed */
+		speed = fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SPEED_MASK;
+		switch (speed) {
+		case PORTSCX_PORT_SPEED_HIGH:
+			udc->gadget.speed = USB_SPEED_HIGH;
+			break;
+		case PORTSCX_PORT_SPEED_FULL:
+			udc->gadget.speed = USB_SPEED_FULL;
+			break;
+		case PORTSCX_PORT_SPEED_LOW:
+			udc->gadget.speed = USB_SPEED_LOW;
+			break;
+		default:
+			udc->gadget.speed = USB_SPEED_UNKNOWN;
+			break;
+		}
+	}
+
+	/* Update USB state */
+	if (!udc->resume_state)
+		udc->usb_state = USB_STATE_DEFAULT;
+}
+
+/* Process suspend interrupt */
+static void suspend_irq(struct fsl_udc *udc)
+{
+	udc->resume_state = udc->usb_state;
+	udc->usb_state = USB_STATE_SUSPENDED;
+
+	/* report suspend to the driver, serial.c does not support this */
+	if (udc->driver->suspend)
+		udc->driver->suspend(&udc->gadget);
+}
+
+static void bus_resume(struct fsl_udc *udc)
+{
+	udc->usb_state = udc->resume_state;
+	udc->resume_state = 0;
+
+	/* report resume to the driver, serial.c does not support this */
+	if (udc->driver->resume)
+		udc->driver->resume(&udc->gadget);
+}
+
+/* Clear up all ep queues */
+static int reset_queues(struct fsl_udc *udc)
+{
+	u8 pipe;
+
+	for (pipe = 0; pipe < udc->max_pipes; pipe++)
+		udc_reset_ep_queue(udc, pipe);
+
+	/* report disconnect; the driver is already quiesced */
+	udc->driver->disconnect(&udc->gadget);
+
+	return 0;
+}
+
+/* Process reset interrupt */
+static void reset_irq(struct fsl_udc *udc)
+{
+	u32 temp;
+	unsigned long timeout;
+
+	/* Clear the device address */
+	temp = fsl_readl(&dr_regs->deviceaddr);
+	fsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
+
+	udc->device_address = 0;
+
+	/* Clear usb state */
+	udc->resume_state = 0;
+	udc->ep0_dir = 0;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+	udc->gadget.b_hnp_enable = 0;
+	udc->gadget.a_hnp_support = 0;
+	udc->gadget.a_alt_hnp_support = 0;
+
+	/* Clear all the setup token semaphores */
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp, &dr_regs->endptsetupstat);
+
+	/* Clear all the endpoint complete status bits */
+	temp = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(temp, &dr_regs->endptcomplete);
+
+	timeout = jiffies + 100;
+	while (fsl_readl(&dr_regs->endpointprime)) {
+		/* Wait until all endptprime bits cleared */
+		if (time_after(jiffies, timeout)) {
+			ERR("Timeout for reset\n");
+			break;
+		}
+		cpu_relax();
+	}
+
+	/* Write 1s to the flush register */
+	fsl_writel(0xffffffff, &dr_regs->endptflush);
+
+	if (fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET) {
+		VDBG("Bus reset");
+		/* Bus is reseting */
+		udc->bus_reset = 1;
+		/* Reset all the queues, include XD, dTD, EP queue
+		 * head and TR Queue */
+		reset_queues(udc);
+		udc->usb_state = USB_STATE_DEFAULT;
+	} else {
+		VDBG("Controller reset");
+		/* initialize usb hw reg except for regs for EP, not
+		 * touch usbintr reg */
+		dr_controller_setup(udc);
+
+		/* Reset all internal used Queues */
+		reset_queues(udc);
+
+		ep0_setup(udc);
+
+		/* Enable DR IRQ reg, Set Run bit, change udc state */
+		dr_controller_run(udc);
+		udc->usb_state = USB_STATE_ATTACHED;
+	}
+}
+
+/*
+ * USB device controller interrupt handler
+ */
+static irqreturn_t fsl_udc_irq(int irq, void *_udc)
+{
+	struct fsl_udc *udc = _udc;
+	u32 irq_src;
+	irqreturn_t status = IRQ_NONE;
+	unsigned long flags;
+
+	/* Disable ISR for OTG host mode */
+	if (udc->stopped)
+		return IRQ_NONE;
+	spin_lock_irqsave(&udc->lock, flags);
+	irq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);
+	/* Clear notification bits */
+	fsl_writel(irq_src, &dr_regs->usbsts);
+
+	VDBG("irq_src [0x%8x]  portsc=0x%x", irq_src,
+	     fsl_readl(&dr_regs->portsc1));
+
+	/* Need to resume? */
+	if (udc->usb_state == USB_STATE_SUSPENDED)
+		if ((fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SUSPEND) == 0)
+			bus_resume(udc);
+
+	/* USB Interrupt */
+	if (irq_src & USB_STS_INT) {
+		VDBG("Packet int");
+		/* Setup package, we only support ep0 as control ep */
+		if (fsl_readl(&dr_regs->endptsetupstat) & EP_SETUP_STATUS_EP0) {
+			tripwire_handler(udc, 0,
+					(u8 *) (&udc->local_setup_buff));
+			setup_received_irq(udc, &udc->local_setup_buff);
+			status = IRQ_HANDLED;
+		}
+
+		/* completion of dtd */
+		if (fsl_readl(&dr_regs->endptcomplete)) {
+			dtd_complete_irq(udc);
+			status = IRQ_HANDLED;
+		}
+	}
+
+	/* SOF (for ISO transfer) */
+	if (irq_src & USB_STS_SOF) {
+		status = IRQ_HANDLED;
+	}
+
+	/* Port Change */
+	if (irq_src & USB_STS_PORT_CHANGE) {
+		port_change_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	/* Reset Received */
+	if (irq_src & USB_STS_RESET) {
+		reset_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	/* Sleep Enable (Suspend) */
+	if (irq_src & USB_STS_SUSPEND) {
+		suspend_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	if (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR)) {
+		VDBG("Error IRQ %x ", irq_src);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return status;
+}
+
+/*----------------------------------------------------------------*
+ * Hook to gadget drivers
+ * Called by initialization code of gadget drivers
+*----------------------------------------------------------------*/
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	int retval = -ENODEV;
+	unsigned long flags = 0;
+	struct fsl_udc *udc = udc_controller;
+
+	pr_debug("udc: udc=0x%p\n", udc);
+
+	if (!udc)
+		return -ENODEV;
+
+	if (!driver || (driver->speed != USB_SPEED_FULL
+			&& driver->speed != USB_SPEED_HIGH)
+			|| !driver->bind || !driver->disconnect
+			|| !driver->setup)
+		return -EINVAL;
+
+	if (udc->driver)
+		return -EBUSY;
+
+	/* lock is needed but whether should use this lock or another */
+	spin_lock_irqsave(&udc->lock, flags);
+
+	driver->driver.bus = 0;
+	udc->softconnect = 1;
+	/* hook up the driver */
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	/* bind udc driver to gadget driver */
+	retval = driver->bind(&udc->gadget);
+	if (retval) {
+		pr_debug("bind to %s --> %d\n", driver->driver.name, retval);
+		udc->gadget.dev.driver = 0;
+		udc->driver = 0;
+		goto out;
+	}
+
+	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+	if (udc->transceiver) {
+		/* Suspend the controller until OTG enables it */
+		udc_suspend(udc);
+		pr_debug("udc: suspend udc for OTG auto detect \n");
+
+		/* Export udc suspend/resume call to OTG */
+		udc->gadget.dev.parent->driver->suspend = fsl_udc_suspend;
+		udc->gadget.dev.parent->driver->resume = fsl_udc_resume;
+
+		retval = otg_set_peripheral(udc->transceiver, &udc->gadget);
+		if (retval < 0) {
+			printk(KERN_ERR "can't bind to transceiver\n");
+			driver->unbind(&udc->gadget);
+			udc->gadget.dev.driver = 0;
+			udc->driver = 0;
+			return retval;
+		}
+	} else {
+		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+		dr_controller_run(udc);
+		udc->usb_state = USB_STATE_ATTACHED;
+		udc->ep0_state = WAIT_FOR_SETUP;
+		pr_debug("udc: ep0_state now WAIT_FOR_SETUP\n");
+		udc->ep0_dir = 0;
+	}
+
+	printk(KERN_INFO "%s: bind to driver %s \n", udc->gadget.name,
+		driver->driver.name);
+
+out:
+	return retval;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/* Disconnect from gadget driver */
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct fsl_ep *loop_ep;
+	unsigned long flags;
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	if (!driver || driver != udc_controller->driver || !driver->unbind)
+		return -EINVAL;
+
+#ifdef CONFIG_USB_OTG
+	if (udc_controller->transceiver)
+		(void)otg_set_peripheral(udc_controller->transceiver, 0);
+#endif
+
+	/* stop DR, disable intr */
+	dr_controller_stop(udc_controller);
+
+	/* in fact, no needed */
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	/* stand operation */
+	spin_lock_irqsave(&udc_controller->lock, flags);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	nuke(&udc_controller->eps[0], -ESHUTDOWN);
+	list_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,
+			ep.ep_list)
+		nuke(loop_ep, -ESHUTDOWN);
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
+
+	/* unbind gadget and unhook driver. */
+	driver->unbind(&udc_controller->gadget);
+	udc_controller->gadget.dev.driver = 0;
+	udc_controller->driver = 0;
+
+	printk(KERN_INFO "unregistered gadget '%s'\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/fsl_usb2_udc";
+
+static int fsl_proc_read(char *page, char **start, off_t off, int count,
+		int *eof, void *_dev)
+{
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t, i;
+	u32 tmp_reg;
+	struct fsl_ep *ep = NULL;
+	struct fsl_req *req;
+
+	struct fsl_udc *udc = udc_controller;
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* ------basic driver infomation ---- */
+	t = scnprintf(next, size,
+			DRIVER_DESC "\n"
+			"%s version: %s\n"
+			"Gadget driver: %s\n\n",
+			driver_name, DRIVER_VERSION,
+			udc->driver ? udc->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	/* ------ DR Registers ----- */
+	tmp_reg = fsl_readl(&dr_regs->usbcmd);
+	t = scnprintf(next, size,
+			"USBCMD reg: 0x%08x\n"
+			"\tSetupTW: %d\n"
+			"\tRun/Stop: %s\n\n",
+			tmp_reg,
+			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
+			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbsts);
+	t = scnprintf(next, size,
+			"USB Status Reg: 0x%08x\n"
+			"\tDr Suspend: %d   Reset Received: %d   "
+			"System Error: %s  USB Error Interrupt: %s\n\n",
+			tmp_reg,
+			(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_STS_RESET) ? 1 : 0,
+			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
+			(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbintr);
+	t = scnprintf(next, size,
+			"USB Interrupt Enable Reg: 0x%08x\n"
+			"\tSleep Enable: %d   SOF Received Enable: %d  "
+			"Reset Enable: %d\n"
+			"\tSystem Error Enable: %d  "
+			"Port Change Dectected Enable: %d\n"
+			"\tUSB Error Intr Enable: %d  USB Intr Enable: %d\n\n",
+			tmp_reg,
+			(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->frindex);
+	t = scnprintf(next, size,
+			"USB Frame Index Reg:  Frame Number is 0x%x\n\n",
+			(tmp_reg & USB_FRINDEX_MASKS));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->deviceaddr);
+	t = scnprintf(next, size,
+			"USB Device Address Reg:  Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->endpointlistaddr);
+	t = scnprintf(next, size,
+			"USB Endpoint List Address Reg:"
+			"Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_EP_LIST_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->portsc1);
+	t = scnprintf(next, size,
+		"USB Port Status&Control Reg:\n"
+		"\tPort Transceiver Type : %s" "Port Speed: %s \n"
+		"\tPHY Low Power Suspend: %s" "Port Reset: %s  "
+		"Port Suspend Mode: %s \n" "\tOver-current Change: %s  "
+		"Port Enable/Disable Change: %s\n"
+		"\tPort Enabled/Disabled: %s"
+		"Current Connect Status: %s\n\n", ( {
+			char *s;
+			switch (tmp_reg & PORTSCX_PTS_FSLS) {
+			case PORTSCX_PTS_UTMI:
+				s = "UTMI"; break;
+			case PORTSCX_PTS_ULPI:
+				s = "ULPI "; break;
+			case PORTSCX_PTS_FSLS:
+				s = "FS/LS Serial"; break;
+			default:
+				s = "None"; break;
+			}
+			s; } ), ( {
+			char *s;
+			switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
+			case PORTSCX_PORT_SPEED_FULL:
+				s = "Full Speed"; break;
+			case PORTSCX_PORT_SPEED_LOW:
+				s = "Low Speed"; break;
+			case PORTSCX_PORT_SPEED_HIGH:
+				s = "High Speed"; break;
+			default:
+				s = "Undefined"; break;
+			}
+			s;
+		} ),
+		(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
+		"Normal PHY mode" : "Low power mode",
+		(tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
+		"Not in Reset",
+		(tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
+		(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
+		"No",
+		(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
+		"Not change",
+		(tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
+		"Not correct",
+		(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
+		"Attached" : "Not-Att");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbmode);
+	t = scnprintf(next, size,
+			"USB Mode Reg:" "Controller Mode is : %s\n\n", ( {
+				char *s;
+				switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
+				case USB_MODE_CTRL_MODE_IDLE:
+					s = "Idle"; break;
+				case USB_MODE_CTRL_MODE_DEVICE:
+					s = "Device Controller"; break;
+				case USB_MODE_CTRL_MODE_HOST:
+					s = "Host Controller"; break;
+				default:
+					s = "None"; break;
+				}
+				s;
+			} ));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->endptsetupstat);
+	t = scnprintf(next, size,
+			"Endpoint Setup Status Reg:" "SETUP on ep 0x%x\n\n",
+			(tmp_reg & EP_SETUP_STATUS_MASK));
+	size -= t;
+	next += t;
+
+	for (i = 0; i < udc->max_ep / 2; i++) {
+		tmp_reg = fsl_readl(&dr_regs->endptctrl[i]);
+		t = scnprintf(next, size, "EP Ctrl Reg [0x%x]: = [0x%x]\n",
+				i, tmp_reg);
+		size -= t;
+		next += t;
+	}
+	tmp_reg = fsl_readl(&dr_regs->endpointprime);
+	t = scnprintf(next, size, "EP Prime Reg = [0x%x]\n", tmp_reg);
+	size -= t;
+	next += t;
+
+#ifdef HAVE_SYS_REGS
+	tmp_reg = usb_sys_regs->snoop1;
+	t = scnprintf(next, size, "\nSnoop1 Reg : = [0x%x]\n\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = usb_sys_regs->control;
+	t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
+			tmp_reg);
+	size -= t;
+	next += t;
+#endif
+
+	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
+	ep = &udc->eps[0];
+	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
+			ep->ep.name, ep_maxpacket(ep), ep_index(ep));
+	size -= t;
+	next += t;
+
+	if (list_empty(&ep->queue)) {
+		t = scnprintf(next, size, "its req queue is empty\n\n");
+		size -= t;
+		next += t;
+	} else {
+		list_for_each_entry(req, &ep->queue, queue) {
+			t = scnprintf(next, size,
+				"req %p actual 0x%x length 0x%x  buf %p\n",
+				&req->req, req->req.actual,
+				req->req.length, req->req.buf);
+			size -= t;
+			next += t;
+		}
+	}
+	/* other gadget->eplist ep */
+	list_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {
+		if (ep->desc) {
+			t = scnprintf(next, size,
+					"\nFor %s Maxpkt is 0x%x "
+					"index is 0x%x\n",
+					ep->ep.name, ep_maxpacket(ep),
+					ep_index(ep));
+			size -= t;
+			next += t;
+
+			if (list_empty(&ep->queue)) {
+				t = scnprintf(next, size,
+						"its req queue is empty\n\n");
+				size -= t;
+				next += t;
+			} else {
+				list_for_each_entry(req, &ep->queue, queue) {
+					t = scnprintf(next, size,
+						"req %p actual 0x%x length"
+						"0x%x  buf %p\n",
+						&req->req, req->req.actual,
+						req->req.length, req->req.buf);
+					size -= t;
+					next += t;
+					} /* end for each_entry of ep req */
+				}	/* end for else */
+			}	/* end for if(ep->queue) */
+		}		/* end (ep->desc) */
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, fsl_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+/*-------------------------------------------------------------------------*/
+
+/* Release udc structures */
+static void fsl_udc_release(struct device *dev)
+{
+	complete(udc_controller->done);
+	dma_free_coherent(dev, udc_controller->ep_qh_size,
+			udc_controller->ep_qh, udc_controller->ep_qh_dma);
+	kfree(udc_controller);
+}
+
+/******************************************************************
+	Internal structure setup functions
+*******************************************************************/
+/*------------------------------------------------------------------
+ * init resource for globle controller
+ * Return the udc handle on success or NULL on failure
+ ------------------------------------------------------------------*/
+static struct fsl_udc *__init struct_udc_setup(struct platform_device *pdev)
+{
+	struct fsl_udc *udc;
+	struct fsl_usb2_platform_data *pdata;
+	size_t size;
+
+	udc = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);
+	if (udc == NULL) {
+		ERR("malloc udc failed\n");
+		return NULL;
+	}
+
+	pdata = pdev->dev.platform_data;
+	udc->phy_mode = pdata->phy_mode;	/* DDD FIXME */
+
+	/* max_ep_nr is bidirectional ep number, max_ep doubles the number */
+	udc->max_ep = pdata->max_ep_nr * 2;
+
+	udc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);
+	if (!udc->eps) {
+		ERR("malloc fsl_ep failed\n");
+		goto cleanup;
+	}
+
+	/* initialized QHs, take care of alignment */
+	size = udc->max_ep * sizeof(struct ep_queue_head);
+	if (size < QH_ALIGNMENT)
+		size = QH_ALIGNMENT;
+	else if ((size % QH_ALIGNMENT) != 0) {
+		size += QH_ALIGNMENT + 1;
+		size &= ~(QH_ALIGNMENT - 1);
+	}
+	udc->ep_qh = dma_alloc_coherent(&pdev->dev, size,
+					&udc->ep_qh_dma, GFP_KERNEL);
+	if (!udc->ep_qh) {
+		ERR("malloc QHs for udc failed\n");
+		kfree(udc->eps);
+		goto cleanup;
+	}
+
+	udc->ep_qh_size = size;
+
+	/* Initialize ep0 status request structure */
+	udc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),
+			struct fsl_req, req);
+	/* allocate a small amount of memory to get valid address */
+	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
+	udc->status_req->req.dma = virt_to_phys(udc->status_req->req.buf);
+
+	udc->resume_state = USB_STATE_NOTATTACHED;
+	udc->usb_state = USB_STATE_POWERED;
+	udc->ep0_dir = 0;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+	spin_lock_init(&udc->lock);
+
+	return udc;
+
+cleanup:
+	kfree(udc);
+	return NULL;
+}
+
+/*----------------------------------------------------------------
+ * Setup the fsl_ep struct for eps
+ * Link fsl_ep->ep to gadget->ep_list
+ * ep0out is not used so do nothing here
+ * ep0in should be taken care
+ *--------------------------------------------------------------*/
+static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
+		char *name, int link)
+{
+	struct fsl_ep *ep = &udc->eps[index];
+
+	ep->udc = udc;
+	strcpy(ep->name, name);
+	ep->ep.name = ep->name;
+
+	ep->ep.ops = &fsl_ep_ops;
+	ep->stopped = 0;
+
+	/* for ep0: maxP defined in desc
+	 * for other eps, maxP is set by epautoconfig() called by gadget layer
+	 */
+	ep->ep.maxpacket = (unsigned short) ~0;
+
+	/* the queue lists any req for this ep */
+	INIT_LIST_HEAD(&ep->queue);
+
+	/* gagdet.ep_list used for ep_autoconfig so no ep0 */
+	if (link)
+		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	ep->gadget = &udc->gadget;
+	ep->qh = &udc->ep_qh[index];
+
+	return 0;
+}
+
+static int board_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	pr_debug("udc: pdev=0x%p  pdata=0x%p\n", pdev, pdata);
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev) != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* Driver probe functions */
+
+static int __init fsl_udc_probe(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_udc *udc;
+	unsigned int i;
+	struct otg_transceiver *transceiver = NULL;
+	int status = -ENODEV;
+	u32 id;
+	int irq_number;
+	u64 rsrc_start, rsrc_len;
+	int ret = -ENODEV;
+
+	pr_debug("udc: pdev=0x%p  pdata=0x%p\n", pdev, pdata);
+
+	if (board_init(pdev) != 0)
+		return -EINVAL;
+
+	/* Initialize the udc structure including QH member and other member */
+	udc = (struct fsl_udc *) struct_udc_setup(pdev);
+	udc_controller = udc;
+
+	if (!udc) {
+		ERR("udc is NULL \n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&pdev->dev, udc);
+	pr_debug("udc_controller=0x%p", udc_controller);
+
+	udc->pdata = pdata;
+	udc->xcvr_type = pdata->xcvr_type;
+
+#ifdef CONFIG_USB_OTG
+	udc->transceiver = otg_get_transceiver();
+	pr_debug("udc: otg_get_transceiver returns 0x%p", udc->transceiver);
+#endif
+
+	if (pdev->resource[1].flags != IORESOURCE_IRQ)
+		return -ENODEV;
+
+	rsrc_start = pdev->resource[0].start;
+	rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	pr_debug("     start=0x%ux   end=0x%ux\n",
+		 pdev->resource[0].start, pdev->resource[0].end);
+	pr_debug("rsrc_start=0x%llx  rsrc_len=0x%llx\n", rsrc_start, rsrc_len);
+
+	dr_regs = (struct fsl_usb_device_regs *)pdata->regs;
+
+	pr_debug("udc: pdate=0x%p dr_regs=0x%p\n", pdata, dr_regs);
+	pr_debug("udc: hci_version=0x%x\n", dr_regs->hciversion);
+	pr_debug("udc: otgsc at 0x%p\n", &dr_regs->otgsc);
+
+	id = fsl_readl(&dr_regs->id);
+	printk(KERN_INFO "FSL2 USBOTG h/w ID=0x%x  revision=0x%x\n",
+	       id & 0x3f, id >> 16);
+
+	/* USB OTG module IRQ */
+	irq_number = platform_get_irq(pdev, 0);
+	if (irq_number > 128) {
+		status = request_irq(irq_number, fsl_udc_irq, IRQF_SHARED,
+				     driver_name, udc);
+		if (status) {
+			ERR("can't get irq %d, err=%d\n", irq_number, status);
+			goto err2;
+		}
+	} else {
+		status = -ENODEV;
+		goto err2;
+	}
+
+	if (!udc->transceiver) {
+		/* initialize usb hw reg except for regs for EP,
+		 * leave usbintr reg untouched*/
+		dr_controller_setup(udc);
+	}
+
+	/* here comes the stand operations for probe
+	 * set the fsl_udc->gadget.xxx
+	 */
+	udc->gadget.ops = &fsl_gadget_ops;
+
+	/* gadget.ep0 is a pointer */
+	udc->gadget.ep0 = &udc->eps[0].ep;
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	udc->gadget.name = driver_name;
+
+	/* Setup gadget.dev and register with kernel */
+	strcpy(udc->gadget.dev.bus_id, "gadget");
+	udc->gadget.dev.release = fsl_udc_release;
+	udc->gadget.dev.parent = &pdev->dev;
+
+	ret = device_register(&udc->gadget.dev);
+	if (ret < 0)
+		goto err3;
+
+	if (udc->transceiver)
+		udc->gadget.is_otg = 1;
+
+	/* setup QH and epctrl for ep0 */
+	ep0_setup(udc);
+
+	/* setup udc->eps[] for ep0 */
+	struct_ep_setup(udc_controller, 0, "ep0", 0);
+	/* for ep0: the desc defined here;
+	 * for other eps, gadget layer called ep_enable with defined desc
+	 */
+	udc->eps[0].desc = &fsl_ep0_desc;
+	udc->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
+
+	/* setup the udc->eps[] for non-control endpoints and link
+	 * to gadget.ep_list */
+	for (i = 1; i < (int)(udc->max_ep / 2); i++) {
+		char name[14];
+
+		sprintf(name, "ep%dout", i);
+		struct_ep_setup(udc, i * 2, name, 1);
+		sprintf(name, "ep%din", i);
+		struct_ep_setup(udc, i * 2 + 1, name, 1);
+	}
+
+	/* use dma_pool for TD management */
+	udc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,
+			sizeof(struct ep_td_struct),
+			DTD_ALIGNMENT, UDC_DMA_BOUNDARY);
+	if (udc->td_pool == NULL) {
+		ret = -ENOMEM;
+		goto err4;
+	}
+#if 0 // DDD why this? hoarks OTG host
+	pullup_disable(udc);
+#endif
+
+	create_proc_file();
+	return 0;
+
+err4:
+	device_unregister(&udc_controller->gadget.dev);
+err3:
+	free_irq(udc_controller->irq, udc_controller);
+err2:
+	kfree(udc);
+	if (transceiver)
+		put_device(transceiver->dev);
+	release_mem_region(pdev->resource[0].start,
+			   pdev->resource[0].end - pdev->resource[0].start + 1);
+	return status;
+
+}
+
+/* Driver removal functions
+ * Free resources
+ * Finish pending transaction
+ */
+static int __exit fsl_udc_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
+	struct fsl_usb2_platform_data *pdata;
+	int irq_number;
+
+	DECLARE_COMPLETION(done);
+
+	pdata = pdev->dev.platform_data;
+
+	if (!udc)
+		return -ENODEV;
+
+	udc->done = &done;
+
+	/* DR has been stopped in usb_gadget_unregister_driver() */
+
+	if (udc->transceiver) {
+		put_device(udc->transceiver->dev);
+		udc->transceiver = NULL;
+	}
+
+	/* remove proc */
+	remove_proc_file();
+
+	/* free irq */
+	irq_number = udc->irq;
+	free_irq(pdev->resource[1].start, udc);
+	udc->irq = 0;
+
+	/* Free allocated memory */
+	kfree(udc->status_req->req.buf);
+	kfree(udc->status_req);
+	kfree(udc_controller->eps);
+
+	dma_pool_destroy(udc_controller->td_pool);
+	/* deinitlaize all ep: strcut */
+	/* deinitialize ep0: reg and QH */
+
+	device_unregister(&udc->gadget.dev);
+	/* free udc --wait for the release() finished */
+	wait_for_completion(&done);
+
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdev);
+
+	return 0;
+}
+
+static int udc_suspend(struct fsl_udc *udc)
+{
+	udc->stopped = 1;
+	return 0;
+}
+
+/*
+ * Modify Power management attributes
+ * Used by OTG statemachine to disable gadget temporarily
+ * Here we stop the DR controller and disable the irq
+ * @param dev device controller pointer
+ * @param state current state
+ * @return The function returns 0 on success or -1 if failed
+ */
+static int fsl_udc_suspend(struct device *dev, pm_message_t state)
+{
+	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
+	pr_debug("udc: Suspend. state=%d\n", state.event);
+	return udc_suspend(udc);
+}
+
+static int udc_resume(struct fsl_udc *udc)
+{
+	/*Enable DR irq reg and set controller Run */
+	if (udc->stopped) {
+		dr_controller_setup(udc);
+		dr_controller_run(udc);
+	}
+	udc->usb_state = USB_STATE_ATTACHED;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->ep0_dir = 0;
+	return 0;
+}
+
+/*
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ * @param dev device controller pointer
+ * @return The function returns 0 on success or -1 if failed
+ */
+static int fsl_udc_resume(struct device *dev)
+{
+	struct fsl_udc *udc = (struct fsl_udc *)dev_get_drvdata(dev);
+	pr_debug("udc: Resume dev=0x%p udc=0x%p\n", dev, udc);
+
+	return udc_resume(udc);
+}
+
+/*-------------------------------------------------------------------------
+	Register entry point for the peripheral controller driver
+--------------------------------------------------------------------------*/
+static struct platform_driver udc_driver = {
+	.probe   = fsl_udc_probe,
+	.remove  = __exit_p(fsl_udc_remove),
+	.driver  = {
+		.name = (char *)driver_name,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init udc_init(void)
+{
+	printk(KERN_INFO "%s version %s init \n", driver_desc, DRIVER_VERSION);
+	return platform_driver_register(&udc_driver);
+}
+
+module_init(udc_init);
+
+static void __exit udc_exit(void)
+{
+	platform_driver_unregister(&udc_driver);
+	printk(KERN_INFO "%s unregistered \n", driver_desc);
+}
+
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -32,6 +32,7 @@ config USB_EHCI_HCD
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
 	depends on USB_EHCI_HCD && EXPERIMENTAL
+	default y if M54455
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
@@ -60,12 +61,12 @@ config USB_EHCI_TT_NEWSCHED
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || M54455)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || M54455)
 	default y
 
 config USB_EHCI_FSL
@@ -260,3 +261,19 @@ config USB_R8A66597_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called r8a66597-hcd.
 
+choice
+	prompt "Select transceiver"
+	depends on M54455
+	default USB_M5445X_ULPI 
+
+config USB_M5445X_ULPI
+	bool "External ULPI"
+	---help---
+	  Enable support for the external HS ULPI transceiver.
+
+config USB_M5445X_FSLS
+	bool "On-chip (FL/LS only)"
+	---help---
+	  Enable support for the on-chip FL/LS transceiver.
+endchoice
+
--- /dev/null
+++ b/drivers/usb/host/ehci-arc.c
@@ -0,0 +1,431 @@
+/*
+ * drivers/usb/host/ehci-arc.c
+ *
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* Note: this file is #included by ehci-hcd.c */
+
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_usb2.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+
+#include "ehci-fsl.h"
+
+
+/* FIXME: Power Managment is un-ported so temporarily disable it */
+#undef CONFIG_PM
+
+/* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_fsl_probe - initialize FSL-based HCDs
+ * @drvier: Driver to be used for this HCD
+ * @pdev: USB Host Controller being probed
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller.
+ *
+ */
+static int usb_hcd_fsl_probe(const struct hc_driver *driver,
+			     struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	pr_debug("initializing FSL-SOC USB Controller\n");
+
+	/* Need platform data for setup */
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", pdev->dev.bus_id);
+		return -ENODEV;
+	}
+
+	retval = fsl_platform_verify(pdev);
+	if (retval)
+		return retval;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
+		retval = -ENODEV;
+		goto err1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			pdev->dev.bus_id);
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	fsl_platform_set_vbus_power(pdev, 1);
+
+	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	if (pdata->regs) {
+		pr_debug("REGS: using pdata->regs (0x%p)\n", pdata->regs);
+		hcd->regs = pdata->regs;
+		hcd->rsrc_start = pdata->r_start;
+		hcd->rsrc_len = pdata->r_len;
+	} else {
+		pr_debug("REGS: NO pdata->regs\n");
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(&pdev->dev, "Found HC with no register addr. "
+				"Check %s setup!\n", pdev->dev.bus_id);
+			retval = -ENODEV;
+			goto err2;
+		}
+		hcd->rsrc_start = res->start;
+		hcd->rsrc_len = res->end - res->start + 1;
+
+		/*
+		printk("DDD %s(): rsrc_start=0x%llx  rsrc_len=0x%llx  "
+			"pdata=0x%p\n", __FUNCTION__,
+			hcd->rsrc_start, hcd->rsrc_len, pdata);
+		*/
+
+		if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+					driver->description)) {
+			dev_dbg(&pdev->dev, "request_mem_region failed\n");
+			retval = -EBUSY;
+			goto err2;
+		}
+		hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+
+		if (hcd->regs == NULL) {
+			dev_dbg(&pdev->dev, "error mapping memory\n");
+			retval = -EFAULT;
+			goto err3;
+		}
+	}
+	hcd->power_budget = pdata->power_budget;
+
+	/* DDD
+	 * the following must be done by this point, otherwise the OTG
+	 * host port doesn't make it thru initializtion.
+	 * ehci_halt(), called by ehci_fsl_setup() returns -ETIMEDOUT
+	 */
+	fsl_platform_set_host_mode(hcd);
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval != 0)
+		goto err4;
+
+#if defined(CONFIG_USB_OTG)
+	if (pdata->does_otg) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		ehci->transceiver = otg_get_transceiver();
+
+		if (ehci->transceiver) {
+			retval = otg_set_host(ehci->transceiver,
+					      &ehci_to_hcd(ehci)->self);
+			if (retval) {
+				if (ehci->transceiver)
+					put_device(ehci->transceiver->dev);
+				goto err3;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto err3;
+		}
+	}
+#endif
+
+	return retval;
+
+err4:
+	/* DDD only if we did the iomap() iounmap(hcd->regs); */
+err3:
+	/* DDD only if we did a request_
+	 * release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	 */
+err2:
+	usb_put_hcd(hcd);
+err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdev);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_fsl_remove - shutdown processing for FSL-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_fsl_probe().
+ *
+ */
+static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
+			       struct platform_device *pdev)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	/* DDD shouldn't we turn off the power here? */
+	fsl_platform_set_vbus_power(pdev, 0);
+
+	usb_remove_hcd(hcd);
+
+	if (ehci->transceiver) {
+		(void)otg_set_host(ehci->transceiver, 0);
+		put_device(ehci->transceiver->dev);
+	}
+	usb_put_hcd(hcd);
+
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdev);
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_fsl_reinit(struct ehci_hcd *ehci)
+{
+	fsl_platform_usb_setup(ehci_to_hcd(ehci));
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+/* called during probe() after chip reset completes */
+static int ehci_fsl_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+	struct fsl_usb2_platform_data *pdata;
+	pdata = hcd->self.controller-> platform_data;
+
+	ehci->big_endian_desc = pdata->big_endian_desc;
+	ehci->big_endian_mmio = pdata->big_endian_mmio;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+	    HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	pr_debug("%s(): ehci->caps=0x%p  ehci->regs=0x%p\n", __FUNCTION__,
+		 ehci->caps, ehci->regs);
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->is_tdi_rh_tt = 1;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	retval = ehci_fsl_reinit(ehci);
+	return retval;
+}
+
+static const struct hc_driver ehci_fsl_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Freescale On-Chip EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = FSL_PLATFORM_HC_FLAGS,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_fsl_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+};
+
+#ifdef CONFIG_USB_OTG
+/*
+ * Holding pen for all the EHCI registers except port_status,
+ * which is a zero element array and hence takes no space.
+ * The port_status register is saved in usb_ehci_portsc.
+ */
+volatile static struct ehci_regs usb_ehci_regs;
+static u32 usb_ehci_portsc;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int ehci_fsl_drv_suspend(struct platform_device *pdev,
+				pm_message_t message)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+
+	pr_debug("%s pdev=0x%p  ehci=0x%p  hcd=0x%p\n",
+		 __FUNCTION__, pdev, ehci, hcd);
+	pr_debug("%s ehci->regs=0x%p  hcd->regs=0x%p  hcd->state=%d\n",
+		 __FUNCTION__, ehci->regs, hcd->regs, hcd->state);
+
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+	if (hcd->driver->suspend)
+		return hcd->driver->suspend(hcd, message);
+
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp &= ~CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	memcpy((void *)&usb_ehci_regs, ehci->regs, sizeof(struct ehci_regs));
+	usb_ehci_portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+
+	/* clear the W1C bits */
+	usb_ehci_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);
+
+	fsl_platform_set_vbus_power(pdev, 0);
+	/* clear PP to cut power to the port */
+	tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	tmp &= ~PORT_POWER;
+	ehci_writel(ehci, tmp, &ehci->regs->port_status[0]);
+
+	return 0;
+}
+
+static int ehci_fsl_drv_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	pr_debug("%s pdev=0x%p  pdata=0x%p  ehci=0x%p  hcd=0x%p\n",
+		 __FUNCTION__, pdev, pdata, ehci, hcd);
+
+	pr_debug("%s ehci->regs=0x%p  hcd->regs=0x%p",
+		 __FUNCTION__, ehci->regs, hcd->regs);
+
+	memcpy(ehci->regs, (void *)&usb_ehci_regs, sizeof(struct ehci_regs));
+	ehci_writel(ehci, usb_ehci_portsc, &ehci->regs->port_status[0]);
+
+	tmp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
+	ehci_writel(ehci, tmp, hcd->regs + FSL_SOC_USB_USBMODE);
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	hcd->state = HC_STATE_RUNNING;
+	pdev->dev.power.power_state = PMSG_ON;
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp |= CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	fsl_platform_set_vbus_power(pdev, 1);
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+#endif				/* CONFIG_USB_OTG */
+
+static int ehci_fsl_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_hcd_fsl_probe(&ehci_fsl_hc_driver, pdev);
+}
+
+static int ehci_fsl_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_fsl_remove(hcd, pdev);
+
+	return 0;
+}
+
+MODULE_ALIAS("fsl-ehci");
+
+static struct platform_driver ehci_fsl_driver = {
+	.probe = ehci_fsl_drv_probe,
+	.remove = ehci_fsl_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+#ifdef CONFIG_USB_OTG
+	.suspend = ehci_fsl_drv_suspend,
+	.resume  = ehci_fsl_drv_resume,
+#endif
+	.driver = {
+		   .name = "fsl-ehci",
+		   },
+};
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -18,6 +18,8 @@
 #ifndef _EHCI_FSL_H
 #define _EHCI_FSL_H
 
+#include <linux/usb/fsl_xcvr.h>
+
 /* offsets for the non-ehci registers in the FSL SOC USB controller */
 #define FSL_SOC_USB_ULPIVP	0x170
 #define FSL_SOC_USB_PORTSC1	0x184
@@ -34,5 +36,29 @@
 #define FSL_SOC_USB_PRICTRL	0x40c	/* NOTE: big-endian */
 #define FSL_SOC_USB_SICTRL	0x410	/* NOTE: big-endian */
 #define FSL_SOC_USB_CTRL	0x500	/* NOTE: big-endian */
-#define SNOOP_SIZE_2GB		0x1e
+
+#ifdef CONFIG_MPC834x
+#include <sysdev/fsl_usb.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX3
+#include <asm/arch/mx31_usb.h>
+#endif
+
+#ifdef CONFIG_ARCH_MX27
+#include <asm/arch/mx27_usb.h>
+#endif
+
+#ifdef CONFIG_M54455
+#include <asm-m68k/mcf5445x_usb.h>
+#endif
+
+
+static void fsl_platform_set_vbus_power(struct platform_device *pdev, int on)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata, on);
+}
 #endif				/* _EHCI_FSL_H */
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1043,6 +1043,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_M54455
+#include "ehci-arc.c"
+#define	PLATFORM_DRIVER		ehci_fsl_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -40,7 +40,8 @@ static inline void ehci_qtd_init(struct 
 {
 	memset (qtd, 0, sizeof *qtd);
 	qtd->qtd_dma = dma;
-	qtd->hw_token = cpu_to_le32 (QTD_STS_HALT);
+	// DDD official code` has: qtd->hw_token = cpu_to_le32 (QTD_STS_HALT);
+	qtd->hw_token = cpu_to_hc32 (ehci, QTD_STS_HALT);
 	qtd->hw_next = EHCI_LIST_END(ehci);
 	qtd->hw_alt_next = EHCI_LIST_END(ehci);
 	INIT_LIST_HEAD (&qtd->qtd_list);
@@ -211,9 +212,11 @@ static int ehci_mem_init (struct ehci_hc
 	}
 
 	/* Hardware periodic table */
-	ehci->periodic = (__le32 *)
+	// DDD official code has: ehci->periodic = (__le32 *)
+	ehci->periodic = (__hc32 *)
 		dma_alloc_coherent (ehci_to_hcd(ehci)->self.controller,
-			ehci->periodic_size * sizeof(__le32),
+			// DDD official: ehci->periodic_size * sizeof(__le32),
+			ehci->periodic_size * sizeof(__hc32),
 			&ehci->periodic_dma, 0);
 	if (ehci->periodic == NULL) {
 		goto fail;
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -122,6 +122,12 @@ struct ehci_hcd {			/* one per controlle
 
 	u8			sbrn;		/* packed release number */
 
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent
+	 */
+	struct otg_transceiver	*transceiver;
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
@@ -753,6 +759,22 @@ ehci_port_speed(struct ehci_hcd *ehci, u
 #define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
 #endif
 
+#if defined(CONFIG_COLDFIRE)
+/*
+ * Sorry, include/asm-m68k/io.h is messed up.  It will give you a
+ * BE readl or a LE readl depending on whether or not CONFIG_PCI is set.
+ * how broken is that?  Do the right thing here.
+ */
+#undef readl
+#undef writel
+
+#define readl(addr)		in_le32((__force unsigned *)(addr))
+#define writel(val,addr)	out_le32((__force unsigned *)(addr),(val))
+
+#define readl_be(addr)		in_be32((__force unsigned *)(addr))
+#define writel_be(val, addr)	out_be32((__force unsigned *)(addr), (val))
+#endif
+
 static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
 		__u32 __iomem * regs)
 {
--- /dev/null
+++ b/drivers/usb/otg/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for USB OTG controller  driver
+#
+fsl_usb2_otg-objs		:= fsl_otg.o otg_fsm.o
+obj-y				+= fsl_usb2_otg.o
--- /dev/null
+++ b/drivers/usb/otg/fsl_otg.c
@@ -0,0 +1,1515 @@
+/*
+ * Copyright (c) Freescale Semiconductor, Inc. 2006-2007
+ *
+ * USB OTG ULPI driver
+ *
+ * Based on code for MPC from:
+ *  Leo Li<LeoLi@freescale.com>
+ *  Jerry Huang<Chang-Ming.Huang@freescale.com>
+ *
+ * and M5329 code from
+ *  Yaroslav Vinogradov yaroslav.vinogradov@freescale.com
+ *  Andrey Butok
+ *
+ *  Initialization based on code from Shlomi Gridish.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ ***************************************************************************
+ * Changes:
+ *   v0.3	08 August 2007		Duck
+ *   v0.2	20 October 2006		Andrey Butok
+ *		Issues fixing and some changes.
+ *   v0.1	September 2006		Yaroslav Vinogradov
+ *		Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/usb.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/workqueue.h>
+#include <linux/time.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_usb2.h>
+
+#include <linux/io.h>
+
+#if defined CONFIG_M54455
+#include <asm/mcfsim.h>
+#endif
+
+#define USE_WORK_QUEUES
+#include "fsl_otg.h"
+
+#define CONFIG_USB_OTG_DEBUG_FILES
+#define DRIVER_VERSION "Revision: 1.56"
+#define DRIVER_AUTHOR "Freescale Semiconductor Inc."
+#define DRIVER_DESC "Freescale USB OTG ULPI Driver"
+#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
+
+MODULE_DESCRIPTION("Freescale USB OTG Controller Driver");
+
+static const char driver_name[] = "fsl-usb2-otg";
+
+static spinlock_t usb_dr_regs_lock;
+
+/*#define HA_DATA_PULSE 1*/
+
+volatile static struct fsl_usb_device_regs *usb_dr_regs;
+static struct fsl_otg *fsl_otg_dev;
+static int srp_wait_done;
+
+/* Driver specific timers */
+struct fsl_otg_timer *b_data_pulse_tmr, *b_vbus_pulse_tmr, *b_srp_fail_tmr,
+	*b_srp_wait_tmr, *a_wait_enum_tmr;
+
+static struct list_head active_timers;
+
+static struct fsl_otg_config fsl_otg_initdata = {
+	.otg_port = 1,
+};
+
+static void dump_state(const char *string, struct otg_fsm *fsm)
+{
+	printk(KERN_DEBUG "%s\n\tOTG state: %s\n", string,
+	       state_string(fsl_otg_dev->otg.state));
+	printk(KERN_DEBUG "\tFSM protocol=%s\n", fsm->protocol ?
+	       (fsm->protocol == PROTO_HOST ? "Host" : "Gadget")
+	       : "None");
+
+	/* regs */
+	printk(KERN_DEBUG "\t  OTGSC 0x%08x\n",
+	       fsl_readl(&usb_dr_regs->otgsc));
+	printk(KERN_DEBUG "\tPORTSC1 0x%08x\n",
+	       fsl_readl(&usb_dr_regs->portsc1));
+	printk(KERN_DEBUG "\tUSBMODE 0x%08x\n",
+	       fsl_readl(&usb_dr_regs->usbmode));
+	printk(KERN_DEBUG "\t USBCMD 0x%08x\n",
+	       fsl_readl(&usb_dr_regs->usbcmd));
+	printk(KERN_DEBUG "\t USBSTS 0x%08x\n",
+	       fsl_readl(&usb_dr_regs->usbsts));
+
+	/* ------ State Machine Variables ----- */
+	printk(KERN_DEBUG "\ta_bus_req: %d\n", fsm->a_bus_req);
+	printk(KERN_DEBUG "\tb_bus_req: %d\n", fsm->b_bus_req);
+	printk(KERN_DEBUG "\ta_bus_resume: %d\n", fsm->a_bus_resume);
+	printk(KERN_DEBUG "\ta_bus_suspend: %d\n", fsm->a_bus_suspend);
+	printk(KERN_DEBUG "\ta_conn: %d\n", fsm->a_conn);
+	printk(KERN_DEBUG "\ta_sess_vld: %d\n", fsm->a_sess_vld);
+	printk(KERN_DEBUG "\ta_srp_det: %d\n", fsm->a_srp_det);
+	printk(KERN_DEBUG "\ta_vbus_vld: %d\n", fsm->a_vbus_vld);
+	printk(KERN_DEBUG "\tb_bus_resume: %d\n", fsm->b_bus_resume);
+	printk(KERN_DEBUG "\tb_bus_suspend: %d\n", fsm->b_bus_suspend);
+	printk(KERN_DEBUG "\tb_conn: %d\n", fsm->b_conn);
+	printk(KERN_DEBUG "\tb_se0_srp: %d\n", fsm->b_se0_srp);
+	printk(KERN_DEBUG "\tb_sess_end: %d\n", fsm->b_sess_end);
+	printk(KERN_DEBUG "\tb_sess_vld: %d\n", fsm->b_sess_vld);
+	printk(KERN_DEBUG "\tid: %d\n", fsm->id);
+}
+
+
+/* Routines to access transceiver ULPI registers */
+u8 view_ulpi(u8 addr)
+{
+	u32 temp;
+
+	temp = 0x40000000 | (addr << 16);
+	fsl_writel(temp, &usb_dr_regs->ulpiview);
+
+	udelay(1000);
+
+	/* DDD timeout this loop: */
+	do {
+		temp = fsl_readl(&usb_dr_regs->ulpiview);
+	} while (temp & 0x40000000);
+
+	return (temp & 0x0000ff00) >> 8;
+}
+
+int write_ulpi(u8 addr, u8 data)
+{
+	u32 temp;
+
+	temp = 0x60000000 | (addr << 16) | data;
+	fsl_writel(temp, &usb_dr_regs->ulpiview);
+	return 0;
+}
+
+/* prototype declaration */
+void fsl_otg_add_timer(void *timer);
+void fsl_otg_del_timer(void *timer);
+
+/* -------------------------------------------------------------*/
+/* Operations that will be called from OTG Finite State Machine */
+
+/* Charge vbus for vbus pulsing in SRP */
+void fsl_otg_chrg_vbus(int on)
+{
+	u32 tmp;
+
+	VDBG(" %d\n", on);
+
+	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
+
+	if (on) {
+		tmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;
+		tmp |= OTGSC_CTRL_VBUS_CHARGE;
+	} else {
+		tmp &= ~OTGSC_CTRL_VBUS_CHARGE;
+	}
+	fsl_writel(tmp, &usb_dr_regs->otgsc);
+}
+
+/* Discharge vbus through a resistor to ground */
+void fsl_otg_dischrg_vbus(int on)
+{
+	u32 tmp;
+
+	VDBG(" %d\n", on);
+
+	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
+
+	if (on)
+		tmp |= OTGSC_CTRL_VBUS_DISCHARGE;
+	else
+		tmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;
+
+	fsl_writel(tmp, &usb_dr_regs->otgsc);
+}
+
+/* A-device driver vbus, controlled through PP bit in PORTSC */
+void fsl_otg_drv_vbus(int on)
+{
+	u32 tmp;
+
+	VDBG(" %d\n", on);
+
+	tmp = fsl_readl(&usb_dr_regs->portsc1) & ~PORTSCX_W1C_BITS;
+
+	if (on)
+		tmp |= PORTSCX_PORT_POWER;
+	else
+		tmp &= ~PORTSCX_PORT_POWER;
+
+	fsl_writel(tmp, &usb_dr_regs->portsc1);
+}
+
+/* Pull-up D+, signalling connect by periperal. Also used in
+ * data-line pulsing in SRP */
+void fsl_otg_loc_conn(int on)
+{
+	u32 tmp;
+
+	VDBG(" %d\n", on);
+
+	tmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;
+
+	if (on)
+		tmp |= OTGSC_CTRL_DATA_PULSING;
+	else
+		tmp &= ~OTGSC_CTRL_DATA_PULSING;
+
+	fsl_writel(tmp, &usb_dr_regs->otgsc);
+}
+
+/* Generate SOF by host.  This is controlled through suspend/resume the
+ * port.  In host mode, controller will automatically send SOF.
+ * Suspend will block the data on the port.
+ */
+void fsl_otg_loc_sof(int on)
+{
+	u32 tmp;
+
+	VDBG(" %d\n", on);
+
+	tmp = fsl_readl(&usb_dr_regs->portsc1) & ~PORTSCX_W1C_BITS;
+
+	if (on)
+		tmp |= PORTSCX_PORT_FORCE_RESUME;
+	else
+		tmp |= PORTSCX_PORT_SUSPEND;
+
+	fsl_writel(tmp, &usb_dr_regs->portsc1);
+}
+
+/* Start SRP pulsing by data-line pulsing, followed with v-bus pulsing. */
+void fsl_otg_start_pulse(void)
+{
+	u32 __attribute__ ((unused)) tmp;
+
+	VDBG("\n");
+	srp_wait_done = 0;
+
+#ifdef HA_DATA_PULSE
+	tmp = fsl_readl(&usb_dr_regs->otgsc) &= ~OTGSC_INTSTS_MASK;
+	tmp |= OTGSC_HA_DATA_PULSE;
+	fsl_writel(tmp, &usb_dr_regs->otgsc);
+#else
+	fsl_otg_loc_conn(1);
+#endif
+
+	fsl_otg_add_timer(b_data_pulse_tmr);
+}
+
+void fsl_otg_pulse_vbus(void);
+
+void b_data_pulse_end(unsigned long foo)
+{
+#ifdef HA_DATA_PULSE
+#else
+	fsl_otg_loc_conn(0);
+#endif
+
+	/* Do VBUS pulse after data pulse */
+	fsl_otg_pulse_vbus();
+}
+
+void fsl_otg_pulse_vbus(void)
+{
+	srp_wait_done = 0;
+	fsl_otg_chrg_vbus(1);
+	/* start the timer to end vbus charge */
+	fsl_otg_add_timer(b_vbus_pulse_tmr);
+}
+
+void b_vbus_pulse_end(unsigned long foo)
+{
+	fsl_otg_chrg_vbus(0);
+
+	/* As USB3300 using the same a_sess_vld and b_sess_vld voltage
+	 * we need to discharge the bus for a while to distinguish
+	 * residual voltage of vbus pulsing and A device pull up */
+	fsl_otg_dischrg_vbus(1);
+	fsl_otg_add_timer(b_srp_wait_tmr);
+}
+
+void b_srp_end(unsigned long foo)
+{
+	fsl_otg_dischrg_vbus(0);
+	srp_wait_done = 1;
+
+	if ((fsl_otg_dev->otg.state == OTG_STATE_B_SRP_INIT) &&
+	    fsl_otg_dev->fsm.b_sess_vld)
+		fsl_otg_dev->fsm.b_srp_done = 1;
+}
+
+/* Workaround for a_host suspending too fast.  When a_bus_req=0,
+ * a_host will start by SRP.  It needs to set b_hnp_enable before
+ * actually suspending to start HNP
+ */
+void a_wait_enum(unsigned long foo)
+{
+	VDBG("a_wait_enum timeout\n");
+	if (!fsl_otg_dev->otg.host->b_hnp_enable)
+		fsl_otg_add_timer(a_wait_enum_tmr);
+	else
+		otg_statemachine(&fsl_otg_dev->fsm);
+}
+
+/* ------------------------------------------------------*/
+
+/* The timeout callback function to set time out bit */
+void set_tmout(unsigned long indicator)
+{
+	*(int *)indicator = 1;
+}
+
+/* Initialize timers */
+void fsl_otg_init_timers(struct otg_fsm *fsm)
+{
+	/* FSM used timers */
+	fsm->a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
+				(unsigned long)&fsm->a_wait_vrise_tmout);
+	fsm->a_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,
+				(unsigned long)&fsm->a_wait_bcon_tmout);
+	fsm->a_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
+				(unsigned long)&fsm->a_aidl_bdis_tmout);
+	fsm->b_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,
+				(unsigned long)&fsm->b_ase0_brst_tmout);
+	fsm->b_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,
+				(unsigned long)&fsm->b_se0_srp);
+	fsm->b_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,
+				(unsigned long)&fsm->b_srp_done);
+	fsm->a_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,
+				(unsigned long)&fsm);
+
+	/* device driver used timers */
+	b_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);
+	b_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,
+				TB_DATA_PLS, 0);
+	b_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,
+				TB_VBUS_PLS, 0);
+
+}
+
+/* Add timer to timer list */
+void fsl_otg_add_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer;
+
+	/* Check if the timer is already in the active list,
+	 * if so update timer count
+	 */
+	list_for_each_entry(tmp_timer, &active_timers, list)
+	    if (tmp_timer == timer) {
+		timer->count = timer->expires;
+		return;
+	}
+	timer->count = timer->expires;
+	list_add_tail(&timer->list, &active_timers);
+}
+
+/* Remove timer from the timer list; clear timeout status */
+void fsl_otg_del_timer(void *gtimer)
+{
+	struct fsl_otg_timer *timer = (struct fsl_otg_timer *)gtimer;
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)
+		if (tmp_timer == timer)
+			list_del(&timer->list);
+}
+
+/*
+ * Reduce timer count by 1, and find timeout conditions.
+ * Called by fsl_otg 1ms timer interrupt
+ */
+int fsl_otg_tick_timer(void)
+{
+	struct fsl_otg_timer *tmp_timer, *del_tmp;
+	int expired = 0;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {
+		tmp_timer->count--;
+		/* check if timer expires */
+		if (!tmp_timer->count) {
+			list_del(&tmp_timer->list);
+			tmp_timer->function(tmp_timer->data);
+			expired = 1;
+		}
+	}
+
+	return expired;
+}
+
+/* Reset controller, not reset the bus */
+void otg_reset_controller(void)
+{
+	u32 command;
+	unsigned long flags;
+	int timeout;
+
+	VDBG("\n");
+
+	spin_lock_irqsave(&usb_dr_regs_lock, flags);
+
+	command = fsl_readl(&usb_dr_regs->usbcmd);
+	command |= USB_CMD_CTRL_RESET;
+	fsl_writel(command, &usb_dr_regs->usbcmd);
+	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
+
+	/* Wait reset completed */
+	timeout = 500;
+	while (fsl_readl(&usb_dr_regs->usbcmd) & USB_CMD_CTRL_RESET)
+		udelay(1);
+	if (timeout <= 0)
+		ERR("%s - USBCMD_RST never clear. Timeout is %d \n",
+			__FUNCTION__, timeout);
+}
+
+/* Call suspend/resume routines in host driver */
+int fsl_otg_start_host(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *dev;
+	struct fsl_otg *otg_dev = container_of(xceiv, struct fsl_otg, otg);
+	u32 retval = 0;
+
+	if (!xceiv->host)
+		return -ENODEV;
+
+	dev = xceiv->host->controller;
+
+	/*
+	 * Update a_vbus_vld state as a_vbus_vld int is disabled
+	 * in device mode
+	 */
+	fsm->a_vbus_vld =
+		!!(fsl_readl(&usb_dr_regs->otgsc) & OTGSC_STS_A_VBUS_VALID);
+	if (on) {
+		/* start fsl usb host controller */
+		if (otg_dev->host_working)
+			goto end;
+		else {
+			otg_reset_controller();
+			VDBG("host on......\n");
+			if (dev->driver->resume) {
+				retval = dev->driver->resume(dev);
+				if (fsm->id) {
+					/* default-b */
+					fsl_otg_drv_vbus(1);
+					/* Workaround: b_host can't driver
+					 * vbus, but PP in PORTSC needs to
+					 * be 1 for host to work.
+					 * So we set drv_vbus bit in
+					 * transceiver to 0 thru ULPI. */
+					write_ulpi(0x0c, 0x20);
+				}
+			}
+
+			otg_dev->host_working = 1;
+		}
+	} else {
+		/* stop fsl usb host controller */
+		if (!otg_dev->host_working)
+			goto end;
+		else {
+			VDBG("host off......\n");
+			if (dev && dev->driver) {
+				retval = dev->driver->suspend(dev, PMSG_SUSPEND);
+				if (fsm->id)
+					/* default-b */
+					fsl_otg_drv_vbus(0);
+			}
+			otg_dev->host_working = 0;
+		}
+	}
+end:
+	return retval;
+}
+
+/*
+ * Call suspend and resume function in udc driver
+ * to stop and start udc driver.
+ */
+int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
+{
+	struct otg_transceiver *xceiv = fsm->transceiver;
+	struct device *dev;
+
+	VDBG("DDD fsm=%p  xceiv=%p\n", fsm, xceiv);
+	if (!xceiv->gadget || !xceiv->gadget->dev.parent)
+		return -ENODEV;
+
+	VDBG("DDD xceiv=%p  xceiv->gadget=%p  parent=%p\n", xceiv, xceiv->gadget,
+		xceiv->gadget->dev.parent);
+
+	VDBG("gadget %s\n", on ? "on" : "off");
+	/* DDD  dump_state("starting gadget", fsm); */
+
+	dev = xceiv->gadget->dev.parent;
+
+	if (on)
+		dev->driver->resume(dev);
+	else
+		dev->driver->suspend(dev, PMSG_SUSPEND);
+
+	return 0;
+}
+
+static void fsl_otg_enable(struct otg_transceiver *otg_p)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+	struct otg_fsm *fsm = &(otg_dev)->fsm;
+	u32 otg_sc;
+
+	/* DDD VDBG(""); */
+	/* enable OTG interrupt */
+	otg_sc = fsl_readl(&usb_dr_regs->otgsc);
+	otg_sc |= OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+	otg_sc &= ~OTGSC_IE_1ms_TIMER;
+	otg_sc &= ~OTGSC_CTRL_VBUS_DISCHARGE;
+	otg_sc |= OTGSC_IE_USB_ID;	/* DDD added this */
+	fsl_writel(otg_sc, &usb_dr_regs->otgsc);
+
+	fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+
+	if (fsm->id) {
+		otg_p->state = OTG_STATE_UNDEFINED;
+	} else {
+		otg_p->state = OTG_STATE_A_IDLE;
+	}
+
+	otg_p->default_a = (fsm->id == 0);
+	otg_p->host->is_b_host = fsm->id;
+	otg_p->gadget->is_a_peripheral = !fsm->id;
+
+	fsm->a_vbus_vld = 1;
+
+	fsm->b_sess_vld = (otg_sc & OTGSC_STS_B_SESSION_VALID) ? 1 : 0;
+	fsm->a_sess_vld = (otg_sc & OTGSC_STS_A_SESSION_VALID) ? 1 : 0;
+	fsm->b_sess_end = (otg_sc & OTGSC_STS_B_SESSION_END) ? 1 : 0;
+}
+
+/*
+ * Called by initialization code of host driver.  Register host controller
+ * to the OTG.  Suspend host for OTG role detection.
+ */
+static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
+{
+#if 0 // DDD beta-final
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+	struct device *dev = host->controller;
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	otg_p->host = host;
+	otg_p->host->is_b_host = otg_dev->fsm.id;
+
+	otg_dev->fsm.a_bus_drop = 0;
+	otg_dev->fsm.a_bus_req = 1;
+
+	otg_p->host->otg_port = fsl_otg_initdata.otg_port;
+
+	if (dev && dev->driver) {
+		VDBG("suspending host\n");
+		dev->driver->suspend(dev, PMSG_SUSPEND);
+		otg_dev->host_working = 0;
+		VDBG("back\n");
+	}
+
+
+	/* dump_state("set_host running statemachine", &otg_dev->fsm); DDD */
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+#else
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	otg_p->host = host;
+
+	otg_dev->fsm.a_bus_drop = 0;
+	otg_dev->fsm.a_bus_req = 1;
+
+	if (host) {
+		VDBG("host off......\n");
+
+		otg_p->host->otg_port = fsl_otg_initdata.otg_port;
+		otg_p->host->is_b_host = otg_dev->fsm.id;
+		/* must leave time for khubd to finish its thing
+		 * before yanking the host driver out from under it,
+		 * so suspend the host after a short delay.
+		 */
+		otg_dev->host_working = 1;
+		schedule_delayed_work(&otg_dev->otg_event, 100);
+		return 0;
+	} else {		/* host driver going away */
+
+		if (!(le32_to_cpu(otg_dev->dr_mem_map->otgsc) &
+		      OTGSC_STS_USB_ID)) {
+			/* Mini-A cable connected */
+			struct otg_fsm *fsm = &otg_dev->fsm;
+
+			otg_p->state = OTG_STATE_UNDEFINED;
+			fsm->protocol = PROTO_UNDEF;
+		}
+	}
+
+	otg_dev->host_working = 0;
+
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+#endif
+}
+
+/* Called by initialization code of udc.  Register udc to OTG.*/
+static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
+				  struct usb_gadget *gadget)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	VDBG("\n");
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	if (!gadget) {
+		if (!otg_dev->otg.default_a)
+			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
+		usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+		otg_dev->otg.gadget = 0;
+		otg_dev->fsm.b_bus_req = 0;
+		otg_statemachine(&otg_dev->fsm);
+		return 0;
+	}
+
+	otg_p->gadget = gadget;
+	otg_p->gadget->is_a_peripheral = !otg_dev->fsm.id;
+
+	otg_dev->fsm.b_bus_req = 1;
+
+#if 0 /* DDD uClinux */
+	if (otg_p->host) {
+		fsl_otg_enable(otg_p);
+		otg_statemachine(&otg_dev->fsm);
+	}
+#endif
+	/* start the gadget right away if the ID pin says Mini-B */
+	DBG("ID pin=%d\n", otg_dev->fsm.id);
+	if (otg_dev->fsm.id == 1) {
+		fsl_otg_start_host(&otg_dev->fsm, 0);
+		fsl_otg_drv_vbus(0);
+		fsl_otg_start_gadget(&otg_dev->fsm, 1);
+	}
+
+	return 0;
+}
+
+/* Set OTG port power, only for B-device */
+static int fsl_otg_set_power(struct otg_transceiver *otg_p, unsigned mA)
+{
+	if (!fsl_otg_dev)
+		return -ENODEV;
+	if (otg_p->state == OTG_STATE_B_PERIPHERAL)
+		printk(KERN_DEBUG "FSL OTG:Draw %d mA\n", mA);
+
+	return 0;
+}
+
+/* Delayed pin detect interrupt processing.
+ *
+ * When the Mini-A cable is disconnected from the board,
+ * the pin-detect interrupt happens before the disconnnect
+ * interrupts for the connected device(s).  In order to
+ * process the disconnect interrupt(s) prior to switching
+ * roles, the pin-detect interrupts are delayed, and handled
+ * by this routine.
+ */
+static void fsl_otg_event(struct work_struct *work)
+{
+	struct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);
+	struct otg_fsm *fsm = &og->fsm;
+
+	VDBG("DDD fsm->id=%d\n", fsm->id);
+	if (fsm->id) {		/* switch to gadget */
+		fsl_otg_start_host(fsm, 0);
+		fsl_otg_drv_vbus(0);
+		fsl_otg_start_gadget(fsm, 1);
+	}
+}
+
+/* B-device start SRP */
+static int fsl_otg_start_srp(struct otg_transceiver *otg_p)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev
+	    || otg_p->state != OTG_STATE_B_IDLE)
+		return -ENODEV;
+
+	otg_dev->fsm.b_bus_req = 1;
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/* A_host suspend will call this function to start hnp */
+static int fsl_otg_start_hnp(struct otg_transceiver *otg_p)
+{
+	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+
+	if (!otg_p || otg_dev != fsl_otg_dev)
+		return -ENODEV;
+
+	VDBG("start_hnp.............\n");
+	/* clear a_bus_req to enter a_suspend state */
+	otg_dev->fsm.a_bus_req = 0;
+	otg_statemachine(&otg_dev->fsm);
+
+	return 0;
+}
+
+/*
+ * Interrupt handler.  OTG/host/peripheral share the same int line.
+ * OTG driver clears OTGSC interrupts and leaves USB interrupts
+ * intact.  It needs to have knowledge of some USB interrupts
+ * such as port change.
+ */
+irqreturn_t fsl_otg_isr(int irq, void *dev_id)
+{
+	struct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;
+	struct otg_transceiver *otg = &((struct fsl_otg *)dev_id)->otg;
+	u32 otg_int_src, otg_sc;
+
+	otg_sc = fsl_readl(&usb_dr_regs->otgsc);
+	otg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);
+
+	/* Only clear otg interrupts */
+	fsl_writel(otg_sc, &usb_dr_regs->otgsc);
+
+	/*FIXME: ID change not generate when init to 0 */
+	fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+	otg->default_a = (fsm->id == 0);
+
+	/* process OTG interrupts */
+	if (otg_int_src) {
+		VDBG("\nOTG irq 0x%08x\n", otg_int_src);
+
+		if (otg_int_src & OTGSC_INTSTS_USB_ID) {
+			fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+			otg->default_a = (fsm->id == 0);
+			/* clear conn information */
+			if (fsm->id)
+				fsm->b_conn = 0;
+			else
+				fsm->a_conn = 0;
+
+			if (otg->host)
+				otg->host->is_b_host = fsm->id;
+			if (otg->gadget)
+				otg->gadget->is_a_peripheral = !fsm->id;
+			VDBG("ID int (ID is %d)\n", fsm->id);
+
+			if (fsm->id) {	/* switch to gadget */
+				schedule_delayed_work(&((struct fsl_otg *)
+							dev_id)->otg_event, 25);
+			} else {	/* switch to host */
+				cancel_delayed_work(&
+						    ((struct fsl_otg *)dev_id)->
+						    otg_event);
+				fsl_otg_start_gadget(fsm, 0);
+				fsl_otg_drv_vbus(1);
+				fsl_otg_start_host(fsm, 1);
+			}
+
+			return IRQ_HANDLED;
+		}
+	}
+
+	return IRQ_NONE;
+}
+
+
+#if 0 // DDD feta-final
+irqreturn_t foo_fsl_otg_isr(int irq, void *dev_id)
+{
+	struct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;
+	struct otg_transceiver *otg = &((struct fsl_otg *)dev_id)->otg;
+	u32 otg_int_src, usb_int_src, otg_sc;
+	int trigger = 0;
+	int tmp;
+
+	usb_int_src = fsl_readl(&usb_dr_regs->usbsts);
+	otg_sc = fsl_readl(&usb_dr_regs->otgsc);
+	otg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);
+
+	/* Only clear otg interrupts */
+	fsl_writel(otg_sc, &usb_dr_regs->otgsc);
+
+	/*FIXME: ID change not generate when init to 0 */
+	/* process OTG interrupts */
+	if (otg_int_src) {
+		VDBG("\nOTG irq 0x%08x\n", otg_int_src);
+		if (otg_int_src & OTGSC_INTSTS_1MS_TIMER)
+			trigger = fsl_otg_tick_timer();
+
+		if (otg_int_src & OTGSC_INTSTS_USB_ID) {
+			fsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;
+			otg->default_a = (fsm->id == 0);
+			if (otg->host)
+				otg->host->is_b_host = fsm->id;
+			if (otg->gadget)
+				otg->gadget->is_a_peripheral = !fsm->id;
+			VDBG("IRQ=ID now=%d\n", fsm->id);
+
+			if (fsm->id) {	/* switch to gadget */
+				schedule_delayed_work(&((struct fsl_otg *)
+							dev_id)->otg_event, 25);
+			} else {	/* switch to host */
+				cancel_delayed_work(&
+						    ((struct fsl_otg *)dev_id)->
+						    otg_event);
+				fsl_otg_start_gadget(fsm, 0);
+				fsl_otg_drv_vbus(1);
+				fsl_otg_start_host(fsm, 1);
+			}
+
+			return IRQ_HANDLED;
+		}
+		if (otg_int_src & OTGSC_INTSTS_DATA_PULSE) {
+			fsm->a_srp_det = 1;
+			trigger = 1;
+			VDBG("!!!!Data pulse int\n");
+		}
+		if (otg_int_src & OTGSC_INTSTS_A_SESSION_VALID) {
+			fsm->a_sess_vld =
+			    (otg_sc & OTGSC_STS_A_SESSION_VALID) ? 1 : 0;
+			/* detect VBUS pulsing */
+			if ((fsm->transceiver->state == OTG_STATE_A_IDLE)
+			    && fsm->a_sess_vld)
+				fsm->a_srp_det = 1;
+			trigger = 1;
+			VDBG("!!!a_sess_vld int state=%d\n", fsm->a_sess_vld);
+		}
+		if (otg_int_src & OTGSC_INTSTS_A_VBUS_VALID) {
+			fsm->a_vbus_vld = !!(otg_sc & OTGSC_STS_A_VBUS_VALID);
+			trigger = 1;
+			VDBG("!!!a_vbus_vld int state=%d\n", fsm->a_vbus_vld);
+
+#if 1
+		if ((fsm->a_vbus_vld == 0) && (fsm->id == 0)) {
+			if (fsm->transceiver->state != OTG_STATE_A_WAIT_VFALL)
+				/* Warning insted of transfer to Error state. */
+				printk(KERN_WARNING "ulpi: The USB Device is "
+				       "sinking too much current!!\n");
+			fsm->a_vbus_vld = 1;
+		}
+#endif
+
+
+		}
+		if (otg_int_src & OTGSC_INTSTS_B_SESSION_VALID) {
+			fsm->b_sess_vld =
+			    (otg_sc & OTGSC_STS_B_SESSION_VALID) ? 1 : 0;
+			trigger = 1;
+			/* SRP done */
+			if ((fsl_otg_dev->otg.state == OTG_STATE_B_SRP_INIT) &&
+			    fsm->b_sess_vld && srp_wait_done)
+				fsm->b_srp_done = 1;
+			VDBG("!!!!b_sess_vld int state=%d\n", fsm->b_sess_vld);
+		}
+		if (otg_int_src & OTGSC_INTSTS_B_SESSION_END) {
+			fsm->b_sess_end =
+			    (otg_sc & OTGSC_STS_B_SESSION_END) ? 1 : 0;
+			trigger = 1;
+			VDBG("!!!!b_sess_end int state=%d\n", fsm->b_sess_end);
+		}
+	}
+
+	/* process USB interrupts */
+	if ((usb_int_src & USB_STS_PORT_CHANGE)
+	    && (fsm->protocol == PROTO_HOST)) {
+		VDBG("\nUSB irq A 0x%08x\n", usb_int_src);
+		/* Device resume do not generate statemachine change */
+		if (fsl_readl(&usb_dr_regs->portsc1) &
+		    PORTSCX_PORT_FORCE_RESUME) {
+			if (otg->default_a) {
+				fsm->b_bus_resume = 1;
+				trigger = 1;
+			} else {
+				fsm->a_bus_resume = 1;
+				trigger = 1;
+			}
+		}
+
+		tmp = (fsl_readl(&usb_dr_regs->portsc1) &
+		       PORTSCX_CURRENT_CONNECT_STATUS) ? 1 : 0;
+		if (otg->default_a && (fsm->b_conn != tmp)) {
+			fsm->b_conn = tmp;
+			trigger = 1;
+		} else if (!otg->default_a && (fsm->a_conn != tmp)) {
+			fsm->a_conn = tmp;
+			trigger = 1;
+		}
+	}
+	/* Workaround: sometimes CSC bit will lost.  We change to
+	 * polling CCS bit for connect change */
+	if (fsm->protocol == PROTO_GADGET) {
+		if (usb_int_src & USB_STS_SUSPEND) {
+			VDBG("\nUSB irq B 0x%08x\n", usb_int_src);
+			VDBG("peripheral detected suspend\n");
+			if (otg->default_a)
+				/* A-device detects B suspend */
+				fsm->b_bus_suspend = 1;
+			else
+				/* B-device detects A suspend */
+				fsm->a_bus_suspend = 1;
+			trigger = 1;
+		} else if (usb_int_src & USB_STS_PORT_CHANGE) {
+			VDBG("\nUSB irq C 0x%08x\n", usb_int_src);
+			VDBG("peripheral resumed\n");
+			if (otg->default_a)
+				fsm->b_bus_suspend = 0;
+			else
+				fsm->a_bus_suspend = 0;
+			trigger = 1;
+		}
+	}
+
+	/* Invoke statemachine until state is stable */
+	while (trigger) {
+		trigger = otg_statemachine(fsm);
+	}
+
+	return IRQ_HANDLED;
+}
+#endif
+
+
+static struct otg_fsm_ops fsl_otg_ops = {
+	.chrg_vbus = fsl_otg_chrg_vbus,
+	.drv_vbus = fsl_otg_drv_vbus,
+	.loc_conn = fsl_otg_loc_conn,
+	.loc_sof = fsl_otg_loc_sof,
+	.start_pulse = fsl_otg_start_pulse,
+
+	.add_timer = fsl_otg_add_timer,
+	.del_timer = fsl_otg_del_timer,
+
+	.start_host = fsl_otg_start_host,
+	.start_gadget = fsl_otg_start_gadget,
+};
+
+/* Initialize the global variable fsl_otg_dev and request IRQ for OTG */
+int fsl_otg_cfg(struct platform_device *pdev)
+{
+	int status;
+	struct fsl_otg *fsl_otg_tc;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res;
+
+	DBG("\n");
+
+	if (fsl_otg_dev)
+		return 0;
+
+	/* allocate space to fsl otg device */
+	fsl_otg_tc = kzalloc(sizeof(struct fsl_otg), GFP_KERNEL);
+	if (!fsl_otg_tc)
+		return -ENODEV;
+
+#if 1 // DDD
+	if (pdata->regs) {
+		fsl_otg_tc->dr_mem_map = pdata->regs;
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(&pdev->dev, "no register addr.\n");
+			return -ENODEV;
+		}
+
+		printk("DDD %s(): rsrc_start=0x%x  rsrc_len=0x%x\n",
+		     __FUNCTION__, res->start, res->end - res->start + 1);
+
+		if (!request_mem_region(res->start, res->end - res->start + 1,
+					"OTG")) {
+			dev_dbg(&pdev->dev, "request_mem_region failed\n");
+			return -EBUSY;
+		}
+		fsl_otg_tc->dr_mem_map = ioremap(res->start,
+						 res->end - res->start + 1);
+	}
+	DBG("set dr_mem_map to 0x%p\n", fsl_otg_tc->dr_mem_map);
+
+#endif 
+	INIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);
+
+	INIT_LIST_HEAD(&active_timers);
+	fsl_otg_init_timers(&fsl_otg_tc->fsm);
+
+	/* Set OTG state machine operations */
+	fsl_otg_tc->fsm.ops = &fsl_otg_ops;
+
+#if 1 /* DDD */
+	/* record initial state of ID pin */
+	fsl_otg_tc->fsm.id = (fsl_otg_tc->dr_mem_map->otgsc & OTGSC_STS_USB_ID)
+	    ? 1 : 0;
+	DBG("initial ID pin=%d\n", fsl_otg_tc->fsm.id);
+#endif
+	/* initialize the otg structure */
+	fsl_otg_tc->otg.label = DRIVER_DESC;
+	fsl_otg_tc->otg.set_host = fsl_otg_set_host;
+	fsl_otg_tc->otg.set_peripheral = fsl_otg_set_peripheral;
+	fsl_otg_tc->otg.set_power = fsl_otg_set_power;
+	fsl_otg_tc->otg.start_hnp = fsl_otg_start_hnp;
+	fsl_otg_tc->otg.start_srp = fsl_otg_start_srp;
+
+	fsl_otg_dev = fsl_otg_tc;
+
+	/* Store the otg transceiver */
+	status = otg_set_transceiver(&fsl_otg_tc->otg);
+	if (status) {
+		printk(KERN_WARNING ": unable to register OTG transceiver.\n");
+		return status;
+	}
+
+	return 0;
+}
+
+/* OTG Initialization*/
+int usb_otg_start(struct platform_device *pdev)
+{
+	struct fsl_otg *p_otg;
+	struct otg_transceiver *otg_trans = otg_get_transceiver();
+	struct otg_fsm *fsm;
+	int status;
+	u32 temp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	int timeout;
+
+	DBG("\n");
+
+	p_otg = container_of(otg_trans, struct fsl_otg, otg);
+	fsm = &p_otg->fsm;
+
+	/* Initialize the state machine structure with default values */
+	SET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);
+	fsm->transceiver = &p_otg->otg;
+
+	usb_dr_regs = p_otg->dr_mem_map;
+	DBG("set usb_dr_regs to 0x%p\n", usb_dr_regs);
+
+	/* request irq */
+	p_otg->irq = platform_get_irq(pdev, 0);
+	status = request_irq(p_otg->irq, fsl_otg_isr,
+				IRQF_SHARED, driver_name, p_otg);
+	if (status) {
+		dev_dbg(p_otg->otg.dev, "can't get IRQ %d, error %d\n",
+			p_otg->irq, status);
+		kfree(p_otg);
+		return status;
+	}
+
+
+	/* stop the controller */
+	temp = fsl_readl(&usb_dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
+	fsl_writel(temp, &usb_dr_regs->usbcmd);
+
+	/* reset the controller */
+	temp = fsl_readl(&usb_dr_regs->usbcmd);
+	temp |= USB_CMD_CTRL_RESET;
+	fsl_writel(temp, &usb_dr_regs->usbcmd);
+
+	/* wait reset completed */
+	timeout = 500;
+	while (timeout-- &&
+		fsl_readl(&usb_dr_regs->usbcmd) & USB_CMD_CTRL_RESET)
+		udelay(1);
+	if (timeout <= 0)
+		ERR("%s - USBCMD_RST never clear. Timeout is %d \n",
+			__FUNCTION__, timeout);
+
+	/* configure the VBUSHS as IDLE(both host and device) */
+#if 0
+	/* DDD really have to check into setting the following */
+	fsl_writel(USB_MODE_STREAM_DISABLE, &usb_dr_regs->usbmode);
+#else
+	temp = USB_MODE_STREAM_DISABLE | (pdata->es ? USBMODE_ES : 0);
+	fsl_writel(temp, &usb_dr_regs->usbmode);
+#endif
+
+	/* configure PHY interface */
+	temp = fsl_readl(&usb_dr_regs->portsc1);
+	temp &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PTW_8BIT);
+
+	/* DDD wrong xcvr setting stuff follows */
+	temp |= PORTSCX_PTS_ULPI;
+	fsl_writel(temp, &usb_dr_regs->portsc1);
+
+
+	/* disable all interrupt and clear all OTGSC status */
+	temp = fsl_readl(&usb_dr_regs->otgsc);
+	temp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+#if 0 // DDD
+	/* DDD only want ID int
+	 * temp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;
+	 */
+	temp |= OTGSC_IE_USB_ID;	/* DDD added this */
+	temp &= ~OTGSC_IE_1ms_TIMER;	/* DDD added this */
+#else
+	temp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;
+#endif
+	fsl_writel(temp, &usb_dr_regs->otgsc);
+
+	fsl_otg_drv_vbus(0);
+
+#if 0 // DDD beta-final
+	temp = fsl_readl(&usb_dr_regs->otgsc);
+	temp |= OTGSC_IE_A_SESSION_VALID;
+	fsl_writel(temp, &usb_dr_regs->otgsc);
+#else
+	/*
+	 * The identification (id) input is FALSE when a Mini-A plug is inserted
+	 * in the devices Mini-AB receptacle. Otherwise, this input is TRUE.
+	 * Also: record initial state of ID pin
+	 */
+	if (fsl_readl(&usb_dr_regs->otgsc) & OTGSC_STS_USB_ID) {
+		p_otg->otg.state = OTG_STATE_UNDEFINED;
+		p_otg->fsm.id = 1;
+	} else {
+		p_otg->otg.state = OTG_STATE_A_IDLE;
+		p_otg->fsm.id = 0;
+	}
+
+	DBG("initial ID pin=%d\n", p_otg->fsm.id);
+
+	/* enable OTG ID pin interrupt */
+	temp = fsl_readl(&usb_dr_regs->otgsc);
+	temp |= OTGSC_IE_USB_ID;
+	temp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_IE_1ms_TIMER);
+	fsl_writel(temp, &usb_dr_regs->otgsc);
+#endif
+
+	return 0;
+}
+
+/* Initialize board specific registers,PIB board,clock and pin multiplexing */
+static int board_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata;
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init(pdev) != 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_OTG_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/fsl_usb2_otg";
+
+static int otg_proc_read(char *page, char **start, off_t off, int count,
+			 int *eof, void *_dev)
+{
+	struct otg_fsm *fsm = &fsl_otg_dev->fsm;
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+	u32 tmp_reg;
+
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	/* ------basic driver infomation ---- */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n" "fsl_usb2_otg version: %s\n\n",
+		      DRIVER_VERSION);
+	size -= t;
+	next += t;
+
+	/* ------ Registers ----- */
+	/* tmp_reg = le32_to_cpu(usb_dr_regs->otgsc); */
+	tmp_reg = fsl_readl(&usb_dr_regs->otgsc);
+	t = scnprintf(next, size, "OTGSC reg: 0x%08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* tmp_reg = le32_to_cpu(usb_dr_regs->portsc); */
+	tmp_reg = fsl_readl(&usb_dr_regs->portsc1);
+	t = scnprintf(next, size, "PORTSC reg: 0x%08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbmode); */
+	tmp_reg = fsl_readl(&usb_dr_regs->usbmode);
+	t = scnprintf(next, size, "USBMODE reg: 0x%08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbcmd); */
+	tmp_reg = fsl_readl(&usb_dr_regs->usbcmd);
+	t = scnprintf(next, size, "USBCMD reg: 0x%08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* tmp_reg = le32_to_cpu(usb_dr_regs->usbsts); */
+	tmp_reg = fsl_readl(&usb_dr_regs->usbsts);
+	t = scnprintf(next, size, "USBSTS reg: 0x%08x\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* ------ State ----- */
+	t = scnprintf(next, size, "FSM protocol=%d %s\n", fsm->protocol,
+		fsm->protocol ?
+		(fsm->protocol == PROTO_HOST ? "Host" : "Gadget")
+		: "None");
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size,
+		      "OTG state: %s\n\n",
+		      state_string(fsl_otg_dev->otg.state));
+	size -= t;
+	next += t;
+
+	/* ------ State Machine Variables ----- */
+	t = scnprintf(next, size, "a_bus_req: %d\n", fsm->a_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_req: %d\n", fsm->b_bus_req);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_resume: %d\n", fsm->a_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_bus_suspend: %d\n", fsm->a_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_conn: %d\n", fsm->a_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_sess_vld: %d\n", fsm->a_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_srp_det: %d\n", fsm->a_srp_det);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "a_vbus_vld: %d\n", fsm->a_vbus_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_resume: %d\n", fsm->b_bus_resume);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_bus_suspend: %d\n", fsm->b_bus_suspend);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_conn: %d\n", fsm->b_conn);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_se0_srp: %d\n", fsm->b_se0_srp);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_end: %d\n", fsm->b_sess_end);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "b_sess_vld: %d\n", fsm->b_sess_vld);
+	size -= t;
+	next += t;
+
+	t = scnprintf(next, size, "id: %d\n", fsm->id);
+	size -= t;
+	next += t;
+
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, otg_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_OTG_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/*CONFIG_USB_OTG_DEBUG_FILES */
+
+/*----------------------------------------------------------*/
+/* Char driver interface to control some OTG input */
+
+/*
+ * This function handle some ioctl command,such as get otg
+ * status and set host suspend
+ */
+static int fsl_otg_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	u32 retval = 0;
+
+	switch (cmd) {
+	case GET_OTG_STATUS:
+		retval = fsl_otg_dev->host_working;
+		break;
+
+	case SET_A_SUSPEND_REQ:
+		fsl_otg_dev->fsm.a_suspend_req = arg;
+		break;
+
+	case SET_A_BUS_DROP:
+		fsl_otg_dev->fsm.a_bus_drop = arg;
+		break;
+
+	case SET_A_BUS_REQ:
+		fsl_otg_dev->fsm.a_bus_req = arg;
+		break;
+
+	case SET_B_BUS_REQ:
+		fsl_otg_dev->fsm.b_bus_req = arg;
+		break;
+
+	default:
+		break;
+	}
+
+	otg_statemachine(&fsl_otg_dev->fsm);
+
+	return retval;
+}
+
+static int fsl_otg_open(struct inode *inode, struct file *file)
+{
+
+	return 0;
+}
+
+static int fsl_otg_release(struct inode *inode, struct file *file)
+{
+
+	return 0;
+}
+
+static struct file_operations otg_fops = {
+	.owner = THIS_MODULE,
+	.llseek = NULL,
+	.read = NULL,
+	.write = NULL,
+	.ioctl = fsl_otg_ioctl,
+	.open = fsl_otg_open,
+	.release = fsl_otg_release,
+};
+
+static int __init fsl_otg_probe(struct platform_device *pdev)
+{
+	int status;
+	struct fsl_usb2_platform_data *pdata;
+
+	DBG("pdev=0x%p\n", pdev);
+
+	if (!pdev)
+		return -ENODEV;
+
+	if (!pdev->dev.platform_data)
+		return -ENOMEM;
+
+	pdata = pdev->dev.platform_data;
+#if 1 // DDD do this elsewhere
+	/* Initialize the clock, multiplexing pin and PHY interface */
+	board_init(pdev);
+#endif
+
+	/* configure the OTG */
+	status = fsl_otg_cfg(pdev);
+	if (status) {
+		printk(KERN_INFO "Couldn't init OTG module\n");
+		return -status;
+	}
+
+	/* start OTG */
+	status = usb_otg_start(pdev);
+
+	if (register_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME, &otg_fops)) {
+		printk(KERN_WARNING FSL_OTG_NAME
+		       ": unable to register FSL OTG device\n");
+		return -EIO;
+	}
+
+	create_proc_file();
+	return status;
+}
+
+static int fsl_otg_remove(struct platform_device *pdev)
+{
+	u32 ie;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	unsigned long flags;
+
+	DBG("pdev=0x%p  pdata=0x%p\n", pdev, pdata);
+
+	otg_set_transceiver(NULL);
+
+	/* disable and clear OTGSC interrupts */
+	spin_lock_irqsave(&usb_dr_regs_lock, flags);
+	ie = fsl_readl(&usb_dr_regs->otgsc);
+	ie &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;
+	ie |= OTGSC_INTERRUPT_STATUS_BITS_MASK;
+	fsl_writel(ie, &usb_dr_regs->otgsc);
+	spin_unlock_irqrestore(&usb_dr_regs_lock, flags);
+
+	free_irq(fsl_otg_dev->irq, fsl_otg_dev);
+
+	kfree(fsl_otg_dev);
+
+	remove_proc_file();
+
+	unregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);
+
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdev);
+
+	fsl_otg_dev = NULL;
+	return 0;
+}
+
+struct platform_driver fsl_otg_driver = {
+	.probe = fsl_otg_probe,
+	.remove = fsl_otg_remove,
+	.driver = {
+		.name  = driver_name,
+		.owner = THIS_MODULE,
+	},
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init fsl_usb_otg_init(void)
+{
+	printk(KERN_INFO DRIVER_DESC " loaded, %s\n", DRIVER_VERSION);
+	return platform_driver_register(&fsl_otg_driver);
+}
+
+static void __exit fsl_usb_otg_exit(void)
+{
+	platform_driver_unregister(&fsl_otg_driver);
+}
+
+module_init(fsl_usb_otg_init);
+module_exit(fsl_usb_otg_exit);
+
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/usb/otg/fsl_otg.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef FSL_OTG_H
+#define FSL_OTG_H
+#include <linux/usb/otg.h>
+#include "otg_fsm.h"
+#include <linux/ioctl.h>
+
+#define ERR(format, arg...) \
+printk(KERN_ERR "%s:%s: " format "\n" , __FILE__,  __FUNCTION__ , ## arg)
+
+/*
+ *  A-DEVICE timing  constants
+ */
+
+/* Wait for VBUS Rise  */
+#define TA_WAIT_VRISE	(100)	/* a_wait_vrise 100 ms, section: 6.6.5.1 */
+
+/* Wait for B-Connect */
+#define TA_WAIT_BCON	(10000)	/* a_wait_bcon > 1 sec, section: 6.6.5.2
+				 * This is only used to get out of
+				 * OTG_STATE_A_WAIT_BCON state if there was
+				 * no connection for these many milliseconds
+				 */
+
+/* A-Idle to B-Disconnect */
+/* It is necessary for this timer to be more than 750 ms because of a bug in OPT
+ * test 5.4 in which B OPT disconnects after 750 ms instead of 75ms as stated
+ * in the test description
+ */
+#define TA_AIDL_BDIS	(5000)	/* a_suspend minimum 200 ms, section: 6.6.5.3 */
+
+/* B-Idle to A-Disconnect */
+#define TA_BIDL_ADIS	(12)	/* 3 to 200 ms */
+
+/* B-device timing constants */
+
+/* Data-Line Pulse Time*/
+#define TB_DATA_PLS	(10)	/* b_srp_init,continue 5~10ms, section:5.3.3 */
+#define TB_DATA_PLS_MIN	(5)	/* minimum 5 ms */
+#define TB_DATA_PLS_MAX	(10)	/* maximum 10 ms */
+
+/* SRP Initiate Time  */
+#define TB_SRP_INIT	(100)	/* b_srp_init,maximum 100 ms, section:5.3.8 */
+
+/* SRP Fail Time  */
+#define TB_SRP_FAIL	(7000)	/* b_srp_init,Fail time 5~30s, section:6.8.2.2 */
+
+/* SRP result wait time */
+#define TB_SRP_WAIT	(60)
+
+/* VBus time */
+#define TB_VBUS_PLS	(30)	/* time to keep vbus pulsing asserted */
+
+/* Discharge time */
+/* This time should be less than 10ms. It varies from system to system. */
+#define TB_VBUS_DSCHRG	(8)
+
+/* A-SE0 to B-Reset  */
+#define TB_ASE0_BRST	(20)	/* b_wait_acon, mini 3.125 ms,section:6.8.2.4 */
+
+/* A bus suspend timer before we can switch to b_wait_aconn */
+#define TB_A_SUSPEND	(7)
+#define TB_BUS_RESUME	(12)
+
+/* SE0 Time Before SRP */
+#define TB_SE0_SRP	(2)	/* b_idle,minimum 2 ms, section:5.3.2 */
+
+#define SET_OTG_STATE(otg_ptr, newstate)	((otg_ptr)->state = newstate)
+
+
+struct fsl_otg_timer {
+	unsigned long expires;	/* Number of count increase to timeout */
+	unsigned long count;	/* Tick counter */
+	void (*function) (unsigned long);	/* Timeout function */
+	unsigned long data;	/* Data passed to function */
+	struct list_head list;
+};
+
+struct fsl_otg_timer inline *otg_timer_initializer
+    (void (*function) (unsigned long), unsigned long expires,
+     unsigned long data) {
+	struct fsl_otg_timer *timer;
+	timer = kmalloc(sizeof(struct fsl_otg_timer), GFP_KERNEL);
+	if (timer == NULL)
+		return NULL;
+	timer->function = function;
+	timer->expires = expires;
+	timer->data = data;
+	return timer;
+}
+
+struct fsl_otg {
+	struct otg_transceiver otg;
+	struct otg_fsm fsm;
+	struct fsl_usb_device_regs *dr_mem_map;
+	struct delayed_work otg_event;
+
+	/*used for usb host */
+	u8 host_working;
+	u8 on_off;
+
+	int irq;
+};
+
+struct fsl_otg_config {
+	u8 otg_port;
+};
+
+/*For SRP and HNP handle*/
+#define FSL_OTG_MAJOR	66
+#define FSL_OTG_NAME	"fsl-otg"
+/*Command to OTG driver(ioctl)*/
+#define OTG_IOCTL_MAGIC		FSL_OTG_MAJOR
+/*if otg work as host,it should return 1,otherwise it return 0*/
+#define GET_OTG_STATUS		_IOR(OTG_IOCTL_MAGIC, 1, int)
+#define SET_A_SUSPEND_REQ	_IOW(OTG_IOCTL_MAGIC, 2, int)
+#define SET_A_BUS_DROP		_IOW(OTG_IOCTL_MAGIC, 3, int)
+#define SET_A_BUS_REQ		_IOW(OTG_IOCTL_MAGIC, 4, int)
+#define SET_B_BUS_REQ		_IOW(OTG_IOCTL_MAGIC, 5, int)
+#define GET_A_SUSPEND_REQ	_IOR(OTG_IOCTL_MAGIC, 6, int)
+#define GET_A_BUS_DROP		_IOR(OTG_IOCTL_MAGIC, 7, int)
+#define GET_A_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 8, int)
+#define GET_B_BUS_REQ		_IOR(OTG_IOCTL_MAGIC, 9, int)
+
+
+/********************************************************************/
+#endif
--- /dev/null
+++ b/drivers/usb/otg/otg_fsm.c
@@ -0,0 +1,381 @@
+/* OTG Finite State Machine from OTG spec
+ *
+ * Copyright (C) 2007 Freescale Semiconductor, Inc.
+ *
+ * Author: 	Li Yang <LeoLi@freescale.com>
+ * 		Jerry Huang <Chang-Ming.Huang@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/usb/otg.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/usb_gadget.h>
+
+#include "otg_fsm.h"
+
+
+/* Defined by device specific driver, for different timer implementation */
+extern void *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,
+	*b_ase0_brst_tmr, *b_se0_srp_tmr, *b_srp_fail_tmr, *a_wait_enum_tmr;
+
+const char *state_string(enum usb_otg_state state)
+{
+	switch (state) {
+	case OTG_STATE_A_IDLE:		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:	return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:	return "a_wait_bcon";
+	case OTG_STATE_A_HOST:		return "a_host";
+	case OTG_STATE_A_SUSPEND:	return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:	return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:	return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:	return "a_vbus_err";
+	case OTG_STATE_B_IDLE:		return "b_idle";
+	case OTG_STATE_B_SRP_INIT:	return "b_srp_init";
+	case OTG_STATE_B_PERIPHERAL:	return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:	return "b_wait_acon";
+	case OTG_STATE_B_HOST:		return "b_host";
+	default:			return "UNDEFINED";
+	}
+}
+EXPORT_SYMBOL(state_string);
+
+/* Change USB protocol when there is a protocol change */
+static int otg_set_protocol(struct otg_fsm *fsm, int protocol)
+{
+	int ret = 0;
+
+	VDBG("DDD old fsm->protocol= %d; new protocol= %d\n",
+		     fsm->protocol, protocol);
+	if (fsm->protocol != protocol) {
+		VDBG("Changing role fsm->protocol= %d; new protocol= %d\n",
+				fsm->protocol, protocol);
+		/* stop old protocol */
+		if (fsm->protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 0);
+		else if (fsm->protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 0);
+		if (ret)
+			return ret;
+
+		/* start new protocol */
+		if (protocol == PROTO_HOST)
+			ret = fsm->ops->start_host(fsm, 1);
+		else if (protocol == PROTO_GADGET)
+			ret = fsm->ops->start_gadget(fsm, 1);
+		if (ret)
+			return ret;
+
+		fsm->protocol = protocol;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int state_changed;
+
+/* Called when leaving a state.  Do state clean up jobs here */
+static void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)
+{
+	switch (old_state) {
+	case OTG_STATE_B_IDLE:
+		otg_del_timer(fsm, fsm->b_se0_srp_tmr);
+		fsm->b_se0_srp = 0;
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		fsm->b_srp_done = 0;
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_del_timer(fsm, fsm->b_ase0_brst_tmr);
+		fsm->b_ase0_brst_tmout = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		break;
+	case OTG_STATE_A_IDLE:
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_del_timer(fsm, fsm->a_wait_vrise_tmr);
+		fsm->a_wait_vrise_tmout = 0;
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_del_timer(fsm, fsm->a_wait_bcon_tmr);
+		fsm->a_wait_bcon_tmout = 0;
+		break;
+	case OTG_STATE_A_HOST:
+		otg_del_timer(fsm, fsm->a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_del_timer(fsm, fsm->a_aidl_bdis_tmr);
+		fsm->a_aidl_bdis_tmout = 0;
+		fsm->a_suspend_req = 0;
+		fsm->a_bus_req = 1;	/* FIXME */
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_del_timer(fsm, fsm->a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		break;
+	default:
+		break;
+	}
+}
+
+/* Called when entering a state */
+static int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
+{
+	state_changed = 1;
+	VDBG("State: old=%s new=%s \n",
+		state_string(fsm->transceiver->state), state_string(new_state));
+
+	if (fsm->transceiver->state == new_state)
+		return 0;
+
+	otg_leave_state(fsm, fsm->transceiver->state);
+	switch (new_state) {
+	case OTG_STATE_B_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, fsm->b_se0_srp_tmr);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		otg_start_pulse(fsm);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		otg_add_timer(fsm, fsm->b_srp_fail_tmr);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, fsm->b_ase0_brst_tmr);
+		fsm->a_bus_suspend = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		usb_bus_start_enum(fsm->transceiver->host,
+				   fsm->transceiver->host->otg_port);
+		break;
+	case OTG_STATE_A_IDLE:
+		otg_drv_vbus(fsm, 0);
+		otg_chrg_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, fsm->a_wait_vrise_tmr);
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, fsm->a_wait_bcon_tmr);
+		break;
+	case OTG_STATE_A_HOST:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 1);
+		otg_set_protocol(fsm, PROTO_HOST);
+		/*
+		 * When HNP is triggered while a_bus_req = 0, a_host will
+		 * suspend too fast to complete a_set_b_hnp_en
+		 */
+		if (!fsm->a_bus_req || fsm->a_suspend_req)
+			otg_add_timer(fsm, fsm->a_wait_enum_tmr);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		otg_drv_vbus(fsm, 1);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		otg_add_timer(fsm, fsm->a_aidl_bdis_tmr);
+
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		otg_loc_conn(fsm, 1);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_GADGET);
+		otg_drv_vbus(fsm, 1);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		otg_drv_vbus(fsm, 0);
+		otg_loc_conn(fsm, 0);
+		otg_loc_sof(fsm, 0);
+		otg_set_protocol(fsm, PROTO_UNDEF);
+		break;
+	default:
+		break;
+	}
+
+	fsm->transceiver->state = new_state;
+	return 0;
+}
+
+/* State change judgement */
+int otg_statemachine(struct otg_fsm *fsm)
+{
+	enum usb_otg_state state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fsm->lock, flags);
+
+	state = fsm->transceiver->state;
+	state_changed = 0;
+	/* State machine state change judgement */
+
+	VDBG(" State: %s \n", state_string(state));
+
+	switch (state) {
+	case OTG_STATE_UNDEFINED:
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_B_IDLE:
+		if (!fsm->id)
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		else if (fsm->b_sess_vld && fsm->transceiver->gadget)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		else if (fsm->b_bus_req && fsm->b_sess_end && fsm->b_se0_srp)
+			otg_set_state(fsm, OTG_STATE_B_SRP_INIT);
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		if (!fsm->id || fsm->b_srp_done)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->b_bus_req &&
+			 fsm->transceiver->
+			 gadget->b_hnp_enable && fsm->a_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_B_WAIT_ACON);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		if (fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_HOST);
+		else if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {
+			fsm->b_ase0_brst_tmout = 0;
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		}
+		break;
+	case OTG_STATE_B_HOST:
+		if (!fsm->id || !fsm->b_sess_vld)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->b_bus_req || !fsm->a_conn)
+			otg_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		break;
+	case OTG_STATE_A_IDLE:
+		if (fsm->id)
+			otg_set_state(fsm, OTG_STATE_B_IDLE);
+		else if (!fsm->a_bus_drop && (fsm->a_bus_req || fsm->a_srp_det))
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_vbus_vld ||
+		    fsm->a_wait_vrise_tmout) {
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		else if (fsm->id | fsm->a_bus_drop | fsm->a_wait_bcon_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (fsm->b_conn)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		break;
+	case OTG_STATE_A_HOST:
+		if ((!fsm->a_bus_req || fsm->a_suspend_req) &&
+		    fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_SUSPEND);
+		else if (fsm->id || !fsm->b_conn || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		if (!fsm->b_conn && fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_PERIPHERAL);
+		else if (!fsm->b_conn && !fsm->transceiver->host->b_hnp_enable)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (fsm->a_bus_req || fsm->b_bus_resume)
+			otg_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		if (fsm->id || fsm->a_bus_drop)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		else if (fsm->b_bus_suspend)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_BCON);
+		else if (!fsm->a_vbus_vld)
+			otg_set_state(fsm, OTG_STATE_A_VBUS_ERR);
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (fsm->id || fsm->a_bus_req || (!fsm->a_sess_vld &&
+						  !fsm->b_conn))
+			otg_set_state(fsm, OTG_STATE_A_IDLE);
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		if (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)
+			otg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&fsm->lock, flags);
+
+	return state_changed;
+}
+EXPORT_SYMBOL(otg_statemachine);
--- /dev/null
+++ b/drivers/usb/otg/otg_fsm.h
@@ -0,0 +1,170 @@
+/* Copyright (C) 2006-2007 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef OTG_FSM_H
+#define OTG_FSM_H
+
+#if 1
+#define DEBUG 	1
+#define VERBOSE 	1
+#endif
+
+#ifdef DEBUG
+#define DBG(fmt, args...) 	printk(KERN_DEBUG "[%s]  " fmt , \
+				__FUNCTION__, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define VDBG		DBG
+#else
+#define VDBG(stuff...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define MPC_LOC printk("Current Location [%s]:[%d]\n", __FILE__, __LINE__)
+#else
+#define MPC_LOC do {} while (0)
+#endif
+
+#define PROTO_UNDEF	0
+#define PROTO_HOST	1
+#define PROTO_GADGET	2
+
+
+
+
+
+/* OTG state machine according to the OTG spec */
+struct otg_fsm {
+	/* Input */
+	int a_bus_resume;
+	int a_bus_suspend;
+	int a_conn;
+	int a_sess_vld;
+	int a_srp_det;
+	int a_vbus_vld;
+	int b_bus_resume;
+	int b_bus_suspend;
+	int b_conn;
+	int b_se0_srp;
+	int b_sess_end;
+	int b_sess_vld;
+	int id;
+
+	/* Internal variables */
+	int a_set_b_hnp_en;
+	int b_srp_done;
+	int b_hnp_enable;
+
+	/* Timeout indicator for timers */
+	int a_wait_vrise_tmout;
+	int a_wait_bcon_tmout;
+	int a_aidl_bdis_tmout;
+	int b_ase0_brst_tmout;
+
+	/* Informative variables */
+	int a_bus_drop;
+	int a_bus_req;
+	int a_clr_err;
+	int a_suspend_req;
+	int b_bus_req;
+
+	/* Output */
+	int drv_vbus;
+	int loc_conn;
+	int loc_sof;
+
+	struct otg_fsm_ops *ops;
+	struct otg_transceiver *transceiver;
+
+	void *a_wait_vrise_tmr;
+	void *a_wait_bcon_tmr;
+	void *a_aidl_bdis_tmr;
+	void *b_ase0_brst_tmr;
+	void *b_se0_srp_tmr;
+	void *b_srp_fail_tmr;
+	void *a_wait_enum_tmr;
+
+	/* Current usb protocol used: 0:undefine; 1:host; 2:client */
+	int protocol;
+	spinlock_t lock;		/* fsm lock */
+};
+
+struct otg_fsm_ops {
+	void 	(*chrg_vbus)(int on);
+	void 	(*drv_vbus)(int on);
+	void 	(*loc_conn)(int on);
+	void 	(*loc_sof)(int on);
+	void	(*start_pulse)(void);
+	void	(*add_timer)(void *timer);
+	void	(*del_timer)(void *timer);
+	int	(*start_host)(struct otg_fsm *fsm, int on);
+	int	(*start_gadget)(struct otg_fsm *fsm, int on);
+};
+
+
+static inline void otg_chrg_vbus(struct otg_fsm *fsm, int on)
+{
+	fsm->ops->chrg_vbus(on);
+}
+
+static inline void otg_drv_vbus(struct otg_fsm *fsm, int on)
+{
+	if (fsm->drv_vbus != on) {
+		fsm->drv_vbus = on;
+		fsm->ops->drv_vbus(on);
+	}
+}
+
+static inline void otg_loc_conn(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_conn != on) {
+		fsm->loc_conn = on;
+		fsm->ops->loc_conn(on);
+	}
+}
+
+static inline void otg_loc_sof(struct otg_fsm *fsm, int on)
+{
+	if (fsm->loc_sof != on) {
+		fsm->loc_sof = on;
+		fsm->ops->loc_sof(on);
+	}
+}
+
+static inline void otg_start_pulse(struct otg_fsm *fsm)
+{
+	fsm->ops->start_pulse();
+}
+
+static inline void otg_add_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->add_timer(timer);
+}
+
+static inline void otg_del_timer(struct otg_fsm *fsm, void *timer)
+{
+	fsm->ops->del_timer(timer);
+}
+
+extern int otg_statemachine(struct otg_fsm *fsm);
+
+extern const char *state_string(enum usb_otg_state state);
+
+#endif
--- a/include/asm-m68k/mcf5445x_usb.h
+++ b/include/asm-m68k/mcf5445x_usb.h
@@ -41,7 +41,8 @@ static inline void fsl_platform_set_host
 
 	/* set host mode and select "big endian" */
 	temp = fsl_readl(&regs->usbmode);
-	fsl_writel(temp | USBMODE_CM_HOST | USBMODE_ES, &regs->usbmode);
+	temp |= USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
+	fsl_writel(temp, &regs->usbmode);
 
 	pr_debug("%s: set usbmode to 0x%x\n\n", __FUNCTION__,
 		fsl_readl(&regs->usbmode));
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -91,6 +91,19 @@ enum fsl_usb2_operating_modes {
 	FSL_USB2_DR_OTG,
 };
 
+/* DDD
+ * replace _operating_modes with _controller
+ *
+ * the operating_mode tests in fsl_platform_verify() aren't needed,
+ * since the ehci driver isn't going to be probe()d unless it's
+ * "fsl-ehci" device anyway, and what we really need to know is
+ * which controller (MPH/DR) we're dealing with
+ */
+enum fsl_usb2_controller {
+	FSL_USB2_MPH,
+	FSL_USB2_DR,
+};
+
 enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_NONE,
 	FSL_USB2_PHY_ULPI,
@@ -101,9 +114,36 @@ enum fsl_usb2_phy_modes {
 
 struct fsl_usb2_platform_data {
 	/* board specific information */
-	enum fsl_usb2_operating_modes	operating_mode;
+	/*
+	 * DDD see note above
+	 * enum fsl_usb2_operating_modes	operating_mode;
+	 */
+	enum fsl_usb2_controller	controller;
 	enum fsl_usb2_phy_modes		phy_mode;
 	unsigned int			port_enables;
+	/*
+	 * DDD this could arguably be moved to a separate
+	 * fsl usb2 device header file
+	 */
+	char *name;			/* pretty print */
+	int (*platform_init) (struct platform_device *);
+	void (*platform_uninit) (struct platform_device *);
+	int (*platform_verify) (struct platform_device *);
+	u32				xcvr_type;	/* PORTSCX_PTS_* */
+	u32				view;		/* ULPI viewport register */
+	u32				r_start;	/* start of MEM resource */
+	u32				r_len;		/* length of MEM resource */
+	void __iomem			*regs;		/* ioremap'd register base */
+	unsigned			big_endian_mmio : 1;
+	unsigned			big_endian_desc : 1;
+	unsigned			es : 1;		/* need USBMODE:ES */
+	unsigned			have_sysif_regs : 1;
+	unsigned			le_setup_buf : 1;
+	unsigned			does_otg : 1;	/* set IFF it's an OTG port */
+
+	unsigned			power_budget;	/* for hcd->power_budget */
+	struct fsl_xcvr_ops		*xcvr_ops;
+	int				max_ep_nr;	/* max # of endpoints */
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
--- /dev/null
+++ b/include/linux/usb/fsl_usb2.h
@@ -0,0 +1,464 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * Freescale USB device/endpoint management registers
+ */
+#ifndef __FSL_USB2_H
+#define __FSL_USB2_H
+
+
+ /* USB DR device mode registers (Little Endian) */
+struct fsl_usb_device_regs {
+	/* Capability register */
+	u32 id;
+	u32 res1[63];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u32 res2[5];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u32 res3[6];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u32 res4;
+	u32 deviceaddr;		/* Device Address */
+	u32 endpointlistaddr;	/* Endpoint List Address Register */
+	u32 res5;
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u32 res6[2];
+	u32 ulpiview;
+	u32 res7[3];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc1;		/* Port 1 Status and Control Register */
+	u32 res8[7];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+#if 0
+	u32 endptctrl[USB_MAX_ENDPOINTS]; /* Endpoint Control Registers */
+#else
+	// DDD see DCCPARAMS:DEN for the real number of device endpoints
+	// DDD 16 is the max
+	u32 endptctrl[16];	/* Endpoint Control Registers */
+#endif
+};
+
+ /* USB DR host mode registers (Little Endian) */
+struct fsl_usb_host_regs {
+	/* Capability register */
+	u32 id;
+	u32 res1[63];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u32 res2[5];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u32 res3[6];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u32 res4;
+	u32 periodiclistbase;	/* Periodic Frame List Base Address Register */
+	u32 asynclistaddr;	/* Current Asynchronous List Address Register */
+	u32 res5;
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u32 res6[2];
+	u32 ulpiview;
+	u32 res7[3];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc1;		/* Port 1 Status and Control Register */
+	u32 res8[7];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+#if 0
+	u32 endptctrl[USB_MAX_ENDPOINTS]; /* Endpoint Control Registers */
+#else
+	// DDD: do these exits in the host register set??
+	// DDD see DCCPARAMS:DEN for the real number of device endpoints
+	// DDD 16 is the max
+	u32 endptctrl[16];	/* Endpoint Control Registers */
+#endif
+};
+
+ /* non-EHCI USB system interface registers (Big Endian) */
+struct usb_sys_interface {
+	u32 snoop1;
+	u32 snoop2;
+	u32 age_cnt_thresh;	/* Age Count Threshold Register */
+	u32 pri_ctrl;		/* Priority Control Register */
+	u32 si_ctrl;		/* System Interface Control Register */
+	u32 res[59];
+	u32 control;		/* General Purpose Control Register */
+};
+
+/* ep0 transfer state */
+#define WAIT_FOR_SETUP		0
+#define DATA_STATE_XMIT		1
+#define DATA_STATE_NEED_ZLP	2
+#define WAIT_FOR_OUT_STATUS	3
+#define DATA_STATE_RECV		4
+
+/* Frame Index Register Bit Masks */
+#define	USB_FRINDEX_MASKS			0x3fff
+
+
+
+/* USBCMD Register Bit Masks */
+#define USB_CMD_RUN_STOP			0x00000001
+#define USB_CMD_CTRL_RESET			0x00000002
+#define USB_CMD_PERIODIC_SCHEDULE_EN		0x00000010
+#define USB_CMD_ASYNC_SCHEDULE_EN		0x00000020
+#define USB_CMD_INT_AA_DOORBELL			0x00000040
+#define USB_CMD_ASP				0x00000300
+#define USB_CMD_ASYNC_SCH_PARK_EN		0x00000800
+#define USB_CMD_SUTW				0x00002000
+#define USB_CMD_ATDTW				0x00004000
+#define USB_CMD_ITC				0x00FF0000
+
+/* bit 15,3,2 are frame list size */
+#define USB_CMD_FRAME_SIZE_1024			0x00000000
+#define USB_CMD_FRAME_SIZE_512			0x00000004
+#define USB_CMD_FRAME_SIZE_256			0x00000008
+#define USB_CMD_FRAME_SIZE_128			0x0000000C
+#define USB_CMD_FRAME_SIZE_64			0x00008000
+#define USB_CMD_FRAME_SIZE_32			0x00008004
+#define USB_CMD_FRAME_SIZE_16			0x00008008
+#define USB_CMD_FRAME_SIZE_8			0x0000800C
+
+/* bit 9-8 are async schedule park mode count */
+#define USB_CMD_ASP_00				0x00000000
+#define USB_CMD_ASP_01				0x00000100
+#define USB_CMD_ASP_10				0x00000200
+#define USB_CMD_ASP_11				0x00000300
+#define USB_CMD_ASP_BIT_POS			8
+
+/* bit 23-16 are interrupt threshold control */
+#define USB_CMD_ITC_NO_THRESHOLD		0x00000000
+#define USB_CMD_ITC_1_MICRO_FRM			0x00010000
+#define USB_CMD_ITC_2_MICRO_FRM			0x00020000
+#define USB_CMD_ITC_4_MICRO_FRM			0x00040000
+#define USB_CMD_ITC_8_MICRO_FRM			0x00080000
+#define USB_CMD_ITC_16_MICRO_FRM		0x00100000
+#define USB_CMD_ITC_32_MICRO_FRM		0x00200000
+#define USB_CMD_ITC_64_MICRO_FRM		0x00400000
+#define USB_CMD_ITC_BIT_POS			16
+
+
+
+
+/* USB STS Register Bit Masks */
+#define USB_STS_INT				0x00000001
+#define USB_STS_ERR				0x00000002
+#define USB_STS_PORT_CHANGE			0x00000004
+#define USB_STS_FRM_LST_ROLL			0x00000008
+#define USB_STS_SYS_ERR				0x00000010
+#define USB_STS_IAA				0x00000020
+#define USB_STS_RESET				0x00000040
+#define USB_STS_SOF				0x00000080
+#define USB_STS_SUSPEND				0x00000100
+#define USB_STS_HC_HALTED			0x00001000
+#define USB_STS_RCL				0x00002000
+#define USB_STS_PERIODIC_SCHEDULE		0x00004000
+#define USB_STS_ASYNC_SCHEDULE			0x00008000
+
+/* USB INTR Register Bit Masks */
+#define USB_INTR_INT_EN				0x00000001
+#define USB_INTR_ERR_INT_EN			0x00000002
+#define USB_INTR_PTC_DETECT_EN			0x00000004
+#define USB_INTR_FRM_LST_ROLL_EN		0x00000008
+#define USB_INTR_SYS_ERR_EN			0x00000010
+#define USB_INTR_ASYN_ADV_EN			0x00000020
+#define USB_INTR_RESET_EN			0x00000040
+#define USB_INTR_SOF_EN				0x00000080
+#define USB_INTR_DEVICE_SUSPEND			0x00000100
+
+/* Device Address bit masks */
+#define USB_DEVICE_ADDRESS_MASK			0xFE000000
+#define USB_DEVICE_ADDRESS_BIT_POS		25
+
+/* endpoint list address bit masks */
+#define USB_EP_LIST_ADDRESS_MASK		0xfffff800
+
+
+/* x_PORTSCx */
+/* bit 31-30 are port transceiver select */
+#define PORTSCX_PTS_MASK		(3 << 30)	/* parallel xcvr select mask */
+#define PORTSCX_PHY_TYPE_SEL		PORTSCX_PTS_MASK
+#define PORTSCX_PTS_UTMI		(0 << 30)	/* UTMI/UTMI+ */
+#define PORTSCX_PTS_PHILIPS		(1 << 30)	/* Philips classic */
+#define PORTSCX_PTS_ULPI		(2 << 30)	/* ULPI */
+#define PORTSCX_PTS_SERIAL		(3 << 30)	/* serial */
+#define PORTSCX_PTS_FSLS		PORTSCX_PTS_SERIAL
+#define PORTSCX_PTS_ONCHIP		PORTSCX_PTS_FSLS
+
+#define PORTSCX_STS			(1 << 29)	/* serial xcvr select */
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define PORTSCX_PTW_8BIT		(0 << 28)	/* 8 bit parallel xcvr */
+#define PORTSCX_PTW_16BIT		(1 << 28)	/* 16 bi parallel xcvr */
+
+/* bit 27-26 are port speed */
+#define PORTSCX_PORT_SPEED_FULL		(0 << 26)
+#define PORTSCX_PORT_SPEED_LOW		(1 << 26)
+#define PORTSCX_PORT_SPEED_HIGH		(2 << 26)
+#define PORTSCX_PORT_SPEED_UNDEF	(3 << 26)
+#define PORTSCX_PORT_SPEED_MASK		(3 << 26)
+
+#define PORTSCX_PHY_LOW_POWER_SPD	(1 << 23)	/* phy low pwr suspend/clk disable */
+
+/* bit 19-16 are port test control */
+#define PORTSCX_PTC_DISABLE		(0 << 16)
+#define PORTSCX_PTC_JSTATE		(1 << 16)
+#define PORTSCX_PTC_KSTATE		(2 << 16)
+#define PORTSCX_PTC_SEQNAK		(3 << 16)	/* SE0 (host) / NAK (device) */
+#define PORTSCX_PTC_PACKET		(4 << 16)
+#define PORTSCX_PTC_FORCE_EN_HS		(5 << 16)
+#define PORTSCX_PTC_FORCE_EN_FS		(6 << 16)
+#define PORTSCX_PTC_FORCE_EN_LS		(7 << 16)
+
+
+/* bit 15-14 are port indicator control */
+#define PORTSCX_PIC_OFF			(0 << 14)
+#define PORTSCX_PIC_AMBER		(1 << 14)
+#define PORTSCX_PIC_GREEN		(2 << 14)
+#define PORTSCX_PIC_UNDEF		(3 << 14)
+
+#define PORTSCX_PORT_POWER		(1 << 12)	/* port power */
+
+/* bit 11-10 are line status */
+#define PORTSCX_LS_MASK			(3 << 10)	/* Line State mask */
+#define PORTSCX_LS_SE0			(0 << 10)	/* SE0     */
+#define PORTSCX_LS_K_STATE		(1 << 10)	/* K-state */
+#define PORTSCX_LS_J_STATE		(2 << 10)	/* J-state */
+
+#define PORTSCX_PORT_RESET		(1 <<  8)	/* Port reset */
+#define PORTSCX_PORT_SUSPEND		(1 <<  7)	/* Suspend */
+#define PORTSCX_PORT_FORCE_RESUME	(1 <<  6)	/* Force port resume */
+#define PORTSCX_OVER_CURRENT_CHG	(1 <<  5)	/* over current change */
+#define PORTSCX_OVER_CURRENT_ACT	(1 <<  4)	/* over currrent active */
+#define PORTSCX_PORT_EN_DIS_CHANGE	(1 <<  3)	/* port {en,dis}able change */
+#define PORTSCX_PORT_ENABLE		(1 <<  2)	/* port enabled */
+#define PORTSCX_CONNECT_STATUS_CHANGE	(1 <<  1)	/* connect status change */
+#define PORTSCX_CURRENT_CONNECT_STATUS	(1 <<  0)	/* current connect status */
+
+#define PORTSCX_W1C_BITS                     \
+       ( PORTSCX_CONNECT_STATUS_CHANGE |     \
+         PORTSCX_PORT_EN_DIS_CHANGE    |     \
+         PORTSCX_OVER_CURRENT_CHG )
+
+
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)	/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)	/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)	/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_INTSTS_MASK		(0x7f << 16)
+#define  OTGSC_INTSTS_USB_ID		(1 << 16)
+#define  OTGSC_INTSTS_A_VBUS_VALID	(1 << 17)
+#define  OTGSC_INTSTS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_INTSTS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_INTSTS_B_SESSION_END	(1 << 20)
+#define  OTGSC_INTSTS_1MS_TIMER		(1 << 21)
+#define  OTGSC_INTSTS_DATA_PULSE	(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1	/* DDD FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_INTSTS_MASK
+#endif // 1
+
+
+
+/* x_USBMODE */
+#undef USBMODE_SDIS	/* defined as bit 3 in drivers/usb/host/ehci.h */
+#define USBMODE_SDIS		(1 << 4)	/* stream disable mode */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+// DDD #define USBMODE_CM_IDLE		(0 << 0)	/* idle */
+
+/* DDD for compatibility for now */
+#define USB_MODE_CTRL_MODE_IDLE		USBMODE_CM_IDLE
+#define USB_MODE_CTRL_MODE_DEVICE	USBMODE_CM_DEVICE
+#define USB_MODE_CTRL_MODE_HOST		USBMODE_CM_HOST
+#define USB_MODE_SETUP_LOCK_OFF		USBMODE_SLOM
+#define USB_MODE_STREAM_DISABLE		USBMODE_SDIS
+
+
+/* ULPIVIEW register bits */
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07		/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF		/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF		/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF		/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+
+/* Endpoint Flush Register */
+#define EPFLUSH_TX_OFFSET			0x00010000
+#define EPFLUSH_RX_OFFSET			0x00000000
+
+/* Endpoint Setup Status bit masks */
+#define EP_SETUP_STATUS_MASK			0x0000003F
+#define EP_SETUP_STATUS_EP0			0x00000001
+
+/* ENDPOINTCTRLx  Register Bit Masks */
+#define EPCTRL_TX_ENABLE			0x00800000
+#define EPCTRL_TX_DATA_TOGGLE_RST		0x00400000	/* Not EP0 */
+#define EPCTRL_TX_DATA_TOGGLE_INH		0x00200000	/* Not EP0 */
+#define EPCTRL_TX_TYPE				0x000C0000
+#define EPCTRL_TX_DATA_SOURCE			0x00020000	/* Not EP0 */
+#define EPCTRL_TX_EP_STALL			0x00010000
+#define EPCTRL_RX_ENABLE			0x00000080
+#define EPCTRL_RX_DATA_TOGGLE_RST		0x00000040	/* Not EP0 */
+#define EPCTRL_RX_DATA_TOGGLE_INH		0x00000020	/* Not EP0 */
+#define EPCTRL_RX_TYPE				0x0000000C
+#define EPCTRL_RX_DATA_SINK			0x00000002	/* Not EP0 */
+#define EPCTRL_RX_EP_STALL			0x00000001
+
+/* bit 19-18 and 3-2 are endpoint type */
+#define EPCTRL_EP_TYPE_CONTROL			0
+#define EPCTRL_EP_TYPE_ISO			1
+#define EPCTRL_EP_TYPE_BULK			2
+#define EPCTRL_EP_TYPE_INTERRUPT		3
+#define EPCTRL_TX_EP_TYPE_SHIFT			18
+#define EPCTRL_RX_EP_TYPE_SHIFT			2
+
+/* SNOOPn Register Bit Masks */
+#define SNOOP_ADDRESS_MASK			0xFFFFF000
+#define SNOOP_SIZE_ZERO				0x00	/* snooping disable */
+#define SNOOP_SIZE_4KB				0x0B	/* 4KB snoop size */
+#define SNOOP_SIZE_8KB				0x0C
+#define SNOOP_SIZE_16KB				0x0D
+#define SNOOP_SIZE_32KB				0x0E
+#define SNOOP_SIZE_64KB				0x0F
+#define SNOOP_SIZE_128KB			0x10
+#define SNOOP_SIZE_256KB			0x11
+#define SNOOP_SIZE_512KB			0x12
+#define SNOOP_SIZE_1MB				0x13
+#define SNOOP_SIZE_2MB				0x14
+#define SNOOP_SIZE_4MB				0x15
+#define SNOOP_SIZE_8MB				0x16
+#define SNOOP_SIZE_16MB				0x17
+#define SNOOP_SIZE_32MB				0x18
+#define SNOOP_SIZE_64MB				0x19
+#define SNOOP_SIZE_128MB			0x1A
+#define SNOOP_SIZE_256MB			0x1B
+#define SNOOP_SIZE_512MB			0x1C
+#define SNOOP_SIZE_1GB				0x1D
+#define SNOOP_SIZE_2GB				0x1E	/* 2GB snoop size */
+
+/* pri_ctrl Register Bit Masks */
+#define PRI_CTRL_PRI_LVL1			0x0000000C
+#define PRI_CTRL_PRI_LVL0			0x00000003
+
+/* si_ctrl Register Bit Masks */
+#define SI_CTRL_ERR_DISABLE			0x00000010
+#define SI_CTRL_IDRC_DISABLE			0x00000008
+#define SI_CTRL_RD_SAFE_EN			0x00000004
+#define SI_CTRL_RD_PREFETCH_DISABLE		0x00000002
+#define SI_CTRL_RD_PREFEFETCH_VAL		0x00000001
+
+
+/* control Register Bit Masks */
+#define USB_CTRL_IOENB				0x00000004
+#define USB_CTRL_ULPI_INT0EN			0x00000001
+
+
+/* Endpoint Transfer Descriptor bit Masks */
+#define DTD_NEXT_TERMINATE			0x00000001
+#define DTD_IOC					0x00008000
+#define DTD_STATUS_ACTIVE			0x00000080
+#define DTD_STATUS_HALTED			0x00000040
+#define DTD_STATUS_DATA_BUFF_ERR		0x00000020
+#define DTD_STATUS_TRANSACTION_ERR		0x00000008
+#define DTD_RESERVED_FIELDS			0x80007300
+#define DTD_ADDR_MASK				0xFFFFFFE0
+#define DTD_PACKET_SIZE				0x7FFF0000
+#define DTD_LENGTH_BIT_POS			16
+#define DTD_ERROR_MASK (DTD_STATUS_HALTED | \
+			DTD_STATUS_DATA_BUFF_ERR | \
+			DTD_STATUS_TRANSACTION_ERR)
+/* Alignment requirements; must be a power of two */
+#define DTD_ALIGNMENT				0x20
+#define QH_ALIGNMENT				2048
+
+/* Controller dma boundary */
+#define UDC_DMA_BOUNDARY			0x1000
+
+#if defined CONFIG_PPC32
+#define fsl_readl(addr)		in_le32((addr))
+#define fsl_writel(addr, val32)	out_le32((addr), (val32))
+#elif defined CONFIG_COLDFIRE
+#define fsl_readl(addr)		in_be32((__force unsigned *)(addr))
+#define fsl_writel(val32, addr)	out_be32((__force unsigned *)(addr), (val32))
+
+#define fsl_readw(addr)		in_be16((__force unsigned *)(addr))
+#define fsl_writew(val16, addr)	out_be16((__force unsigned *)(addr), (val16))
+#else
+#error fsl_{readl, writel} must be defined
+#endif
+
+#endif	/* __FSL_USB2_H */
--- /dev/null
+++ b/include/linux/usb/fsl_xcvr.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+enum fsl_usb_ctrlr {
+	USB_CTRLR_H1 = 0,
+	USB_CTRLR_H2 = 1,
+	USB_CTRLR_OTG = 2,
+};
+
+
+/**
+ * struct fsl_xcvr_ops - USB transceiver operations
+ *
+ * @xcvr_type: one of PORTSCX_PTS_{UTMI,SERIAL,ULPI}
+ * @init: transceiver- and board-specific initialization function
+ * @uninit: transceiver- and board-specific uninitialization function
+ * @set_host:
+ * @set_device:
+ *
+ */
+struct fsl_xcvr_ops {
+	enum fsl_usb_ctrlr ctrlr;	/* H1, H2, OTG */
+	u32 xcvr_type;
+
+	void (*init)(struct platform_device *pdev);
+	void (*uninit)(struct platform_device *pdev);
+	void (*set_host)(void);	/* DDD combine set_host and _device ? */
+	void (*set_device)(void);
+	void (*set_vbus_power)(struct fsl_usb2_platform_data *pdata, int on);
+};
+
+
