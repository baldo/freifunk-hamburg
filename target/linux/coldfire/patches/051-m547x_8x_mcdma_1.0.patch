From 6c9df5dff79b6d09d1a31681067e7fbd85285f80 Mon Sep 17 00:00:00 2001
From: Kurt Mahan <kmahan@freescale.com>
Date: Wed, 30 Apr 2008 12:22:03 -0600
Subject: [PATCH] Update MultiChannel DMA to code version 1.0.

Changes since previous:
- Updated FEC RX task to work around bug where it would not update
  the RX buffer descriptors correctly and adjusted size accordingly.
- Added flag MCD_TT_FLAGS_PI for use with DSPI on MCD547x/8x.
- Fixed cleanup of paused tasks in MCD_killDma.
- Cosmetic changes to cleanup MCD_dmaApi.c.

LTIBName: m547x-8x-mcdma-1.0
Signed-off-by: Kurt Mahan <kmahan@freescale.com>
---
 arch/m68k/coldfire/Makefile       |    3 +-
 arch/m68k/coldfire/dma.c          |  532 ----
 arch/m68k/coldfire/m547x_8x-dma.c |  516 ++++
 drivers/dma/MCD_dma.h             |  786 +++---
 drivers/dma/MCD_dmaApi.c          |  417 ++--
 drivers/dma/MCD_progCheck.h       |   45 +-
 drivers/dma/MCD_tasks.c           | 4917 +++++++++++++++++++------------------
 drivers/dma/MCD_tasksInit.c       |  402 ++--
 drivers/dma/MCD_tasksInit.h       |   49 +-
 9 files changed, 3785 insertions(+), 3882 deletions(-)
 delete mode 100644 arch/m68k/coldfire/dma.c
 create mode 100644 arch/m68k/coldfire/m547x_8x-dma.c

--- a/arch/m68k/coldfire/Makefile
+++ b/arch/m68k/coldfire/Makefile
@@ -10,5 +10,4 @@ endif
 
 obj-$(CONFIG_PCI)	+= pci.o mcf5445x-pci.o iomap.o
 obj-$(CONFIG_M54455)	+= mcf5445x-devices.o
-
-obj-$(CONFIG_MCD_DMA)	+= dma.o
+obj-$(CONFIG_MCD_DMA)	+= m547x_8x-dma.o
--- a/arch/m68k/coldfire/dma.c
+++ /dev/null
@@ -1,532 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/dma.h>
-#include <asm/coldfire.h>
-#include <asm/m5485sram.h>
-#include <asm/mcfsim.h>
-
-
-
-void dma_interrupt_handler(int irq, void *dev_id, struct pt_regs *regs);
-
-/* 
- * This global keeps track of which initiators have been
- * used of the available assignments.  Initiators 0-15 are
- * hardwired.  Initiators 16-31 are multiplexed and controlled
- * via the Initiatior Mux Control Registe (IMCR).  The
- * assigned requestor is stored with the associated initiator
- * number.
- */
-static int used_reqs[32] = {
-	DMA_ALWAYS, DMA_DSPI_RX, DMA_DSPI_TX, DMA_DREQ0,
-	DMA_PSC0_RX, DMA_PSC0_TX, DMA_USBEP0, DMA_USBEP1,
-	DMA_USBEP2, DMA_USBEP3, DMA_PCI_TX, DMA_PCI_RX,
-	DMA_PSC1_RX, DMA_PSC1_TX, DMA_I2C_RX, DMA_I2C_TX,
-	0, 0, 0, 0,
-	0, 0, 0, 0,
-	0, 0, 0, 0,
-	0, 0, 0, 0
-};
-
-/*
- * This global keeps track of which channels have been assigned
- * to tasks.  This methology assumes that no single initiator
- * will be tied to more than one task/channel
- */
-static char used_channel[16] = {
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1
-};
-
-unsigned int connected_channel[16] = {
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0
-};
-
-/********************************************************************/
-/*
- * Attempt to enable the provided Initiator in the Initiator
- * Mux Control Register
- *
- * Parameters:
- *  initiator   Initiator identifier
- *
- * Return Value:
- *  1   if unable to make the assignment
- *  0   successful
- */
-int
-dma_set_initiator(int initiator)
-{
-	switch (initiator) {	/*
-				 * These initiators are always active 
-				 */
-	case DMA_ALWAYS:
-	case DMA_DSPI_RX:
-	case DMA_DSPI_TX:
-	case DMA_DREQ0:
-	case DMA_PSC0_RX:
-	case DMA_PSC0_TX:
-	case DMA_USBEP0:
-	case DMA_USBEP1:
-	case DMA_USBEP2:
-	case DMA_USBEP3:
-	case DMA_PCI_TX:
-	case DMA_PCI_RX:
-	case DMA_PSC1_RX:
-	case DMA_PSC1_TX:
-	case DMA_I2C_RX:
-	case DMA_I2C_TX:
-		break;
-
-	case DMA_FEC0_RX:
-		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC16(3))
-		    | MCF_DMA_IMCR_SRC16_FEC0RX;
-		used_reqs[16] = DMA_FEC0_RX;
-		break;
-
-	case DMA_FEC0_TX:
-		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC17(3))
-		    | MCF_DMA_IMCR_SRC17_FEC0TX;
-		used_reqs[17] = DMA_FEC0_TX;
-		break;
-
-	case DMA_FEC1_RX:
-		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC20(3))
-		    | MCF_DMA_IMCR_SRC20_FEC1RX;
-		used_reqs[20] = DMA_FEC1_RX;
-		break;
-
-	case DMA_FEC1_TX:
-		if (used_reqs[21] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
-			    | MCF_DMA_IMCR_SRC21_FEC1TX;
-			used_reqs[21] = DMA_FEC1_TX;
-		} else if (used_reqs[25] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
-			    | MCF_DMA_IMCR_SRC25_FEC1TX;
-			used_reqs[25] = DMA_FEC1_TX;
-		} else if (used_reqs[31] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
-			    | MCF_DMA_IMCR_SRC31_FEC1TX;
-			used_reqs[31] = DMA_FEC1_TX;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_DREQ1:
-		if (used_reqs[29] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
-			    | MCF_DMA_IMCR_SRC29_DREQ1;
-			used_reqs[29] = DMA_DREQ1;
-		} else if (used_reqs[21] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
-			    | MCF_DMA_IMCR_SRC21_DREQ1;
-			used_reqs[21] = DMA_DREQ1;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM0:
-		if (used_reqs[24] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC24(3))
-			    | MCF_DMA_IMCR_SRC24_CTM0;
-			used_reqs[24] = DMA_CTM0;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM1:
-		if (used_reqs[25] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
-			    | MCF_DMA_IMCR_SRC25_CTM1;
-			used_reqs[25] = DMA_CTM1;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM2:
-		if (used_reqs[26] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
-			    | MCF_DMA_IMCR_SRC26_CTM2;
-			used_reqs[26] = DMA_CTM2;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM3:
-		if (used_reqs[27] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
-			    | MCF_DMA_IMCR_SRC27_CTM3;
-			used_reqs[27] = DMA_CTM3;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM4:
-		if (used_reqs[28] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
-			    | MCF_DMA_IMCR_SRC28_CTM4;
-			used_reqs[28] = DMA_CTM4;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM5:
-		if (used_reqs[29] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
-			    | MCF_DMA_IMCR_SRC29_CTM5;
-			used_reqs[29] = DMA_CTM5;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM6:
-		if (used_reqs[30] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
-			    | MCF_DMA_IMCR_SRC30_CTM6;
-			used_reqs[30] = DMA_CTM6;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_CTM7:
-		if (used_reqs[31] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
-			    | MCF_DMA_IMCR_SRC31_CTM7;
-			used_reqs[31] = DMA_CTM7;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_USBEP4:
-		if (used_reqs[26] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
-			    | MCF_DMA_IMCR_SRC26_USBEP4;
-			used_reqs[26] = DMA_USBEP4;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_USBEP5:
-		if (used_reqs[27] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
-			    | MCF_DMA_IMCR_SRC27_USBEP5;
-			used_reqs[27] = DMA_USBEP5;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_USBEP6:
-		if (used_reqs[28] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
-			    | MCF_DMA_IMCR_SRC28_USBEP6;
-			used_reqs[28] = DMA_USBEP6;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_PSC2_RX:
-		if (used_reqs[28] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
-			    | MCF_DMA_IMCR_SRC28_PSC2RX;
-			used_reqs[28] = DMA_PSC2_RX;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_PSC2_TX:
-		if (used_reqs[29] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
-			    | MCF_DMA_IMCR_SRC29_PSC2TX;
-			used_reqs[29] = DMA_PSC2_TX;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_PSC3_RX:
-		if (used_reqs[30] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
-			    | MCF_DMA_IMCR_SRC30_PSC3RX;
-			used_reqs[30] = DMA_PSC3_RX;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	case DMA_PSC3_TX:
-		if (used_reqs[31] == 0) {
-			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
-			    | MCF_DMA_IMCR_SRC31_PSC3TX;
-			used_reqs[31] = DMA_PSC3_TX;
-		} else		/* No empty slots */
-			return 1;
-		break;
-
-	default:
-		return 1;
-	}
-	return 0;
-}
-
-/********************************************************************/
-/*
- * Return the initiator number for the given requestor
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- *
- * Return Value:
- *  The initiator number (0-31) if initiator has been assigned
- *  0 (always initiator) otherwise
- */
-unsigned int
-dma_get_initiator(int requestor)
-{
-	u32 i;
-
-	for (i = 0; i < sizeof (used_reqs); ++i) {
-		if (used_reqs[i] == requestor)
-			return i;
-	}
-	return 0;
-}
-
-/********************************************************************/
-/*
- * Remove the given initiator from the active list
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- */
-void
-dma_remove_initiator(int requestor)
-{
-	u32 i;
-
-	for (i = 0; i < sizeof (used_reqs); ++i) {
-		if (used_reqs[i] == requestor) {
-			used_reqs[i] = -1;
-			break;
-		}
-	}
-}
-
-/********************************************************************/
-/*
- * Attempt to find an available channel for FEC and mark is as used
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- *
- * Return Value:
- *  First available channel (from 0 to 5) or -1 if they are all occupied
- */
-int
-dma_set_channel_fec(int requestor)
-{
-	u32 i, t;
-
-#ifdef CONFIG_FEC_548x_ENABLE_FEC2
-	t = 4;
-#else
-	t = 2;
-#endif
-
-
-
-	for (i = 0; i < t ; ++i)
-		if (used_channel[i] == -1) {
-			used_channel[i] = requestor;
-			return i;
-		}
-	/* All channels taken */
-	return -1;
-}
-
-/********************************************************************/
-/*
- * Attempt to find an available channel and mark is as used
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- *
- * Return Value:
- *  First available channel (from 6 to 15) or -1 if they are all occupied
- */
-int
-dma_set_channel(int requestor)
-{
-	u32 i;
-#ifdef CONFIG_NET_FEC2
-	i = 4;
-#else
-	i = 2;
-#endif				
-
-	for (; i < 16; ++i)
-		if (used_channel[i] == -1) {
-			used_channel[i] = requestor;
-			return i;
-		}
-
-	/* All channels taken */
-	return -1;
-}
-
-/********************************************************************/
-/*
- * Return the channel being initiated by the given requestor
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- */
-int
-dma_get_channel(int requestor)
-{
-	u32 i;
-
-	for (i = 0; i < sizeof (used_channel); ++i) {
-		if (used_channel[i] == requestor)
-			return i;
-	}
-	return -1;
-}
-
-/********************************************************************/
-/*
- * Connects a channel with reference on your data 
- *
- * Parameters:
- *  channel   channel number
- *  reference addres of your data
-  */
-int
-dma_connect(int channel, int address)
-{
-	if ((channel < 16) && (channel >= 0))
-		connected_channel[channel] = address;
-	else
-		return -1;
-	return 0;
-}
-
-/********************************************************************/
-/*
- * Disconnects a channel with reference on your data 
- *
- * Parameters:
- *  channel   channel number
-*/
-int
-dma_disconnect(int channel)
-{
-	if ((channel < 16) && (channel >= 0))
-		connected_channel[channel] = 0;
-	else
-		return -1;
-	return 0;
-}
-
-/********************************************************************/
-/*
- * Remove the channel being initiated by the given requestor from 
- * the active list
- *
- * Parameters:
- *  requestor   Initiator/Requestor identifier
- */
-void
-dma_remove_channel(int requestor)
-{
-	u32 i;
-
-	for (i = 0; i < sizeof (used_channel); ++i) {
-		if (used_channel[i] == requestor) {
-			used_channel[i] = -1;
-			break;
-		}
-	}
-}
-
-/********************************************************************/
-/* 
- * This is the catch-all interrupt handler for the mult-channel DMA 
- */
-volatile u8 dma_iflag[16];
-u32 tx = 0;
-
-void
-dma_interrupt_handler(int irq, void *dev_id, struct pt_regs *regs)
-{
-	u32 i, interrupts/*, mask, temp*/;
-
-	/*
-	 * Determine which interrupt(s) triggered by AND'ing the 
-	 * pending interrupts with those that aren't masked.            
-	 */
-/*	mask = MCF_DMA_DIMR;
-	MCF_DMA_DIMR = 0xffffffff;
-*/
-	interrupts = MCF_DMA_DIPR;
-	MCF_DMA_DIPR |= interrupts;
-//	temp = interrupts;
-
-	//MCF_DMA_DIPR = interrupts;
-	for (i = 0; i < 16; ++i, interrupts >>= 1)
-		if (interrupts & 0x1)
-			if (connected_channel[i] != 0)
-				((void (*)(void)) (connected_channel[i])) ();
-
-/*	MCF_DMA_DIPR |= temp;
-	MCF_DMA_DIMR = mask;*/
-}
-
-void
-dma_remove_channel_by_number(int channel)
-{
-	if (channel < sizeof (used_channel) && channel >= 0)
-		used_channel[channel] = -1;
-}
-
-int __devinit
-dma_init()
-{
-	int result;
-	char *dma_version_str;
-
-	MCD_getVersion(&dma_version_str);
-	printk("Initialize %s\n", dma_version_str);
-
-	if (request_irq
-	    (64 + ISC_DMA, 
-	     dma_interrupt_handler, 
-	     IRQF_DISABLED, 
-	     "MCD-DMA", 
-	     NULL)) {
-		printk("Cannot allocate the DMA IRQ(48)\n");
-		return 1;
-	}
-
-	MCF_DMA_DIMR = 0;
-	MCF_DMA_DIPR = 0xFFFFFFFF;
-
-	MCF_ICR(ISC_DMA) = ILP_DMA;
-
-	result = MCD_initDma((dmaRegs *) (MCF_MBAR + 0x8000),
-			(void *) SYS_SRAM_DMA_START, MCD_RELOC_TASKS);
-	if (result != MCD_OK) {
-		printk("Cannot perform DMA initialization\n");
-		free_irq(64 + ISC_DMA, NULL);
-		return 1;
-	}
-
-	return 0;
-}
-
-device_initcall(dma_init);
-
--- /dev/null
+++ b/arch/m68k/coldfire/m547x_8x-dma.c
@@ -0,0 +1,516 @@
+/*
+ * arch/m68k/coldfire/m547x_8x-dma.c
+ *
+ * Coldfire M547x/M548x DMA
+ *
+ * Copyright (c) 2008 Freescale Semiconductor, Inc.
+ *	Kurt Mahan <kmahan@freescale.com>
+ *
+ * This code is based on patches from the Freescale M547x_8x BSP
+ * release mcf547x_8x-20070107-ltib.iso
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/coldfire.h>
+#include <asm/m5485sram.h>
+#include <asm/mcfsim.h>
+
+/*
+ * This global keeps track of which initiators have been
+ * used of the available assignments.  Initiators 0-15 are
+ * hardwired.  Initiators 16-31 are multiplexed and controlled
+ * via the Initiatior Mux Control Registe (IMCR).  The
+ * assigned requestor is stored with the associated initiator
+ * number.
+ */
+static int used_reqs[32] = {
+	DMA_ALWAYS, DMA_DSPI_RX, DMA_DSPI_TX, DMA_DREQ0,
+	DMA_PSC0_RX, DMA_PSC0_TX, DMA_USBEP0, DMA_USBEP1,
+	DMA_USBEP2, DMA_USBEP3, DMA_PCI_TX, DMA_PCI_RX,
+	DMA_PSC1_RX, DMA_PSC1_TX, DMA_I2C_RX, DMA_I2C_TX,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0
+};
+
+/*
+ * This global keeps track of which channels have been assigned
+ * to tasks.  This methology assumes that no single initiator
+ * will be tied to more than one task/channel
+ */
+static char used_channel[16] = {
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+unsigned int connected_channel[16] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/**
+ * dma_set_initiator - enable initiator
+ * @initiator: initiator identifier
+ *
+ * Returns 0 of successful, non-zero otherwise
+ *
+ * Attempt to enable the provided Initiator in the Initiator
+ * Mux Control Register.
+ */
+int dma_set_initiator(int initiator)
+{
+	switch (initiator) {
+	case DMA_ALWAYS:
+	case DMA_DSPI_RX:
+	case DMA_DSPI_TX:
+	case DMA_DREQ0:
+	case DMA_PSC0_RX:
+	case DMA_PSC0_TX:
+	case DMA_USBEP0:
+	case DMA_USBEP1:
+	case DMA_USBEP2:
+	case DMA_USBEP3:
+	case DMA_PCI_TX:
+	case DMA_PCI_RX:
+	case DMA_PSC1_RX:
+	case DMA_PSC1_TX:
+	case DMA_I2C_RX:
+	case DMA_I2C_TX:
+		/*
+		 * These initiators are always active
+		 */
+		break;
+
+	case DMA_FEC0_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC16(3))
+		    | MCF_DMA_IMCR_SRC16_FEC0RX;
+		used_reqs[16] = DMA_FEC0_RX;
+		break;
+
+	case DMA_FEC0_TX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC17(3))
+		    | MCF_DMA_IMCR_SRC17_FEC0TX;
+		used_reqs[17] = DMA_FEC0_TX;
+		break;
+
+	case DMA_FEC1_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC20(3))
+		    | MCF_DMA_IMCR_SRC20_FEC1RX;
+		used_reqs[20] = DMA_FEC1_RX;
+		break;
+
+	case DMA_FEC1_TX:
+		if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_FEC1TX;
+			used_reqs[21] = DMA_FEC1_TX;
+		} else if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_FEC1TX;
+			used_reqs[25] = DMA_FEC1_TX;
+		} else if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_FEC1TX;
+			used_reqs[31] = DMA_FEC1_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_DREQ1:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_DREQ1;
+			used_reqs[29] = DMA_DREQ1;
+		} else if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_DREQ1;
+			used_reqs[21] = DMA_DREQ1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM0:
+		if (used_reqs[24] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC24(3))
+			    | MCF_DMA_IMCR_SRC24_CTM0;
+			used_reqs[24] = DMA_CTM0;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM1:
+		if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_CTM1;
+			used_reqs[25] = DMA_CTM1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM2:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_CTM2;
+			used_reqs[26] = DMA_CTM2;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM3:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_CTM3;
+			used_reqs[27] = DMA_CTM3;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM4:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_CTM4;
+			used_reqs[28] = DMA_CTM4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM5:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_CTM5;
+			used_reqs[29] = DMA_CTM5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM6:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_CTM6;
+			used_reqs[30] = DMA_CTM6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM7:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_CTM7;
+			used_reqs[31] = DMA_CTM7;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP4:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_USBEP4;
+			used_reqs[26] = DMA_USBEP4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP5:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_USBEP5;
+			used_reqs[27] = DMA_USBEP5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP6:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_USBEP6;
+			used_reqs[28] = DMA_USBEP6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_RX:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_PSC2RX;
+			used_reqs[28] = DMA_PSC2_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_TX:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_PSC2TX;
+			used_reqs[29] = DMA_PSC2_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_RX:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_PSC3RX;
+			used_reqs[30] = DMA_PSC3_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_TX:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_PSC3TX;
+			used_reqs[31] = DMA_PSC3_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	default:
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * dma_get_initiator - get the initiator for the given requestor
+ * @requestor: initiator identifier
+ *
+ * Returns initiator number (0-31) if assigned or just 0
+ */
+unsigned int dma_get_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_reqs); ++i) {
+		if (used_reqs[i] == requestor)
+			return i;
+	}
+	return 0;
+}
+
+/**
+ * dma_remove_initiator - remove the given initiator from active list
+ * @requestor: requestor to remove
+ */
+void dma_remove_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_reqs); ++i) {
+		if (used_reqs[i] == requestor) {
+			used_reqs[i] = -1;
+			break;
+		}
+	}
+}
+
+/**
+ * dma_set_channel_fec: find available channel for fec and mark
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns first avaialble channel (0-5) or -1 if all occupied
+ */
+int dma_set_channel_fec(int requestor)
+{
+	u32 i, t;
+
+#ifdef CONFIG_FEC_548x_ENABLE_FEC2
+	t = 4;
+#else
+	t = 2;
+#endif
+
+	for (i = 0; i < t ; ++i) {
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+	}
+	/* All channels taken */
+	return -1;
+}
+
+/**
+ * dma_set_channel - find an available channel and mark as used
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns first available channel (6-15) or -1 if all occupied
+ */
+int dma_set_channel(int requestor)
+{
+	u32 i;
+#ifdef CONFIG_NET_FEC2
+	i = 4;
+#else
+	i = 2;
+#endif
+
+	for (; i < 16; ++i)
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+
+	/* All channels taken */
+	return -1;
+}
+
+/**
+ * dma_get_channel - get the channel being initiated by the requestor
+ * @requestor: initiator/requestor identifier
+ *
+ * Returns Initiator for requestor or -1 if not found
+ */
+int dma_get_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_channel); ++i) {
+		if (used_channel[i] == requestor)
+			return i;
+	}
+	return -1;
+}
+
+/**
+ * dma_connect - connect a channel with reference on data
+ * @channel: channel number
+ * @address: reference address of data
+ *
+ * Returns 0 if success or -1 if invalid channel
+ */
+int dma_connect(int channel, int address)
+{
+	if ((channel < 16) && (channel >= 0)) {
+		connected_channel[channel] = address;
+		return 0;
+	}
+	return -1;
+}
+
+/**
+ * dma_disconnect - disconnect a channel
+ * @channel: channel number
+ *
+ * Returns 0 if success or -1 if invalid channel
+ */
+int dma_disconnect(int channel)
+{
+	if ((channel < 16) && (channel >= 0)) {
+		connected_channel[channel] = 0;
+		return 0;
+	}
+	return -1;
+}
+
+/**
+ * dma_remove_channel - remove channel from the active list
+ * @requestor: initiator/requestor identifier
+ */
+void dma_remove_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof(used_channel); ++i) {
+		if (used_channel[i] == requestor) {
+			used_channel[i] = -1;
+			break;
+		}
+	}
+}
+
+/**
+ * dma_interrupt_handler - dma interrupt handler
+ * @irq: interrupt number
+ * @dev_id: data
+ *
+ * Returns IRQ_HANDLED
+ */
+irqreturn_t dma_interrupt_handler(int irq, void *dev_id)
+{
+	u32 i, interrupts;
+
+	/*
+	 * Determine which interrupt(s) triggered by AND'ing the
+	 * pending interrupts with those that aren't masked.
+	 */
+	interrupts = MCF_DMA_DIPR;
+	MCF_DMA_DIPR |= interrupts;
+
+	for (i = 0; i < 16; ++i, interrupts >>= 1) {
+		if (interrupts & 0x1)
+			if (connected_channel[i] != 0)
+				((void (*)(void)) (connected_channel[i])) ();
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * dma_remove_channel_by_number - clear dma channel
+ * @channel: channel number to clear
+ */
+void dma_remove_channel_by_number(int channel)
+{
+	if ((channel < sizeof(used_channel)) && (channel >= 0))
+		used_channel[channel] = -1;
+}
+
+/**
+ * dma_init - initialize the dma subsystem
+ *
+ * Returns 0 if success non-zero if failure
+ *
+ * Handles the DMA initialization during device setup.
+ */
+int __devinit dma_init()
+{
+	int result;
+	char *dma_version_str;
+
+	MCD_getVersion(&dma_version_str);
+	printk(KERN_INFO "m547x_8x DMA: Initialize %s\n", dma_version_str);
+
+	/* attempt to setup dma interrupt handler */
+	if (request_irq(64 + ISC_DMA, dma_interrupt_handler, IRQF_DISABLED,
+			"MCD-DMA", NULL)) {
+		printk(KERN_ERR "MCD-DMA: Cannot allocate the DMA IRQ(48)\n");
+		return 1;
+	}
+
+	MCF_DMA_DIMR = 0;
+	MCF_DMA_DIPR = 0xFFFFFFFF;
+
+	MCF_ICR(ISC_DMA) = ILP_DMA;
+
+	result = MCD_initDma((dmaRegs *) (MCF_MBAR + 0x8000),
+			(void *) SYS_SRAM_DMA_START, MCD_RELOC_TASKS);
+	if (result != MCD_OK) {
+		printk(KERN_ERR "MCD-DMA: Cannot perform DMA initialization\n");
+		free_irq(64 + ISC_DMA, NULL);
+		return 1;
+	}
+
+	return 0;
+}
+device_initcall(dma_init);
--- a/drivers/dma/MCD_dma.h
+++ b/drivers/dma/MCD_dma.h
@@ -1,45 +1,27 @@
-/*********************************************************************
- *
- * Copyright (C) 2004  Motorola, Inc.
- *  MOTOROLA, INC. All Rights Reserved.
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This
- *  software is provided on an "AS IS" basis and without warranty.
+/*
+ * drivers/dma/MCD_dma.h
  *
- *  To the maximum extent permitted by applicable law, MOTOROLA
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
- *  ACCOMPANYING WRITTEN MATERIALS.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
-
-/*
- * File:        MCD_dma.h
- * Purpose:     Main header file for multi-channel DMA API.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * Notes:
- *
- * Modifications:
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 #ifndef _MCD_API_H
 #define _MCD_API_H
 
-#include <asm/types.h>
-
 /*
  * Turn Execution Unit tasks ON (#define) or OFF (#undef)
  */
@@ -79,26 +61,13 @@
 /*
  * Portability typedefs
  */
- /*
-#ifndef s32
 typedef int s32;
-#endif
-#ifndef u32
 typedef unsigned int u32;
-#endif
-#ifndef s16
 typedef short s16;
-#endif
-#ifndef u16
 typedef unsigned short u16;
-#endif
-#ifndef s8
 typedef char s8;
-#endif
-#ifndef u8
 typedef unsigned char u8;
-#endif
-*/
+
 /*
  * These structures represent the internal registers of the
  * multi-channel DMA
@@ -233,6 +202,7 @@ typedef volatile struct dmaRegs_s dmaReg
 #define MCD_TT_FLAGS_RL   0x00000001 /* Read line */
 #define MCD_TT_FLAGS_CW   0x00000002 /* Combine Writes */
 #define MCD_TT_FLAGS_SP   0x00000004 /* Speculative prefetch(XLB) MCF547x/548x ONLY  */
+#define MCD_TT_FLAGS_PI   0x00000040 /* Precise Increment */
 #define MCD_TT_FLAGS_MASK 0x000000ff
 #define MCD_TT_FLAGS_DEF  (MCD_TT_FLAGS_RL | MCD_TT_FLAGS_CW)
 
--- a/drivers/dma/MCD_dmaApi.c
+++ b/drivers/dma/MCD_dmaApi.c
@@ -1,46 +1,26 @@
-/*********************************************************************
- *
- * Copyright (C) 2004  Motorola, Inc.
- *  MOTOROLA, INC. All Rights Reserved.
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This
- *  software is provided on an "AS IS" basis and without warranty.
- *
- *  To the maximum extent permitted by applicable law, MOTOROLA
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
- *  ACCOMPANYING WRITTEN MATERIALS.
- *
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
- *
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
-
 /*
- * File:        MCD_dmaApi.c
- * Purpose:     Main C file for multi-channel DMA API.
- *
- * Notes:
+ * drivers/dma/MCD_dmaApi.c
  *
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
- * Modifications:
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
-#include <asm/types.h>
-#include <asm/MCD_dma.h>
-#include <asm/virtconvert.h>
+
+#include "MCD_dma.h"
 #include "MCD_tasksInit.h"
 #include "MCD_progCheck.h"
 
@@ -148,7 +128,6 @@ MCD_bufDesc *MCD_relocBuffDesc;
 
 /*
  * Structure to remember which variant is on which channel
- * TBD- need this?
  */
 typedef struct MCD_remVariants_struct MCD_remVariant;
 struct MCD_remVariants_struct
@@ -164,6 +143,7 @@ struct MCD_remVariants_struct
  * Structure to remember the startDma parameters for each channel
  */
 MCD_remVariant MCD_remVariants;
+
 /********************************************************************/
 /*
  * Function: MCD_initDma
@@ -185,15 +165,14 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
     int i;
     TaskTableEntry *entryPtr;
 
-    /* setup the local pointer to register set */
+    /* Setup the local pointer to register set */
     MCD_dmaBar = dmaBarAddr;
 
-    /* do we need to move/create a task table */
+    /* Do we need to move/create a task table */
     if ((flags & MCD_RELOC_TASKS) != 0)
     {
         int fixedSize;
         u32 *fixedPtr;
-        /*int *tablePtr = taskTableDest;TBD*/
         int varTabsOffset, funcDescTabsOffset, contextSavesOffset;
         int taskDescTabsOffset;
         int taskTableSize, varTabsSize, funcDescTabsSize, contextSavesSize;
@@ -201,7 +180,7 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
 
         int i;
 
-        /* check if physical address is aligned on 512 byte boundary */
+        /* Check if physical address is aligned on 512 byte boundary */
         if (((u32)taskTableDest & 0x000001ff) != 0)
             return(MCD_TABLE_UNALIGNED);
 
@@ -215,13 +194,12 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
          * - copy over model task table with the the actual task descriptor
          *   tables
          */
-
         taskTableSize = NCHANNELS * sizeof(TaskTableEntry);
-        /* align variable tables to size */
+        /* Align variable tables to size */
         varTabsOffset = taskTableSize + (u32)taskTableDest;
         if ((varTabsOffset & (VAR_TAB_SIZE - 1)) != 0)
             varTabsOffset = (varTabsOffset + VAR_TAB_SIZE) & (~VAR_TAB_SIZE);
-        /* align function descriptor tables */
+        /* Align function descriptor tables */
         varTabsSize = NCHANNELS * VAR_TAB_SIZE;
         funcDescTabsOffset = varTabsOffset + varTabsSize;
 
@@ -235,13 +213,13 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
         fixedSize = taskTableSize + varTabsSize + funcDescTabsSize +
                     contextSavesSize;
 
-        /* zero the thing out */
+        /* Zero the thing out */
         fixedPtr = (u32 *)taskTableDest;
         for (i = 0;i<(fixedSize/4);i++)
             fixedPtr[i] = 0;
 
         entryPtr = (TaskTableEntry*)MCD_taskTable;
-        /* set up fixed pointers */
+        /* Set up fixed pointers */
         for (i = 0; i < NCHANNELS; i++)
         {
             entryPtr[i].varTab = (u32)varTabsOffset; /* update ptr to local value */
@@ -253,25 +231,25 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
 #endif
             contextSavesOffset += CONTEXT_SAVE_SIZE;
         }
-        /* copy over the function descriptor table */
+        /* Copy over the function descriptor table */
         for ( i = 0; i < FUNCDESC_TAB_NUM; i++)
         {
             MCD_memcpy((void*)(entryPtr[i].FDTandFlags & ~MCD_TT_FLAGS_MASK),
                        (void*)MCD_funcDescTab0, FUNCDESC_TAB_SIZE);
         }
 
-        /* copy model task table to where the context saves stuff leaves off*/
+        /* Copy model task table to where the context save stuff leaves off */
         MCD_modelTaskTable = (TaskTableEntry*)contextSavesOffset;
 
         MCD_memcpy ((void*)MCD_modelTaskTable, (void*)MCD_modelTaskTableSrc,
                     NUMOFVARIANTS * sizeof(TaskTableEntry));
 
-        entryPtr = MCD_modelTaskTable; /* point to local version of
-                                                            model task table */
+        /* Point to local version of model task table */
+        entryPtr = MCD_modelTaskTable;
         taskDescTabsOffset = (u32)MCD_modelTaskTable +
                             (NUMOFVARIANTS * sizeof(TaskTableEntry));
 
-        /* copy actual task code and update TDT ptrs in local model task table */
+        /* Copy actual task code and update TDT ptrs in local model task table */
         for (i = 0; i < NUMOFVARIANTS; i++)
         {
             taskDescTabSize = entryPtr[i].TDTend - entryPtr[i].TDTstart + 4;
@@ -280,25 +258,29 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
             taskDescTabsOffset += taskDescTabSize;
             entryPtr[i].TDTend = (u32)taskDescTabsOffset - 4;
         }
-#ifdef MCD_INCLUDE_EU /* Tack single DMA BDs onto end of code so API controls
-                         where they are since DMA might write to them */        
+#ifdef MCD_INCLUDE_EU 
+        /* 
+         * Tack single DMA BDs onto end of code so API controls where
+         * they are since DMA might write to them 
+         */
         MCD_relocBuffDesc = (MCD_bufDesc*)(entryPtr[NUMOFVARIANTS - 1].TDTend + 4);
-#else /* DMA does not touch them so they can be wherever and we don't need to 
-         waste SRAM on them */
+#else 
+        /* 
+         * DMA does not touch them so they can be wherever and we don't need to
+         * waste SRAM on them 
+         */
         MCD_relocBuffDesc = MCD_singleBufDescs;
 #endif
     }
     else
     {
-        /* point the would-be relocated task tables and the
-        buffer descriptors to the ones the linker generated */
-
+        /* 
+         * Point the would-be relocated task tables and the buffer descriptors
+         * to the ones the linker generated
+         */
         if (((u32)MCD_realTaskTableSrc & 0x000001ff) != 0)
             return(MCD_TABLE_UNALIGNED);
 
-        /* need to add code to make sure that every thing else is aligned properly TBD*/
-        /* this is problematic if we init more than once or after running tasks,
-            need to add variable to see if we have aleady init'd */
         entryPtr = MCD_realTaskTableSrc;
         for (i = 0; i < NCHANNELS; i++)
         {
@@ -312,9 +294,7 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
         MCD_relocBuffDesc = MCD_singleBufDescs;
     }
 
-
-    /* Make all channels as totally inactive, and remember them as such: */
-
+    /* Make all channels inactive, and remember them as such: */
     MCD_dmaBar->taskbar = (u32) MCD_taskTable;
     for (i = 0;  i < NCHANNELS;  i++)
     {
@@ -323,13 +303,12 @@ int MCD_initDma (dmaRegs *dmaBarAddr, vo
     }
 
    /* Set up pausing mechanism to inactive state: */
-    MCD_dmaBar->debugComp1 = 0;  /* no particular values yet for either comparator registers */
+    MCD_dmaBar->debugComp1 = 0;
     MCD_dmaBar->debugComp2 = 0;
     MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
     MCD_dmaBar->debugStatus = DBG_KILL_ALL_STAT;
 
-    /* enable or disable commbus prefetch, really need an ifdef or
-       something to keep from trying to set this in the 8220 */
+    /* Enable or disable commbus prefetch */
     if ((flags & MCD_COMM_PREFETCH_EN) != 0)
         MCD_dmaBar->ptdControl &= ~PTD_CTL_COMM_PREFETCH;
     else
@@ -354,8 +333,7 @@ int MCD_dmaStatus (int channel)
 
     tcrValue = MCD_dmaBar->taskControl[channel];
     if ((tcrValue & TASK_CTL_EN) == 0)
-    {  /* nothing running */
-        /* if last reported with task enabled */
+    {   /* Nothing running if last reported with task enabled */
         if (   MCD_chStatus[channel] == MCD_RUNNING
             || MCD_chStatus[channel] == MCD_IDLE)
             MCD_chStatus[channel] = MCD_DONE;
@@ -367,13 +345,12 @@ int MCD_dmaStatus (int channel)
             || MCD_chStatus[channel] == MCD_IDLE)
         {
             MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT;
-            /* This register is selected to know which initiator is
-            actually asserted. */
+            /* Determine which initiator is asserted. */
             if ((MCD_dmaBar->ptdDebug >> channel ) & 0x1 )
                 MCD_chStatus[channel] = MCD_RUNNING;
             else
                 MCD_chStatus[channel] = MCD_IDLE;
-        /* do not change the status if it is already paused. */
+            /* Do not change the status if it is already paused */
         }
     }
     return MCD_chStatus[channel];
@@ -414,67 +391,86 @@ int MCD_startDma (
 
     if((channel < 0) || (channel >= NCHANNELS))
         return(MCD_CHANNEL_INVALID);
-        
-    /* tbd - need to determine the proper response to a bad funcDesc when not 
-       including EU functions, for now, assign a benign funcDesc, but maybe
-       should return an error */
+
 #ifndef MCD_INCLUDE_EU
     funcDesc = MCD_FUNC_NOEU1;
 #endif
-        
+
 #ifdef MCD_DEBUG
 printf("startDma:Setting up params\n");
 #endif
-   /* Set us up for task-wise priority.  We don't technically need to do this on every start, but
-      since the register involved is in the same longword as other registers that users are in control
-      of, setting it more than once is probably preferable.  That since the documentation doesn't seem
-      to be completely consistent about the nature of the PTD control register. */
+
+   /* Enable task-wise priority */
     MCD_dmaBar->ptdControl |= (u16) 0x8000;
-#if 1 /* Not sure what we need to keep here rtm TBD */
+
     /* Calculate additional parameters to the regular DMA calls. */
     srcRsdIncr = srcIncr < 0 ? -1 : (srcIncr > 0 ? 1 : 0);
     destRsdIncr = destIncr < 0 ? -1 : (destIncr > 0 ? 1 : 0);
-
     xferSizeIncr = (xferSize & 0xffff) | 0x20000000;
 
-    /* Remember for each channel which variant is running. */
+    /* Remember which variant is running for each channel */
     MCD_remVariants.remSrcRsdIncr[channel] = srcRsdIncr;
     MCD_remVariants.remDestRsdIncr[channel] = destRsdIncr;
     MCD_remVariants.remDestIncr[channel] = destIncr;
     MCD_remVariants.remSrcIncr[channel] = srcIncr;
     MCD_remVariants.remXferSize[channel] = xferSize;
-#endif
 
-    cSave = (int*)(MCD_taskTable[channel].contextSaveSpace) + CSAVE_OFFSET + CURRBD;
+    cSave = (int*)(MCD_taskTable[channel].contextSaveSpace) 
+            + CSAVE_OFFSET 
+            + CURRBD;
 
-#ifdef MCD_INCLUDE_EU /* may move this to EU specific calls */
+#ifdef MCD_INCLUDE_EU
     realFuncArray = (u32 *) (MCD_taskTable[channel].FDTandFlags & 0xffffff00);
-    /* Modify the LURC's normal and byte-residue-loop functions according to parameter. */
-    realFuncArray[(LURC*16)] = xferSize == 4 ?
-                                 funcDesc : xferSize == 2 ?
-                                     funcDesc & 0xfffff00f : funcDesc & 0xffff000f;
-    realFuncArray[(LURC*16+1)] = (funcDesc & MCD_BYTE_SWAP_KILLER) | MCD_NO_BYTE_SWAP_ATALL;
-#endif
-   /* Write the initiator field in the TCR, and also set the initiator-hold
-      bit.  Note that,due to a hardware quirk, this could collide with an
-      MDE access to the initiator-register file, so we have to verify that the write
-      reads back correctly. */
 
-    MCD_dmaBar->taskControl[channel] =
-        (initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM;
+    /* 
+     * Modify the LURC's normal and byte-residue-loop functions 
+     * according to parameter. 
+     */
+    switch (xferSize)
+    {
+        case 4:
+            realFuncArray[(LURC*16)] = funcDesc;
+            break;
+        case 2:
+            realFuncArray[(LURC*16)] = funcDesc & 0xfffff00f;
+            break;
+        case 1:
+        default:
+            realFuncArray[(LURC*16)] = funcDesc & 0xffff000f;
+            break;
+    }
 
+    realFuncArray[(LURC*16+1)] = 0
+        | (funcDesc & MCD_BYTE_SWAP_KILLER) 
+        | MCD_NO_BYTE_SWAP_ATALL;
+#endif
+
+   /* Write the initiator field in the TCR and set the initiator-hold bit*/
+    MCD_dmaBar->taskControl[channel] = 0
+        | (initiator << 8)
+        | TASK_CTL_HIPRITSKEN
+        | TASK_CTL_HLDINITNUM;
+
+    /* 
+     * Current versions of the MPC8220 MCD have a hardware quirk that could
+     * cause the write to the TCR to collide with an MDE access to the 
+     * initiator-register file, so we have to verify that the write occurred
+     * correctly by reading back the value.  On MCF547x/8x devices and any
+     * future revisions of the MPC8220, this loop will not be entered.
+     */
     while(((MCD_dmaBar->taskControl[channel] & 0x1fff) !=
           ((initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM)) &&
             (tcrCount < 1000))
     {
         tcrCount++;
-        /*MCD_dmaBar->ptd_tcr[channel] = (initiator << 8) | 0x0020;*/
-        MCD_dmaBar->taskControl[channel] =
-            (initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM;
+        MCD_dmaBar->taskControl[channel] = 0
+            | (initiator << 8)
+            | TASK_CTL_HIPRITSKEN
+            | TASK_CTL_HLDINITNUM;
     }
 
     MCD_dmaBar->priority[channel] = (u8)priority & PRIORITY_PRI_MASK;
-    /* should be albe to handle this stuff with only one write to ts reg - tbd */
+
     if (channel < 8 && channel >= 0)
     {
         MCD_dmaBar->taskSize0 &= ~(0xf << (7-channel)*4);
@@ -488,7 +484,7 @@ printf("startDma:Setting up params\n");
         MCD_dmaBar->taskSize1 |= (xferSize & 3) << ((15 - channel)*4);
     }
 
-    /* setup task table flags/options which mostly control the line buffers */
+    /* Setup task table flags/options */
     MCD_taskTable[channel].FDTandFlags &= ~MCD_TT_FLAGS_MASK;
     MCD_taskTable[channel].FDTandFlags |= (MCD_TT_FLAGS_MASK & flags);
 
@@ -508,79 +504,86 @@ printf("startDma:Setting up params\n");
     }
     else if(flags & MCD_SINGLE_DMA)
     {
-        /* this buffer descriptor is used for storing off initial parameters for later
-           progress query calculation and for the DMA to write the resulting checksum
-           The DMA does not use this to determine how to operate, that info is passed
-           with the init routine*/
+        /* 
+         * This buffer descriptor is used for storing off initial parameters 
+         * for later progress query calculation and for the DMA to write the 
+         * resulting checksum. The DMA does not use this to determine how to 
+         * operate, that info is passed with the init routine
+         */
         MCD_relocBuffDesc[channel].srcAddr = srcAddr;
         MCD_relocBuffDesc[channel].destAddr = destAddr;
-        MCD_relocBuffDesc[channel].lastDestAddr = destAddr;  /* definitely not its final value */
+        MCD_relocBuffDesc[channel].lastDestAddr = destAddr;
         MCD_relocBuffDesc[channel].dmaSize = dmaSize;
         MCD_relocBuffDesc[channel].flags = 0;       /* not used */
         MCD_relocBuffDesc[channel].csumResult = 0;  /* not used */
         MCD_relocBuffDesc[channel].next = 0;        /* not used */
 
         /* Initialize the progress-querying stuff to show no progress:*/
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET] = (int)srcAddr;
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET] = (int)destAddr;
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] = 0;
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] =
-                                             (u32) &(MCD_relocBuffDesc[channel]);
-        /* tbd - need to keep the user from trying to call the EU routine
-           when MCD_INCLUDE_EU is not defined */
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET] 
+            = (int)srcAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET] 
+            = (int)destAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] 
+            = 0;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] 
+            = (u32) &(MCD_relocBuffDesc[channel]);
+
         if( funcDesc == MCD_FUNC_NOEU1 || funcDesc == MCD_FUNC_NOEU2)
         {
-           /* TDTStart and TDTEnd */
-           MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLENOEU].TDTstart;
-           MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLENOEU].TDTend;
-           MCD_startDmaSingleNoEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize, dmaSize,
-                                xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), cSave,
-                                MCD_taskTable, channel);
+            /* TDTStart and TDTEnd */
+            MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLENOEU].TDTstart;
+            MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLENOEU].TDTend;
+            MCD_startDmaSingleNoEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize,
+                                xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), 
+                                cSave, MCD_taskTable, channel);
         }
         else
         {
-           /* TDTStart and TDTEnd */
-           MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLEEU].TDTstart;
-           MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLEEU].TDTend;
-           MCD_startDmaSingleEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize, dmaSize,
-                              xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), cSave,
-                              MCD_taskTable, channel);
+            /* TDTStart and TDTEnd */
+            MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLEEU].TDTstart;
+            MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLEEU].TDTend;
+            MCD_startDmaSingleEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize,
+                                xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), 
+                                cSave, MCD_taskTable, channel);
         }
     }
-    else
-    { /* chained DMAS */
+    else /* Chained DMA */
+    {
         /* Initialize the progress-querying stuff to show no progress:*/
 #if 1 /* (!defined(MCD_NEED_ADDR_TRANS)) */
         ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET]
-          = (int)((MCD_bufDesc*) phys_to_virt(srcAddr))->srcAddr;
+            = (int)((MCD_bufDesc*) srcAddr)->srcAddr;
         ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET]
-          = (int)((MCD_bufDesc*) phys_to_virt(srcAddr))->destAddr;
+            = (int)((MCD_bufDesc*) srcAddr)->destAddr;
 #else /* if using address translation, need the virtual addr of the first buffdesc */
         ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET]
           = (int)((MCD_bufDesc*) srcAddrVirt)->srcAddr;
         ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET]
           = (int)((MCD_bufDesc*) srcAddrVirt)->destAddr;
 #endif
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] = 0;
-        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] = (u32) srcAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] 
+          = 0;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] 
+          = (u32) srcAddr;
 
         if( funcDesc == MCD_FUNC_NOEU1 || funcDesc == MCD_FUNC_NOEU2)
         {
-          /*TDTStart and TDTEnd*/
-          MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINNOEU].TDTstart;
-          MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINNOEU].TDTend;
-          MCD_startDmaChainNoEu((int *)srcAddr, srcIncr, destIncr, xferSize,
+            /* TDTStart and TDTEnd */
+            MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINNOEU].TDTstart;
+            MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINNOEU].TDTend;
+            MCD_startDmaChainNoEu((int *)srcAddr, srcIncr, destIncr, xferSize,
                                     xferSizeIncr, cSave, MCD_taskTable, channel);
         }
         else
         {
-          /*TDTStart and TDTEnd*/
-          MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINEU].TDTstart;
-          MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINEU].TDTend;
-          MCD_startDmaChainEu((int *)srcAddr, srcIncr, destIncr, xferSize,
+            /* TDTStart and TDTEnd */
+            MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINEU].TDTstart;
+            MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINEU].TDTend;
+            MCD_startDmaChainEu((int *)srcAddr, srcIncr, destIncr, xferSize,
                                  xferSizeIncr, cSave, MCD_taskTable, channel);
         }
     }
+
     MCD_chStatus[channel] = MCD_IDLE;
     return(MCD_OK);
 }
@@ -597,7 +600,7 @@ printf("startDma:Setting up params\n");
  * Notes:
  *  MCD_XferProgrQuery() upon completing or after aborting a DMA, or
  *  while the DMA is in progress, this function returns the first
- *  DMA-destination address not (or not yet) used in the DMA. When 
+ *  DMA-destination address not (or not yet) used in the DMA. When
  *  encountering a non-ready buffer descriptor, the information for
  *  the last completed descriptor is returned.
  *
@@ -642,11 +645,13 @@ int MCD_XferProgrQuery (int channel, MCD
     prevRep.dmaSize = ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET];
     prevRep.currBufDesc =
           (MCD_bufDesc*) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
+
     /* Repeatedly reread those values until they match previous values: */
     do {
-        /* Waste a little bit of time to ensure stability: */
+        /* Take a little bit of time to ensure stability: */
         for (i = 0;  i < STABTIME;  i++)
-            i += i >> 2;  /* make sure this loop does something so that it doesn't get optimized out */
+            i += i >> 2;  /* make sure this loop does something so that it 
+                             doesn't get optimized out */
         /* Check them again: */
         progRep->lastSrcAddr =
             (s8 *) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET];
@@ -655,31 +660,33 @@ int MCD_XferProgrQuery (int channel, MCD
         progRep->dmaSize = ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET];
         progRep->currBufDesc =
             (MCD_bufDesc*) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
-       /* See if they match: */
-       if (   prevRep.lastSrcAddr != progRep->lastSrcAddr
-           || prevRep.lastDestAddr != progRep->lastDestAddr
-           || prevRep.dmaSize != progRep->dmaSize
-           || prevRep.currBufDesc != progRep->currBufDesc)
-       {
-          /* If they don't match, remember previous values and try again:*/
-          prevRep.lastSrcAddr = progRep->lastSrcAddr;
-          prevRep.lastDestAddr = progRep->lastDestAddr;
-          prevRep.dmaSize = progRep->dmaSize;
-          prevRep.currBufDesc = progRep->currBufDesc;
-          again = MCD_TRUE;
-       }
-       else
+
+        /* See if they match: */
+        if (   prevRep.lastSrcAddr  != progRep->lastSrcAddr
+            || prevRep.lastDestAddr != progRep->lastDestAddr
+            || prevRep.dmaSize      != progRep->dmaSize
+            || prevRep.currBufDesc  != progRep->currBufDesc)
+        {
+            /* If they don't match, remember previous values and try again:*/
+            prevRep.lastSrcAddr = progRep->lastSrcAddr;
+            prevRep.lastDestAddr = progRep->lastDestAddr;
+            prevRep.dmaSize = progRep->dmaSize;
+            prevRep.currBufDesc = progRep->currBufDesc;
+            again = MCD_TRUE;
+        }
+        else
           again = MCD_FALSE;
     } while (again == MCD_TRUE);
 
 
-    /* Update the dCount, srcAddr and destAddr */
-    /* To calculate dmaCount, we consider destination address. C
-       overs M1,P1,Z for destination */
-    switch(MCD_remVariants.remDestRsdIncr[channel]) {
+    /* Update dmaSize and lastDestAddr */
+    switch(MCD_remVariants.remDestRsdIncr[channel]) 
+    {
         case MINUS1:
-           subModVal = ((int)progRep->lastDestAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
-           addModVal = ((int)progRep->currBufDesc->destAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+           subModVal = ((int)progRep->lastDestAddr) 
+                        & ((MCD_remVariants.remXferSize[channel]) - 1);
+           addModVal = ((int)progRep->currBufDesc->destAddr) 
+                        & ((MCD_remVariants.remXferSize[channel]) - 1);
            LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr) - addModVal;
            LWAlignedCurrDestAddr = (progRep->lastDestAddr) - subModVal;
            destDiffBytes = LWAlignedInitDestAddr - LWAlignedCurrDestAddr;
@@ -692,25 +699,28 @@ int MCD_XferProgrQuery (int channel, MCD
            progRep->lastDestAddr = progRep->currBufDesc->destAddr;
            break;
         case PLUS1:
-           /* This value has to be subtracted from the final calculated dCount. */
-           subModVal = ((int)progRep->currBufDesc->destAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+           /* This value has to be subtracted from the final calculated dmaSize. */
+            subModVal = ((int)progRep->currBufDesc->destAddr) 
+                        & ((MCD_remVariants.remXferSize[channel]) - 1);
            /* These bytes are already in lastDestAddr. */
-            addModVal = ((int)progRep->lastDestAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+            addModVal = ((int)progRep->lastDestAddr) 
+                        & ((MCD_remVariants.remXferSize[channel]) - 1);
             LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr) - subModVal;
             LWAlignedCurrDestAddr = (progRep->lastDestAddr) - addModVal;
             destDiffBytes = (progRep->lastDestAddr - LWAlignedInitDestAddr);
             numIterations = ( LWAlignedCurrDestAddr - LWAlignedInitDestAddr)/MCD_remVariants.remDestIncr[channel];
             bytesNotXfered =  numIterations *
-                ( MCD_remVariants.remDestIncr[channel]
-                  - MCD_remVariants.remXferSize[channel]);
-           progRep->dmaSize = destDiffBytes - bytesNotXfered - subModVal;
-           break;
+                              (MCD_remVariants.remDestIncr[channel]
+                             - MCD_remVariants.remXferSize[channel]);
+            progRep->dmaSize = destDiffBytes - bytesNotXfered - subModVal;
+            break;
         default:
-           break;
+            break;
     }
 
     /* This covers M1,P1,Z for source */
-    switch(MCD_remVariants.remSrcRsdIncr[channel]) {
+    switch(MCD_remVariants.remSrcRsdIncr[channel]) 
+    {
         case MINUS1:
             progRep->lastSrcAddr =
                 progRep->currBufDesc->srcAddr +
@@ -720,13 +730,14 @@ int MCD_XferProgrQuery (int channel, MCD
         case ZERO:
             progRep->lastSrcAddr = progRep->currBufDesc->srcAddr;
             break;
-       case PLUS1:
+        case PLUS1:
             progRep->lastSrcAddr =
                 progRep->currBufDesc->srcAddr +
                  ( MCD_remVariants.remSrcIncr[channel] *
                    (progRep->dmaSize/MCD_remVariants.remXferSize[channel]));
-          break;
-       default: break;
+            break;
+        default: 
+            break;
     }
 
     return(MCD_OK);
@@ -744,8 +755,10 @@ static void MCD_resmActions (int channel
 {
    MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
    MCD_dmaBar->debugStatus = MCD_dmaBar->debugStatus;
-   MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT; /* This register is selected to know
-                                        which initiator is actually asserted. */
+
+   /* Determine which initiators are asserted */
+   MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT; 
+
    if((MCD_dmaBar->ptdDebug >> channel ) & 0x1)
        MCD_chStatus[channel] = MCD_RUNNING;
    else
@@ -767,27 +780,20 @@ static void MCD_resmActions (int channel
  */
 int MCD_killDma (int channel)
 {
-   /* MCD_XferProg progRep; */
-
     if((channel < 0) || (channel >= NCHANNELS))
         return(MCD_CHANNEL_INVALID);
 
     MCD_dmaBar->taskControl[channel] = 0x0;
-    MCD_resumeDma (channel);
-    /*
-     * This must be after the write to the TCR so that the task doesn't
-     * start up again momentarily, and before the status assignment so
-     * as to override whatever MCD_resumeDma() may do to the channel
-     * status.
-     */
+    
+    /* Clean up after a paused task */
+    if (MCD_chStatus[channel] == MCD_PAUSED)
+    {
+        MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+        MCD_dmaBar->debugStatus = MCD_dmaBar->debugStatus;        
+    }
+     
     MCD_chStatus[channel] = MCD_HALTED;
 
-    /*
-     * Update the current buffer descriptor's lastDestAddr field
-     *
-     * MCD_XferProgrQuery (channel, &progRep);
-     * progRep.currBufDesc->lastDestAddr = progRep.lastDestAddr;
-     */
     return(MCD_OK);
 }
 /************************ End of MCD_killDma() **********************/
@@ -843,7 +849,7 @@ int MCD_continDma (int channel)
  * this means that bits 14 and 0 must enable debug functions before
  * bits 1 and 2, respectively, have any effect.
  *
- * NOTE: It's extremely important to not pause more than one DMA channel 
+ * NOTE: It's extremely important to not pause more than one DMA channel
  *  at a time.
  ********************************************************************/
 
@@ -856,8 +862,6 @@ int MCD_continDma (int channel)
  */
 int MCD_pauseDma (int channel)
 {
-    /* MCD_XferProg progRep; */
-
     if((channel < 0) || (channel >= NCHANNELS))
         return(MCD_CHANNEL_INVALID);
 
@@ -866,13 +870,6 @@ int MCD_pauseDma (int channel)
         MCD_dmaBar->debugComp1 = channel;
         MCD_dmaBar->debugControl = DBG_CTL_ENABLE | (1 << (channel + 16));
         MCD_chStatus[channel] = MCD_PAUSED;
-
-        /*
-         * Update the current buffer descriptor's lastDestAddr field
-         *
-         * MCD_XferProgrQuery (channel, &progRep);
-         * progRep.currBufDesc->lastDestAddr = progRep.lastDestAddr;
-         */
     }
     return(MCD_OK);
 }
@@ -929,9 +926,9 @@ int MCD_csumQuery (int channel, u32 *csu
 int MCD_getCodeSize(void)
 {
 #ifdef MCD_INCLUDE_EU
-    return(0x2b5c);
+    return(0x2b64);
 #else
-    return(0x173c);
+    return(0x1744);
 #endif
 }
 /********************** End of MCD_getCodeSize() ********************/
@@ -943,9 +940,9 @@ int MCD_getCodeSize(void)
  *                    which points to the version string
  * Returns:     Version number and version string (by reference)
  */
-char MCD_versionString[] = "Multi-channel DMA API Alpha v0.3 (2004-04-26)";
-#define MCD_REV_MAJOR   0x00
-#define MCD_REV_MINOR   0x03
+char MCD_versionString[] = "Multi-channel DMA API v1.0";
+#define MCD_REV_MAJOR   0x01
+#define MCD_REV_MINOR   0x00
 
 int MCD_getVersion(char **longVersion)
 {
--- a/drivers/dma/MCD_progCheck.h
+++ b/drivers/dma/MCD_progCheck.h
@@ -1,32 +1,27 @@
-/*********************************************************************
+/*
+ * drivers/dma/MCD_progCheck.h
  *
- * Copyright (C) 2004  Motorola, Inc.
- *  MOTOROLA, INC. All Rights Reserved.
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This
- *  software is provided on an "AS IS" basis and without warranty.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
- *  To the maximum extent permitted by applicable law, MOTOROLA
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
- *  ACCOMPANYING WRITTEN MATERIALS.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
- /* This file is autogenerated. Do not change */
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This file is autogenerated. Do not change */
+
 #define CURRBD 4
 #define DCOUNT 6
 #define DESTPTR 5
--- a/drivers/dma/MCD_tasks.c
+++ b/drivers/dma/MCD_tasks.c
@@ -1,44 +1,26 @@
-/*********************************************************************
- *
- * Copyright (C) 2004  Motorola, Inc.
- *  MOTOROLA, INC. All Rights Reserved.
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This
- *  software is provided on an "AS IS" basis and without warranty.
- *
- *  To the maximum extent permitted by applicable law, MOTOROLA
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
- *  ACCOMPANYING WRITTEN MATERIALS.
- *
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
- *
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
 /*
- * File:        MCD_tasks.c
- * Purpose:     Contains task code and structures for Multi-channel DMA
- *
- * Notes:
+ * drivers/dma/MCD_tasks.c
  *
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
- * Modifications:
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
-#include <asm/MCD_dma.h>
+#include "MCD_dma.h"
 
 u32 MCD_varTab0[];
 u32 MCD_varTab1[];
@@ -922,13 +904,13 @@ u32 MCD_funcDescTab0[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 #ifdef MCD_INCLUDE_EU
@@ -991,13 +973,13 @@ u32 MCD_funcDescTab1[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab2[]=
@@ -1059,13 +1041,13 @@ u32 MCD_funcDescTab2[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab3[]=
@@ -1127,13 +1109,13 @@ u32 MCD_funcDescTab3[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab4[]=
@@ -1195,13 +1177,13 @@ u32 MCD_funcDescTab4[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab5[]=
@@ -1263,13 +1245,13 @@ u32 MCD_funcDescTab5[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab6[]=
@@ -1331,13 +1313,13 @@ u32 MCD_funcDescTab6[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab7[]=
@@ -1399,13 +1381,13 @@ u32 MCD_funcDescTab7[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab8[]=
@@ -1467,13 +1449,13 @@ u32 MCD_funcDescTab8[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab9[]=
@@ -1535,13 +1517,13 @@ u32 MCD_funcDescTab9[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab10[]=
@@ -1603,13 +1585,13 @@ u32 MCD_funcDescTab10[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab11[]=
@@ -1671,13 +1653,13 @@ u32 MCD_funcDescTab11[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab12[]=
@@ -1739,13 +1721,13 @@ u32 MCD_funcDescTab12[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab13[]=
@@ -1807,13 +1789,13 @@ u32 MCD_funcDescTab13[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab14[]=
@@ -1875,13 +1857,13 @@ u32 MCD_funcDescTab14[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 
 u32 MCD_funcDescTab15[]=
@@ -1943,13 +1925,13 @@ u32 MCD_funcDescTab15[]=
     0x20400000, /* add(), EU# 3 */
     0x20500000, /* sub(), EU# 3 */
     0x205a0000, /* andNot(), EU# 3 */
+    0x20a00000, /* shiftR(), EU# 3 */
     0x202fa000, /* andReadyBit(), EU# 3 */
     0x202f9000, /* andNotReadyBit(), EU# 3 */
     0x202ea000, /* andWrapBit(), EU# 3 */
-    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202da000, /* andLastBit(), EU# 3 */
     0x202e2000, /* andInterruptBit(), EU# 3 */
-    0x202f2000, /* andLoopBit(), EU# 3 */
-    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+    0x202f2000, /* andCrcRestartBit(), EU# 3 */
 };
 #endif /*MCD_INCLUDE_EU*/
 
@@ -1970,7 +1952,6 @@ u32 MCD_contextSave13[128]; /* Task 13 c
 u32 MCD_contextSave14[128]; /* Task 14 context save space */
 u32 MCD_contextSave15[128]; /* Task 15 context save space */
 
-/* Task Descriptor Tables - the guts */
 u32 MCD_ChainNoEu_TDT[];
 u32 MCD_SingleNoEu_TDT[];
 #ifdef MCD_INCLUDE_EU
@@ -1983,7 +1964,7 @@ u32 MCD_ENetXmit_TDT[];
 u32 MCD_modelTaskTableSrc[]=
 {
     (u32)MCD_ChainNoEu_TDT,
-    (u32)&((u8*)MCD_ChainNoEu_TDT)[0x00000178],
+    (u32)&((u8*)MCD_ChainNoEu_TDT)[0x0000016c],
     0x00000000,
     0x00000000,
     0x00000000,
@@ -2000,7 +1981,7 @@ u32 MCD_modelTaskTableSrc[]=
     0x00000000,
 #ifdef MCD_INCLUDE_EU
     (u32)MCD_ChainEu_TDT,
-    (u32)&((u8*)MCD_ChainEu_TDT)[0x00000180],
+    (u32)&((u8*)MCD_ChainEu_TDT)[0x000001b4],
     0x00000000,
     0x00000000,
     0x00000000,
@@ -2008,7 +1989,7 @@ u32 MCD_modelTaskTableSrc[]=
     0x00000000,
     0x00000000,
     (u32)MCD_SingleEu_TDT,
-    (u32)&((u8*)MCD_SingleEu_TDT)[0x000000dc],
+    (u32)&((u8*)MCD_SingleEu_TDT)[0x00000124],
     0x00000000,
     0x00000000,
     0x00000000,
@@ -2017,7 +1998,7 @@ u32 MCD_modelTaskTableSrc[]=
     0x00000000,
 #endif
     (u32)MCD_ENetRcv_TDT,
-    (u32)&((u8*)MCD_ENetRcv_TDT)[0x0000009C],
+    (u32)&((u8*)MCD_ENetRcv_TDT)[0x000000a4],
     0x00000000,
     0x00000000,
     0x00000000,
@@ -2033,420 +2014,452 @@ u32 MCD_modelTaskTableSrc[]=
     0x00000000,
     0x00000000,
 };
-
 u32 MCD_ChainNoEu_TDT[]=
 {
     0x80004000, /* 0000(:370):  LCDEXT: idx0 = 0x00000000; ; */
     0x8118801b, /* 0004(:370):  LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0xb8ca0018, /* 0008(:371):    LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
-    0x10004b10, /* 000C(:372):      DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x7000000c, /* 0010(:373):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x024cf89f, /* 0014(:373):      DRD2B1: var9 = EU3(); EU3(idx2)  */
-    0x60000009, /* 0018(:374):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0xb8c60018, /* 0008(:371):    LCD: idx2 = *(idx1 + var12); idx2 once var0; idx2 += inc3 */
+    0x10002b10, /* 000C(:372):      DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000d, /* 0010(:373):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x018cf89f, /* 0014(:373):      DRD2B1: var6 = EU3(); EU3(idx2)  */
+    0x6000000a, /* 0018(:374):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
     0x080cf89f, /* 001C(:374):      DRD2B1: idx0 = EU3(); EU3(idx2)  */
     0x000001f8, /* 0020(:0):    NOP */
-    0x98180524, /* 0024(:378):  LCD: idx0 = idx0; idx0 != var20; idx0 += inc4 */
+    0x98180364, /* 0024(:378):  LCD: idx0 = idx0; idx0 == var13; idx0 += inc4 */
     0x8118801b, /* 0028(:380):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0xf8ca001a, /* 002C(:381):      LCDEXT: idx2 = *(idx1 + var20 + 8); idx2 once var0; idx2 += inc3 */
-    0xb8ca601b, /* 0030(:382):      LCD: idx3 = *(idx1 + var20 + 12); ; idx3 += inc3 */
-    0x10004310, /* 0034(:384):        DRD1A: var16 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x00001718, /* 0038(:385):        DRD1A: var5 = idx3; FN=0 init=0 WS=0 RS=0 */
-    0xb8ca001d, /* 003C(:387):      LCD: idx2 = *(idx1 + var20 + 20); idx2 once var0; idx2 += inc3 */
-    0x10001f10, /* 0040(:388):        DRD1A: var7 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0xf8c6001a, /* 002C(:381):      LCDEXT: idx2 = *(idx1 + var12 + 8); idx2 once var0; idx2 += inc3 */
+    0xb8c6601b, /* 0030(:382):      LCD: idx3 = *(idx1 + var12 + 12); ; idx3 += inc3 */
+    0x10002710, /* 0034(:384):        DRD1A: var9 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x00000f18, /* 0038(:385):        DRD1A: var3 = idx3; FN=0 init=0 WS=0 RS=0 */
+    0xb8c6001d, /* 003C(:387):      LCD: idx2 = *(idx1 + var12 + 20); idx2 once var0; idx2 += inc3 */
+    0x10001310, /* 0040(:388):        DRD1A: var4 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
     0x60000007, /* 0044(:389):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=7 EXT init=0 WS=0 RS=0 */
-    0x020cf893, /* 0048(:389):        DRD2B1: var8 = EU3(); EU3(idx2,var19)  */
-    0x98ca001c, /* 004C(:391):      LCD: idx2 = idx1 + var20 + 4; idx2 once var0; idx2 += inc3 */
+    0x014cf88b, /* 0048(:389):        DRD2B1: var5 = EU3(); EU3(idx2,var11)  */
+    0x98c6001c, /* 004C(:391):      LCD: idx2 = idx1 + var12 + 4; idx2 once var0; idx2 += inc3 */
     0x00000710, /* 0050(:392):        DRD1A: var1 = idx2; FN=0 init=0 WS=0 RS=0 */
-    0x98ca8018, /* 0054(:393):      LCD: idx2 = idx1 + var21; idx2 once var0; idx2 += inc3 */
-    0x10002b10, /* 0058(:394):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x0000c828, /* 005C(:395):        DRD1A: *idx2 = var5; FN=0 init=0 WS=0 RS=0 */
+    0x98c70018, /* 0054(:393):      LCD: idx2 = idx1 + var14; idx2 once var0; idx2 += inc3 */
+    0x10001f10, /* 0058(:394):        DRD1A: var7 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c818, /* 005C(:395):        DRD1A: *idx2 = var3; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 0060(:0):      NOP */
-    0xc14ae018, /* 0064(:399):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
-    0xc004a51d, /* 0068(:399):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var20; idx2 += inc3, idx3 += inc5 */
+    0xc1476018, /* 0064(:399):    LCDEXT: idx1 = var2 + var14; ; idx1 += inc3 */
+    0xc003231d, /* 0068(:399):    LCDEXT: idx2 = var0, idx3 = var6; idx3 == var12; idx2 += inc3, idx3 += inc5 */
     0x811a601b, /* 006C(:400):    LCD: idx4 = var2; ; idx4 += inc3 */
-    0xc28a21c2, /* 0070(:403):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
-    0x881be009, /* 0074(:403):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0xc1862102, /* 0070(:403):      LCDEXT: idx5 = var3, idx6 = var12; idx6 < var4; idx5 += inc0, idx6 += inc2 */
+    0x849be009, /* 0074(:403):      LCD: idx7 = var9; ; idx7 += inc1 */
     0x03fed7b8, /* 0078(:406):        DRD1A: *idx7; FN=0 init=31 WS=3 RS=3 */
     0xda9b001b, /* 007C(:408):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
     0x9b9be01b, /* 0080(:408):      LCD: idx7 = idx7; ; idx7 += inc3 */
     0x1000cb20, /* 0084(:409):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 0088(:410):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 008C(:410):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 008C(:410):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb28, /* 0090(:411):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 0094(:412):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 0098(:412):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 0098(:412):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb30, /* 009C(:413):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 00A0(:414):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00A4(:414):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 00A4(:414):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb38, /* 00A8(:415):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
     0x0000c728, /* 00AC(:416):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 00B0(:0):      NOP */
-    0xc14ae018, /* 00B4(:420):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
-    0xc004a5dd, /* 00B8(:420):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var23; idx2 += inc3, idx3 += inc5 */
+    0xc1476018, /* 00B4(:420):    LCDEXT: idx1 = var2 + var14; ; idx1 += inc3 */
+    0xc003241d, /* 00B8(:420):    LCDEXT: idx2 = var0, idx3 = var6; idx3 == var16; idx2 += inc3, idx3 += inc5 */
     0x811a601b, /* 00BC(:421):    LCD: idx4 = var2; ; idx4 += inc3 */
     0xda9b001b, /* 00C0(:424):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
     0x9b9be01b, /* 00C4(:424):      LCD: idx7 = idx7; ; idx7 += inc3 */
     0x0000d3a0, /* 00C8(:425):        DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
-    0xc28a21c2, /* 00CC(:427):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
-    0x881be009, /* 00D0(:427):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0xc1862102, /* 00CC(:427):      LCDEXT: idx5 = var3, idx6 = var12; idx6 < var4; idx5 += inc0, idx6 += inc2 */
+    0x849be009, /* 00D0(:427):      LCD: idx7 = var9; ; idx7 += inc1 */
     0x0bfed7b8, /* 00D4(:430):        DRD1A: *idx7; FN=0 TFD init=31 WS=3 RS=3 */
     0xda9b001b, /* 00D8(:432):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
     0x9b9be01b, /* 00DC(:432):      LCD: idx7 = idx7; ; idx7 += inc3 */
     0x1000cb20, /* 00E0(:433):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 00E4(:434):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00E8(:434):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 00E8(:434):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb28, /* 00EC(:435):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 00F0(:436):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00F4(:436):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 00F4(:436):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb30, /* 00F8(:437):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
     0x70000006, /* 00FC(:438):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 0100(:438):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x088cf88f, /* 0100(:438):        DRD2B1: idx2 = EU3(); EU3(idx2,var15)  */
     0x1000cb38, /* 0104(:439):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
     0x0000c728, /* 0108(:440):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 010C(:0):      NOP */
     0x8118801b, /* 0110(:444):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0x8a19001b, /* 0114(:446):      LCD: idx2 = var20; idx2 once var0; idx2 += inc3 */
-    0x6000000e, /* 0118(:447):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
-    0x088cf49f, /* 011C(:447):        DRD2B1: idx2 = EU3(); EU3(var18)  */
-    0xd9190536, /* 0120(:448):      LCDEXT: idx2 = idx2; idx2 == var20; idx2 += inc6 */
-    0x98ca0018, /* 0124(:448):      LCD: idx3 = idx1 + var20; idx3 once var0; idx3 += inc3 */
-    0x6000000a, /* 0128(:450):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
-    0x0cccfcdf, /* 012C(:450):        DRD2B1: *idx3 = EU3(); EU3(*idx3)  */
-    0x000001f8, /* 0130(:0):      NOP */
-    0xa14a001e, /* 0134(:453):    LCD: idx1 = *(var2 + var20 + 24); idx1 once var0; idx1 += inc3 */
-    0x10000b08, /* 0138(:454):      DRD1A: var2 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x10002c90, /* 013C(:455):      DRD1A: var11 = var18; FN=0 MORE init=0 WS=0 RS=0 */
-    0xb8ca0018, /* 0140(:456):      LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
-    0x10004b10, /* 0144(:457):        DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000009, /* 0148(:458):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT MORE init=0 WS=0 RS=0 */
-    0x080cf89f, /* 014C(:458):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
-    0x6000000c, /* 0150(:459):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT init=0 WS=0 RS=0 */
-    0x024cf89f, /* 0154(:459):        DRD2B1: var9 = EU3(); EU3(idx2)  */
-    0x000001f8, /* 0158(:0):      NOP */
-    0x8a18801b, /* 015C(:465):    LCD: idx1 = var20; idx1 once var0; idx1 += inc3 */
-    0x7000000d, /* 0160(:466):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
-    0x084cf2df, /* 0164(:466):      DRD2B1: idx1 = EU3(); EU3(var11)  */
-    0xd899053f, /* 0168(:467):      LCDEXT: idx2 = idx1; idx2 > var20; idx2 += inc7 */
-    0x8019801b, /* 016C(:467):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
-    0x040001f8, /* 0170(:468):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
-    0x000001f8, /* 0174(:0):      NOP */
-    0x000001f8, /* 0178(:0):    NOP */
+    0xd8c60018, /* 0114(:446):      LCDEXT: idx2 = idx1 + var12; idx2 once var0; idx2 += inc3 */
+    0x98c6601c, /* 0118(:446):      LCD: idx3 = idx1 + var12 + 4; ; idx3 += inc3 */
+    0x6000000b, /* 011C(:447):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT init=0 WS=0 RS=0 */
+    0x0c8cfc9f, /* 0120(:447):        DRD2B1: *idx2 = EU3(); EU3(*idx2)  */
+    0x000001f8, /* 0124(:0):      NOP */
+    0xa146001e, /* 0128(:450):    LCD: idx1 = *(var2 + var12 + 24); idx1 once var0; idx1 += inc3 */
+    0x10000b08, /* 012C(:451):      DRD1A: var2 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x10002050, /* 0130(:452):      DRD1A: var8 = var10; FN=0 MORE init=0 WS=0 RS=0 */
+    0xb8c60018, /* 0134(:453):      LCD: idx2 = *(idx1 + var12); idx2 once var0; idx2 += inc3 */
+    0x10002b10, /* 0138(:454):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000a, /* 013C(:455):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf89f, /* 0140(:455):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x6000000d, /* 0144(:456):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x018cf89f, /* 0148(:456):        DRD2B1: var6 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 014C(:0):      NOP */
+    0x8618801b, /* 0150(:462):    LCD: idx1 = var12; idx1 once var0; idx1 += inc3 */
+    0x7000000e, /* 0154(:463):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT MORE init=0 WS=0 RS=0 */
+    0x084cf21f, /* 0158(:463):      DRD2B1: idx1 = EU3(); EU3(var8)  */
+    0xd8990336, /* 015C(:464):      LCDEXT: idx2 = idx1; idx2 > var12; idx2 += inc6 */
+    0x8019801b, /* 0160(:464):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x040001f8, /* 0164(:465):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 0168(:0):      NOP */
+    0x000001f8, /* 016C(:0):    NOP */
 };
 u32 MCD_SingleNoEu_TDT[]=
 {
-    0x8318001b, /* 0000(:646):  LCD: idx0 = var6; idx0 once var0; idx0 += inc3 */
-    0x7000000c, /* 0004(:647):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x080cf81f, /* 0008(:647):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
-    0x8318801b, /* 000C(:648):    LCD: idx1 = var6; idx1 once var0; idx1 += inc3 */
-    0x6000000d, /* 0010(:649):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
-    0x084cf85f, /* 0014(:649):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
+    0x8198001b, /* 0000(:657):  LCD: idx0 = var3; idx0 once var0; idx0 += inc3 */
+    0x7000000d, /* 0004(:658):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf81f, /* 0008(:658):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
+    0x8198801b, /* 000C(:659):    LCD: idx1 = var3; idx1 once var0; idx1 += inc3 */
+    0x6000000e, /* 0010(:660):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x084cf85f, /* 0014(:660):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
     0x000001f8, /* 0018(:0):    NOP */
-    0x8498001b, /* 001C(:653):  LCD: idx0 = var9; idx0 once var0; idx0 += inc3 */
-    0x7000000c, /* 0020(:654):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x020cf81f, /* 0024(:654):    DRD2B1: var8 = EU3(); EU3(idx0)  */
-    0x6000000d, /* 0028(:655):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
-    0x028cf81f, /* 002C(:655):    DRD2B1: var10 = EU3(); EU3(idx0)  */
-    0xc404601b, /* 0030(:658):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
-    0xc00423dc, /* 0034(:658):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var15; idx2 += inc3, idx3 += inc4 */
-    0x809a601b, /* 0038(:659):  LCD: idx4 = var1; ; idx4 += inc3 */
-    0xc207a182, /* 003C(:662):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
-    0x869be009, /* 0040(:662):    LCD: idx7 = var13; ; idx7 += inc1 */
-    0x03fed7b8, /* 0044(:665):      DRD1A: *idx7; FN=0 init=31 WS=3 RS=3 */
-    0xda9b001b, /* 0048(:667):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 004C(:667):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x70000006, /* 0050(:669):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 0054(:669):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb28, /* 0058(:670):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 005C(:671):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 0060(:671):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb30, /* 0064(:672):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 0068(:673):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 006C(:673):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x0000cb38, /* 0070(:674):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x8298001b, /* 001C(:664):  LCD: idx0 = var5; idx0 once var0; idx0 += inc3 */
+    0x7000000d, /* 0020(:665):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x010cf81f, /* 0024(:665):    DRD2B1: var4 = EU3(); EU3(idx0)  */
+    0x6000000e, /* 0028(:666):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x018cf81f, /* 002C(:666):    DRD2B1: var6 = EU3(); EU3(idx0)  */
+    0xc202601b, /* 0030(:669):  LCDEXT: idx0 = var4, idx1 = var4; ; idx0 += inc3, idx1 += inc3 */
+    0xc002221c, /* 0034(:669):  LCDEXT: idx2 = var0, idx3 = var4; idx3 == var8; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0038(:670):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xc10420c2, /* 003C(:673):    LCDEXT: idx5 = var2, idx6 = var8; idx6 < var3; idx5 += inc0, idx6 += inc2 */
+    0x839be009, /* 0040(:673):    LCD: idx7 = var7; ; idx7 += inc1 */
+    0x03fed7b8, /* 0044(:676):      DRD1A: *idx7; FN=0 init=31 WS=3 RS=3 */
+    0xda9b001b, /* 0048(:678):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 004C(:678):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 0050(:680):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 0054(:680):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x1000cb28, /* 0058(:681):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 005C(:682):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 0060(:682):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x1000cb30, /* 0064(:683):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0068(:684):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 006C(:684):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x0000cb38, /* 0070(:685):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 0074(:0):    NOP */
-    0xc404601b, /* 0078(:678):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
-    0xc004245c, /* 007C(:678):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var17; idx2 += inc3, idx3 += inc4 */
-    0x809a601b, /* 0080(:679):  LCD: idx4 = var1; ; idx4 += inc3 */
-    0xda9b001b, /* 0084(:682):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 0088(:682):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x0000d3a0, /* 008C(:683):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
-    0xc207a182, /* 0090(:685):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
-    0x869be009, /* 0094(:685):    LCD: idx7 = var13; ; idx7 += inc1 */
-    0x0bfed7b8, /* 0098(:688):      DRD1A: *idx7; FN=0 TFD init=31 WS=3 RS=3 */
-    0xda9b001b, /* 009C(:690):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 00A0(:690):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x70000006, /* 00A4(:692):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00A8(:692):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb28, /* 00AC(:693):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00B0(:694):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00B4(:694):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb30, /* 00B8(:695):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00BC(:696):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00C0(:696):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x0000cb38, /* 00C4(:697):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0xc202601b, /* 0078(:689):  LCDEXT: idx0 = var4, idx1 = var4; ; idx0 += inc3, idx1 += inc3 */
+    0xc002229c, /* 007C(:689):  LCDEXT: idx2 = var0, idx3 = var4; idx3 == var10; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0080(:690):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xda9b001b, /* 0084(:693):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0088(:693):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 008C(:694):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc10420c2, /* 0090(:696):    LCDEXT: idx5 = var2, idx6 = var8; idx6 < var3; idx5 += inc0, idx6 += inc2 */
+    0x839be009, /* 0094(:696):    LCD: idx7 = var7; ; idx7 += inc1 */
+    0x0bfed7b8, /* 0098(:699):      DRD1A: *idx7; FN=0 TFD init=31 WS=3 RS=3 */
+    0xda9b001b, /* 009C(:701):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00A0(:701):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 00A4(:703):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 00A8(:703):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x1000cb28, /* 00AC(:704):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00B0(:705):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 00B4(:705):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x1000cb30, /* 00B8(:706):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00BC(:707):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf889, /* 00C0(:707):      DRD2B1: idx2 = EU3(); EU3(idx2,var9)  */
+    0x0000cb38, /* 00C4(:708):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 00C8(:0):    NOP */
-    0xc51803ed, /* 00CC(:701):  LCDEXT: idx0 = var10; idx0 > var15; idx0 += inc5 */
-    0x8018801b, /* 00D0(:701):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
-    0x040001f8, /* 00D4(:702):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0xc318022d, /* 00CC(:712):  LCDEXT: idx0 = var6; idx0 > var8; idx0 += inc5 */
+    0x8018801b, /* 00D0(:712):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
+    0x040001f8, /* 00D4(:713):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
 };
 #ifdef MCD_INCLUDE_EU
 u32 MCD_ChainEu_TDT[]=
 {
-    0x80004000, /* 0000(:928):  LCDEXT: idx0 = 0x00000000; ; */
-    0x8118801b, /* 0004(:928):  LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0xb8ca0018, /* 0008(:929):    LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
-    0x10004b10, /* 000C(:930):      DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x7000000c, /* 0010(:931):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x024cf89f, /* 0014(:931):      DRD2B1: var9 = EU3(); EU3(idx2)  */
-    0x60000009, /* 0018(:932):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
-    0x080cf89f, /* 001C(:932):      DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x80004000, /* 0000(:947):  LCDEXT: idx0 = 0x00000000; ; */
+    0x8198801b, /* 0004(:947):  LCD: idx1 = var3; idx1 once var0; idx1 += inc3 */
+    0xb8c68018, /* 0008(:948):    LCD: idx2 = *(idx1 + var13); idx2 once var0; idx2 += inc3 */
+    0x10002f10, /* 000C(:949):      DRD1A: var11 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000d, /* 0010(:950):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x01ccf89f, /* 0014(:950):      DRD2B1: var7 = EU3(); EU3(idx2)  */
+    0x6000000a, /* 0018(:951):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x080cf89f, /* 001C(:951):      DRD2B1: idx0 = EU3(); EU3(idx2)  */
     0x000001f8, /* 0020(:0):    NOP */
-    0x98180524, /* 0024(:936):  LCD: idx0 = idx0; idx0 != var20; idx0 += inc4 */
-    0x8118801b, /* 0028(:938):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0xf8ca001a, /* 002C(:939):      LCDEXT: idx2 = *(idx1 + var20 + 8); idx2 once var0; idx2 += inc3 */
-    0xb8ca601b, /* 0030(:940):      LCD: idx3 = *(idx1 + var20 + 12); ; idx3 += inc3 */
-    0x10004310, /* 0034(:942):        DRD1A: var16 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x00001718, /* 0038(:943):        DRD1A: var5 = idx3; FN=0 init=0 WS=0 RS=0 */
-    0xb8ca001d, /* 003C(:945):      LCD: idx2 = *(idx1 + var20 + 20); idx2 once var0; idx2 += inc3 */
-    0x10001f10, /* 0040(:946):        DRD1A: var7 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000007, /* 0044(:947):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=7 EXT init=0 WS=0 RS=0 */
-    0x020cf893, /* 0048(:947):        DRD2B1: var8 = EU3(); EU3(idx2,var19)  */
-    0x98ca001c, /* 004C(:949):      LCD: idx2 = idx1 + var20 + 4; idx2 once var0; idx2 += inc3 */
-    0x00000710, /* 0050(:950):        DRD1A: var1 = idx2; FN=0 init=0 WS=0 RS=0 */
-    0x98ca8018, /* 0054(:951):      LCD: idx2 = idx1 + var21; idx2 once var0; idx2 += inc3 */
-    0x10002b10, /* 0058(:952):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x0000c828, /* 005C(:953):        DRD1A: *idx2 = var5; FN=0 init=0 WS=0 RS=0 */
+    0x981803a4, /* 0024(:955):  LCD: idx0 = idx0; idx0 == var14; idx0 += inc4 */
+    0x8198801b, /* 0028(:957):    LCD: idx1 = var3; idx1 once var0; idx1 += inc3 */
+    0xf8c6801a, /* 002C(:958):      LCDEXT: idx2 = *(idx1 + var13 + 8); idx2 once var0; idx2 += inc3 */
+    0xb8c6e01b, /* 0030(:959):      LCD: idx3 = *(idx1 + var13 + 12); ; idx3 += inc3 */
+    0x10002b10, /* 0034(:961):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x00001318, /* 0038(:962):        DRD1A: var4 = idx3; FN=0 init=0 WS=0 RS=0 */
+    0xb8c6801d, /* 003C(:964):      LCD: idx2 = *(idx1 + var13 + 20); idx2 once var0; idx2 += inc3 */
+    0x10001710, /* 0040(:965):        DRD1A: var5 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000007, /* 0044(:966):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=7 EXT init=0 WS=0 RS=0 */
+    0x018cf88c, /* 0048(:966):        DRD2B1: var6 = EU3(); EU3(idx2,var12)  */
+    0x98c6801c, /* 004C(:968):      LCD: idx2 = idx1 + var13 + 4; idx2 once var0; idx2 += inc3 */
+    0x00000b10, /* 0050(:969):        DRD1A: var2 = idx2; FN=0 init=0 WS=0 RS=0 */
+    0x98c78018, /* 0054(:970):      LCD: idx2 = idx1 + var15; idx2 once var0; idx2 += inc3 */
+    0x10002310, /* 0058(:971):        DRD1A: var8 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c820, /* 005C(:972):        DRD1A: *idx2 = var4; FN=0 init=0 WS=0 RS=0 */
     0x000001f8, /* 0060(:0):      NOP */
-    0xc14ae018, /* 0064(:957):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
-    0xc004a51d, /* 0068(:957):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var20; idx2 += inc3, idx3 += inc5 */
-    0x811a601b, /* 006C(:958):    LCD: idx4 = var2; ; idx4 += inc3 */
-    0xc28a21c2, /* 0070(:961):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
-    0x881be009, /* 0074(:961):      LCD: idx7 = var16; ; idx7 += inc1 */
-    0x63fe0000, /* 0078(:964):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
-    0x0d4cfddf, /* 007C(:964):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
-    0xda9b001b, /* 0080(:966):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 0084(:966):      LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x1000cb20, /* 0088(:967):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 008C(:968):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 0090(:968):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb28, /* 0094(:969):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 0098(:970):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 009C(:970):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb30, /* 00A0(:971):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00A4(:972):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00A8(:972):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb38, /* 00AC(:973):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
-    0x0000c728, /* 00B0(:974):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
-    0x000001f8, /* 00B4(:0):      NOP */
-    0xc14ae018, /* 00B8(:978):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
-    0xc004a5dd, /* 00BC(:978):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var23; idx2 += inc3, idx3 += inc5 */
-    0x811a601b, /* 00C0(:979):    LCD: idx4 = var2; ; idx4 += inc3 */
-    0xda9b001b, /* 00C4(:982):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 00C8(:982):      LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x0000d3a0, /* 00CC(:983):        DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
-    0xc28a21c2, /* 00D0(:985):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
-    0x881be009, /* 00D4(:985):      LCD: idx7 = var16; ; idx7 += inc1 */
-    0x6bfe0000, /* 00D8(:988):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
-    0x0d4cfddf, /* 00DC(:988):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
-    0xda9b001b, /* 00E0(:990):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 00E4(:990):      LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x1000cb20, /* 00E8(:991):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00EC(:992):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00F0(:992):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb28, /* 00F4(:993):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00F8(:994):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 00FC(:994):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb30, /* 0100(:995):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 0104(:996):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf896, /* 0108(:996):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
-    0x1000cb38, /* 010C(:997):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
-    0x0000c728, /* 0110(:998):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
-    0x000001f8, /* 0114(:0):      NOP */
-    0x8118801b, /* 0118(:1002):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
-    0x8a19001b, /* 011C(:1004):      LCD: idx2 = var20; idx2 once var0; idx2 += inc3 */
-    0x6000000e, /* 0120(:1005):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
-    0x088cf49f, /* 0124(:1005):        DRD2B1: idx2 = EU3(); EU3(var18)  */
-    0xd9190536, /* 0128(:1006):      LCDEXT: idx2 = idx2; idx2 == var20; idx2 += inc6 */
-    0x98ca0018, /* 012C(:1006):      LCD: idx3 = idx1 + var20; idx3 once var0; idx3 += inc3 */
-    0x6000000a, /* 0130(:1008):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
-    0x0cccfcdf, /* 0134(:1008):        DRD2B1: *idx3 = EU3(); EU3(*idx3)  */
-    0x000001f8, /* 0138(:0):      NOP */
-    0xa14a001e, /* 013C(:1011):    LCD: idx1 = *(var2 + var20 + 24); idx1 once var0; idx1 += inc3 */
-    0x10000b08, /* 0140(:1012):      DRD1A: var2 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x10002c90, /* 0144(:1013):      DRD1A: var11 = var18; FN=0 MORE init=0 WS=0 RS=0 */
-    0xb8ca0018, /* 0148(:1014):      LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
-    0x10004b10, /* 014C(:1015):        DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000009, /* 0150(:1016):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT MORE init=0 WS=0 RS=0 */
-    0x080cf89f, /* 0154(:1016):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
-    0x6000000c, /* 0158(:1017):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT init=0 WS=0 RS=0 */
-    0x024cf89f, /* 015C(:1017):        DRD2B1: var9 = EU3(); EU3(idx2)  */
-    0x000001f8, /* 0160(:0):      NOP */
-    0x8a18801b, /* 0164(:1023):    LCD: idx1 = var20; idx1 once var0; idx1 += inc3 */
-    0x7000000d, /* 0168(:1024):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
-    0x084cf2df, /* 016C(:1024):      DRD2B1: idx1 = EU3(); EU3(var11)  */
-    0xd899053f, /* 0170(:1025):      LCDEXT: idx2 = idx1; idx2 > var20; idx2 += inc7 */
-    0x8019801b, /* 0174(:1025):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
-    0x040001f8, /* 0178(:1026):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
-    0x000001f8, /* 017C(:0):      NOP */
-    0x000001f8, /* 0180(:0):    NOP */
+    0x8698801b, /* 0064(:976):    LCD: idx1 = var13; idx1 once var0; idx1 += inc3 */
+    0x7000000f, /* 0068(:977):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=15 EXT MORE init=0 WS=0 RS=0 */
+    0x084cf2df, /* 006C(:977):      DRD2B1: idx1 = EU3(); EU3(var11)  */
+    0xd899042d, /* 0070(:978):      LCDEXT: idx2 = idx1; idx2 >= var16; idx2 += inc5 */
+    0x8019801b, /* 0074(:978):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x60000003, /* 0078(:979):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 */
+    0x2cd7c7df, /* 007C(:979):        DRD2B2: EU3(var13)  */
+    0xd8990364, /* 0080(:980):      LCDEXT: idx2 = idx1; idx2 == var13; idx2 += inc4 */
+    0x8019801b, /* 0084(:980):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x60000003, /* 0088(:981):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 */
+    0x2c17c7df, /* 008C(:981):        DRD2B2: EU3(var1)  */
+    0x000001f8, /* 0090(:0):      NOP */
+    0xc1c7e018, /* 0094(:984):    LCDEXT: idx1 = var3 + var15; ; idx1 += inc3 */
+    0xc003a35e, /* 0098(:984):    LCDEXT: idx2 = var0, idx3 = var7; idx3 == var13; idx2 += inc3, idx3 += inc6 */
+    0x819a601b, /* 009C(:985):    LCD: idx4 = var3; ; idx4 += inc3 */
+    0xc206a142, /* 00A0(:988):      LCDEXT: idx5 = var4, idx6 = var13; idx6 < var5; idx5 += inc0, idx6 += inc2 */
+    0x851be009, /* 00A4(:988):      LCD: idx7 = var10; ; idx7 += inc1 */
+    0x63fe0000, /* 00A8(:991):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 00AC(:991):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 00B0(:993):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00B4(:993):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000002, /* 00B8(:994):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf81f, /* 00BC(:994):        DRD2B1: var1 = EU3(); EU3(idx0)  */
+    0x1000cb20, /* 00C0(:995):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00C4(:996):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 00C8(:996):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb28, /* 00CC(:997):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00D0(:998):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 00D4(:998):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb30, /* 00D8(:999):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00DC(:1000):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 00E0(:1000):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb38, /* 00E4(:1001):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 00E8(:1002):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00EC(:0):      NOP */
+    0xc1c7e018, /* 00F0(:1006):    LCDEXT: idx1 = var3 + var15; ; idx1 += inc3 */
+    0xc003a49e, /* 00F4(:1006):    LCDEXT: idx2 = var0, idx3 = var7; idx3 == var18; idx2 += inc3, idx3 += inc6 */
+    0x819a601b, /* 00F8(:1007):    LCD: idx4 = var3; ; idx4 += inc3 */
+    0xda9b001b, /* 00FC(:1010):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0100(:1010):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 0104(:1011):        DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc206a142, /* 0108(:1013):      LCDEXT: idx5 = var4, idx6 = var13; idx6 < var5; idx5 += inc0, idx6 += inc2 */
+    0x851be009, /* 010C(:1013):      LCD: idx7 = var10; ; idx7 += inc1 */
+    0x6bfe0000, /* 0110(:1016):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 0114(:1016):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 0118(:1018):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 011C(:1018):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000002, /* 0120(:1019):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf81f, /* 0124(:1019):        DRD2B1: var1 = EU3(); EU3(idx0)  */
+    0x1000cb20, /* 0128(:1020):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 012C(:1021):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 0130(:1021):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb28, /* 0134(:1022):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0138(:1023):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 013C(:1023):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb30, /* 0140(:1024):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0144(:1025):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf891, /* 0148(:1025):        DRD2B1: idx2 = EU3(); EU3(idx2,var17)  */
+    0x1000cb38, /* 014C(:1026):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 0150(:1027):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0154(:0):      NOP */
+    0x8198801b, /* 0158(:1031):    LCD: idx1 = var3; idx1 once var0; idx1 += inc3 */
+    0xd8c68018, /* 015C(:1033):      LCDEXT: idx2 = idx1 + var13; idx2 once var0; idx2 += inc3 */
+    0x98c6e01c, /* 0160(:1033):      LCD: idx3 = idx1 + var13 + 4; ; idx3 += inc3 */
+    0x6000000b, /* 0164(:1034):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT init=0 WS=0 RS=0 */
+    0x0c8cfc9f, /* 0168(:1034):        DRD2B1: *idx2 = EU3(); EU3(*idx2)  */
+    0x0000cc08, /* 016C(:1035):      DRD1A: *idx3 = var1; FN=0 init=0 WS=0 RS=0 */
+    0xa1c6801e, /* 0170(:1038):    LCD: idx1 = *(var3 + var13 + 24); idx1 once var0; idx1 += inc3 */
+    0x10000f08, /* 0174(:1039):      DRD1A: var3 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x10002458, /* 0178(:1040):      DRD1A: var9 = var11; FN=0 MORE init=0 WS=0 RS=0 */
+    0xb8c68018, /* 017C(:1041):      LCD: idx2 = *(idx1 + var13); idx2 once var0; idx2 += inc3 */
+    0x10002f10, /* 0180(:1042):        DRD1A: var11 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000a, /* 0184(:1043):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf89f, /* 0188(:1043):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x6000000d, /* 018C(:1044):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x01ccf89f, /* 0190(:1044):        DRD2B1: var7 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 0194(:0):      NOP */
+    0x8698801b, /* 0198(:1050):    LCD: idx1 = var13; idx1 once var0; idx1 += inc3 */
+    0x7000000e, /* 019C(:1051):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT MORE init=0 WS=0 RS=0 */
+    0x084cf25f, /* 01A0(:1051):      DRD2B1: idx1 = EU3(); EU3(var9)  */
+    0xd899037f, /* 01A4(:1052):      LCDEXT: idx2 = idx1; idx2 > var13; idx2 += inc7 */
+    0x8019801b, /* 01A8(:1052):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x040001f8, /* 01AC(:1053):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 01B0(:0):      NOP */
+    0x000001f8, /* 01B4(:0):    NOP */
 };
 u32 MCD_SingleEu_TDT[]=
 {
-    0x8318001b, /* 0000(:1204):  LCD: idx0 = var6; idx0 once var0; idx0 += inc3 */
-    0x7000000c, /* 0004(:1205):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x080cf81f, /* 0008(:1205):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
-    0x8318801b, /* 000C(:1206):    LCD: idx1 = var6; idx1 once var0; idx1 += inc3 */
-    0x6000000d, /* 0010(:1207):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
-    0x084cf85f, /* 0014(:1207):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
+    0x8218001b, /* 0000(:1248):  LCD: idx0 = var4; idx0 once var0; idx0 += inc3 */
+    0x7000000d, /* 0004(:1249):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf81f, /* 0008(:1249):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
+    0x8218801b, /* 000C(:1250):    LCD: idx1 = var4; idx1 once var0; idx1 += inc3 */
+    0x6000000e, /* 0010(:1251):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x084cf85f, /* 0014(:1251):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
     0x000001f8, /* 0018(:0):    NOP */
-    0x8498001b, /* 001C(:1211):  LCD: idx0 = var9; idx0 once var0; idx0 += inc3 */
-    0x7000000c, /* 0020(:1212):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x020cf81f, /* 0024(:1212):    DRD2B1: var8 = EU3(); EU3(idx0)  */
-    0x6000000d, /* 0028(:1213):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
-    0x028cf81f, /* 002C(:1213):    DRD2B1: var10 = EU3(); EU3(idx0)  */
-    0xc404601b, /* 0030(:1216):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
-    0xc00423dc, /* 0034(:1216):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var15; idx2 += inc3, idx3 += inc4 */
-    0x809a601b, /* 0038(:1217):  LCD: idx4 = var1; ; idx4 += inc3 */
-    0xc207a182, /* 003C(:1220):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
-    0x869be009, /* 0040(:1220):    LCD: idx7 = var13; ; idx7 += inc1 */
-    0x63fe0000, /* 0044(:1223):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
-    0x0d4cfddf, /* 0048(:1223):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
-    0xda9b001b, /* 004C(:1225):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 0050(:1225):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x70000006, /* 0054(:1227):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 0058(:1227):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb28, /* 005C(:1228):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 0060(:1229):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 0064(:1229):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb30, /* 0068(:1230):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 006C(:1231):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 0070(:1231):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x0000cb38, /* 0074(:1232):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
-    0x000001f8, /* 0078(:0):    NOP */
-    0xc404601b, /* 007C(:1236):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
-    0xc004245c, /* 0080(:1236):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var17; idx2 += inc3, idx3 += inc4 */
-    0x809a601b, /* 0084(:1237):  LCD: idx4 = var1; ; idx4 += inc3 */
-    0xda9b001b, /* 0088(:1240):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 008C(:1240):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x0000d3a0, /* 0090(:1241):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
-    0xc207a182, /* 0094(:1243):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
-    0x869be009, /* 0098(:1243):    LCD: idx7 = var13; ; idx7 += inc1 */
-    0x6bfe0000, /* 009C(:1246):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
-    0x0d4cfddf, /* 00A0(:1246):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
-    0xda9b001b, /* 00A4(:1248):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
-    0x9b9be01b, /* 00A8(:1248):    LCD: idx7 = idx7; ; idx7 += inc3 */
-    0x70000006, /* 00AC(:1250):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00B0(:1250):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb28, /* 00B4(:1251):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00B8(:1252):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00BC(:1252):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x1000cb30, /* 00C0(:1253):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
-    0x70000006, /* 00C4(:1254):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
-    0x088cf890, /* 00C8(:1254):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
-    0x0000cb38, /* 00CC(:1255):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
-    0x000001f8, /* 00D0(:0):    NOP */
-    0xc51803ed, /* 00D4(:1259):  LCDEXT: idx0 = var10; idx0 > var15; idx0 += inc5 */
-    0x8018801b, /* 00D8(:1259):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
-    0x040001f8, /* 00DC(:1260):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x8318001b, /* 001C(:1255):  LCD: idx0 = var6; idx0 once var0; idx0 += inc3 */
+    0x7000000d, /* 0020(:1256):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x014cf81f, /* 0024(:1256):    DRD2B1: var5 = EU3(); EU3(idx0)  */
+    0x6000000e, /* 0028(:1257):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x01ccf81f, /* 002C(:1257):    DRD2B1: var7 = EU3(); EU3(idx0)  */
+    0x8498001b, /* 0030(:1260):  LCD: idx0 = var9; idx0 once var0; idx0 += inc3 */
+    0x7000000f, /* 0034(:1261):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=15 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf19f, /* 0038(:1261):    DRD2B1: idx0 = EU3(); EU3(var6)  */
+    0xd81882a4, /* 003C(:1262):    LCDEXT: idx1 = idx0; idx1 >= var10; idx1 += inc4 */
+    0x8019001b, /* 0040(:1262):    LCD: idx2 = var0; idx2 once var0; idx2 += inc3 */
+    0x60000003, /* 0044(:1263):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 */
+    0x2c97c7df, /* 0048(:1263):      DRD2B2: EU3(var9)  */
+    0xd818826d, /* 004C(:1264):    LCDEXT: idx1 = idx0; idx1 == var9; idx1 += inc5 */
+    0x8019001b, /* 0050(:1264):    LCD: idx2 = var0; idx2 once var0; idx2 += inc3 */
+    0x60000003, /* 0054(:1265):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 */
+    0x2c17c7df, /* 0058(:1265):      DRD2B2: EU3(var1)  */
+    0x000001f8, /* 005C(:0):    NOP */
+    0xc282e01b, /* 0060(:1268):  LCDEXT: idx0 = var5, idx1 = var5; ; idx0 += inc3, idx1 += inc3 */
+    0xc002a25e, /* 0064(:1268):  LCDEXT: idx2 = var0, idx3 = var5; idx3 == var9; idx2 += inc3, idx3 += inc6 */
+    0x811a601b, /* 0068(:1269):  LCD: idx4 = var2; ; idx4 += inc3 */
+    0xc184a102, /* 006C(:1272):    LCDEXT: idx5 = var3, idx6 = var9; idx6 < var4; idx5 += inc0, idx6 += inc2 */
+    0x841be009, /* 0070(:1272):    LCD: idx7 = var8; ; idx7 += inc1 */
+    0x63fe0000, /* 0074(:1275):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 0078(:1275):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 007C(:1277):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0080(:1277):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000002, /* 0084(:1279):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf99f, /* 0088(:1279):      DRD2B1: var1 = EU3(); EU3(idx6)  */
+    0x70000006, /* 008C(:1280):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 0090(:1280):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x1000cb28, /* 0094(:1281):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0098(:1282):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 009C(:1282):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x1000cb30, /* 00A0(:1283):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00A4(:1284):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 00A8(:1284):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x0000cb38, /* 00AC(:1285):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00B0(:0):    NOP */
+    0xc282e01b, /* 00B4(:1289):  LCDEXT: idx0 = var5, idx1 = var5; ; idx0 += inc3, idx1 += inc3 */
+    0xc002a31e, /* 00B8(:1289):  LCDEXT: idx2 = var0, idx3 = var5; idx3 == var12; idx2 += inc3, idx3 += inc6 */
+    0x811a601b, /* 00BC(:1290):  LCD: idx4 = var2; ; idx4 += inc3 */
+    0xda9b001b, /* 00C0(:1293):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00C4(:1293):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 00C8(:1294):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc184a102, /* 00CC(:1296):    LCDEXT: idx5 = var3, idx6 = var9; idx6 < var4; idx5 += inc0, idx6 += inc2 */
+    0x841be009, /* 00D0(:1296):    LCD: idx7 = var8; ; idx7 += inc1 */
+    0x6bfe0000, /* 00D4(:1299):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 00D8(:1299):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 00DC(:1301):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00E0(:1301):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000002, /* 00E4(:1303):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf99f, /* 00E8(:1303):      DRD2B1: var1 = EU3(); EU3(idx6)  */
+    0x70000006, /* 00EC(:1304):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 00F0(:1304):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x1000cb28, /* 00F4(:1305):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00F8(:1306):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 00FC(:1306):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x1000cb30, /* 0100(:1307):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0104(:1308):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf88b, /* 0108(:1308):      DRD2B1: idx2 = EU3(); EU3(idx2,var11)  */
+    0x0000cb38, /* 010C(:1309):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0110(:0):    NOP */
+    0x8144801c, /* 0114(:1312):  LCD: idx0 = var2 + var9 + 4; idx0 once var0; idx0 += inc3 */
+    0x0000c008, /* 0118(:1313):    DRD1A: *idx0 = var1; FN=0 init=0 WS=0 RS=0 */
+    0xc398027f, /* 011C(:1315):  LCDEXT: idx0 = var7; idx0 > var9; idx0 += inc7 */
+    0x8018801b, /* 0120(:1315):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
+    0x040001f8, /* 0124(:1316):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
 };
 #endif
 u32 MCD_ENetRcv_TDT[]=
 {
-    0x80004000, /* 0000(:1334):  LCDEXT: idx0 = 0x00000000; ; */
-    0x82188000, /* 0004(:1334):  LCD: idx1 = var4; idx1 once var0; idx1 += inc0 */
-    0x10000788, /* 0008(:1335):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000009, /* 000C(:1336):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
-    0x080cf05f, /* 0010(:1336):    DRD2B1: idx0 = EU3(); EU3(var1)  */
-    0x98180249, /* 0014(:1339):  LCD: idx0 = idx0; idx0 != var9; idx0 += inc1 */
-    0x82448004, /* 0018(:1341):    LCD: idx1 = var4 + var9 + 4; idx1 once var0; idx1 += inc0 */
-    0x7000000d, /* 001C(:1342):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
-    0x014cf05f, /* 0020(:1342):      DRD2B1: var5 = EU3(); EU3(var1)  */
-    0x7000000b, /* 0024(:1343):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT MORE init=0 WS=0 RS=0 */
-    0x020cf05f, /* 0028(:1343):      DRD2B1: var8 = EU3(); EU3(var1)  */
-    0x70000004, /* 002C(:1344):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
-    0x018cf04a, /* 0030(:1344):      DRD2B1: var6 = EU3(); EU3(var1,var10)  */
-    0x70000004, /* 0034(:1345):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
-    0x004cf04b, /* 0038(:1345):      DRD2B1: var1 = EU3(); EU3(var1,var11)  */
-    0x00000b88, /* 003C(:1348):      DRD1A: var2 = *idx1; FN=0 init=0 WS=0 RS=0 */
-    0xc4838190, /* 0040(:1351):    LCDEXT: idx1 = var9, idx2 = var7; idx1 < var6; idx1 += inc2, idx2 += inc0 */
-    0x8119e012, /* 0044(:1351):    LCD: idx3 = var2; ; idx3 += inc2 */
-    0x03e0cf90, /* 0048(:1354):      DRD1A: *idx3 = *idx2; FN=0 init=31 WS=0 RS=0 */
-    0x81188000, /* 004C(:1357):    LCD: idx1 = var2; idx1 once var0; idx1 += inc0 */
-    0x000ac788, /* 0050(:1358):      DRD1A: *idx1 = *idx1; FN=0 init=0 WS=1 RS=1 */
-    0xc4838000, /* 0054(:1360):    LCDEXT: idx1 = var9, idx2 = var7; idx1 once var0; idx1 += inc0, idx2 += inc0 */
-    0x8219e000, /* 0058(:1360):    LCD: idx3 = var4; ; idx3 += inc0 */
-    0x70000004, /* 005C(:1368):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
-    0x084cfc8c, /* 0060(:1368):      DRD2B1: idx1 = EU3(); EU3(*idx2,var12)  */
-    0x60000005, /* 0064(:1371):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */
-    0x0cccf841, /* 0068(:1371):      DRD2B1: *idx3 = EU3(); EU3(idx1,var1)  */
-    0x82468000, /* 006C(:1377):    LCD: idx1 = var4 + var13; idx1 once var0; idx1 += inc0 */
-    0xc419025b, /* 0070(:1379):      LCDEXT: idx2 = var8; idx2 > var9; idx2 += inc3 */
-    0x80198000, /* 0074(:1379):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
-    0x00008400, /* 0078(:1380):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
-    0x00001308, /* 007C(:1381):      DRD1A: var4 = idx1; FN=0 init=0 WS=0 RS=0 */
-    0x82188000, /* 0080(:1384):    LCD: idx1 = var4; idx1 once var0; idx1 += inc0 */
-    0x10000788, /* 0084(:1385):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000009, /* 0088(:1386):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
-    0x080cf05f, /* 008C(:1386):      DRD2B1: idx0 = EU3(); EU3(var1)  */
-    0xc2988249, /* 0090(:1389):    LCDEXT: idx1 = var5; idx1 != var9; idx1 += inc1 */
-    0x80190000, /* 0094(:1389):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
-    0x040001f8, /* 0098(:1390):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
-    0x000001f8, /* 009C(:0):    NOP */
+    0x80004000, /* 0000(:1389):  LCDEXT: idx0 = 0x00000000; ; */
+    0x81988000, /* 0004(:1389):  LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 0008(:1390):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x6000000a, /* 000C(:1391):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 0010(:1391):    DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0x98180209, /* 0014(:1394):  LCD: idx0 = idx0; idx0 != var8; idx0 += inc1 */
+    0x81c40004, /* 0018(:1396):    LCD: idx1 = var3 + var8 + 4; idx1 once var0; idx1 += inc0 */
+    0x7000000e, /* 001C(:1397):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT MORE init=0 WS=0 RS=0 */
+    0x010cf05f, /* 0020(:1397):      DRD2B1: var4 = EU3(); EU3(var1)  */
+    0x7000000c, /* 0024(:1398):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x01ccf05f, /* 0028(:1398):      DRD2B1: var7 = EU3(); EU3(var1)  */
+    0x70000004, /* 002C(:1399):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x014cf049, /* 0030(:1399):      DRD2B1: var5 = EU3(); EU3(var1,var9)  */
+    0x70000004, /* 0034(:1400):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf04a, /* 0038(:1400):      DRD2B1: var1 = EU3(); EU3(var1,var10)  */
+    0x00000b88, /* 003C(:1403):      DRD1A: var2 = *idx1; FN=0 init=0 WS=0 RS=0 */
+    0xc4030150, /* 0040(:1406):    LCDEXT: idx1 = var8, idx2 = var6; idx1 < var5; idx1 += inc2, idx2 += inc0 */
+    0x8119e012, /* 0044(:1406):    LCD: idx3 = var2; ; idx3 += inc2 */
+    0x03e0cf90, /* 0048(:1409):      DRD1A: *idx3 = *idx2; FN=0 init=31 WS=0 RS=0 */
+    0x81188000, /* 004C(:1412):    LCD: idx1 = var2; idx1 once var0; idx1 += inc0 */
+    0x000ac788, /* 0050(:1413):      DRD1A: *idx1 = *idx1; FN=0 init=0 WS=1 RS=1 */
+    0xc4030000, /* 0054(:1415):    LCDEXT: idx1 = var8, idx2 = var6; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x8199e000, /* 0058(:1415):    LCD: idx3 = var3; ; idx3 += inc0 */
+    0x63e00004, /* 005C(:1418):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT init=31 WS=0 RS=0 */
+    0x084cfc8b, /* 0060(:1418):      DRD2B1: idx1 = EU3(); EU3(*idx2,var11)  */
+    0xd8990000, /* 0064(:1421):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x9999e000, /* 0068(:1421):    LCD: idx3 = idx3; ; idx3 += inc0 */
+    0x60000005, /* 006C(:1422):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */
+    0x0cccf841, /* 0070(:1422):      DRD2B1: *idx3 = EU3(); EU3(idx1,var1)  */
+    0x81c60000, /* 0074(:1427):    LCD: idx1 = var3 + var12; idx1 once var0; idx1 += inc0 */
+    0xc399021b, /* 0078(:1429):      LCDEXT: idx2 = var7; idx2 > var8; idx2 += inc3 */
+    0x80198000, /* 007C(:1429):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
+    0x00008400, /* 0080(:1430):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
+    0x00000f08, /* 0084(:1431):      DRD1A: var3 = idx1; FN=0 init=0 WS=0 RS=0 */
+    0x81988000, /* 0088(:1434):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 008C(:1435):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x6000000a, /* 0090(:1436):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 0094(:1436):      DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0xc2188209, /* 0098(:1439):    LCDEXT: idx1 = var4; idx1 != var8; idx1 += inc1 */
+    0x80190000, /* 009C(:1439):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
+    0x040001f8, /* 00A0(:1440):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 00A4(:0):    NOP */
 };
 u32 MCD_ENetXmit_TDT[]=
 {
-    0x80004000, /* 0000(:1465):  LCDEXT: idx0 = 0x00000000; ; */
-    0x81988000, /* 0004(:1465):  LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
-    0x10000788, /* 0008(:1466):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000009, /* 000C(:1467):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
-    0x080cf05f, /* 0010(:1467):    DRD2B1: idx0 = EU3(); EU3(var1)  */
-    0x98180309, /* 0014(:1470):  LCD: idx0 = idx0; idx0 != var12; idx0 += inc1 */
-    0x80004003, /* 0018(:1472):    LCDEXT: idx1 = 0x00000003; ; */
-    0x81c60004, /* 001C(:1472):    LCD: idx2 = var3 + var12 + 4; idx2 once var0; idx2 += inc0 */
-    0x7000000d, /* 0020(:1473):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
-    0x014cf05f, /* 0024(:1473):      DRD2B1: var5 = EU3(); EU3(var1)  */
-    0x7000000b, /* 0028(:1474):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT MORE init=0 WS=0 RS=0 */
-    0x028cf05f, /* 002C(:1474):      DRD2B1: var10 = EU3(); EU3(var1)  */
-    0x7000000c, /* 0030(:1475):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
-    0x018cf05f, /* 0034(:1475):      DRD2B1: var6 = EU3(); EU3(var1)  */
-    0x70000004, /* 0038(:1476):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
-    0x01ccf04d, /* 003C(:1476):      DRD2B1: var7 = EU3(); EU3(var1,var13)  */
-    0x10000b90, /* 0040(:1477):      DRD1A: var2 = *idx2; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000004, /* 0044(:1478):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT init=0 WS=0 RS=0 */
-    0x020cf0a1, /* 0048(:1478):      DRD2B1: var8 = EU3(); EU3(var2,idx1)  */
-    0xc3188312, /* 004C(:1481):    LCDEXT: idx1 = var6; idx1 > var12; idx1 += inc2 */
-    0x83c70000, /* 0050(:1481):    LCD: idx2 = var7 + var14; idx2 once var0; idx2 += inc0 */
-    0x00001f10, /* 0054(:1482):      DRD1A: var7 = idx2; FN=0 init=0 WS=0 RS=0 */
-    0xc583a3c3, /* 0058(:1484):    LCDEXT: idx1 = var11, idx2 = var7; idx2 >= var15; idx1 += inc0, idx2 += inc3 */
-    0x81042325, /* 005C(:1484):    LCD: idx3 = var2, idx4 = var8; idx4 == var12; idx3 += inc4, idx4 += inc5 */
-    0x03e0c798, /* 0060(:1489):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=0 RS=0 */
-    0xd8990000, /* 0064(:1492):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
-    0x9999e000, /* 0068(:1492):    LCD: idx3 = idx3; ; idx3 += inc0 */
-    0x000acf98, /* 006C(:1493):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
-    0xd8992306, /* 0070(:1495):    LCDEXT: idx1 = idx1, idx2 = idx2; idx2 > var12; idx1 += inc0, idx2 += inc6 */
-    0x9999e03f, /* 0074(:1495):    LCD: idx3 = idx3; ; idx3 += inc7 */
-    0x03eac798, /* 0078(:1498):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=1 RS=1 */
-    0xd8990000, /* 007C(:1501):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
-    0x9999e000, /* 0080(:1501):    LCD: idx3 = idx3; ; idx3 += inc0 */
-    0x000acf98, /* 0084(:1502):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
-    0xd8990000, /* 0088(:1504):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
-    0x99832302, /* 008C(:1504):    LCD: idx3 = idx3, idx4 = var6; idx4 > var12; idx3 += inc0, idx4 += inc2 */
-    0x0beac798, /* 0090(:1507):      DRD1A: *idx1 = *idx3; FN=0 TFD init=31 WS=1 RS=1 */
-    0x81988000, /* 0094(:1509):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
-    0x6000000a, /* 0098(:1510):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
-    0x0c4cfc5f, /* 009C(:1510):      DRD2B1: *idx1 = EU3(); EU3(*idx1)  */
-    0x81c80000, /* 00A0(:1512):    LCD: idx1 = var3 + var16; idx1 once var0; idx1 += inc0 */
-    0xc5190312, /* 00A4(:1514):      LCDEXT: idx2 = var10; idx2 > var12; idx2 += inc2 */
-    0x80198000, /* 00A8(:1514):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
-    0x00008400, /* 00AC(:1515):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
-    0x00000f08, /* 00B0(:1516):      DRD1A: var3 = idx1; FN=0 init=0 WS=0 RS=0 */
-    0x81988000, /* 00B4(:1519):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
-    0x10000788, /* 00B8(:1520):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
-    0x60000009, /* 00BC(:1521):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
-    0x080cf05f, /* 00C0(:1521):      DRD2B1: idx0 = EU3(); EU3(var1)  */
-    0xc2988309, /* 00C4(:1524):    LCDEXT: idx1 = var5; idx1 != var12; idx1 += inc1 */
-    0x80190000, /* 00C8(:1524):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
-    0x040001f8, /* 00CC(:1525):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x80004000, /* 0000(:1515):  LCDEXT: idx0 = 0x00000000; ; */
+    0x81988000, /* 0004(:1515):  LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 0008(:1516):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x6000000a, /* 000C(:1517):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 0010(:1517):    DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0x98180309, /* 0014(:1520):  LCD: idx0 = idx0; idx0 != var12; idx0 += inc1 */
+    0x80004003, /* 0018(:1522):    LCDEXT: idx1 = 0x00000003; ; */
+    0x81c60004, /* 001C(:1522):    LCD: idx2 = var3 + var12 + 4; idx2 once var0; idx2 += inc0 */
+    0x7000000e, /* 0020(:1523):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT MORE init=0 WS=0 RS=0 */
+    0x014cf05f, /* 0024(:1523):      DRD2B1: var5 = EU3(); EU3(var1)  */
+    0x7000000c, /* 0028(:1524):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x028cf05f, /* 002C(:1524):      DRD2B1: var10 = EU3(); EU3(var1)  */
+    0x7000000d, /* 0030(:1525):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x018cf05f, /* 0034(:1525):      DRD2B1: var6 = EU3(); EU3(var1)  */
+    0x70000004, /* 0038(:1526):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x01ccf04d, /* 003C(:1526):      DRD2B1: var7 = EU3(); EU3(var1,var13)  */
+    0x10000b90, /* 0040(:1527):      DRD1A: var2 = *idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000004, /* 0044(:1528):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT init=0 WS=0 RS=0 */
+    0x020cf0a1, /* 0048(:1528):      DRD2B1: var8 = EU3(); EU3(var2,idx1)  */
+    0xc3188312, /* 004C(:1531):    LCDEXT: idx1 = var6; idx1 > var12; idx1 += inc2 */
+    0x83c70000, /* 0050(:1531):    LCD: idx2 = var7 + var14; idx2 once var0; idx2 += inc0 */
+    0x00001f10, /* 0054(:1532):      DRD1A: var7 = idx2; FN=0 init=0 WS=0 RS=0 */
+    0xc583a3c3, /* 0058(:1534):    LCDEXT: idx1 = var11, idx2 = var7; idx2 >= var15; idx1 += inc0, idx2 += inc3 */
+    0x81042325, /* 005C(:1534):    LCD: idx3 = var2, idx4 = var8; idx4 == var12; idx3 += inc4, idx4 += inc5 */
+    0x03e0c798, /* 0060(:1539):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=0 RS=0 */
+    0xd8990000, /* 0064(:1542):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x9999e000, /* 0068(:1542):    LCD: idx3 = idx3; ; idx3 += inc0 */
+    0x000acf98, /* 006C(:1543):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
+    0xd8992306, /* 0070(:1545):    LCDEXT: idx1 = idx1, idx2 = idx2; idx2 > var12; idx1 += inc0, idx2 += inc6 */
+    0x9999e03f, /* 0074(:1545):    LCD: idx3 = idx3; ; idx3 += inc7 */
+    0x03eac798, /* 0078(:1548):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=1 RS=1 */
+    0xd8990000, /* 007C(:1551):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x9999e000, /* 0080(:1551):    LCD: idx3 = idx3; ; idx3 += inc0 */
+    0x000acf98, /* 0084(:1552):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
+    0xd8990000, /* 0088(:1554):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x99832302, /* 008C(:1554):    LCD: idx3 = idx3, idx4 = var6; idx4 > var12; idx3 += inc0, idx4 += inc2 */
+    0x0beac798, /* 0090(:1557):      DRD1A: *idx1 = *idx3; FN=0 TFD init=31 WS=1 RS=1 */
+    0x81988000, /* 0094(:1559):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x6000000b, /* 0098(:1560):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT init=0 WS=0 RS=0 */
+    0x0c4cfc5f, /* 009C(:1560):      DRD2B1: *idx1 = EU3(); EU3(*idx1)  */
+    0x81c80000, /* 00A0(:1562):    LCD: idx1 = var3 + var16; idx1 once var0; idx1 += inc0 */
+    0xc5190312, /* 00A4(:1564):      LCDEXT: idx2 = var10; idx2 > var12; idx2 += inc2 */
+    0x80198000, /* 00A8(:1564):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
+    0x00008400, /* 00AC(:1565):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
+    0x00000f08, /* 00B0(:1566):      DRD1A: var3 = idx1; FN=0 init=0 WS=0 RS=0 */
+    0x81988000, /* 00B4(:1569):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 00B8(:1570):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x6000000a, /* 00BC(:1571):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 00C0(:1571):      DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0xc2988309, /* 00C4(:1574):    LCDEXT: idx1 = var5; idx1 != var12; idx1 += inc1 */
+    0x80190000, /* 00C8(:1574):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
+    0x040001f8, /* 00CC(:1575):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
     0x000001f8, /* 00D0(:0):    NOP */
 };
 
+#ifdef MCD_INCLUDE_EU
+MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#endif
--- a/drivers/dma/MCD_tasksInit.c
+++ b/drivers/dma/MCD_tasksInit.c
@@ -1,51 +1,34 @@
-/*********************************************************************
- *
- * Copyright (C) 2004  Motorola, Inc.
- *	MOTOROLA, INC. All Rights Reserved.  
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This 
- *  software is provided on an "AS IS" basis and without warranty.
- *
- *  To the maximum extent permitted by applicable law, MOTOROLA 
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING 
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE 
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY 
- *  ACCOMPANYING WRITTEN MATERIALS.
- * 
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING 
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS 
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.   
- * 
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
 /*
- * Do not edit!
- */
- /*
- * File:		MCD_tasksInit.c
- * Purpose:		Function for initialize variable tables of different
- *              types of tasks.
+ * drivers/dma/MCD_tasksInit.c
  *
- * Notes:
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
- * Modifications:
- *  	
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- */ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
 
-#include <asm/MCD_dma.h>
+/*
+ * Autogenerated - Do not edit!
+ */
+
+#include "MCD_dma.h"
 
 extern dmaRegs *MCD_dmaBar;
 
+
 /*
  * Task 0
  */
@@ -53,232 +36,203 @@ extern dmaRegs *MCD_dmaBar;
 void  MCD_startDmaChainNoEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel)
 {
 
-	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 19, (u32)xferSize);	/* var[19] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
-	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
-	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000000);	/* var[16] */
-	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000000);	/* var[17] */
-	MCD_SET_VAR(taskTable+channel, 18, (u32)0x00000000);	/* var[18] */
-	MCD_SET_VAR(taskTable+channel, 20, (u32)0x00000000);	/* var[20] */
-	MCD_SET_VAR(taskTable+channel, 21, (u32)0x00000010);	/* var[21] */
-	MCD_SET_VAR(taskTable+channel, 22, (u32)0x00000004);	/* var[22] */
-	MCD_SET_VAR(taskTable+channel, 23, (u32)0x00000080);	/* var[23] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
-	MCD_SET_VAR(taskTable+channel, 28, (u32)0x60000000);	/* inc[4] */
-	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);	/* inc[5] */
-	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000000);	/* inc[6] */
-	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);	/* inc[7] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)currBD); /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));   /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));  /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 11, (u32)xferSize);  /* var[11] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));  /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000); /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);    /* var[12] */
+    MCD_SET_VAR(taskTable+channel, 13, (u32)0x80000000);    /* var[13] */
+    MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000010);    /* var[14] */
+    MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);    /* var[15] */
+    MCD_SET_VAR(taskTable+channel, 16, (u32)0x08000000);    /* var[16] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+    MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000000);    /* inc[4] */
+    MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);    /* inc[5] */
+    MCD_SET_VAR(taskTable+channel, 30, (u32)0x40000000);    /* inc[6] */
 
     /* Set the task's Enable bit in its Task Control Register */
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
-	
-
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
 
 
 /*
  * Task 1
  */
- 
-void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
 {
-	
-	MCD_SET_VAR(taskTable+channel, 13, (u32)srcAddr);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)destAddr);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)dmaSize);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)dmaSizeMXferSize);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)flags);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)currBD);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
-	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
-	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000004);	/* var[16] */
-	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000080);	/* var[17] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
-	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);	/* inc[4] */
-	MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);	/* inc[5] */
 
+    MCD_SET_VAR(taskTable+channel, 7, (u32)srcAddr);    /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));   /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)destAddr);   /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));  /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 3, (u32)dmaSize);    /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));  /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)flags);  /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)currBD); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000004); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x08000000);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+    MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);    /* inc[4] */
+    MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);    /* inc[5] */
 
-    /* enable the task */
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
 
 
 /*
  * Task 2
  */
- 
+
 void  MCD_startDmaChainEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel)
 {
-	
-	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 19, (u32)xferSize);	/* var[19] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
-	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
-	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000000);	/* var[16] */
-	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000000);	/* var[17] */
-	MCD_SET_VAR(taskTable+channel, 18, (u32)0x00000000);	/* var[18] */
-	MCD_SET_VAR(taskTable+channel, 20, (u32)0x00000000);	/* var[20] */
-	MCD_SET_VAR(taskTable+channel, 21, (u32)0x00000010);	/* var[21] */
-	MCD_SET_VAR(taskTable+channel, 22, (u32)0x00000004);	/* var[22] */
-	MCD_SET_VAR(taskTable+channel, 23, (u32)0x00000080);	/* var[23] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
-	MCD_SET_VAR(taskTable+channel, 28, (u32)0x60000000);	/* inc[4] */
-	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);	/* inc[5] */
-	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000000);	/* inc[6] */
-	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);	/* inc[7] */
 
-    /*enable the task*/
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+    MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));   /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));  /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 12, (u32)xferSize);  /* var[12] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));  /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);    /* var[11] */
+    MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);    /* var[13] */
+    MCD_SET_VAR(taskTable+channel, 14, (u32)0x80000000);    /* var[14] */
+    MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000010);    /* var[15] */
+    MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000001);    /* var[16] */
+    MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000004);    /* var[17] */
+    MCD_SET_VAR(taskTable+channel, 18, (u32)0x08000000);    /* var[18] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+    MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000000);    /* inc[4] */
+    MCD_SET_VAR(taskTable+channel, 29, (u32)0xc0000000);    /* inc[5] */
+    MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000001);    /* inc[6] */
+    MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);    /* inc[7] */
+
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
 
 
 /*
  * Task 3
  */
- 
-void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
 {
-	
-	MCD_SET_VAR(taskTable+channel, 13, (u32)srcAddr);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)destAddr);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)dmaSize);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)dmaSizeMXferSize);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)flags);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)currBD);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
-	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
-	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000004);	/* var[16] */
-	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000080);	/* var[17] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
-	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);	/* inc[4] */
-	MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);	/* inc[5] */
 
-    /*enable the task*/
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+    MCD_SET_VAR(taskTable+channel, 8, (u32)srcAddr);    /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));   /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 3, (u32)destAddr);   /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));  /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)dmaSize);    /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));  /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)flags);  /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)currBD); /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);  /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000001);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000004);    /* var[11] */
+    MCD_SET_VAR(taskTable+channel, 12, (u32)0x08000000);    /* var[12] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);    /* inc[3] */
+    MCD_SET_VAR(taskTable+channel, 28, (u32)0xc0000000);    /* inc[4] */
+    MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);    /* inc[5] */
+    MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000001);    /* inc[6] */
+    MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);    /* inc[7] */
 
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
 
 
 /*
  * Task 4
  */
- 
+
 void  MCD_startDmaENetRcv(char *bDBase, char *currBD, char *rcvFifoPtr, volatile TaskTableEntry *taskTable, int channel)
 {
-	
-	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)currBD);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)rcvFifoPtr);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x0000ffff);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)0x30000000);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x0fffffff);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000008);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)0x20000004);	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0x40000000);	/* inc[3] */
-    /*enable the task*/
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
 
+    MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase); /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)rcvFifoPtr); /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x0000ffff); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x30000000);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 11, (u32)0x0fffffff);    /* var[11] */
+    MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000008);    /* var[12] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);    /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);    /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)0x20000004);    /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0x40000000);    /* inc[3] */
+
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
 
 
 /*
  * Task 5
  */
- 
+
 void  MCD_startDmaENetXmit(char *bDBase, char *currBD, char *xmitFifoPtr, volatile TaskTableEntry *taskTable, int channel)
 {
-	
-	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase);	/* var[0] */
-	MCD_SET_VAR(taskTable+channel, 3, (u32)currBD);	/* var[3] */
-	MCD_SET_VAR(taskTable+channel, 11, (u32)xmitFifoPtr);	/* var[11] */
-	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
-	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
-	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
-	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
-	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
-	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
-	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
-	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
-	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
-	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
-	MCD_SET_VAR(taskTable+channel, 13, (u32)0x0000ffff);	/* var[13] */
-	MCD_SET_VAR(taskTable+channel, 14, (u32)0xffffffff);	/* var[14] */
-	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);	/* var[15] */
-	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000008);	/* var[16] */
-	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);	/* inc[0] */
-	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);	/* inc[1] */
-	MCD_SET_VAR(taskTable+channel, 26, (u32)0x40000000);	/* inc[2] */
-	MCD_SET_VAR(taskTable+channel, 27, (u32)0xc000fffc);	/* inc[3] */
-	MCD_SET_VAR(taskTable+channel, 28, (u32)0xe0000004);	/* inc[4] */
-	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);	/* inc[5] */
-	MCD_SET_VAR(taskTable+channel, 30, (u32)0x4000ffff);	/* inc[6] */
-	MCD_SET_VAR(taskTable+channel, 31, (u32)0xe0000001);	/* inc[7] */
 
-    /*enable the task*/
-    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+    MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase); /* var[0] */
+    MCD_SET_VAR(taskTable+channel, 3, (u32)currBD); /* var[3] */
+    MCD_SET_VAR(taskTable+channel, 11, (u32)xmitFifoPtr);   /* var[11] */
+    MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000); /* var[1] */
+    MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000); /* var[2] */
+    MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000); /* var[4] */
+    MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000); /* var[5] */
+    MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000); /* var[6] */
+    MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000); /* var[7] */
+    MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000); /* var[8] */
+    MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000); /* var[9] */
+    MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);    /* var[10] */
+    MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);    /* var[12] */
+    MCD_SET_VAR(taskTable+channel, 13, (u32)0x0000ffff);    /* var[13] */
+    MCD_SET_VAR(taskTable+channel, 14, (u32)0xffffffff);    /* var[14] */
+    MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);    /* var[15] */
+    MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000008);    /* var[16] */
+    MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);    /* inc[0] */
+    MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);    /* inc[1] */
+    MCD_SET_VAR(taskTable+channel, 26, (u32)0x40000000);    /* inc[2] */
+    MCD_SET_VAR(taskTable+channel, 27, (u32)0xc000fffc);    /* inc[3] */
+    MCD_SET_VAR(taskTable+channel, 28, (u32)0xe0000004);    /* inc[4] */
+    MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);    /* inc[5] */
+    MCD_SET_VAR(taskTable+channel, 30, (u32)0x4000ffff);    /* inc[6] */
+    MCD_SET_VAR(taskTable+channel, 31, (u32)0xe0000001);    /* inc[7] */
 
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000;
 }
--- a/drivers/dma/MCD_tasksInit.h
+++ b/drivers/dma/MCD_tasksInit.h
@@ -1,40 +1,31 @@
-/*********************************************************************
+/*
+ * drivers/dma/MCD_tasksInit.h
  *
- * Copyright (C) 2004  Motorola, Inc.
- *  MOTOROLA, INC. All Rights Reserved.
- *  You are hereby granted a copyright license to use
- *  the SOFTWARE so long as this entire notice is
- *  retained without alteration in any modified and/or redistributed
- *  versions, and that such modified versions are clearly identified
- *  as such. No licenses are granted by implication, estoppel or
- *  otherwise under any patents or trademarks of Motorola, Inc. This
- *  software is provided on an "AS IS" basis and without warranty.
+ * Copyright (C) 2004-2008 Freescale Semiconductor, Inc.
+ *     Kurt Mahan <kmahan@freescale.com>
  *
- *  To the maximum extent permitted by applicable law, MOTOROLA
- *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
- *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
- *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
- *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
- *  ACCOMPANYING WRITTEN MATERIALS.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
  *
- *  To the maximum extent permitted by applicable law, IN NO EVENT
- *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
- *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
- *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
- *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- *  Motorola assumes no responsibility for the maintenance and support
- *  of this software
- ********************************************************************/
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
 #ifndef MCD_TSK_INIT_H
 #define MCD_TSK_INIT_H 1
 
 /*
- * Do not edit!
+ * Autogenerated - Do not edit!
  */
 
-
-
 /*
  * Task 0
  */
@@ -44,7 +35,7 @@ void  MCD_startDmaChainNoEu(int *currBD,
 /*
  * Task 1
  */
-void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
 
 
 /*
@@ -56,7 +47,7 @@ void  MCD_startDmaChainEu(int *currBD, s
 /*
  * Task 3
  */
-void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
 
 
 /*
