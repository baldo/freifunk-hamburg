From 5bac5f471fb1124c51a5811757c54174f6224e7e Mon Sep 17 00:00:00 2001
From: Kurt Mahan <kmahan@freescale.com>
Date: Wed, 12 Mar 2008 17:13:29 -0600
Subject: [PATCH] Clean up FEC DMA driver.

LTIBName: m547x-8x-fec-cleanup
Signed-off-by: Kurt Mahan <kmahan@freescale.com>
---
 drivers/net/fec/fec.c |  611 +++++++++++++++++++++---------------------------
 1 files changed, 267 insertions(+), 344 deletions(-)

--- a/drivers/net/fec/fec.c
+++ b/drivers/net/fec/fec.c
@@ -4,7 +4,6 @@
  *
  * Code crunched to get it to work on 2.6.24 -- FEC cleanup coming
  * soon -- Kurt Mahan
- *
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -44,42 +43,40 @@
 #undef	FEC_2
 #endif
 
-#define VERSION "0.13"
+#define VERSION "0.20"
 MODULE_DESCRIPTION( "DMA Fast Ethernet Controller driver ver " VERSION);
 
-// Private structure
+/* fec private */
 struct fec_priv {
 	struct net_device *netdev;		/* owning net device */
-	void* fecpriv_txbuf[FEC_TX_BUF_NUMBER];	//Array of transmission buffers
-	MCD_bufDescFec *fecpriv_txdesc;	// Array of transmission descriptors
-	volatile unsigned int fecpriv_current_tx;	// Inex of the transmission descriptor that is used by DMA
-	volatile unsigned int fecpriv_next_tx;	// Inex of the transmission descriptor that can be used for new data
-	unsigned int fecpriv_current_rx;	// Index of the reception descriptor that is used by DMA
-	MCD_bufDescFec *fecpriv_rxdesc;		// Array of reception descriptors
-//	unsigned char *fecpriv_rxbuf;		// Address of reception buffers
-	struct sk_buff *askb_rx[FEC_RX_BUF_NUMBER]; // Array of reception skb structure pointers
-	unsigned int fecpriv_initiator_rx;	// Reception DMA initiator
-	unsigned int fecpriv_initiator_tx;	// Transmission DMA initiator
-	int fecpriv_fec_rx_channel;	// DMA reception channel
-	int fecpriv_fec_tx_channel;	// DMA transmission channel
-	int fecpriv_rx_requestor;	// DMA reception requestor
-	int fecpriv_tx_requestor;	// DMA transmission requestor
-	void *fecpriv_interrupt_fec_rx_handler;	// DMA reception handler
-	void *fecpriv_interrupt_fec_tx_handler;	// DMA transmission handler
-	unsigned char *fecpriv_mac_addr;	// Private copy of FEC address
-	struct net_device_stats fecpriv_stat;	// Pointer to the statistical information
+	void* fecpriv_txbuf[FEC_TX_BUF_NUMBER];	/* tx buffer ptrs */
+	MCD_bufDescFec *fecpriv_txdesc;		/* tx descriptor ptrs */
+	volatile unsigned int fecpriv_current_tx; /* current tx desc index */
+	volatile unsigned int fecpriv_next_tx;	/* next tx desc index */
+	unsigned int fecpriv_current_rx;	/* current rx desc index */
+	MCD_bufDescFec *fecpriv_rxdesc;		/* rx descriptor ptrs */
+	struct sk_buff *askb_rx[FEC_RX_BUF_NUMBER]; /* rx SKB ptrs */
+	unsigned int fecpriv_initiator_rx;	/* rx dma initiator */
+	unsigned int fecpriv_initiator_tx;	/* tx dma initiator */
+	int fecpriv_fec_rx_channel;		/* rx dma channel */
+	int fecpriv_fec_tx_channel;		/* tx dma channel */
+	int fecpriv_rx_requestor;		/* rx dma requestor */
+	int fecpriv_tx_requestor;		/* tx dma requestor */
+	void *fecpriv_interrupt_fec_rx_handler;	/* dma rx handler */
+	void *fecpriv_interrupt_fec_tx_handler;	/* dma tx handler */
+	unsigned char *fecpriv_mac_addr;	/* private fec mac addr */
+	struct net_device_stats fecpriv_stat;	/* stats ptr */
 	spinlock_t fecpriv_lock;
 	int fecpriv_rxflag;
 	struct tasklet_struct fecpriv_tasklet_reinit;
-	int index;
+	int index;				/* fec hw number */
 };
 
 struct net_device *fec_dev[FEC_MAX_PORTS];
 
-// FEC functions
+/* FEC functions */
 int __init fec_init(void);
 struct net_device_stats *fec_get_stat(struct net_device *dev);
-
 int fec_open(struct net_device *dev);
 int fec_close(struct net_device *nd);
 int fec_tx(struct sk_buff *skb, struct net_device *dev);
@@ -93,10 +90,12 @@ void fec_interrupt_fec_tx_handler_fec0(v
 void fec_interrupt_fec_rx_handler_fec0(void);
 void fec_interrupt_fec_reinit(unsigned long data);
 
-unsigned char fec_mac_addr_fec0[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x50 };	// Default address of FEC0
+/* default fec0 address */
+unsigned char fec_mac_addr_fec0[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x50 };
 
 #ifdef   FEC_2
-unsigned char fec_mac_addr_fec1[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x51 };	// Default address of FEC1
+/* default fec1 address */
+unsigned char fec_mac_addr_fec1[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x51 };
 #endif
 
 extern unsigned char uboot_enet0[];
@@ -111,17 +110,18 @@ int __init fec_mac_setup0 (char *s);
 #ifdef   FEC_2
 void fec_interrupt_fec_tx_handler_fec1(void);
 void fec_interrupt_fec_rx_handler_fec1(void);
+#endif
 
 #ifndef MODULE
 int __init fec_mac_setup1 (char *s);
 #endif
 
-#endif
 int fec_read_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int *data);
 int fec_write_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int data);
 
 module_init(fec_init);
 /* module_exit(fec_cleanup); */
+
 __setup("mac0=", fec_mac_setup0);
 
 #ifdef   FEC_2
@@ -140,7 +140,6 @@ int fec_enet_init(struct net_device *dev
 	fp->index = index;
 	fp->netdev = dev;
 	fec_dev[ index ] = dev;
-printk(KERN_INFO "FEI: index=%d\n", index);
 
 	if (index == 0) {
 		/* disable fec0 */
@@ -175,8 +174,6 @@ printk(KERN_INFO "FEI: index=%d\n", inde
 		/* rx descriptors */
 		fp->fecpriv_rxdesc = (void*)FEC_RX_DESC_FEC0;
 
-printk(KERN_INFO "FEI: txdesc=0x%p  rxdesc=0x%p\n", fp->fecpriv_txdesc, fp->fecpriv_rxdesc);
-
 		/* mac addr */
 		if (uboot_enet0[0] || uboot_enet0[1] || uboot_enet0[2] ||
 		    uboot_enet0[3] || uboot_enet0[4] || uboot_enet0[5]) {
@@ -229,8 +226,6 @@ printk(KERN_INFO "FEI: txdesc=0x%p  rxde
 #endif
 	}
 
-printk(KERN_INFO "FEI: index=%d base_addr=0x%lx\n", index, dev->base_addr);
-
 	/* clear MIB */
 	memset((void *) (dev->base_addr + 0x200), 0, FEC_MIB_LEN);
 
@@ -288,8 +283,7 @@ int __init fec_init(void)
 	int err;
 	DECLARE_MAC_BUF(mac);
 
-	printk(KERN_INFO "FEC ENET (DMA) Version .00\n");
-
+	printk(KERN_INFO "FEC ENET (DMA) Version %s\n", VERSION);
 
 	for (i = 0; i < FEC_MAX_PORTS; i++) {
 		dev = alloc_etherdev(sizeof(struct fec_priv));
@@ -333,7 +327,6 @@ void fec_stop(struct net_device *dev)
 *
 * RETURNS: If no error occurs, this function returns zero.
 *************************************************************************/
-
 int fec_open(struct net_device *dev)
 {
 	struct fec_priv *fp = netdev_priv(dev);
@@ -343,13 +336,10 @@ int fec_open(struct net_device *dev)
 	int channel;
 	int error_code = -EBUSY;
 
-printk(KERN_INFO "FECOPEN: index=%d\n", fp->index);
-
-	//Receive the DMA channels
+	/* Receive the DMA channels */
 	channel = dma_set_channel_fec(fp->fecpriv_rx_requestor);
 
-	if (channel == -1)
-	{
+	if (channel == -1) {
 		printk("Dma channel cannot be reserved\n");
 		goto ERRORS;
 	}
@@ -360,60 +350,54 @@ printk(KERN_INFO "FECOPEN: index=%d\n", 
 
 	channel = dma_set_channel_fec(fp->fecpriv_tx_requestor);
 
-	if (channel == -1)
-	{
+	if (channel == -1) {
 		printk("Dma channel cannot be reserved\n");
 		goto ERRORS;
 	}
-printk(KERN_INFO "FECOPEN2\n");
 
 	fp->fecpriv_fec_tx_channel = channel;
 
 	dma_connect(channel, (int) fp->fecpriv_interrupt_fec_tx_handler);
 
-	// init tasklet for controller reinitialization
+	/* init tasklet for controller reinitialization */
 	tasklet_init(&fp->fecpriv_tasklet_reinit, fec_interrupt_fec_reinit, (unsigned long) dev);
-printk(KERN_INFO "FECOPEN3\n");
 
-	// Reset FIFOs
+	/* Reset FIFOs */
 	FEC_FECFRST(base_addr) |= FEC_SW_RST | FEC_RST_CTL;
 	FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
 
-	// Reset and disable FEC
+	/* Reset and disable FEC */
 	FEC_ECR(base_addr) = FEC_ECR_RESET;
 
-	// Wait
 	udelay(10);
 
-	// Clear all events
+	/* Clear all events */
 	FEC_EIR(base_addr) = FEC_EIR_CLEAR;
 
-	// Reset FIFO status
+	/* Reset FIFO status */
 	FEC_FECTFSR(base_addr) = FEC_FECTFSR_MSK;
 	FEC_FECRFSR(base_addr) = FEC_FECRFSR_MSK;
 
-#if 0
-/* JKM -- move into HW init */
-	// Copy the default address to the device structure
-	memcpy(dev->dev_addr, fp->fecpriv_mac_addr, ETH_ALEN);
-#endif
+	/* Set the default address */
+	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) |
+			      (fp->fecpriv_mac_addr[1] << 16) |
+			      (fp->fecpriv_mac_addr[2] << 8) |
+			      fp->fecpriv_mac_addr[3];
+	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) |
+			      (fp->fecpriv_mac_addr[5] << 16) | 0x8808;
 
-	// Set the default address
-	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) | (fp->fecpriv_mac_addr[1] << 16) | (fp->fecpriv_mac_addr[2] << 8) | fp->fecpriv_mac_addr[3];
-	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) | (fp->fecpriv_mac_addr[5] << 16) | 0x8808;
-
-	// Reset the group address descriptor
+	/* Reset the group address descriptor */
 	FEC_GALR(base_addr) = 0x00000000;
 	FEC_GAUR(base_addr) = 0x00000000;
 
-	// Reset the individual address descriptor
+	/* Reset the individual address descriptor */
 	FEC_IALR(base_addr) = 0x00000000;
 	FEC_IAUR(base_addr) = 0x00000000;
 
-	// Set the receive control register
+	/* Set the receive control register */
 	FEC_RCR(base_addr) = FEC_RCR_MAX_FRM_SIZE | FEC_RCR_MII;
 
-	// Set the receive FIFO control register
+	/* Set the receive FIFO control register */
 //	FEC_FECRFCR(base_addr) = FEC_FECRFCR_FRM | FEC_FECRFCR_GR | FEC_FECRFCR_MSK;
 	FEC_FECRFCR(base_addr) = FEC_FECRFCR_FRM | FEC_FECRFCR_GR
                              | (FEC_FECRFCR_MSK     // disable all but ...
@@ -422,10 +406,10 @@ printk(KERN_INFO "FECOPEN3\n");
 //                                & ~FEC_FECRFCR_UF   // enable FIFO underflow
                              );
 
-	//Set the receive FIFO alarm register
+	/* Set the receive FIFO alarm register */
 	FEC_FECRFAR(base_addr) = FEC_FECRFAR_ALARM;
 
-	// Set the transmit FIFO control register
+	/* Set the transmit FIFO control register */
 //	FEC_FECTFCR(base_addr) = FEC_FECTFCR_FRM | FEC_FECTFCR_GR | FEC_FECTFCR_MSK;
 	FEC_FECTFCR(base_addr) = FEC_FECTFCR_FRM | FEC_FECTFCR_GR
                              | (FEC_FECTFCR_MSK     // disable all but ...
@@ -434,16 +418,16 @@ printk(KERN_INFO "FECOPEN3\n");
 //                                & ~FEC_FECTFCR_UF   // enable FIFO underflow
                                 & ~FEC_FECTFCR_OF); // enable FIFO overflow
 
-	//Set the transmit FIFO alarm register
+	/* Set the transmit FIFO alarm register */
 	FEC_FECTFAR(base_addr) = FEC_FECTFAR_ALARM;
 
-	// Set the Tx FIFO watermark
+	/* Set the Tx FIFO watermark */
 	FEC_FECTFWR(base_addr) = FEC_FECTFWR_XWMRK;
 
-	// Enable the transmitter to append the CRC
+	/* Enable the transmitter to append the CRC */
 	FEC_CTCWR(base_addr) = FEC_CTCWR_TFCW_CRC;
 
-	// Enable the ethernet interrupts
+	/* Enable the ethernet interrupts */
 //	FEC_EIMR(base_addr) = FEC_EIMR_MASK;
 	FEC_EIMR(base_addr) = FEC_EIMR_DISABLE
                             | FEC_EIR_LC
@@ -453,9 +437,16 @@ printk(KERN_INFO "FECOPEN3\n");
                             | FEC_EIR_XFERR
                             | FEC_EIR_RFERR
                             ;
-printk(KERN_INFO "FECOPEN4\n");
 
-#ifdef   CONFIG_FEC_548x_AUTO_NEGOTIATION
+/*
+ * JKM --
+ *
+ * There's a problem with the PHY initialization code -- 
+ * for now assume uboot left it in an initialized state.
+ */
+// printk(KERN_INFO "FECOPEN: starting auto-negotiation\n");
+// #ifdef   CONFIG_FEC_548x_AUTO_NEGOTIATION
+#if 0
 	if ((error_code = init_transceiver(base_addr, &fduplex)) != 0)
 	{
 		printk("Initialization of the transceiver is failed\n");
@@ -464,25 +455,24 @@ printk(KERN_INFO "FECOPEN4\n");
 #else
 	fduplex = 1;
 #endif
-printk(KERN_INFO "FECOPEN5\n");
+// printk(KERN_INFO "FECOPEN: done with auto-negotiation\n");
 
 	if (fduplex)
-		// Enable the full duplex mode
+		/* Enable the full duplex mode */
 		FEC_TCR(base_addr) = FEC_TCR_FDEN | FEC_TCR_HBC;
 	else
-		// Disable reception of frames while transmitting
+		/* Disable reception of frames while transmitting */
 		FEC_RCR(base_addr) |= FEC_RCR_DRT;
 
-	// Enable MIB
+	/* Enable MIB */
 	FEC_MIBC(base_addr) = FEC_MIBC_ENABLE;
 
-	// Enable FEC
+	/* Enable FEC */
 	FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
 
-	// Initialize transmission descriptors and start DMA for the transmission
+	/* Initialize tx descriptors and start DMA for the transmission */
 	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
 		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
-printk(KERN_INFO "FECOPEN6\n");
 
 	fp->fecpriv_txdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
 
@@ -494,31 +484,27 @@ printk(KERN_INFO "FECOPEN6\n");
 		     FEC_TX_DMA_PRI, MCD_FECTX_DMA | MCD_INTERRUPT,
 		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
 
-	// Initialize reception descriptors and start DMA for the reception
-	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
-	{
+	/* Initialize rx descriptors and start DMA for the reception */
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++) {
 		fp->askb_rx[i] = alloc_skb(FEC_MAXBUF_SIZE + 16, GFP_DMA);
-		if (!fp->askb_rx[i])
-		{
-    		fp->fecpriv_rxdesc[i].dataPointer = 0;
-    		fp->fecpriv_rxdesc[i].statCtrl = 0;
-	    	fp->fecpriv_rxdesc[i].length = 0;
+		if (!fp->askb_rx[i]) {
+			fp->fecpriv_rxdesc[i].dataPointer = 0;
+			fp->fecpriv_rxdesc[i].statCtrl = 0;
+			fp->fecpriv_rxdesc[i].length = 0;
 		}
-		else
-		{
-		    skb_reserve(fp->askb_rx[i], 16);
+		else {
+			skb_reserve(fp->askb_rx[i], 16);
 			fp->askb_rx[i]->dev = dev;
-    		fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
-    		fp->fecpriv_rxdesc[i].statCtrl = MCD_FEC_BUF_READY | MCD_FEC_INTERRUPT;
-	    	fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
-	    }
+    			fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
+    			fp->fecpriv_rxdesc[i].statCtrl = MCD_FEC_BUF_READY | MCD_FEC_INTERRUPT;
+	    		fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
+		}
 	}
-printk(KERN_INFO "FECOPEN7\n");
 
 	fp->fecpriv_rxdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
 	fp->fecpriv_current_rx = 0;
 
-	// flush entire data cache before restarting the DMA
+	/* flush entire data cache before restarting the DMA */
 #if 0
 /* JKM -- currently running with cache turned off */
 	DcacheFlushInvalidate();
@@ -531,31 +517,24 @@ printk(KERN_INFO "FECOPEN7\n");
 		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
 
 	netif_start_queue(dev);
-
-//	MOD_INC_USE_COUNT;
-printk(KERN_INFO "FECOPEN: finished\n");
-
 	return 0;
 
 ERRORS:
 
-	// Remove the channels and return with the error code
-	if (fp->fecpriv_fec_rx_channel != -1)
-	{
+	/* Remove the channels and return with the error code */
+	if (fp->fecpriv_fec_rx_channel != -1) {
 		dma_disconnect(fp->fecpriv_fec_rx_channel);
 		dma_remove_channel_by_number(fp->fecpriv_fec_rx_channel);
 		fp->fecpriv_fec_rx_channel = -1;
 	}
 
-	if (fp->fecpriv_fec_tx_channel != -1)
-	{
+	if (fp->fecpriv_fec_tx_channel != -1) {
 		dma_disconnect(fp->fecpriv_fec_tx_channel);
 		dma_remove_channel_by_number(fp->fecpriv_fec_tx_channel);
 		fp->fecpriv_fec_tx_channel = -1;
 	}
 
 	return error_code;
-
 }
 
 /************************************************************************
@@ -568,31 +547,26 @@ ERRORS:
 *************************************************************************/
 int fec_close(struct net_device *dev)
 {
-	//Receive the pointer to the private structure
 	struct fec_priv *fp = netdev_priv(dev);
-
-	// Receive the base address
 	unsigned long base_addr = (unsigned long) dev->base_addr;
-
 	unsigned long time;
-
 	int i;
 
 	netif_stop_queue(dev);
 
-	// Perform the graceful stop
+	/* Perform the graceful stop */
 	FEC_TCR(base_addr) |= FEC_TCR_GTS;
 
 	time = jiffies;
 
-	// Wait for the graceful stop
+	/* Wait for the graceful stop */
 	while (!(FEC_EIR(base_addr) & FEC_EIR_GRA) && jiffies - time < FEC_GR_TIMEOUT * HZ)
 		schedule();
 
-	// Disable FEC
+	/* Disable FEC */
 	FEC_ECR(base_addr) = FEC_ECR_DISABLE;
 
-	// Reset the DMA channels
+	/* Reset the DMA channels */
 	spin_lock_irq(&fp->fecpriv_lock);
 	MCD_killDma(fp->fecpriv_fec_tx_channel);
 	spin_unlock_irq(&fp->fecpriv_lock);
@@ -600,12 +574,12 @@ int fec_close(struct net_device *dev)
 	dma_disconnect(fp->fecpriv_fec_tx_channel);
 	fp->fecpriv_fec_tx_channel = -1;
 
-	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
-		if (fp->fecpriv_txbuf[i])
-		{
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++) {
+		if (fp->fecpriv_txbuf[i]) {
 			kfree(fp->fecpriv_txbuf[i]);
 			fp->fecpriv_txbuf[i] = NULL;
 		}
+	}
 
 	spin_lock_irq(&fp->fecpriv_lock);
 	MCD_killDma(fp->fecpriv_fec_rx_channel);
@@ -615,15 +589,12 @@ int fec_close(struct net_device *dev)
 	dma_disconnect(fp->fecpriv_fec_rx_channel);
 	fp->fecpriv_fec_rx_channel = -1;
 
-	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
-	{
-		if (fp->askb_rx[i])
-		{
-		    kfree_skb(fp->askb_rx[i]);
-		    fp->askb_rx[i] = NULL;
-	    }
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++) {
+		if (fp->askb_rx[i]) {
+			kfree_skb(fp->askb_rx[i]);
+			fp->askb_rx[i] = NULL;
+		}
 	}
-//	MOD_DEC_USE_COUNT;
 
 	return 0;
 }
@@ -635,14 +606,10 @@ int fec_close(struct net_device *dev)
 *************************************************************************/
 struct net_device_stats * fec_get_stat(struct net_device *dev)
 {
-
-	//Receive the pointer to the private structure
 	struct fec_priv *fp = netdev_priv(dev);
-
-	// Receive the base address
 	unsigned long base_addr = dev->base_addr;
 
-	// Receive the statistical information
+	/* Receive the statistical information */
 	fp->fecpriv_stat.rx_packets = FECSTAT_RMON_R_PACKETS(base_addr);
 	fp->fecpriv_stat.tx_packets = FECSTAT_RMON_T_PACKETS(base_addr);
 	fp->fecpriv_stat.rx_bytes = FECSTAT_RMON_R_OCTETS(base_addr);
@@ -651,7 +618,10 @@ struct net_device_stats * fec_get_stat(s
 	fp->fecpriv_stat.multicast = FECSTAT_RMON_R_MC_PKT(base_addr);
 	fp->fecpriv_stat.collisions = FECSTAT_RMON_T_COL(base_addr);
 
-	fp->fecpriv_stat.rx_length_errors = FECSTAT_RMON_R_UNDERSIZE(base_addr) + FECSTAT_RMON_R_OVERSIZE(base_addr) + FECSTAT_RMON_R_FRAG(base_addr) + FECSTAT_RMON_R_JAB(base_addr);
+	fp->fecpriv_stat.rx_length_errors = FECSTAT_RMON_R_UNDERSIZE(base_addr) +
+		FECSTAT_RMON_R_OVERSIZE(base_addr) +
+		FECSTAT_RMON_R_FRAG(base_addr) +
+		FECSTAT_RMON_R_JAB(base_addr);
 	fp->fecpriv_stat.rx_crc_errors = FECSTAT_IEEE_R_CRC(base_addr);
 	fp->fecpriv_stat.rx_frame_errors = FECSTAT_IEEE_R_ALIGN(base_addr);
 	fp->fecpriv_stat.rx_over_errors = FECSTAT_IEEE_R_MACERR(base_addr);
@@ -660,9 +630,18 @@ struct net_device_stats * fec_get_stat(s
 	fp->fecpriv_stat.tx_fifo_errors = FECSTAT_IEEE_T_MACERR(base_addr);
 	fp->fecpriv_stat.tx_window_errors = FECSTAT_IEEE_T_LCOL(base_addr);
 
-	// I hope that one frame doesn't have more than one error
-	fp->fecpriv_stat.rx_errors = fp->fecpriv_stat.rx_length_errors + fp->fecpriv_stat.rx_crc_errors + fp->fecpriv_stat.rx_frame_errors + fp->fecpriv_stat.rx_over_errors + fp->fecpriv_stat.rx_dropped;
-	fp->fecpriv_stat.tx_errors = fp->fecpriv_stat.tx_carrier_errors + fp->fecpriv_stat.tx_fifo_errors + fp->fecpriv_stat.tx_window_errors + fp->fecpriv_stat.tx_aborted_errors + fp->fecpriv_stat.tx_heartbeat_errors + fp->fecpriv_stat.tx_dropped;
+	/* I hope that one frame doesn't have more than one error */
+	fp->fecpriv_stat.rx_errors = fp->fecpriv_stat.rx_length_errors +
+		fp->fecpriv_stat.rx_crc_errors +
+		fp->fecpriv_stat.rx_frame_errors +
+		fp->fecpriv_stat.rx_over_errors +
+		fp->fecpriv_stat.rx_dropped;
+	fp->fecpriv_stat.tx_errors = fp->fecpriv_stat.tx_carrier_errors +
+		fp->fecpriv_stat.tx_fifo_errors +
+		fp->fecpriv_stat.tx_window_errors +
+		fp->fecpriv_stat.tx_aborted_errors +
+		fp->fecpriv_stat.tx_heartbeat_errors +
+		fp->fecpriv_stat.tx_dropped;
 
 	return &fp->fecpriv_stat;
 }
@@ -674,59 +653,47 @@ struct net_device_stats * fec_get_stat(s
 *************************************************************************/
 void fec_set_multicast_list(struct net_device *dev)
 {
-	// Pointer to the address list
 	struct dev_mc_list *dmi;
-
 	unsigned int crc, data;
 	int i, j, k;
-
-	// Receive the base address
 	unsigned long base_addr = (unsigned long) dev->base_addr;
 
-	if (dev->flags & IFF_PROMISC || dev->flags & IFF_ALLMULTI)
-	{
-		// Allow all incoming frames
+	if (dev->flags & IFF_PROMISC || dev->flags & IFF_ALLMULTI) {
+		/* Allow all incoming frames */
 		FEC_GALR(base_addr) = 0xFFFFFFFF;
 		FEC_GAUR(base_addr) = 0xFFFFFFFF;
 		return;
 	}
-	// Reset the group address register
+
+	/* Reset the group address register */
 	FEC_GALR(base_addr) = 0x00000000;
 	FEC_GAUR(base_addr) = 0x00000000;
 
-	// Process all addresses
-	for (i = 0, dmi = dev->mc_list; i < dev->mc_count; i++, dmi = dmi->next)
-	{
-		// Processing must be only for the group addresses
+	/* Process all addresses */
+	for (i = 0, dmi = dev->mc_list; i < dev->mc_count; i++, dmi = dmi->next) {
+		/* Processing must be only for the group addresses */
 		if (!(dmi->dmi_addr[0] & 1))
 			continue;
 
-		// Calculate crc value for the current address
+		/* Calculate crc value for the current address */
 		crc = 0xFFFFFFFF;
-		for (j = 0; j < dmi->dmi_addrlen; j++)
-		{
-
-			for (k = 0, data = dmi->dmi_addr[j]; k < 8;  k++, data >>= 1)
-			{
+		for (j = 0; j < dmi->dmi_addrlen; j++) {
+			for (k = 0, data = dmi->dmi_addr[j]; k < 8;  k++, data >>= 1) {
 				if ((crc ^ data) & 1)
 					crc = (crc >> 1) ^ FEC_CRCPOL;
 				else
 					crc >>= 1;
-
 			}
-
 		}
 
-		// Add this value
+		/* Add this value */
 		crc >>= 26;
 		crc &= 0x3F;
 		if (crc > 31)
 			FEC_GAUR(base_addr) |= 0x1 << (crc - 32);
 		else
 			FEC_GALR(base_addr) |= 0x1 << crc;
-
 	}
-
 }
 
 /************************************************************************
@@ -736,26 +703,27 @@ void fec_set_multicast_list(struct net_d
 *************************************************************************/
 int fec_set_mac_address(struct net_device *dev, void *p)
 {
-	//Receive the pointer to the private structure
 	struct fec_priv *fp = netdev_priv(dev);
-
-	// Receive the base address
 	unsigned long base_addr = (unsigned long) dev->base_addr;
-
 	struct sockaddr *addr = p;
 
 	if (netif_running(dev))
 		return -EBUSY;
 
-	// Copy a new address to the device structure
+	/* Copy a new address to the device structure */
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
 
-	// Copy a new address to the private structure
+	/* Copy a new address to the private structure */
 	memcpy(fp->fecpriv_mac_addr, addr->sa_data, 6);
 
-	// Set the address to the registers
-	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) | (fp->fecpriv_mac_addr[1] << 16) | (fp->fecpriv_mac_addr[2] << 8) | fp->fecpriv_mac_addr[3];
-	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) | (fp->fecpriv_mac_addr[5] << 16) | 0x8808;
+	/* Set the address to the registers */
+	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) |
+		(fp->fecpriv_mac_addr[1] << 16) |
+		(fp->fecpriv_mac_addr[2] << 8) |
+		fp->fecpriv_mac_addr[3];
+	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) |
+		(fp->fecpriv_mac_addr[5] << 16) |
+		0x8808;
 
 	return 0;
 }
@@ -769,27 +737,24 @@ int fec_set_mac_address(struct net_devic
 *************************************************************************/
 int fec_tx(struct sk_buff *skb, struct net_device *dev)
 {
-
-	//Receive the pointer to the private structure
 	struct fec_priv *fp = netdev_priv(dev);
-
 	void *data, *data_aligned;
 	int offset;
 
 	data = kmalloc(skb->len + 15, GFP_DMA | GFP_ATOMIC);
 
-	if (!data)
-	{
+	if (!data) {
 		fp->fecpriv_stat.tx_dropped++;
 		dev_kfree_skb(skb);
 		return 0;
 	}
 
-	offset = (((unsigned long)virt_to_phys(data) + 15) & 0xFFFFFFF0) - (unsigned long)virt_to_phys(data);
+	offset = (((unsigned long)virt_to_phys(data) + 15) & 0xFFFFFFF0) -
+		(unsigned long)virt_to_phys(data);
 	data_aligned = (void*)((unsigned long)data + offset);
 	memcpy(data_aligned, skb->data, skb->len);
 
-	// flush data cache before initializing the descriptor and starting DMA
+	/* flush data cache before initializing the descriptor and starting DMA */
 #if 0
 /* JKM -- currently running with cache turned off */
 	DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(data_aligned), skb->len);
@@ -797,7 +762,7 @@ int fec_tx(struct sk_buff *skb, struct n
 
 	spin_lock_irq(&fp->fecpriv_lock);
 
-	// Initialize the descriptor
+	/* Initialize the descriptor */
 	fp->fecpriv_txbuf[fp->fecpriv_next_tx] = data;
 	fp->fecpriv_txdesc[fp->fecpriv_next_tx].dataPointer = (unsigned int) virt_to_phys(data_aligned);
 	fp->fecpriv_txdesc[fp->fecpriv_next_tx].length = skb->len;
@@ -809,7 +774,7 @@ int fec_tx(struct sk_buff *skb, struct n
 
 	spin_unlock_irq(&fp->fecpriv_lock);
 
-	// Tell the DMA to continue the transmission
+	/* Tell the DMA to continue the transmission */
 	MCD_continDma(fp->fecpriv_fec_tx_channel);
 
 	dev_kfree_skb(skb);
@@ -835,14 +800,10 @@ void fec_tx_timeout(struct net_device *d
 
 	spin_lock_irq(&fp->fecpriv_lock);
 	MCD_killDma(fp->fecpriv_fec_tx_channel);
-	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
-	{
-		if (fp->fecpriv_txbuf[i])
-		{
-
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++) {
+		if (fp->fecpriv_txbuf[i]) {
 			kfree(fp->fecpriv_txbuf[i]);
 			fp->fecpriv_txbuf[i] = NULL;
-
 		}
 		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
 	}
@@ -850,14 +811,14 @@ void fec_tx_timeout(struct net_device *d
 
 	fp->fecpriv_current_tx = fp->fecpriv_next_tx = 0;
 
-    // Reset FIFOs
+    /* Reset FIFOs */
     FEC_FECFRST(base_addr) |= FEC_SW_RST;
     FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
 
-	// Reset and disable FEC
+	/* Reset and disable FEC */
 //	FEC_ECR(base_addr) = FEC_ECR_RESET;
 
-	// Enable FEC
+	/* Enable FEC */
 	FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
 
 	MCD_startDma(fp->fecpriv_fec_tx_channel, (char *) fp->fecpriv_txdesc, 0,
@@ -883,23 +844,22 @@ int fec_read_mii(unsigned int base_addr,
 {
 	unsigned long time;
 
-	// Clear the MII interrupt bit
+	/* Clear the MII interrupt bit */
 	FEC_EIR(base_addr) = FEC_EIR_MII;
 
-	// Write to the MII management frame register
+	/* Write to the MII management frame register */
 	FEC_MMFR(base_addr) = FEC_MMFR_READ | (pa << 23) | (ra << 18);
 
 	time = jiffies;
 
-	// Wait for the reading
-	while (!(FEC_EIR(base_addr) & FEC_EIR_MII))
-	{
+	/* Wait for the reading */
+	while (!(FEC_EIR(base_addr) & FEC_EIR_MII)) {
 		if (jiffies - time > FEC_MII_TIMEOUT * HZ)
 			return -ETIME;
 		schedule();
 	}
 
-	// Clear the MII interrupt bit
+	/* Clear the MII interrupt bit */
 	FEC_EIR(base_addr) = FEC_EIR_MII;
 
 	*data = FEC_MMFR(base_addr) & 0x0000FFFF;
@@ -918,25 +878,22 @@ int fec_write_mii(unsigned int base_addr
 {
 	unsigned long time;
 
-	// Clear the MII interrupt bit
+	/* Clear the MII interrupt bit */
 	FEC_EIR(base_addr) = FEC_EIR_MII;
 
-	// Write to the MII management frame register
+	/* Write to the MII management frame register */
 	FEC_MMFR(base_addr) = FEC_MMFR_WRITE | (pa << 23) | (ra << 18) | data;
 
 	time = jiffies;
 
-	// Wait for the writing
-
-	while (!(FEC_EIR(base_addr) & FEC_EIR_MII))
-	{
+	/* Wait for the writing */
+	while (!(FEC_EIR(base_addr) & FEC_EIR_MII)) {
 		if (jiffies - time > FEC_MII_TIMEOUT * HZ)
 			return -ETIME;
-
 		schedule();
 	}
 
-	// Clear the MII interrupt bit
+	/* Clear the MII interrupt bit */
 	FEC_EIR(base_addr) = FEC_EIR_MII;
 
 	return 0;
@@ -953,27 +910,24 @@ void fec_interrupt_fec_tx_handler(struct
 {
 	struct fec_priv *fp = netdev_priv(dev);
 
-	//Release the socket buffer
-	if(fp->fecpriv_txbuf[fp->fecpriv_current_tx])
-	{
+	/* Release the socket buffer */
+	if(fp->fecpriv_txbuf[fp->fecpriv_current_tx]) {
 		kfree(fp->fecpriv_txbuf[fp->fecpriv_current_tx]);
 		fp->fecpriv_txbuf[fp->fecpriv_current_tx] = NULL;
 	}
 	fp->fecpriv_current_tx = (fp->fecpriv_current_tx + 1) & FEC_TX_INDEX_MASK;
 
-	if (MCD_dmaStatus(fp->fecpriv_fec_tx_channel) == MCD_DONE)
-		for (; fp->fecpriv_current_tx != fp->fecpriv_next_tx; fp->fecpriv_current_tx = (fp->fecpriv_current_tx + 1) & FEC_TX_INDEX_MASK)
-		{
-			if(fp->fecpriv_txbuf[fp->fecpriv_current_tx])
-			{
+	if (MCD_dmaStatus(fp->fecpriv_fec_tx_channel) == MCD_DONE) {
+		for (; fp->fecpriv_current_tx != fp->fecpriv_next_tx; fp->fecpriv_current_tx = (fp->fecpriv_current_tx + 1) & FEC_TX_INDEX_MASK) {
+			if(fp->fecpriv_txbuf[fp->fecpriv_current_tx]) {
 				kfree(fp->fecpriv_txbuf[fp->fecpriv_current_tx]);
 				fp->fecpriv_txbuf[fp->fecpriv_current_tx] = NULL;
 			}
 		}
+	}
 
 	if (netif_queue_stopped(dev))
 		netif_wake_queue(dev);
-
 }
 
 /************************************************************************
@@ -1008,49 +962,41 @@ void fec_interrupt_fec_rx_handler(struct
 		}
 	}
 */
-	for (; fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl & MCD_FEC_END_FRAME;	fp->fecpriv_current_rx = (fp->fecpriv_current_rx + 1) & FEC_RX_INDEX_MASK)
-	{
+	for (; fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl & MCD_FEC_END_FRAME;	fp->fecpriv_current_rx = (fp->fecpriv_current_rx + 1) & FEC_RX_INDEX_MASK) {
 	    if( (fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length <= FEC_MAXBUF_SIZE) &&
-		    (fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length > 4)) // --tym--
-	    {
+		    (fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length > 4)) { /* --tym-- */
     		skb = fp->askb_rx[fp->fecpriv_current_rx];
     		if (!skb)
-    		{
-    		    fp->fecpriv_stat.rx_dropped++;
-            }
-    		else
-    		{
-    		    // flush data cache before initializing the descriptor and starting DMA
+			fp->fecpriv_stat.rx_dropped++;
+    		else {
+    		    /* flush data cache before initializing the descriptor and starting DMA */
 //		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), fp->askb_rx[fp->fecpriv_current_rx]->len);
 
     			skb_put(skb, fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length - 4);
-//    			skb->dev = dev;
     			skb->protocol = eth_type_trans(skb, dev);
     			netif_rx(skb);
-    		}
-		    fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl &= ~MCD_FEC_END_FRAME;
-    		// allocate new skbuff
+		}
+		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl &= ~MCD_FEC_END_FRAME;
+    		/* allocate new skbuff */
     		fp->askb_rx[fp->fecpriv_current_rx] = alloc_skb(FEC_MAXBUF_SIZE + 16, /*GFP_ATOMIC |*/ GFP_DMA);
-		    if (!fp->askb_rx[fp->fecpriv_current_rx])
-    	    {
-        		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].dataPointer = 0;
-	    	    fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length = 0;
-    		    fp->fecpriv_stat.rx_dropped++;
-		    }
-    		else
-    		{
-    		    skb_reserve(fp->askb_rx[fp->fecpriv_current_rx], 16);
-    			fp->askb_rx[fp->fecpriv_current_rx]->dev = dev;
+		if (!fp->askb_rx[fp->fecpriv_current_rx]) {
+			fp->fecpriv_rxdesc[fp->fecpriv_current_rx].dataPointer = 0;
+			fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length = 0;
+			fp->fecpriv_stat.rx_dropped++;
+		}
+    		else {
+			skb_reserve(fp->askb_rx[fp->fecpriv_current_rx], 16);
+			fp->askb_rx[fp->fecpriv_current_rx]->dev = dev;
 
-    		    // flush data cache before initializing the descriptor and starting DMA
+			/* flush data cache before initializing the descriptor and starting DMA */
 #if 0
 /* JKM -- currently running with cache turned off */
-		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), FEC_MAXBUF_SIZE);
+			DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), FEC_MAXBUF_SIZE);
 #endif
 
     	    	fp->fecpriv_rxdesc[fp->fecpriv_current_rx].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail);
     	    	fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length = FEC_MAXBUF_SIZE;
-        		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl |= MCD_FEC_BUF_READY;
+		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl |= MCD_FEC_BUF_READY;
 
     		    // flush data cache before initializing the descriptor and starting DMA
 //		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), FEC_MAXBUF_SIZE);
@@ -1059,11 +1005,10 @@ void fec_interrupt_fec_rx_handler(struct
 
 	}
 
-	// Tell the DMA to continue the reception
+	/* Tell the DMA to continue the reception */
 	MCD_continDma(fp->fecpriv_fec_rx_channel);
 
 	fp->fecpriv_rxflag = 0;
-
 }
 
 /************************************************************************
@@ -1080,76 +1025,70 @@ irqreturn_t fec_interrupt_handler(int ir
 	unsigned long base_addr = (unsigned long) dev->base_addr;
 	unsigned long events;
 
-	// Read and clear the events
+	/* Read and clear the events */
 	events = FEC_EIR(base_addr) & FEC_EIMR(base_addr);
 
-	if (events & FEC_EIR_HBERR)
-	{
+	if (events & FEC_EIR_HBERR) {
 		fp->fecpriv_stat.tx_heartbeat_errors++;
-    	FEC_EIR(base_addr) = FEC_EIR_HBERR;
+		FEC_EIR(base_addr) = FEC_EIR_HBERR;
 	}
 
-    // receive/transmit FIFO error
-    if (((events & FEC_EIR_RFERR) != 0) || ((events & FEC_EIR_XFERR) != 0))
-    {
-        // kill DMA receive channel
-        MCD_killDma (fp->fecpriv_fec_rx_channel);
-        // kill running transmission by DMA
-        MCD_killDma (fp->fecpriv_fec_tx_channel);
-
-        // Reset FIFOs
-        FEC_FECFRST(base_addr) |= FEC_SW_RST;
-        FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
-
-        // reset receive FIFO status register
-        FEC_FECRFSR(base_addr) = FEC_FECRFSR_FAE
-                                 | FEC_FECRFSR_RXW
-                                 | FEC_FECRFSR_UF;
-
-        // reset transmit FIFO status register
-        FEC_FECTFSR(base_addr) = FEC_FECTFSR_FAE
-                                 | FEC_FECTFSR_TXW
-                                 | FEC_FECTFSR_UF
-                                 | FEC_FECTFSR_OF;
+	/* receive/transmit FIFO error */
+    	if (((events & FEC_EIR_RFERR) != 0) || ((events & FEC_EIR_XFERR) != 0)) {
+        	/* kill DMA receive channel */
+        	MCD_killDma (fp->fecpriv_fec_rx_channel);
 
-        // reset RFERR and XFERR event
-        FEC_EIR(base_addr) = FEC_EIR_RFERR | FEC_EIR_XFERR;
+        	/* kill running transmission by DMA */
+        	MCD_killDma (fp->fecpriv_fec_tx_channel);
 
-	// stop queue
-	netif_stop_queue(dev);
-	
-        // execute reinitialization as tasklet
-    	tasklet_schedule(&fp->fecpriv_tasklet_reinit);
+		/* Reset FIFOs */
+        	FEC_FECFRST(base_addr) |= FEC_SW_RST;
+        	FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
 
-        fp->fecpriv_stat.rx_dropped++;
+        	/* reset receive FIFO status register */
+        	FEC_FECRFSR(base_addr) = FEC_FECRFSR_FAE |
+					 FEC_FECRFSR_RXW |
+					 FEC_FECRFSR_UF;
 
-    }
+		/* reset transmit FIFO status register */
+        	FEC_FECTFSR(base_addr) = FEC_FECTFSR_FAE |
+					 FEC_FECTFSR_TXW |
+					 FEC_FECTFSR_UF |
+					 FEC_FECTFSR_OF;
 
-    // transmit FIFO underrun
-    if ((events & FEC_EIR_XFUN) != 0)
-    {
-        // reset XFUN event
-        FEC_EIR(base_addr) = FEC_EIR_XFUN;
-		fp->fecpriv_stat.tx_aborted_errors++;
-    }
+		/* reset RFERR and XFERR event */
+        	FEC_EIR(base_addr) = FEC_EIR_RFERR | FEC_EIR_XFERR;
+
+		/* stop queue */
+		netif_stop_queue(dev);
+	
+		/* execute reinitialization as tasklet */
+		tasklet_schedule(&fp->fecpriv_tasklet_reinit);
+
+		fp->fecpriv_stat.rx_dropped++;
+	}
 
-    // late collision
-    if ((events & FEC_EIR_LC) != 0)
-    {
-        // reset LC event
-        FEC_EIR(base_addr) = FEC_EIR_LC;
+	/* transmit FIFO underrun */
+    	if ((events & FEC_EIR_XFUN) != 0) {
+        	/* reset XFUN event */
+        	FEC_EIR(base_addr) = FEC_EIR_XFUN;
 		fp->fecpriv_stat.tx_aborted_errors++;
-    }
+    	}
 
-    // collision retry limit
-    if ((events & FEC_EIR_RL) != 0)
-    {
-        // reset RL event
-        FEC_EIR(base_addr) = FEC_EIR_RL;
+	/* late collision */
+    	if ((events & FEC_EIR_LC) != 0) {
+        	/* reset LC event */
+		FEC_EIR(base_addr) = FEC_EIR_LC;
 		fp->fecpriv_stat.tx_aborted_errors++;
-    }
+    	}
 
-    return 0;
+	/* collision retry limit */
+    	if ((events & FEC_EIR_RL) != 0) {
+		/* reset RL event */
+        	FEC_EIR(base_addr) = FEC_EIR_RL;
+		fp->fecpriv_stat.tx_aborted_errors++;
+    	}
+    	return 0;
 }
 
 /************************************************************************
@@ -1166,52 +1105,46 @@ void fec_interrupt_fec_reinit(unsigned l
 	struct fec_priv *fp = netdev_priv(dev);
 	unsigned long base_addr = (unsigned long) dev->base_addr;
 
-	// Initialize reception descriptors and start DMA for the reception
-	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
-	{
-		if (!fp->askb_rx[i])
-		{
-    		fp->askb_rx[i] = alloc_skb(FEC_MAXBUF_SIZE + 16, GFP_ATOMIC | GFP_DMA);
-        	if (!fp->askb_rx[i])
-		    {
-        		fp->fecpriv_rxdesc[i].dataPointer = 0;
-	        	fp->fecpriv_rxdesc[i].statCtrl = 0;
-    	    	fp->fecpriv_rxdesc[i].length = 0;
-    	    	continue;
-	        }
+	/* Initialize reception descriptors and start DMA for the reception */
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++) {
+		if (!fp->askb_rx[i]) {
+			fp->askb_rx[i] = alloc_skb(FEC_MAXBUF_SIZE + 16, GFP_ATOMIC | GFP_DMA);
+			if (!fp->askb_rx[i]) {
+				fp->fecpriv_rxdesc[i].dataPointer = 0;
+				fp->fecpriv_rxdesc[i].statCtrl = 0;
+				fp->fecpriv_rxdesc[i].length = 0;
+				continue;
+			}
 			fp->askb_rx[i]->dev = dev;
-    	    skb_reserve(fp->askb_rx[i], 16);
-	    }
-	    fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
+			skb_reserve(fp->askb_rx[i], 16);
+		}
+		fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
 		fp->fecpriv_rxdesc[i].statCtrl = MCD_FEC_BUF_READY | MCD_FEC_INTERRUPT;
-    	fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
+		fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
 	}
 
 	fp->fecpriv_rxdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
 	fp->fecpriv_current_rx = 0;
 
-    // restart frame transmission
-	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
-	{
-		if (fp->fecpriv_txbuf[i])
-		{
-
+	/* restart frame transmission */
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++) {
+		if (fp->fecpriv_txbuf[i]) {
 			kfree(fp->fecpriv_txbuf[i]);
 			fp->fecpriv_txbuf[i] = NULL;
-    		fp->fecpriv_stat.tx_dropped++;
+    			fp->fecpriv_stat.tx_dropped++;
 		}
 		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
 	}
 	fp->fecpriv_txdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
 	fp->fecpriv_current_tx = fp->fecpriv_next_tx = 0;
 
-	// flush entire data cache before restarting the DMA
+	/* flush entire data cache before restarting the DMA */
 #if 0
 /* JKM -- currently running with cache turned off */
 	DcacheFlushInvalidate();
 #endif
 	
-    // restart DMA from beginning
+	/* restart DMA from beginning */
 	MCD_startDma(fp->fecpriv_fec_rx_channel,
 		     (char *) fp->fecpriv_rxdesc, 0,
 		     (unsigned char *) &(FEC_FECRFDR(base_addr)), 0,
@@ -1225,11 +1158,10 @@ void fec_interrupt_fec_reinit(unsigned l
 		     FEC_TX_DMA_PRI, MCD_FECTX_DMA | MCD_INTERRUPT,
 		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
 
-    // Enable FEC
-    FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
+	/* Enable FEC */
+	FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
 
 	netif_wake_queue(dev);
-
 }
 
 /************************************************************************
@@ -1284,8 +1216,8 @@ void fec_interrupt_fec_rx_handler_fec1(v
 }
 
 #endif
-#ifndef MODULE
 
+#ifndef MODULE
 /************************************************************************
 * NAME: fec_mac_setup0
 *
@@ -1300,7 +1232,6 @@ int __init fec_mac_setup0(char *s)
 	if(fec_str_to_mac(s, fec_mac_addr_fec0))
 		printk("The MAC address of FEC0 cannot be set from command line");
 	return 1;
-
 }
 
 #ifdef   FEC_2
@@ -1316,11 +1247,9 @@ int __init fec_mac_setup1(char *s)
 	if(!s || !*s)
 		return 1;
 
-
 	if(fec_str_to_mac(s, fec_mac_addr_fec1))
 		printk("The MAC address of FEC1 cannot be set from command line");
 	return 1;
-
 }
 #endif
 
@@ -1332,52 +1261,46 @@ int __init fec_mac_setup1(char *s)
 *************************************************************************/
 int fec_str_to_mac( char *str_mac, unsigned char* addr)
 {
-    unsigned long val;
+	unsigned long val;
 	char c;
 	unsigned long octet[6], *octetptr = octet;
 	int i;
-again:
 
+again:
 	val = 0;
-	while ((c = *str_mac) != '\0')
-	{
-		if ((c>='0')&&(c<='9'))
-		{
+	while ((c = *str_mac) != '\0') {
+		if ((c>='0')&&(c<='9')) {
 			val = (val * 16) + (c - '0');
 			str_mac++;
 			continue;
 		}
-		else
-		if (((c>='a')&&(c<='f'))||((c>='A')&&(c<='F')))
-		{
+		else if (((c>='a')&&(c<='f'))||((c>='A')&&(c<='F'))) {
 			val = (val << 4) + (c + 10 - (((c>='a')&&(c<='f')) ? 'a' : 'A'));
 			str_mac++;
 			continue;
 		}
 		break;
 	}
-	if (*str_mac == ':')
-	{
+	if (*str_mac == ':') {
 		*octetptr++ = val, str_mac++;
 		if (octetptr >= octet + 6)
 			return 1;
 		goto again;
 	}
 
-	 //Check for trailing characters.
+	/* Check for trailing characters */
 	if (*str_mac && !(*str_mac==' '))
 		return 1;
+
 	*octetptr++ = val;
 
-	if ((octetptr - octet)==6)
-	{
-	   for(i=0;i<=6;i++)
-	      addr[i]=octet[i];
+	if ((octetptr - octet)==6) {
+		for(i=0;i<=6;i++)
+			addr[i]=octet[i];
 	}
-    else
+	else
 		return 1;
 
 	return 0;
-
 }
 #endif
