--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 1
 PATCHLEVEL = 1
 SUBLEVEL = 5
-EXTRAVERSION =
+EXTRAVERSION = -IFX-LXDB
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -44,6 +44,25 @@ export	HOSTARCH HOSTOS
 # Deal with colliding definitions from tcsh etc.
 VENDOR=
 
+# Default algorithm form compressing u-boot.bin
+ifndef COMPRESS
+COMPRESS=none
+COMPRESS_FILE=$(obj)u-boot.img
+else
+ifeq ($(COMPRESS),lzma)
+COMPRESS_FILE=$(obj)u-boot.limg
+endif
+ifeq ($(COMPRESS),bz2)
+COMPRESS_FILE=$(obj)u-boot.bzimg
+endif
+ifeq ($(COMPRESS),gzip)
+COMPRESS_FILE=$(obj)u-boot.zimg
+endif
+ifeq ($(COMPRESS),none)
+COMPRESS_FILE=$(obj)u-boot.img
+endif
+endif
+
 #########################################################################
 #
 # U-boot build supports producing a object files to the separate external
@@ -164,6 +183,11 @@ include $(TOPDIR)/config.mk
 # U-Boot objects....order is important (i.e. start must be first)
 
 OBJS  = cpu/$(CPU)/start.o
+OBJS_BOOTSTRAP  = cpu/$(CPU)/start_bootstrap.o
+
+cpu/$(CPU)/start_bootstrap.S: cpu/$(CPU)/start.S
+	ln -s start.S cpu/$(CPU)/start_bootstrap.S
+
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
 OBJS += cpu/$(CPU)/reset.o
@@ -183,6 +207,7 @@ OBJS += cpu/$(CPU)/cplbhdlr.o	cpu/$(CPU)
 endif
 
 OBJS := $(addprefix $(obj),$(OBJS))
+OBJS_BOOTSTRAP := $(addprefix $(obj),$(OBJS_BOOTSTRAP))
 
 LIBS  = lib_generic/libgeneric.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
@@ -206,15 +231,24 @@ LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
 LIBS := $(addprefix $(obj),$(LIBS))
+
+LIBS_BOOTSTRAP  = lib_bootstrap/libbootstrap.a
+LIBS_BOOTSTRAP+= board/$(BOARDDIR)/lib$(BOARD).a
+#LIBS_BOOTSTRAP+= board/ifx/libifx.a
+LIBS_BOOTSTRAP+= cpu/$(CPU)/lib$(CPU).a
+
+LIBS_BOOTSTRAP := $(addprefix $(obj),$(LIBS_BOOTSTRAP))
+
 .PHONY : $(LIBS)
+.PHONY : $(obj)lib_bootstrap/libbootstrap.a
 
 # Add GCC lib
 PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
+	  #examples
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
@@ -226,14 +260,75 @@ endif
 
 __OBJS := $(subst $(obj),,$(OBJS))
 __LIBS := $(subst $(obj),,$(LIBS))
+__LIBS_BOOTSTRAP := $(subst $(obj),,$(LIBS_BOOTSTRAP))
+
+#__HEAD_OBJS := $(subst $(obj),,$(HEAD_OBJS))
+#__HEAD_LIBS := $(subst $(obj),,$(HEAD_LIBS))
 
 #########################################################################
 #########################################################################
 
 ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+#IFX_ALL = $(obj)u-boot.ifx $(obj)head.srec $(obj)head.bin $(obj)head $(obj)head.map $(COMPRESS_FILE) $(obj)u-boot.srec
+IFX_ALL = $(obj)u-boot.srec $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)System.map $(obj)bootstrap.bin $(obj)System_bootstrap.map
+IFX_BOOTSTRAP = $(obj)bootstrap.bin
 
 all:		$(ALL)
 
+ifx_all:	$(IFX_ALL)
+
+ifx_bootstrap:	$(IFX_BOOTSTRAP)
+
+$(obj)u-boot.ifx: $(obj)bootstrap.bin $(obj)u-boot.lzimg
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.ifx
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.ifx
+
+$(obj)u-boot.lzimg: $(obj)u-boot.bin $(obj)System.map
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		$(obj)tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.lzma $@
+
+$(obj)ld_uboot.img: $(obj)u-boot.ifx $(obj)u-boot.lzimg $(obj)bootstrap.bin
+		@  cp -f $(obj)u-boot.ifx $(obj)u-boot.bin
+		@ ./mkbootimg.incaip2 $(obj)ld_uboot.img < ld_uboot.conf
+
+$(obj)u-boot.zimg:	$(obj)u-boot.bin $(obj)System.map
+		gzip $(obj)u-boot.bin
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C gzip \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			 sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.gz $@
+
+$(obj)u-boot.bzimg:	$(obj)u-boot.bin $(obj)System.map
+		bzip $(obj)u-boot.bin
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C bzip2 \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bz2 $@
+
+$(obj)u-boot.limg:	$(obj)u-boot.bin $(obj)System.map
+		@lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.lzma $@
+
+$(obj)u-boot.img:	$(obj)u-boot.bin $(obj)System.map
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C none \
+		-a 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(obj)System.map | awk '{ printf "%s", $$1 }') \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[     ]*$$/ for $(BOARD) board"/') \
+		-d u-boot.bin $@
+
 $(obj)u-boot.hex:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
 
@@ -243,28 +338,33 @@ $(obj)u-boot.srec:	$(obj)u-boot
 $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
-		./tools/mkimage -A $(ARCH) -T firmware -C none \
-		-a $(TEXT_BASE) -e 0 \
-		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
-			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
-		-d $< $@
-
 $(obj)u-boot.dis:	$(obj)u-boot
 		$(OBJDUMP) -d $< > $@
 
-$(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
+$(obj)u-boot:	depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
 		cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
 			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
 			-Map u-boot.map -o u-boot
 
+$(obj)bootstrap.bin:	$(obj)bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(obj)bootstrap :		depend version $(SUBDIRS) $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) $(LDSCRIPT_BOOTSTRAP)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS_BOOTSTRAP) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		$(LD) $(LDFLAGS_BOOTSTRAP) $$UNDEF_SYM $(OBJS_BOOTSTRAP) \
+			--start-group $(__LIBS_BOOTSTRAP) --end-group $(PLATFORM_LIBS) \
+			-Map bootstrap.map -o bootstrap
+
 $(OBJS):
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+$(obj)lib_bootstrap/libbootstrap.a:
+		$(MAKE) -C $(dir $(subst $(obj),,$@))
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -310,7 +410,12 @@ etags:
 $(obj)System.map:	$(obj)u-boot
 		@$(NM) $< | \
 		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
-		sort > $(obj)System.map
+		sort > $@
+
+$(obj)System_bootstrap.map:	$(obj)bootstrap
+		@$(NM) $< | \
+		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
+		sort > $@
 
 #########################################################################
 else
@@ -2032,7 +2137,20 @@ sc520_spunk_rel_config	:	unconfig
 # MIPS
 #========================================================================
 #########################################################################
-## MIPS32 4Kc
+## Infineon MIPS generic u-boot config
+#########################################################################
+danube_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips danube ifx danube
+
+amazon_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips amazon
+
+
+incaip2_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips incaip2
+
+#########################################################################
+## MIPS32 4kc
 #########################################################################
 
 xtract_incaip = $(subst _100MHz,,$(subst _133MHz,,$(subst _150MHz,,$(subst _config,,$1))))
@@ -2254,7 +2372,7 @@ clobber:	clean
 		| xargs -0 rm -f
 	rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS $(obj)include/version_autogenerated.h
 	rm -fr $(obj)*.*~
-	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL) $(IFX_ALL)
 	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c
 	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
 	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -31,6 +31,7 @@
 #include <malloc.h>
 #include <zlib.h>
 #include <bzlib.h>
+#include <LzmaWrapper.h>
 #include <environment.h>
 #include <asm/byteorder.h>
 
@@ -79,6 +80,8 @@ DECLARE_GLOBAL_DATA_PTR;
 # define CHUNKSZ (64 * 1024)
 #endif
 
+#ifndef CFG_HEAD_CODE
+
 int  gunzip (void *, int, unsigned char *, unsigned long *);
 
 static void *zalloc(void *, unsigned, unsigned);
@@ -341,6 +344,7 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 		}
 		break;
+#ifndef CONFIG_REMOVE_GZIP
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
@@ -350,6 +354,7 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag
 			do_reset (cmdtp, flag, argc, argv);
 		}
 		break;
+#endif /* CONFIG_REMOVE_GZIP */
 #ifdef CONFIG_BZIP2
 	case IH_COMP_BZIP2:
 		printf ("   Uncompressing %s ... ", name);
@@ -369,6 +374,18 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#ifdef CONFIG_LZMA
+	case IH_COMP_LZMA:
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
+		if (i != LZMA_RESULT_OK) {
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			udelay(100000);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#endif /* CONFIG_LZMA */
 	default:
 		if (iflag)
 			enable_interrupts();
@@ -1176,6 +1193,8 @@ U_BOOT_CMD(
 );
 #endif	/* CFG_CMD_IMLS */
 
+#endif	/* ! CFG_HEAD_CODE */
+
 void
 print_image_hdr (image_header_t *hdr)
 {
@@ -1270,12 +1289,15 @@ print_type (image_header_t *hdr)
 	case IH_COMP_NONE:	comp = "uncompressed";		break;
 	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
 	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:      comp = "lzma compressed";       break;
 	default:		comp = "unknown compression";	break;
 	}
 
 	printf ("%s %s %s (%s)", arch, os, type, comp);
 }
 
+#ifndef CFG_HEAD_CODE
+
 #define	ZALLOC_ALIGNMENT	16
 
 static void *zalloc(void *x, unsigned items, unsigned size)
@@ -1427,3 +1449,5 @@ do_bootm_lynxkdi (cmd_tbl_t *cmdtp, int 
 }
 
 #endif /* CONFIG_LYNXKDI */
+
+#endif /* ! CFG_HEAD_CODE */
--- a/common/cmd_flash.c
+++ b/common/cmd_flash.c
@@ -196,9 +196,17 @@ addr_spec(char *arg1, char *arg2, ulong 
 }
 
 static int
-flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
-			int *s_first, int *s_last,
-			int *s_count )
+flash_fill_sect_ranges(
+	ulong *addr_first_sect_start,
+	ulong addr_first,
+	ulong *addr_last_sect_end,
+	ulong addr_last,
+	int *s_first,
+	int *s_last,
+	int *bPartialStart,
+	int *bPartialEnd,
+	int *s_count,
+	unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -211,9 +219,7 @@ flash_fill_sect_ranges (ulong addr_first
 		s_last [bank] = -1;	/* last  sector to erase	*/
 	}
 
-	for (bank=0,info=&flash_info[0];
-	     (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last);
-	     ++bank, ++info) {
+	for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last); ++bank, ++info) {
 		ulong b_end;
 		int sect;
 		short s_end;
@@ -225,7 +231,6 @@ flash_fill_sect_ranges (ulong addr_first
 		b_end = info->start[0] + info->size - 1;	/* bank end addr */
 		s_end = info->sector_count - 1;			/* last sector   */
 
-
 		for (sect=0; sect < info->sector_count; ++sect) {
 			ulong end;	/* last address in current sect	*/
 
@@ -238,11 +243,21 @@ flash_fill_sect_ranges (ulong addr_first
 
 			if (addr_first == info->start[sect]) {
 				s_first[bank] = sect;
+			} else if (addr_first > info->start[sect] && addr_first <= end && bPartialErase) {
+				*addr_first_sect_start = info->start[sect];
+				s_first[bank] = sect;
+				*bPartialStart = 1;
 			}
+
 			if (addr_last  == end) {
 				s_last[bank]  = sect;
+			} else if (addr_last >= info->start[sect] && addr_last < end && bPartialErase) {
+				*addr_last_sect_end = end;
+				s_last[bank] = sect;
+				*bPartialEnd = 1;
 			}
 		}
+
 		if (s_first[bank] >= 0) {
 			if (s_last[bank] < 0) {
 				if (addr_last > b_end) {
@@ -316,6 +331,8 @@ int do_flerase (cmd_tbl_t *cmdtp, int fl
 	struct part_info *part;
 	u8 dev_type, dev_num, pnum;
 #endif
+	unsigned int bPartialErase = 0;
+
 	int rcode = 0;
 
 	if (argc < 2) {
@@ -369,7 +386,7 @@ int do_flerase (cmd_tbl_t *cmdtp, int fl
 	}
 #endif
 
-	if (argc != 3) {
+	if (argc != 4) {
 		printf ("Usage:\n%s\n", cmdtp->usage);
 		return 1;
 	}
@@ -397,11 +414,117 @@ int do_flerase (cmd_tbl_t *cmdtp, int fl
 		return 1;
 	}
 
-	rcode = flash_sect_erase(addr_first, addr_last);
+	printf ("Erase Flash from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+	if(argc == 4) {
+		bPartialErase = simple_strtoul(argv[3], NULL, 10);
+	}
+
+	rcode = flash_sect_erase(addr_first, addr_last, bPartialErase);
 	return rcode;
 }
 
-int flash_sect_erase (ulong addr_first, ulong addr_last)
+int flerase_Partial(
+	ulong addr_first_sect_start,
+	ulong addr_first,
+	ulong addr_last_sect_end,
+	ulong addr_last,
+	flash_info_t *info,
+	int first_sect,
+	int last_sect,
+	int bFirstPartial,
+	int bLastPartial) {
+	unsigned int firstMemLen = 0;
+	unsigned int lastMemLen = 0;
+	unsigned int sectMemLen = 0;
+	uchar *pSavedFirstMem = NULL;
+	uchar *pSavedLastMem = NULL;
+	uchar *pSavedSectMem = NULL;
+	int bSectPartial = 0;
+	int rt_code = 0;
+
+	debug("%s ... 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%p, %d, %d, %d, %d\n", __FUNCTION__, addr_first_sect_start, addr_first, addr_last_sect_end, addr_last, info, first_sect, last_sect, bFirstPartial, bLastPartial);
+
+	if (bFirstPartial && bLastPartial && (first_sect == last_sect))
+	{
+		ulong b_end = info->start[0] + info->size - 1;
+		ulong end = (first_sect == (info->sector_count - 1)) ? b_end : info->start[first_sect + 1] - 1;
+		sectMemLen = end - info->start[first_sect] + 1;
+		pSavedSectMem = (uchar *)calloc(sectMemLen, sizeof(char));
+		if (pSavedSectMem == NULL)
+		{
+			debug("calloc %u FAILED\n", sectMemLen);
+			rt_code = 1;
+			goto ret;
+		}
+		memset(pSavedSectMem, 0xff, sectMemLen);
+		bSectPartial = 1;
+		memcpy(pSavedSectMem, (uchar *)addr_first_sect_start, addr_first - addr_first_sect_start);
+		memcpy(pSavedSectMem + (addr_last - info->start[first_sect]) + 1, addr_last + 1, end - addr_last);
+	}
+	else
+	{
+		if (bFirstPartial){
+			firstMemLen = addr_first - addr_first_sect_start + 1;
+			pSavedFirstMem = (uchar *)calloc(firstMemLen,sizeof(char));
+			memcpy(pSavedFirstMem,(uchar *)addr_first_sect_start,firstMemLen - 1);
+		}
+		if (bLastPartial){
+			lastMemLen = addr_last_sect_end - addr_last + 1;
+			pSavedLastMem = (uchar *)calloc(lastMemLen,sizeof(char));
+			memcpy(pSavedLastMem,(uchar *)addr_last + 1,lastMemLen - 1);
+		}
+	}
+
+	if (bFirstPartial){
+		if(flash_erase (info, first_sect, first_sect)) {
+			printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, first_sect);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("%s ... erase sector %d done!\n", __FUNCTION__, first_sect);
+	}
+
+	if (bLastPartial && first_sect != last_sect){
+		if(flash_erase (info, last_sect, last_sect)) {
+			printf("%s ... Couldn't erase sector %d\n", __FUNCTION__, last_sect);
+			rt_code = 1;
+			goto ret;
+		}
+		debug("%s ... erase sector %d done!\n", __FUNCTION__, last_sect);
+	}
+
+	if (bFirstPartial && bLastPartial && (first_sect == last_sect))
+	{
+		flash_write(pSavedSectMem, (uchar *)addr_first_sect_start, sectMemLen);
+		debug("flash_write from 0x%08x with len %u\n", addr_first_sect_start, sectMemLen);
+	}
+	else
+	{
+		if (bFirstPartial){
+			if(flash_write(pSavedFirstMem,(uchar *)addr_first_sect_start,firstMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_first_sect_start,firstMemLen - 1);
+				rt_code = 1;
+				goto ret;
+			}
+		}
+		if (bLastPartial){
+			if(flash_write(pSavedLastMem,(uchar *)addr_last + 1,lastMemLen - 1)) {
+				printf("%s ... Couldn't write at 0x%08lx length %d\n", __FUNCTION__, addr_last, lastMemLen - 1);
+				rt_code = 1;
+			}
+		}
+	}
+ret:
+	if (bFirstPartial)
+		free(pSavedFirstMem);
+	if (bLastPartial)
+		free(pSavedLastMem);
+	if (bSectPartial)
+		free(pSavedSectMem);
+	return rt_code;
+}
+
+int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase)
 {
 	flash_info_t *info;
 	ulong bank;
@@ -413,27 +536,66 @@ int flash_sect_erase (ulong addr_first, 
 	int erased = 0;
 	int planned;
 	int rcode = 0;
-
-	rcode = flash_fill_sect_ranges (addr_first, addr_last,
-					s_first, s_last, &planned );
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			bPartialErase );
 
 	if (planned && (rcode == 0)) {
-		for (bank=0,info=&flash_info[0];
-		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
-		     ++bank, ++info) {
+		for (bank=0, info=&flash_info[0]; (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0); ++bank, ++info) {
+			ulong b_end = info->start[0] + info->size - 1;	/* bank end addr */
 			if (s_first[bank]>=0) {
-				erased += s_last[bank] - s_first[bank] + 1;
-				debug ("Erase Flash from 0x%08lx to 0x%08lx "
-					"in Bank # %ld ",
-					info->start[s_first[bank]],
-					(s_last[bank] == info->sector_count) ?
-						info->start[0] + info->size - 1:
-						info->start[s_last[bank]+1] - 1,
-					bank+1);
-				rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				if(bPartialErase) {
+					rcode = flerase_Partial(
+							addr_first_sect_start,
+							addr_first,
+							addr_last_sect_end,
+							addr_last,
+							info,
+							s_first[bank],
+							s_last[bank],
+							bPartialStart,
+							bPartialEnd);
+				}
+
+				//Erase full sectores
+				if (bPartialStart)
+					s_first[bank] += 1;
+				if (bPartialEnd)
+					s_last[bank] -= 1;
+				if (s_last[bank] >= s_first[bank]) {
+					erased += s_last[bank] - s_first[bank] + 1;
+					debug ("Erase Flash from 0x%08lx to 0x%08lx in Bank # %ld ",
+						info->start[s_first[bank]],
+						(s_last[bank] == info->sector_count) ?
+							info->start[0] + info->size - 1:
+							info->start[s_last[bank]+1] - 1,
+						bank + 1);
+					rcode = flash_erase (info, s_first[bank], s_last[bank]);
+				}
 			}
 		}
-		printf ("Erased %d sectors\n", erased);
+
+		if (erased && !bPartialErase) {
+			printf ("Erased %d sectors\n", erased);
+		} else if (bPartialErase){
+			printf ("Partial erased from 0x%08lx to 0x%08lx\n", addr_first, addr_last);
+		} else {
+			printf ("Error: start and/or end address not on sector boundary\n");
+			rcode = 1;
+		}
 	} else if (rcode == 0) {
 		puts ("Error: start and/or end address"
 			" not on sector boundary\n");
@@ -629,8 +791,22 @@ int flash_sect_protect (int p, ulong add
 	int protected, i;
 	int planned;
 	int rcode;
-
-	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
+	int bPartialStart = 0;		// Start sector has to be erased partially
+	int bPartialEnd = 0;		// End sector has to be erased partially
+	ulong addr_first_sect_start = 0;// Sector start address of location addr_start
+	ulong addr_last_sect_end = 0;	// Sector end address of location addr_last
+
+	rcode = flash_fill_sect_ranges (
+			&addr_first_sect_start,
+			addr_first,
+			&addr_last_sect_end,
+			addr_last,
+			s_first,
+			s_last,
+			&bPartialStart,
+			&bPartialEnd,
+			&planned,
+			1 );
 
 	protected = 0;
 
@@ -690,7 +866,7 @@ U_BOOT_CMD(
 );
 
 U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
+	erase,   4,   1,  do_flerase,
 	"erase   - erase FLASH memory\n",
 	"start end\n"
 	"    - erase FLASH from addr 'start' to addr 'end'\n"
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -540,8 +540,19 @@ int do_saveenv (cmd_tbl_t *cmdtp, int fl
 	extern char * env_name_spec;
 
 	printf ("Saving Environment to %s...\n", env_name_spec);
-
+#if 1
+	if(saveenv() == 0) {
+#ifdef UBOOT_ENV_COPY
+		saveenv_copy();
+#else
+		;
+#endif //UBOOT_ENV_COPY
+	} else
+		return 1;
+	return 0;
+#else
 	return (saveenv() ? 1 : 0);
+#endif
 }
 
 
--- a/common/console.c
+++ b/common/console.c
@@ -324,7 +324,7 @@ inline void dbg(const char *fmt, ...)
 #endif
 
 /** U-Boot INIT FUNCTIONS *************************************************/
-
+#ifndef CFG_HEAD_CODE
 int console_assign (int file, char *devname)
 {
 	int flag, i;
@@ -357,7 +357,7 @@ int console_assign (int file, char *devn
 
 	return -1;
 }
-
+#endif	//CFG_HEAD_CODE
 /* Called before relocation - use serial functions */
 int console_init_f (void)
 {
@@ -392,6 +392,7 @@ device_t *search_device (int flags, char
 }
 #endif /* CFG_CONSOLE_IS_IN_ENV || CONFIG_SPLASH_SCREEN */
 
+#ifndef CFG_HEAD_CODE
 #ifdef CFG_CONSOLE_IS_IN_ENV
 /* Called after the relocation - use desired console functions */
 int console_init_r (void)
@@ -570,3 +571,4 @@ int console_init_r (void)
 }
 
 #endif /* CFG_CONSOLE_IS_IN_ENV */
+#endif	//CFG_HEAD_CODE
--- a/common/devices.c
+++ b/common/devices.c
@@ -39,6 +39,7 @@ DECLARE_GLOBAL_DATA_PTR;
 list_t devlist = 0;
 device_t *stdio_devices[] = { NULL, NULL, NULL };
 char *stdio_names[MAX_FILES] = { "stdin", "stdout", "stderr" };
+#ifndef CFG_HEAD_CODE
 
 #if defined(CONFIG_SPLASH_SCREEN) && !defined(CFG_DEVICE_NULLDEV)
 #define	CFG_DEVICE_NULLDEV	1
@@ -214,3 +215,5 @@ int devices_done (void)
 
 	return 0;
 }
+#endif //CFG_HEAD_CODE
+
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -219,7 +219,9 @@ void env_relocate (void)
 	 * We must allocate a buffer for the environment
 	 */
 	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
-	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
+	if(!env_ptr)
+		DEBUGF ("malloc env_ptr error!!\n");
+	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__, __LINE__, env_ptr);
 #endif
 
 	/*
@@ -227,6 +229,10 @@ void env_relocate (void)
 	 */
 	env_get_char = env_get_char_memory;
 
+	//leejack
+	DEBUGF ("%s[%d] gd->env_valid=%d\n", __FUNCTION__, __LINE__, gd->env_valid);
+	DEBUGF ("%s[%d] CFG_ENV_SIZE=%d\n", __FUNCTION__, __LINE__, CFG_ENV_SIZE);
+
 	if (gd->env_valid == 0) {
 #if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
@@ -242,18 +248,17 @@ void env_relocate (void)
 		}
 
 		memset (env_ptr, 0, sizeof(env_t));
-		memcpy (env_ptr->data,
-			default_environment,
-			sizeof(default_environment));
+		memcpy (env_ptr->data, default_environment, sizeof(default_environment));
+
 #ifdef CFG_REDUNDAND_ENVIRONMENT
 		env_ptr->flags = 0xFF;
 #endif
 		env_crc_update ();
 		gd->env_valid = 1;
-	}
-	else {
+	} else {
 		env_relocate_spec ();
 	}
+
 	gd->env_addr = (ulong)&(env_ptr->data);
 
 #ifdef CONFIG_AMIGAONEG3SE
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -66,7 +66,6 @@ static env_t *flash_addr = (env_t *)CFG_
 #endif
 
 #else /* ! ENV_IS_EMBEDDED */
-
 env_t *env_ptr = (env_t *)CFG_ENV_ADDR;
 #ifdef CMD_SAVEENV
 static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
@@ -201,6 +200,7 @@ int saveenv(void)
 	debug (" %08lX ... %08lX ...",
 		(ulong)&(flash_addr_new->data),
 		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
+
 	if ((rc = flash_write((char *)env_ptr->data,
 			(ulong)&(flash_addr_new->data),
 			sizeof(env_ptr->data))) ||
@@ -256,7 +256,6 @@ Done:
 #endif /* CMD_SAVEENV */
 
 #else /* ! CFG_ENV_ADDR_REDUND */
-
 int  env_init(void)
 {
 #ifdef CONFIG_OMAP2420H4
@@ -280,6 +279,52 @@ bad_flash:
 
 #ifdef CMD_SAVEENV
 
+#ifdef UBOOT_ENV_COPY
+int saveenv_copy(void) {
+	uchar *env_buffer = (char *)env_ptr;
+	char *kernel_addr;
+	char *rootfs_addr;
+	char *rootfs_size;
+	ulong start_addr,end_addr,rootfs_end_addr;
+	ulong flash_start;
+
+	kernel_addr = getenv("f_kernel_addr");
+	end_addr = simple_strtoul(kernel_addr,NULL,16) - 1;
+	start_addr = end_addr - CFG_ENV_SIZE - sizeof(UBOOTCONFIG_COPY_HEADER) + 1;
+
+	rootfs_addr = getenv("f_rootfs_addr");
+	rootfs_size = getenv("f_rootfs_size");
+	rootfs_end_addr = simple_strtoul(rootfs_addr,NULL,16) + simple_strtoul(rootfs_size,NULL,16);
+
+	if(rootfs_end_addr >= start_addr)
+	{
+		printf("Can not copy the environment at 0x%08lx as no space left.\nf_kernel_addr = 0x%08lx while rootfs_end_addr = 0x%08lx\n",start_addr,end_addr,rootfs_end_addr);
+		return 1;
+	}
+
+	debug ("Protect off %08lX ... %08lX\n", (ulong)rootfs_end_addr, end_addr);
+	if (flash_sect_protect (0, rootfs_end_addr, end_addr))
+		return 1;
+
+	//delete the old environment copy, if found
+	flash_start = rootfs_end_addr;
+	while(flash_start + sizeof(UBOOTCONFIG_COPY_HEADER) + ENV_SIZE < end_addr)
+	{
+		if(strncmp((char *)flash_start,UBOOTCONFIG_COPY_HEADER,sizeof(UBOOTCONFIG_COPY_HEADER)) == 0)
+		{
+			flash_sect_erase(flash_start,flash_start + sizeof(UBOOTCONFIG_COPY_HEADER),1);
+		}
+		flash_start += 1;
+	}
+	flash_sect_erase(start_addr,end_addr,1);
+	flash_write(UBOOTCONFIG_COPY_HEADER,start_addr,sizeof(UBOOTCONFIG_COPY_HEADER));
+	flash_write(env_buffer,start_addr + sizeof(UBOOTCONFIG_COPY_HEADER), CFG_ENV_SIZE);
+	flash_sect_protect (1, rootfs_end_addr, end_addr);
+	printf("saved copy of the env at 0x%08lx\n",start_addr);
+	return 0;
+}
+#endif	//UBOOT_ENV_COPY
+
 int saveenv(void)
 {
 	int	len, rc;
@@ -331,7 +376,7 @@ int saveenv(void)
 		return 1;
 
 	puts ("Erasing Flash...");
-	if (flash_sect_erase (flash_sect_addr, end_addr))
+	if (flash_sect_erase (flash_sect_addr, end_addr, 1))
 		return 1;
 
 	puts ("Writing to Flash... ");
--- a/config.mk
+++ b/config.mk
@@ -127,10 +127,15 @@ OBJCOPY = $(CROSS_COMPILE)objcopy
 OBJDUMP = $(CROSS_COMPILE)objdump
 RANLIB	= $(CROSS_COMPILE)RANLIB
 
+ifneq (,$(findstring s,$(MAKEFLAGS)))
+ARFLAGS = cr
+else
 ARFLAGS = crv
+endif
 RELFLAGS= $(PLATFORM_RELFLAGS)
 DBGFLAGS= -g # -DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
+OWRT_FLAGS?=
 ifndef LDSCRIPT
 #LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug
 ifeq ($(CONFIG_NAND_U_BOOT),y)
@@ -139,12 +144,15 @@ else
 LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
 endif
 endif
+
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARDDIR)/u-boot-bootstrap.lds
+
 OBJCFLAGS += --gap-fill=0xff
 
 gccincdir := $(shell $(CC) -print-file-name=include)
 
-CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
-	-D__KERNEL__ -DTEXT_BASE=$(TEXT_BASE)		\
+CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)	$(OWRT_FLAGS)	\
+	-D__KERNEL__ -DUBOOT_RAM_TEXT_BASE=$(UBOOT_RAM_TEXT_BASE)		\
 
 ifneq ($(OBJTREE),$(SRCTREE))
 CPPFLAGS += -I$(OBJTREE)/include2 -I$(OBJTREE)/include
@@ -180,7 +188,8 @@ endif
 
 AFLAGS := $(AFLAGS_DEBUG) -D__ASSEMBLY__ $(CPPFLAGS)
 
-LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(UBOOT_RAM_TEXT_BASE) $(PLATFORM_LDFLAGS)
+LDFLAGS_BOOTSTRAP += -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(BOOTSTRAP_TEXT_BASE) $(PLATFORM_LDFLAGS)
 
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
@@ -214,12 +223,19 @@ endif
 export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
 	AS LD CC CPP AR NM STRIP OBJCOPY OBJDUMP \
 	MAKE
-export	TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
+export	UBOOT_RAM_TEXT_BASE BOOTSTRAP_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
 
 #########################################################################
 
 ifndef REMOTE_BUILD
 
+%_bootstrap.s:	%_bootstrap.S
+	$(CPP) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -o $@ $<
+%_bootstrap.o:	%_bootstrap.S
+	$(CC) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+%_bootstrap.o:	%_bootstrap.c
+	$(CC) $(CFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+
 %.s:	%.S
 	$(CPP) $(AFLAGS) -o $@ $<
 %.o:	%.S
@@ -229,12 +245,20 @@ ifndef REMOTE_BUILD
 
 else
 
+$(obj)%_bootstrap.s:	%_bootstrap.S
+	$(CPP) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -o $@ $<
+$(obj)%_bootstrap.o:	%_bootstrap.S
+	$(CC) $(AFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+$(obj)%_bootstrap.o:	%_bootstrap.c
+	$(CC) $(CFLAGS) -DCFG_BOOTSTRAP_CODE -c -o $@ $<
+
 $(obj)%.s:	%.S
 	$(CPP) $(AFLAGS) -o $@ $<
 $(obj)%.o:	%.S
 	$(CC) $(AFLAGS) -c -o $@ $<
 $(obj)%.o:	%.c
 	$(CC) $(CFLAGS) -c -o $@ $<
+
 endif
 
 #########################################################################
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -50,7 +50,7 @@ COBJS	= 3c589.o 5701rls.o ali512x.o \
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
-	  rpx_pcmcia.o
+	  rpx_pcmcia.o ifx_sw.o
 
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -48,6 +48,7 @@
 #define CP0_CAUSE $13
 #define CP0_EPC $14
 #define CP0_PRID $15
+#define CP0_EBASE $15,1
 #define CP0_CONFIG $16
 #define CP0_LLADDR $17
 #define CP0_WATCHLO $18
@@ -330,11 +331,32 @@ __BUILD_SET_CP0(config,CP0_CONFIG)
 #  define KSU_USER		0x00000010
 #  define KSU_SUPERVISOR	0x00000008
 #  define KSU_KERNEL		0x00000000
+#ifdef CONFIG_DANUBE	/* MIPS 24KE */
+/* bits 5 & 6 & 7: reserved */
+/* bits 8~15: IM0~7 */
+/* bits 16: reserved */
+#define ST0_CEE			0x00020000
+/* bits 18: always 0 */
+#define ST0_NMI			0x00080000
+#define ST0_SR			0x00100000
+#define ST0_TS			0x00200000
+#define ST0_BEV			0x00400000
+/* bits 23: reserved */
+#define ST0_MX			0x01000000
+#define ST0_RE			0x02000000
+#define ST0_FR			0x04000000
+#define ST0_RP			0x08000000
+#define ST0_CU0			0x10000000
+#define ST0_CU1			0x20000000
+#define ST0_CU2			0x40000000
+#define ST0_CU3			0x80000000
+#else
 #define ST0_UX			0x00000020
 #define ST0_SX			0x00000040
 #define ST0_KX 			0x00000080
 #define ST0_DE			0x00010000
 #define ST0_CE			0x00020000
+#endif
 
 /*
  * Bitfields in the R[23]000 cp0 status register.
@@ -471,6 +493,14 @@ __BUILD_SET_CP0(config,CP0_CONFIG)
 #define  CAUSEF_BD		(1   << 31)
 
 /*
+ * Bits in the coprocessor 0 EBase register
+ */
+#define EBASEB_CPUNUM		0
+#define EBASEF_CPUNUM		(0x3ff << EBASEB_CPUNUM)
+#define EBASEB_EXPBASE		12
+#define EBASEF_EXPBASE		(0x3ffff << EBASEB_EXPBASE)
+
+/*
  * Bits in the coprozessor 0 config register.
  */
 #define CONF_CM_CACHABLE_NO_WA		0
@@ -544,4 +574,10 @@ __BUILD_SET_CP0(config,CP0_CONFIG)
 #define CEB_KERNEL	2	/* Count events in kernel mode EXL = ERL = 0 */
 #define CEB_EXL		1	/* Count events with EXL = 1, ERL = 0 */
 
+/*
+ * Bits in ErrCtl register
+ */
+#define ECCB_WST	29
+#define ECCF_WST	(0x1 << ECCB_WST)
+
 #endif /* _ASM_MIPSREGS_H */
--- a/include/cmd_confdefs.h
+++ b/include/cmd_confdefs.h
@@ -94,6 +94,7 @@
 #define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
 #define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
 #define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+#define CFG_CMD_DHRYSTONE	0x8000000000000000ULL	/* Dhrystone benchmark support		*/
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
@@ -141,6 +142,7 @@
 			CFG_CMD_SPI	| \
 			CFG_CMD_UNIVERSE | \
 			CFG_CMD_USB	| \
+			CFG_CMD_DHRYSTONE | \
 			CFG_CMD_VFD	)
 
 /* Default configuration
--- /dev/null
+++ b/include/config.h
@@ -0,0 +1,2 @@
+/* Automatically generated - do not edit */
+#include <configs/danube.h>
--- /dev/null
+++ b/include/config.mk
@@ -0,0 +1,5 @@
+ARCH   = mips
+CPU    = mips
+BOARD  = danube
+VENDOR = ifx
+SOC    = danube
--- a/include/flash.h
+++ b/include/flash.h
@@ -79,7 +79,7 @@ typedef struct {
 extern unsigned long flash_init (void);
 extern void flash_print_info (flash_info_t *);
 extern int flash_erase	(flash_info_t *, int, int);
-extern int flash_sect_erase (ulong addr_first, ulong addr_last);
+extern int flash_sect_erase (ulong addr_first, ulong addr_last, unsigned int bPartialErase);
 extern int flash_sect_protect (int flag, ulong addr_first, ulong addr_last);
 
 /* common/flash.c */
@@ -131,7 +131,9 @@ extern void flash_read_factory_serial(fl
 #define MT2_MANUFACT	0x002C002C	/* alternate MICRON manufacturer ID*/
 #define EXCEL_MANUFACT	0x004A004A	/* Excel Semiconductor			*/
 
-					/* Micron Technologies (INTEL compat.)	*/
+#define	EON_ID_EN29LV320B 0x22f9
+#define FLASH_29LV320B	0xE0
+/* Micron Technologies (INTEL compat.)	*/
 #define MT_ID_28F400_T	0x44704470	/* 28F400B3 ID ( 4 M, top boot sector)	*/
 #define MT_ID_28F400_B	0x44714471	/* 28F400B3 ID ( 4 M, bottom boot sect) */
 
@@ -299,6 +301,10 @@ extern void flash_read_factory_serial(fl
 #define TOSH_ID_FVT160	0xC2		/* TC58FVT160 ID (16 M, top )		*/
 #define TOSH_ID_FVB160	0x43		/* TC58FVT160 ID (16 M, bottom )	*/
 
+#define MX_ID_29LV320AB 0x22A822A8      /* MXIC  MX29LV320AB ID (32 M, bottom ) joelin       */
+#define MX_ID_29LV160BB 0x22492249      /* MXIC  MX29LV160BB ID (16 M, bottom ) joelin       */
+#define MX_ID_29LV640BB 0x22cb22cb      /* MXIC  MX29LV640BB ID (64 M, bottom ) joelin       */
+
 /*-----------------------------------------------------------------------
  * Internal FLASH identification codes
  *
@@ -422,6 +428,10 @@ extern void flash_read_factory_serial(fl
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 #define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
 
+#define FLASH_29LV320AB 0x00B0          /* MXIC MX29LV320AB( 32M = 4M x 16 ) joelin 10/07/2004*/
+#define FLASH_29LV160BB 0x00B1          /* MXIC MX29LV160BB( 16M = 2M x 16 ) joelin 11/22/2004*/
+#define FLASH_29LV640BB 0x00B2          /* MXIC MX29LV640BB( 64M = 8M x 16 ) liupeng*/
+
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
 
--- a/include/image.h
+++ b/include/image.h
@@ -132,6 +132,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+#define IH_COMP_LZMA		3	/* lzma Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
--- /dev/null
+++ b/include/syscall.h
@@ -0,0 +1,42 @@
+#ifndef __MON_SYS_CALL_H__
+#define __MON_SYS_CALL_H__
+
+#ifndef __ASSEMBLY__
+
+#include <common.h>
+
+/* These are declarations of system calls available in C code */
+int  mon_getc(void);
+int  mon_tstc(void);
+void mon_putc(const char);
+void mon_puts(const char*);
+void mon_printf(const char* fmt, ...);
+void mon_install_hdlr(int, interrupt_handler_t*, void*);
+void mon_free_hdlr(int);
+void *mon_malloc(size_t);
+void mon_free(void*);
+void mon_udelay(unsigned long);
+unsigned long mon_get_timer(unsigned long);
+
+#endif    /* ifndef __ASSEMBLY__ */
+
+#define NR_SYSCALLS            11        /* number of syscalls */
+
+
+/*
+ * Make sure these functions are in the same order as they
+ * appear in the "examples/syscall.S" file !!!
+ */
+#define SYSCALL_GETC           0
+#define SYSCALL_TSTC           1
+#define SYSCALL_PUTC           2
+#define SYSCALL_PUTS           3
+#define SYSCALL_PRINTF         4
+#define SYSCALL_INSTALL_HDLR   5
+#define SYSCALL_FREE_HDLR      6
+#define SYSCALL_MALLOC         7
+#define SYSCALL_FREE           8
+#define SYSCALL_UDELAY         9
+#define SYSCALL_GET_TIMER     10
+
+#endif
--- /dev/null
+++ b/ld_uboot.conf
@@ -0,0 +1,8 @@
+TAG_DWNLD()
+{
+   0xA0B00000 "u-boot.bin" /* Download u-boot image */
+};
+TAG_START()
+{
+   0xA0B00000
+}; /* Start u-boot image */
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -28,7 +28,7 @@ LIB	= $(obj)libgeneric.a
 COBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
 	  bzlib_randtable.o bzlib_huffman.o \
 	  crc32.o ctype.o display_options.o ldiv.o \
-	  string.o vsprintf.o zlib.o
+	  string.o vsprintf.o zlib.o LzmaDecode.o LzmaWrapper.o
 
 SRCS 	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
--- a/lib_mips/board.c
+++ b/lib_mips/board.c
@@ -29,9 +29,30 @@
 #include <net.h>
 #include <environment.h>
 
+#ifdef CFG_BOOTSTRAP_CODE
+//#include <asm/danube.h>
+#undef CONFIG_MICROBZIP2
+
+#ifdef CONFIG_BZIP2
+#include <bzlib.h>
+#endif
+
+#ifdef CONFIG_MICROBZIP2
+#include <micro_bzlib.h>
+#endif
+
+#ifdef CONFIG_LZMA
+#include <LzmaWrapper.h>
+#endif
+#endif //CFG_BOOTSTRAP_CODE
+
 DECLARE_GLOBAL_DATA_PTR;
 
-#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < CFG_MONITOR_BASE) || \
+#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < BOOTSTRAP_CFG_MONITOR_BASE) || \
+	(CFG_ENV_ADDR >= (BOOTSTRAP_CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
+    defined(CFG_ENV_IS_IN_NVRAM) && defined(CFG_BOOTSTRAP_CODE)
+#define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
+#elif ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < CFG_MONITOR_BASE) || \
       (CFG_ENV_ADDR >= (CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
     defined(CFG_ENV_IS_IN_NVRAM)
 #define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
@@ -39,21 +60,24 @@ DECLARE_GLOBAL_DATA_PTR;
 #define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
 #endif
 
-#undef DEBUG
-
 extern int timer_init(void);
-
 extern int incaip_set_cpuclk(void);
 
+#ifdef CFG_BOOTSTRAP_CODE
+extern ulong uboot_end_data_bootstrap;
+extern ulong uboot_end_bootstrap;
+#else //CFG_BOOTSTRAP_CODE
 extern ulong uboot_end_data;
 extern ulong uboot_end;
+#endif //CFG_BOOTSTRAP_CODE
 
 ulong monitor_flash_len;
 
-const char version_string[] =
-	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+const char version_string[] = U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 static char *failed = "*** failed ***\n";
+#endif
 
 /*
  * Begin and End of memory area for malloc(), and current "brk"
@@ -62,14 +86,15 @@ static ulong mem_malloc_start;
 static ulong mem_malloc_end;
 static ulong mem_malloc_brk;
 
-
 /*
  * The Malloc area is immediately below the monitor copy in DRAM
  */
-static void mem_malloc_init (void)
-{
+#ifdef CFG_BOOTSTRAP_CODE
+static void mem_malloc_init (ulong dest_addr) {
+#else //CFG_BOOTSTRAP_CODE
+static void mem_malloc_init (void) {
 	ulong dest_addr = CFG_MONITOR_BASE + gd->reloc_off;
-
+#endif //CFG_BOOTSTRAP_CODE
 	mem_malloc_end = dest_addr;
 	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
 	mem_malloc_brk = mem_malloc_start;
@@ -79,6 +104,25 @@ static void mem_malloc_init (void)
 		mem_malloc_end - mem_malloc_start);
 }
 
+#ifdef CFG_BOOTSTRAP_CODE
+void *malloc(unsigned int size) {
+	if(size < (mem_malloc_end - mem_malloc_start)) {
+		mem_malloc_start += size;
+		debug ("malloc : size required = 0x%08lx and pointer = 0x%08lx\n",size,mem_malloc_start - size);
+		return (void *)(mem_malloc_start - size);
+	}
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size) {
+	return NULL;
+}
+
+void free(void *src) {
+	return;
+}
+#endif //CFG_BOOTSTRAP_CODE
+
 void *sbrk (ptrdiff_t increment)
 {
 	ulong old = mem_malloc_brk;
@@ -99,42 +143,58 @@ static int init_func_ram (void)
 #else
 	int board_type = 0;	/* use dummy arg */
 #endif
-	puts ("DRAM:  ");
 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+#ifdef CONFIG_USE_DDR_RAM
+	puts ("DDR-DRAM:  ");
+#else
+	puts ("DRAM:  ");
+#endif
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	if ((gd->ram_size = initdram (board_type)) > 0) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 		print_size (gd->ram_size, "\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 		return (0);
 	}
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	puts (failed);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	return (1);
 }
 
+#if !defined(CFG_BOOTSTRAP_CODE) || defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF)
 static int display_banner(void)
 {
-
 	printf ("\n\n%s\n\n", version_string);
 	return (0);
 }
+#endif
 
+#ifndef CFG_BOOTSTRAP_CODE
 static void display_flash_config(ulong size)
 {
 	puts ("Flash: ");
 	print_size (size, "\n");
 }
+#endif //CFG_BOOTSTRAP_CODE
 
-
+#if !defined(CFG_BOOTSTRAP_CODE) || defined(DEBUG_ENABLE_BOOTSTRAP_PRINTF)
 static int init_baudrate (void)
 {
+#ifndef CFG_BOOTSTRAP_CODE
 	char tmp[64];	/* long enough for environment variables */
 	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
 
 	gd->baudrate = (i > 0)
 			? (int) simple_strtoul (tmp, NULL, 10)
 			: CONFIG_BAUDRATE;
-
+#else //CFG_BOOTSTRAP_CODE
+	gd->baudrate = CONFIG_BAUDRATE;
+#endif //CFG_BOOTSTRAP_CODE
 	return (0);
 }
-
+#endif
 
 /*
  * Breath some life into the board...
@@ -159,27 +219,49 @@ static int init_baudrate (void)
 typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
+#ifdef CFG_BOOTSTRAP_CODE
+	//fuse_prg,
+	//timer_init,
+	//env_init,		/* initialize environment */
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,
+	display_banner,		/* say that we are here */
+	checkboard,
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	init_func_ram,
+	NULL,
+#else /********** CFG_BOOTSTRAP_CODE **********/
 	timer_init,
-	env_init,		/* initialize environment */
-#ifdef CONFIG_INCA_IP
-	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
-#endif
 	init_baudrate,		/* initialze baudrate settings */
 	serial_init,		/* serial communications setup */
 	console_init_f,
 	display_banner,		/* say that we are here */
 	checkboard,
 	init_func_ram,
+	env_init,               /* initialize environment */
 	NULL,
+#endif //CFG_BOOTSTRAP_CODE
 };
 
+#ifdef CFG_BOOTSTRAP_CODE
+extern void bootstrap_relocate_code(ulong addr_sp, gd_t *id, ulong addr);
 
+void bootstrap_board_init_f(ulong bootflag)
+#else
 void board_init_f(ulong bootflag)
+#endif
 {
 	gd_t gd_data, *id;
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
-	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
+#ifdef CFG_BOOTSTRAP_CODE
+	ulong addr, addr_sp, len = (ulong)&uboot_end_bootstrap - BOOTSTRAP_CFG_MONITOR_BASE;
+	ulong lzmaImageaddr = 0;
+#else //CFG_BOOTSTRAP_CODE
+	ulong addr, addr_sp, len = CFG_MONITOR_LEN;
+#endif //CFG_BOOTSTRAP_CODE
 	ulong *s;
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
@@ -219,13 +301,12 @@ void board_init_f(ulong bootflag)
 	addr -= len;
 	addr &= ~(16 * 1024 - 1);
 
-	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+	debug ("Reserving %d Bytes for U-Boot at: %08lx\n", len, addr);
 
 	 /* Reserve memory for malloc() arena.
 	 */
 	addr_sp = addr - TOTAL_MALLOC_LEN;
-	debug ("Reserving %dk for malloc() at: %08lx\n",
-			TOTAL_MALLOC_LEN >> 10, addr_sp);
+	debug ("Reserving %d Bytes for malloc() at: %08lx\n", TOTAL_MALLOC_LEN, addr_sp);
 
 	/*
 	 * (permanently) allocate a Board Info struct
@@ -234,20 +315,17 @@ void board_init_f(ulong bootflag)
 	addr_sp -= sizeof(bd_t);
 	bd = (bd_t *)addr_sp;
 	gd->bd = bd;
-	debug ("Reserving %d Bytes for Board Info at: %08lx\n",
-			sizeof(bd_t), addr_sp);
+	debug ("Reserving %d Bytes for Board Info at: %08lx\n",	sizeof(bd_t), addr_sp);
 
 	addr_sp -= sizeof(gd_t);
 	id = (gd_t *)addr_sp;
-	debug ("Reserving %d Bytes for Global Data at: %08lx\n",
-			sizeof (gd_t), addr_sp);
+	debug ("Reserving %d Bytes for Global Data at: %08lx\n", sizeof (gd_t), addr_sp);
 
  	/* Reserve memory for boot params.
 	 */
 	addr_sp -= CFG_BOOTPARAMS_LEN;
 	bd->bi_boot_params = addr_sp;
-	debug ("Reserving %dk for boot params() at: %08lx\n",
-			CFG_BOOTPARAMS_LEN >> 10, addr_sp);
+	debug ("Reserving %dk for boot params() at: %08lx\n", CFG_BOOTPARAMS_LEN >> 10, addr_sp);
 
 	/*
 	 * Finally, we set up a new (bigger) stack.
@@ -279,7 +357,16 @@ void board_init_f(ulong bootflag)
 	copy_code(addr);
 #endif
 
+#ifdef CFG_BOOTSTRAP_CODE
+	lzmaImageaddr = (ulong)&uboot_end_data_bootstrap;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts("\n BOOTSTRAP: relocate_code start");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	bootstrap_relocate_code (addr_sp, id, addr);
+#else //CFG_BOOTSTRAP_CODE
+	puts("\n relocate_code start");
 	relocate_code (addr_sp, id, addr);
+#endif //CFG_BOOTSTRAP_CODE
 
 	/* NOTREACHED - relocate_code() does not return */
 }
@@ -292,7 +379,110 @@ void board_init_f(ulong bootflag)
  *
  ************************************************************************
  */
+#ifdef CFG_BOOTSTRAP_CODE
+void bootstrap_board_init_r (gd_t *id, ulong dest_addr) {
+	int i;
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	unsigned int destLen;
+	int (*fn)(void);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts("\n BOOTSTRAP: relocate_code finish.\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+	/* initialize malloc() area */
+	mem_malloc_init(dest_addr);
+
+	addr = (char *)(BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr));
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Magic Number at address 0x%08lx\n",addr);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
 
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+	if (crc32 (0, (unsigned char *)data, len) != checksum) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Header Checksum\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+	len_ptr = (ulong *)data;
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Disabling all the interrupts\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	disable_interrupts();
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("   Uncompressing UBoot Image ... \n" );
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	/*
+	 * If we've got less than 4 MB of malloc() space,
+	 * use slower decompression algorithm which requires
+	 * at most 2300 KB of memory.
+	 */
+	destLen = 0x0;
+
+#ifdef CONFIG_BZIP2
+	i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					0x400000, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != BZ_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+			printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+			return;
+	}
+#elif CONFIG_MICROBZIP2
+	i = micro_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+					&destLen, (char *)data, len,
+					CFG_MALLOC_LEN < (4096 * 1024), 0);
+	if (i != RETVAL_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("MICRO_BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+#elif CONFIG_LZMA
+	i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+	if (i != LZMA_RESULT_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		return;
+	}
+#else
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("NONE Compressing u-boot body!!\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	memmove ((void *)ntohl(hdr->ih_load), (uchar *)data, len);
+	destLen = len;
+#endif
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("   Uncompression completed successfully with destLen %d.\n ",destLen );
+	debug ("Head: Jumping to u-boot in the ram at 0x%08lx\n", CFG_MONITOR_BASE);
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+	fn = ntohl(hdr->ih_load);
+	(*fn)();
+	hang ();
+}
+#else //CFG_BOOTSTRAP_CODE
 void board_init_r (gd_t *id, ulong dest_addr)
 {
 	cmd_tbl_t *cmdtp;
@@ -305,6 +495,8 @@ void board_init_r (gd_t *id, ulong dest_
 	bd_t *bd;
 	int i;
 
+	puts("\n relocate_code finish.\n");
+
 	gd = id;
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 
@@ -321,12 +513,10 @@ void board_init_r (gd_t *id, ulong dest_
 		ulong addr;
 
 		addr = (ulong) (cmdtp->cmd) + gd->reloc_off;
-#if 0
-		printf ("Command \"%s\": 0x%08lx => 0x%08lx\n",
-				cmdtp->name, (ulong) (cmdtp->cmd), addr);
-#endif
-		cmdtp->cmd =
-			(int (*)(struct cmd_tbl_s *, int, int, char *[]))addr;
+
+		debug ("Command \"%s\": 0x%08lx => 0x%08lx\n", cmdtp->name, (ulong) (cmdtp->cmd), addr);
+
+		cmdtp->cmd = (int (*)(struct cmd_tbl_s *, int, int, char *[]))addr;
 
 		addr = (ulong)(cmdtp->name) + gd->reloc_off;
 		cmdtp->name = (char *)addr;
@@ -363,7 +553,13 @@ void board_init_r (gd_t *id, ulong dest_
 	/* initialize malloc() area */
 	mem_malloc_init();
 	malloc_bin_reloc();
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	nand_init();	/* go init the NAND */
+#endif
 
+#ifdef CONFIG_SPI
+	spi_init_f();            /* go init the SPI flash */
+#endif
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
@@ -424,9 +620,12 @@ void board_init_r (gd_t *id, ulong dest_
 
 	/* NOTREACHED - no way out of command loop except booting */
 }
+#endif //CFG_BOOTSTRAP_CODE
 
 void hang (void)
 {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	puts ("### ERROR ### Please RESET the board ###\n");
+#endif //DEBUG_ENABLE_BOOTSTRAP_PRINTF
 	for (;;);
 }
--- a/lib_mips/time.c
+++ b/lib_mips/time.c
@@ -80,6 +80,19 @@ void udelay (unsigned long usec)
 		/*NOP*/;
 }
 
+#ifndef CFG_BOOTSTRAP_CODE
+void mdelay (unsigned long msec)
+{
+       int i,j;
+       for(i=0;i<msec;i++)
+       {
+          udelay(1000);
+
+       }
+
+}
+#endif
+
 /*
  * This function is derived from PowerPC code (read timebase as long long).
  * On MIPS it just returns the timer value.
--- a/net/eth.c
+++ b/net/eth.c
@@ -25,6 +25,9 @@
 #include <command.h>
 #include <net.h>
 #include <miiphy.h>
+#if defined(CONFIG_IFX_MIPS)
+#       include "ifx_eth.c"
+#endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_NET) && defined(CONFIG_NET_MULTI)
 
@@ -54,6 +57,9 @@ extern int scc_initialize(bd_t*);
 extern int skge_initialize(bd_t*);
 extern int tsec_initialize(bd_t*, int, char *);
 extern int npe_initialize(bd_t *);
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE_EXTERN
+#endif
 
 static struct eth_device *eth_devices, *eth_current;
 
@@ -235,7 +241,9 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
-
+#if defined(CONFIG_IFX_MIPS)
+	IFX_ETH_INITIALIZE(bis)
+#endif
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 	} else {
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -28,6 +28,7 @@
 #ifndef __WIN32__
 #include <netinet/in.h>		/* for host / network byte order conversions	*/
 #endif
+#include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <time.h>
@@ -138,6 +139,7 @@ table_entry_t comp_name[] = {
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {	IH_COMP_LZMA,	"lzma",		"lzma compressed",	},
     {	-1,		"",		"",			},
 };
 
@@ -445,7 +447,7 @@ NXTARG:		;
 	}
 
 	/* We're a bit of paranoid */
-#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__)
+#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__) && !defined(__APPLE__)
 	(void) fdatasync (ifd);
 #else
 	(void) fsync (ifd);
@@ -495,7 +497,7 @@ NXTARG:		;
 	(void) munmap((void *)ptr, sbuf.st_size);
 
 	/* We're a bit of paranoid */
-#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__)
+#if defined(_POSIX_SYNCHRONIZED_IO) && !defined(__sun__) && !defined(__FreeBSD__) && !defined(__APPLE__)
 	(void) fdatasync (ifd);
 #else
 	(void) fsync (ifd);
--- a/cpu/mips/cache.S
+++ b/cpu/mips/cache.S
@@ -29,7 +29,9 @@
 #include <asm/mipsregs.h>
 #include <asm/addrspace.h>
 #include <asm/cacheops.h>
-
+#if defined(CONFIG_IFX_MIPS)
+#	include "danube/ifx_cache.S"
+#endif
 
 	/* 16KB is the maximum size of instruction and data caches on
 	 * MIPS 4K.
@@ -155,6 +157,9 @@ mips_cache_reset:
 	 */
 
 	mtc0	zero, CP0_TAGLO
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_EXTRA_INVALID_TAG)
+	IFX_CACHE_EXTRA_INVALID_TAG
+#endif
 
    /*
     * The caches are probably in an indeterminate state,
@@ -171,6 +176,9 @@ mips_cache_reset:
 	move	a1, a2
 	icacheopn(a0,a1,a2,a3,121,(Index_Store_Tag_I,Fill))
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_EXTRA_OPERATION)
+	IFX_CACHE_EXTRA_OPERATION
+#else
 	/* To support Orion/R4600, we initialise the data cache in 3 passes.
 	 */
 
@@ -200,6 +208,7 @@ mips_cache_reset:
 	move	a3, t5		# dcacheLineSize
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
+#endif
 
 	j  ra
 	.end  mips_cache_reset
--- a/cpu/mips/config.mk
+++ b/cpu/mips/config.mk
@@ -20,20 +20,26 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 # MA 02111-1307 USA
 #
-v=$(shell \
-$(CROSS_COMPILE)as --version|grep "GNU assembler"|awk '{print $$3}'|awk -F . '{print $$2}')
-MIPSFLAGS=$(shell \
-if [ "$v" -lt "14" ]; then \
-	echo "-mcpu=4kc"; \
-else \
-	echo "-march=4kc -mtune=4kc"; \
-fi)
 
+ifndef PLATFORM_CPU
+PLATFORM_CPU = mips32
+endif
+
+MIPSFLAGS +=$(call cc-option,-march=$(PLATFORM_CPU) -mtune=$(PLATFORM_CPU),-mcpu=$(PLATFORM_CPU))
+
+ifeq ($(CROSS_COMPILE_UCLIBC),1)
+ifneq (,$(findstring mipsel,$(CROSS_COMIPLE)))
+ENDIANNESS = -el
+else
+ENDIANNESS = -eb
+endif
+else
 ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
 ENDIANNESS = -EL
 else
 ENDIANNESS = -EB
 endif
+endif
 
 MIPSFLAGS += $(ENDIANNESS) -mabicalls
 
--- a/cpu/mips/cpu.c
+++ b/cpu/mips/cpu.c
@@ -23,7 +23,12 @@
 
 #include <common.h>
 #include <command.h>
-#include <asm/inca-ip.h>
+#if defined(CONFIG_INCA_IP)
+#	include <asm/inca-ip.h>
+#elif defined(CONFIG_IFX_MIPS)
+#	include <asm/danube.h>
+#	include "danube/ifx_cpu.c"
+#endif
 #include <asm/mipsregs.h>
 
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -34,6 +39,8 @@ int do_reset(cmd_tbl_t *cmdtp, int flag,
 	void (*f)(void) = (void *) 0xbfc00000;
 
 	f();
+#elif defined(CONFIG_IFX_MIPS)
+	IFX_CPU_RESET;
 #endif
 	fprintf(stderr, "*** reset failed ***\n");
 	return 0;
--- a/cpu/mips/incaip_clock.c
+++ b/cpu/mips/incaip_clock.c
@@ -22,8 +22,9 @@
  */
 
 #include <common.h>
-#include <asm/inca-ip.h>
 
+#ifdef CONFIG_INCA_IP
+#include <asm/inca-ip.h>
 
 /*******************************************************************************
 *
@@ -114,3 +115,5 @@ int incaip_set_cpuclk (void)
 
 	return 0;
 }
+
+#endif /* CONFIG_INCA_IP */
--- a/cpu/mips/start.S
+++ b/cpu/mips/start.S
@@ -27,7 +27,9 @@
 #include <version.h>
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
-
+#if defined(CONFIG_IFX_MIPS)
+#	include "danube/ifx_start.S"
+#endif
 
 #define RVECENT(f,n) \
    b f; nop
@@ -36,15 +38,24 @@
    li k0,bev
 
 	.set noreorder
-
+#ifdef CFG_BOOTSTRAP_CODE
+	.globl _start_bootstrap
+#else
 	.globl _start
+#endif
 	.text
+#ifdef CFG_BOOTSTRAP_CODE
+_start_bootstrap:
+#else
 _start:
+#endif
 	RVECENT(reset,0)	/* U-boot entry point */
 	RVECENT(reset,1)	/* software reboot */
-#if defined(CONFIG_INCA_IP)
+#if defined(CONFIG_INCA_IP) || defined(CONFIG_INCA_IP2)
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
 	.word 0x00000000           /* phase of the flash                    */
+#elif defined(CONFIG_IFX_MIPS) && defined(IFX_EBU_BOOTCFG_DWORD)
+	IFX_EBU_BOOTCFG_DWORD
 #elif defined(CONFIG_PURPLE)
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
 	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
@@ -181,6 +192,9 @@ _start:
 	 * 128 * 8 == 1024 == 0x400
 	 * so this is address R_VEC+0x400 == 0xbfc00400
 	 */
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_MORE_RESERVED_VECTORS)
+	IFX_MORE_RESERVED_VECTORS
+#else
 #ifdef CONFIG_PURPLE
 /* 0xbfc00400 */
 	.word	0xdc870000
@@ -205,8 +219,12 @@ _start:
 	.word	0x00000000
 	.word   0x00000000
 #endif /* CONFIG_PURPLE */
+#endif /* CONFIG_IFX_MIPS */
 	.align 4
 reset:
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_RESET_PRECHECK)
+	IFX_RESET_PRECHECK
+#endif
 
 	/* Clear watch registers.
 	 */
@@ -226,6 +244,10 @@ reset:
 	/* CAUSE register */
 	mtc0	zero, CP0_CAUSE
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU_EXTRA_INIT)
+	IFX_CPU_EXTRA_INIT
+#endif
+
 	/* Init Timer */
 	mtc0	zero, CP0_COUNT
 	mtc0	zero, CP0_COMPARE
@@ -252,12 +274,26 @@ reset:
 	nop
 #endif
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_SKIP_LOWLEVEL_INIT)
+	IFX_SKIP_LOWLEVEL_INIT
+#endif
+#ifdef CFG_BOOTSTRAP_CODE
 	/* Initialize any external memory.
 	 */
 	la      t9, lowlevel_init
 	jalr    t9
 	nop
+#endif
+lowlevel_init_done:
+
+	beq	s0, zero, init_cache_0
+	nop
+
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_CPU1_INIT)
+        IFX_CPU1_INIT
+#endif
 
+init_cache_0:
 	/* Initialize caches...
 	 */
 	la      t9, mips_cache_reset
@@ -266,7 +302,11 @@ reset:
 
 	/* ... and enable them.
 	 */
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CACHE_OPER_MODE)
+	IFX_CACHE_OPER_MODE
+#else
 	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+#endif
 	mtc0	t0, CP0_CONFIG
 
 
@@ -280,13 +320,38 @@ reset:
 	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
 	la	sp, 0(t0)
 
+#if defined(CONFIG_IFX_MIPS) && defined(IFX_CPU1_SUPPORT) && defined(IFX_BOOT_CLEAR)
+	IFX_BOOT_CLEAR
+#endif
+
+#ifdef CFG_BOOTSTRAP_CODE
+	la	t9, bootstrap_board_init_f
+#else
 	la	t9, board_init_f
+#endif
 	j	t9
 	nop
 
+#ifdef CFG_BOOTSTRAP_CODE
+/*
+ * void jump_unconditional (addr)
+ * This function simply jumps to the location pointed by a0.
+ * a0 = target_location
+ *
+ */
+	.globl  jump_unconditional
+	.ent    jump_unconditional
+jump_unconditional:
+	move t9, a0
+	j       t9
+	nop
+	.end    jump_unconditional
+
+#endif
 
 /*
  * void relocate_code (addr_sp, gd, addr_moni)
+ * void bootstrap_relocate_code (addr_sp, gd, addr_moni)
  *
  * This "function" does not return, instead it continues in RAM
  * after relocating the monitor code.
@@ -295,12 +360,22 @@ reset:
  * a1 = gd
  * a2 = destination address
  */
+#ifdef CFG_BOOTSTRAP_CODE
+	.globl	bootstrap_relocate_code
+	.ent	bootstrap_relocate_code
+bootstrap_relocate_code:
+#else
 	.globl	relocate_code
 	.ent	relocate_code
 relocate_code:
+#endif
 	move	sp, a0		/* Set new stack pointer		*/
 
+#ifdef CFG_BOOTSTRAP_CODE
+	li	t0, BOOTSTRAP_CFG_MONITOR_BASE
+#else
 	li	t0, CFG_MONITOR_BASE
+#endif
 	la	t3, in_ram
 	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/
 	move	t1, a2
@@ -311,7 +386,11 @@ relocate_code:
 	 * New GOT-PTR = (old GOT-PTR - CFG_MONITOR_BASE) + Destination Address
 	 */
 	move	t6, gp
+#ifdef CFG_BOOTSTRAP_CODE
+	sub	gp, BOOTSTRAP_CFG_MONITOR_BASE
+#else
 	sub	gp, CFG_MONITOR_BASE
+#endif
 	add	gp, a2			/* gp now adjusted		*/
 	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
 
@@ -337,12 +416,21 @@ relocate_code:
 
 	/* Jump to where we've relocated ourselves.
 	 */
+#ifdef CFG_BOOTSTRAP_CODE
+	addi	t0, a2, in_ram - _start_bootstrap
+#else
 	addi	t0, a2, in_ram - _start
+#endif
 	j	t0
 	nop
 
+#ifdef CFG_BOOTSTRAP_CODE
+	.word	uboot_end_data_bootstrap
+	.word	uboot_end_bootstrap
+#else
 	.word	uboot_end_data
 	.word	uboot_end
+#endif
 	.word	num_got_entries
 
 in_ram:
@@ -374,12 +462,19 @@ in_ram:
 	sw	zero, 0(t1)	/* delay slot			*/
 
 	move	a0, a1
+#ifdef CFG_BOOTSTRAP_CODE
+	la	t9, bootstrap_board_init_r
+#else
 	la	t9, board_init_r
+#endif
 	j	t9
 	move	a1, a2		/* delay slot			*/
 
+#ifdef CFG_BOOTSTRAP_CODE
+	.end	bootstrap_relocate_code
+#else
 	.end	relocate_code
-
+#endif
 
 	/* Exception handlers.
 	 */
@@ -388,3 +483,20 @@ romReserved:
 
 romExcHandle:
 	b romExcHandle
+
+romEjtagHandle:
+#ifdef CFG_BOOTSTRAP_CODE
+	deret
+	nop
+#endif /* CFG_BOOTSTRAP_CODE */
+1:
+	b 1b
+
+	/* Additional handlers.
+	 */
+#if defined(CONFIG_IFX_MIPS)
+#if defined(IFX_MIPS_HANDLER_1)
+ifx_mips_handler_1:
+	IFX_MIPS_HANDLER_1
+#endif
+#endif
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -21,7 +21,7 @@
 # MA 02111-1307 USA
 #
 
-BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
+BIN_FILES	= mkimage$(SFX)
 
 OBJ_LINKS	= environment.o crc32.o
 OBJ_FILES	= img2srec.o mkimage.o envcrc.o gen_eth_addr.o bmp_logo.o
