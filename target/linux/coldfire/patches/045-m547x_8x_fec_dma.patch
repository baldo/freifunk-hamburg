From b778a60aba67d29857fc7016c8c2f2d87a23de1f Mon Sep 17 00:00:00 2001
From: Kurt Mahan <kmahan@freescale.com>
Date: Sun, 9 Mar 2008 22:14:05 -0600
Subject: [PATCH] Add DMA and FEC.

LTIBName: m547x-8x-fec-dma
Signed-off-by: Kurt Mahan <kmahan@freescale.com>
---
 arch/m68k/Kconfig            |    9 +
 arch/m68k/coldfire/Makefile  |    2 +
 arch/m68k/coldfire/dma.c     |  537 +++++++++
 drivers/Makefile             |    2 +
 drivers/dma/MCD_dma.h        |  408 +++++++
 drivers/dma/MCD_dmaApi.c     |  968 +++++++++++++++++
 drivers/dma/MCD_progCheck.h  |   33 +
 drivers/dma/MCD_tasks.c      | 2452 ++++++++++++++++++++++++++++++++++++++++++
 drivers/dma/MCD_tasksInit.c  |  284 +++++
 drivers/dma/MCD_tasksInit.h  |   73 ++
 drivers/dma/Makefile         |    2 +
 drivers/net/Kconfig          |    2 +
 drivers/net/Makefile         |    2 +
 drivers/net/fec/Kconfig      |   25 +
 drivers/net/fec/Makefile     |    7 +
 drivers/net/fec/fec.c        | 1375 +++++++++++++++++++++++
 drivers/net/fec/fec.h        |  162 +++
 drivers/net/fec/ks8721.c     |  125 +++
 drivers/net/fec/ks8721.h     |   21 +
 include/asm-m68k/MCD_dma.h   |  408 +++++++
 include/asm-m68k/coldfire.h  |    1 +
 include/asm-m68k/dma.h       |  106 ++-
 include/asm-m68k/m5485dma.h  |   97 ++
 include/asm-m68k/m5485sram.h |   12 +
 24 files changed, 7112 insertions(+), 1 deletions(-)
 create mode 100644 arch/m68k/coldfire/dma.c
 create mode 100644 drivers/dma/MCD_dma.h
 create mode 100644 drivers/dma/MCD_dmaApi.c
 create mode 100644 drivers/dma/MCD_progCheck.h
 create mode 100644 drivers/dma/MCD_tasks.c
 create mode 100644 drivers/dma/MCD_tasksInit.c
 create mode 100644 drivers/dma/MCD_tasksInit.h
 create mode 100644 drivers/net/fec/Kconfig
 create mode 100644 drivers/net/fec/Makefile
 create mode 100755 drivers/net/fec/fec.c
 create mode 100755 drivers/net/fec/fec.h
 create mode 100644 drivers/net/fec/ks8721.c
 create mode 100644 drivers/net/fec/ks8721.h
 create mode 100644 include/asm-m68k/MCD_dma.h
 create mode 100644 include/asm-m68k/m5485dma.h
 create mode 100644 include/asm-m68k/m5485sram.h

--- a/arch/m68k/Kconfig
+++ b/arch/m68k/Kconfig
@@ -141,6 +141,15 @@ config CFV4E
 	select MMU_CFV4E if MMU
 	default y
 
+config MCD_DMA
+	bool "ColdFire MCD DMA support"
+	depends on CFV4E
+	default y
+	help
+	  This enables support for the ColdFire 547x/548x family
+	  multichannel DMA support.  Many drivers need it.
+	  If you want it, say Y
+
 config AMIGA
 	bool "Amiga support"
 	depends on !MMU_SUN3
--- a/arch/m68k/coldfire/Makefile
+++ b/arch/m68k/coldfire/Makefile
@@ -10,3 +10,5 @@ endif
 
 obj-$(CONFIG_PCI)	+= pci.o mcf5445x-pci.o iomap.o
 obj-$(CONFIG_M54455)	+= mcf5445x-devices.o
+
+obj-$(CONFIG_MCD_DMA)	+= dma.o
--- /dev/null
+++ b/arch/m68k/coldfire/dma.c
@@ -0,0 +1,537 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/coldfire.h>
+#include <asm/m5485sram.h>
+#include <asm/mcfsim.h>
+
+
+
+void dma_interrupt_handler(int irq, void *dev_id, struct pt_regs *regs);
+
+/* 
+ * This global keeps track of which initiators have been
+ * used of the available assignments.  Initiators 0-15 are
+ * hardwired.  Initiators 16-31 are multiplexed and controlled
+ * via the Initiatior Mux Control Registe (IMCR).  The
+ * assigned requestor is stored with the associated initiator
+ * number.
+ */
+static int used_reqs[32] = {
+	DMA_ALWAYS, DMA_DSPI_RX, DMA_DSPI_TX, DMA_DREQ0,
+	DMA_PSC0_RX, DMA_PSC0_TX, DMA_USBEP0, DMA_USBEP1,
+	DMA_USBEP2, DMA_USBEP3, DMA_PCI_TX, DMA_PCI_RX,
+	DMA_PSC1_RX, DMA_PSC1_TX, DMA_I2C_RX, DMA_I2C_TX,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0,
+	0, 0, 0, 0
+};
+
+/*
+ * This global keeps track of which channels have been assigned
+ * to tasks.  This methology assumes that no single initiator
+ * will be tied to more than one task/channel
+ */
+static char used_channel[16] = {
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+unsigned int connected_channel[16] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/********************************************************************/
+/*
+ * Attempt to enable the provided Initiator in the Initiator
+ * Mux Control Register
+ *
+ * Parameters:
+ *  initiator   Initiator identifier
+ *
+ * Return Value:
+ *  1   if unable to make the assignment
+ *  0   successful
+ */
+int
+dma_set_initiator(int initiator)
+{
+	switch (initiator) {	/*
+				 * These initiators are always active 
+				 */
+	case DMA_ALWAYS:
+	case DMA_DSPI_RX:
+	case DMA_DSPI_TX:
+	case DMA_DREQ0:
+	case DMA_PSC0_RX:
+	case DMA_PSC0_TX:
+	case DMA_USBEP0:
+	case DMA_USBEP1:
+	case DMA_USBEP2:
+	case DMA_USBEP3:
+	case DMA_PCI_TX:
+	case DMA_PCI_RX:
+	case DMA_PSC1_RX:
+	case DMA_PSC1_TX:
+	case DMA_I2C_RX:
+	case DMA_I2C_TX:
+		break;
+
+	case DMA_FEC0_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC16(3))
+		    | MCF_DMA_IMCR_SRC16_FEC0RX;
+		used_reqs[16] = DMA_FEC0_RX;
+		break;
+
+	case DMA_FEC0_TX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC17(3))
+		    | MCF_DMA_IMCR_SRC17_FEC0TX;
+		used_reqs[17] = DMA_FEC0_TX;
+		break;
+
+	case DMA_FEC1_RX:
+		MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC20(3))
+		    | MCF_DMA_IMCR_SRC20_FEC1RX;
+		used_reqs[20] = DMA_FEC1_RX;
+		break;
+
+	case DMA_FEC1_TX:
+		if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_FEC1TX;
+			used_reqs[21] = DMA_FEC1_TX;
+		} else if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_FEC1TX;
+			used_reqs[25] = DMA_FEC1_TX;
+		} else if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_FEC1TX;
+			used_reqs[31] = DMA_FEC1_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_DREQ1:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_DREQ1;
+			used_reqs[29] = DMA_DREQ1;
+		} else if (used_reqs[21] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC21(3))
+			    | MCF_DMA_IMCR_SRC21_DREQ1;
+			used_reqs[21] = DMA_DREQ1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM0:
+		if (used_reqs[24] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC24(3))
+			    | MCF_DMA_IMCR_SRC24_CTM0;
+			used_reqs[24] = DMA_CTM0;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM1:
+		if (used_reqs[25] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC25(3))
+			    | MCF_DMA_IMCR_SRC25_CTM1;
+			used_reqs[25] = DMA_CTM1;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM2:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_CTM2;
+			used_reqs[26] = DMA_CTM2;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM3:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_CTM3;
+			used_reqs[27] = DMA_CTM3;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM4:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_CTM4;
+			used_reqs[28] = DMA_CTM4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM5:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_CTM5;
+			used_reqs[29] = DMA_CTM5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM6:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_CTM6;
+			used_reqs[30] = DMA_CTM6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_CTM7:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_CTM7;
+			used_reqs[31] = DMA_CTM7;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP4:
+		if (used_reqs[26] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC26(3))
+			    | MCF_DMA_IMCR_SRC26_USBEP4;
+			used_reqs[26] = DMA_USBEP4;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP5:
+		if (used_reqs[27] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC27(3))
+			    | MCF_DMA_IMCR_SRC27_USBEP5;
+			used_reqs[27] = DMA_USBEP5;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_USBEP6:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_USBEP6;
+			used_reqs[28] = DMA_USBEP6;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_RX:
+		if (used_reqs[28] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC28(3))
+			    | MCF_DMA_IMCR_SRC28_PSC2RX;
+			used_reqs[28] = DMA_PSC2_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC2_TX:
+		if (used_reqs[29] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC29(3))
+			    | MCF_DMA_IMCR_SRC29_PSC2TX;
+			used_reqs[29] = DMA_PSC2_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_RX:
+		if (used_reqs[30] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC30(3))
+			    | MCF_DMA_IMCR_SRC30_PSC3RX;
+			used_reqs[30] = DMA_PSC3_RX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	case DMA_PSC3_TX:
+		if (used_reqs[31] == 0) {
+			MCF_DMA_IMCR = (MCF_DMA_IMCR & ~MCF_DMA_IMCR_SRC31(3))
+			    | MCF_DMA_IMCR_SRC31_PSC3TX;
+			used_reqs[31] = DMA_PSC3_TX;
+		} else		/* No empty slots */
+			return 1;
+		break;
+
+	default:
+		return 1;
+	}
+	return 0;
+}
+
+/********************************************************************/
+/*
+ * Return the initiator number for the given requestor
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ *
+ * Return Value:
+ *  The initiator number (0-31) if initiator has been assigned
+ *  0 (always initiator) otherwise
+ */
+unsigned int
+dma_get_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof (used_reqs); ++i) {
+		if (used_reqs[i] == requestor)
+			return i;
+	}
+	return 0;
+}
+
+/********************************************************************/
+/*
+ * Remove the given initiator from the active list
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ */
+void
+dma_remove_initiator(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof (used_reqs); ++i) {
+		if (used_reqs[i] == requestor) {
+			used_reqs[i] = -1;
+			break;
+		}
+	}
+}
+
+/********************************************************************/
+/*
+ * Attempt to find an available channel for FEC and mark is as used
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ *
+ * Return Value:
+ *  First available channel (from 0 to 5) or -1 if they are all occupied
+ */
+int
+dma_set_channel_fec(int requestor)
+{
+	u32 i, t;
+
+#ifdef CONFIG_FEC_548x_ENABLE_FEC2
+	t = 4;
+#else
+	t = 2;
+#endif
+
+
+
+	for (i = 0; i < t ; ++i)
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+	/* All channels taken */
+	return -1;
+}
+
+/********************************************************************/
+/*
+ * Attempt to find an available channel and mark is as used
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ *
+ * Return Value:
+ *  First available channel (from 6 to 15) or -1 if they are all occupied
+ */
+int
+dma_set_channel(int requestor)
+{
+	u32 i;
+#ifdef CONFIG_NET_FEC2
+	i = 4;
+#else
+	i = 2;
+#endif				
+
+	for (; i < 16; ++i)
+		if (used_channel[i] == -1) {
+			used_channel[i] = requestor;
+			return i;
+		}
+
+	/* All channels taken */
+	return -1;
+}
+
+/********************************************************************/
+/*
+ * Return the channel being initiated by the given requestor
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ */
+int
+dma_get_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof (used_channel); ++i) {
+		if (used_channel[i] == requestor)
+			return i;
+	}
+	return -1;
+}
+
+/********************************************************************/
+/*
+ * Connects a channel with reference on your data 
+ *
+ * Parameters:
+ *  channel   channel number
+ *  reference addres of your data
+  */
+int
+dma_connect(int channel, int address)
+{
+	if ((channel < 16) && (channel >= 0))
+		connected_channel[channel] = address;
+	else
+		return -1;
+	return 0;
+}
+
+/********************************************************************/
+/*
+ * Disconnects a channel with reference on your data 
+ *
+ * Parameters:
+ *  channel   channel number
+*/
+int
+dma_disconnect(int channel)
+{
+	if ((channel < 16) && (channel >= 0))
+		connected_channel[channel] = 0;
+	else
+		return -1;
+	return 0;
+}
+
+/********************************************************************/
+/*
+ * Remove the channel being initiated by the given requestor from 
+ * the active list
+ *
+ * Parameters:
+ *  requestor   Initiator/Requestor identifier
+ */
+void
+dma_remove_channel(int requestor)
+{
+	u32 i;
+
+	for (i = 0; i < sizeof (used_channel); ++i) {
+		if (used_channel[i] == requestor) {
+			used_channel[i] = -1;
+			break;
+		}
+	}
+}
+
+/********************************************************************/
+/* 
+ * This is the catch-all interrupt handler for the mult-channel DMA 
+ */
+volatile u8 dma_iflag[16];
+u32 tx = 0;
+
+void
+dma_interrupt_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 i, interrupts/*, mask, temp*/;
+
+	/*
+	 * Determine which interrupt(s) triggered by AND'ing the 
+	 * pending interrupts with those that aren't masked.            
+	 */
+/*	mask = MCF_DMA_DIMR;
+	MCF_DMA_DIMR = 0xffffffff;
+*/
+	interrupts = MCF_DMA_DIPR;
+	MCF_DMA_DIPR |= interrupts;
+//	temp = interrupts;
+
+	//MCF_DMA_DIPR = interrupts;
+	for (i = 0; i < 16; ++i, interrupts >>= 1)
+		if (interrupts & 0x1)
+			if (connected_channel[i] != 0)
+				((void (*)(void)) (connected_channel[i])) ();
+
+/*	MCF_DMA_DIPR |= temp;
+	MCF_DMA_DIMR = mask;*/
+}
+
+void
+dma_remove_channel_by_number(int channel)
+{
+	if (channel < sizeof (used_channel) && channel >= 0)
+		used_channel[channel] = -1;
+}
+
+int __devinit
+dma_init()
+{
+	int result;
+	char *dma_version_str;
+
+	MCD_getVersion(&dma_version_str);
+	printk("Initialize %s\n", dma_version_str);
+
+	if (request_irq
+	    (64 + ISC_DMA, 
+	     dma_interrupt_handler, 
+	     IRQF_DISABLED, 
+	     "MCD-DMA", 
+	     NULL)) {
+		printk("Cannot allocate the DMA IRQ(48)\n");
+		return 1;
+	}
+
+	MCF_DMA_DIMR = 0;
+	MCF_DMA_DIPR = 0xFFFFFFFF;
+
+	MCF_ICR(ISC_DMA) = ILP_DMA;
+#if 0
+// JKM
+	enable_irq( 64 + ISC_DMA );
+#endif
+
+	result =
+	    MCD_initDma((dmaRegs *) (MCF_MBAR + 0x8000),
+			(void *) SYS_SRAM_DMA_START, MCD_RELOC_TASKS);
+	if (result != MCD_OK) {
+		printk("Cannot perform DMA initialization\n");
+		free_irq(64 + ISC_DMA, NULL);
+		return 1;
+	}
+
+	return 0;
+}
+
+device_initcall(dma_init);
+
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -93,3 +93,5 @@ obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
 obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
+
+obj-$(CONFIG_MCD_DMA)		+= dma/
--- /dev/null
+++ b/drivers/dma/MCD_dma.h
@@ -0,0 +1,408 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+
+/*
+ * File:        MCD_dma.h
+ * Purpose:     Main header file for multi-channel DMA API.
+ *
+ * Notes:
+ *
+ * Modifications:
+ */
+#ifndef _MCD_API_H
+#define _MCD_API_H
+
+#include <asm/types.h>
+
+/*
+ * Turn Execution Unit tasks ON (#define) or OFF (#undef)
+ */
+#undef MCD_INCLUDE_EU
+
+/*
+ * Number of DMA channels
+ */
+#define NCHANNELS 16
+
+/*
+ * Total number of variants
+ */
+#ifdef MCD_INCLUDE_EU
+#define NUMOFVARIANTS   6
+#else
+#define NUMOFVARIANTS   4
+#endif
+
+/*
+ * Define sizes of the various tables
+ */
+#define TASK_TABLE_SIZE     (NCHANNELS*32)
+#define VAR_TAB_SIZE        (128)
+#define CONTEXT_SAVE_SIZE   (128)
+#define FUNCDESC_TAB_SIZE   (256)
+
+#ifdef MCD_INCLUDE_EU
+#define FUNCDESC_TAB_NUM    16
+#else
+#define FUNCDESC_TAB_NUM    1
+#endif
+
+
+#ifndef DEFINESONLY
+
+/*
+ * Portability typedefs
+ */
+ /*
+#ifndef s32
+typedef int s32;
+#endif
+#ifndef u32
+typedef unsigned int u32;
+#endif
+#ifndef s16
+typedef short s16;
+#endif
+#ifndef u16
+typedef unsigned short u16;
+#endif
+#ifndef s8
+typedef char s8;
+#endif
+#ifndef u8
+typedef unsigned char u8;
+#endif
+*/
+/*
+ * These structures represent the internal registers of the
+ * multi-channel DMA
+ */
+struct dmaRegs_s {
+   u32 taskbar;         /* task table base address register */
+   u32 currPtr;
+   u32 endPtr;
+   u32 varTablePtr;
+   u16 dma_rsvd0;
+   u16 ptdControl;      /* ptd control */
+   u32 intPending;      /* interrupt pending register */
+   u32 intMask;         /* interrupt mask register */
+   u16 taskControl[16]; /* task control registers */
+   u8  priority[32];    /* priority registers */
+   u32 initiatorMux;    /* initiator mux control */
+   u32 taskSize0;       /* task size control register 0. */
+   u32 taskSize1;       /* task size control register 1. */
+   u32 dma_rsvd1;       /* reserved */
+   u32 dma_rsvd2;       /* reserved */
+   u32 debugComp1;      /* debug comparator 1 */
+   u32 debugComp2;      /* debug comparator 2 */
+   u32 debugControl;    /* debug control */
+   u32 debugStatus;     /* debug status */
+   u32 ptdDebug;        /* priority task decode debug */
+   u32 dma_rsvd3[31];   /* reserved */
+};
+typedef volatile struct dmaRegs_s dmaRegs;
+
+#endif
+
+/*
+ * PTD contrl reg bits
+ */
+#define PTD_CTL_TSK_PRI         0x8000
+#define PTD_CTL_COMM_PREFETCH   0x0001
+
+/*
+ * Task Control reg bits and field masks
+ */
+#define TASK_CTL_EN             0x8000
+#define TASK_CTL_VALID          0x4000
+#define TASK_CTL_ALWAYS         0x2000
+#define TASK_CTL_INIT_MASK      0x1f00
+#define TASK_CTL_ASTRT          0x0080
+#define TASK_CTL_HIPRITSKEN     0x0040
+#define TASK_CTL_HLDINITNUM     0x0020
+#define TASK_CTL_ASTSKNUM_MASK  0x000f
+
+/*
+ * Priority reg bits and field masks
+ */
+#define PRIORITY_HLD            0x80
+#define PRIORITY_PRI_MASK       0x07
+
+/*
+ * Debug Control reg bits and field masks
+ */
+#define DBG_CTL_BLOCK_TASKS_MASK    0xffff0000
+#define DBG_CTL_AUTO_ARM            0x00008000
+#define DBG_CTL_BREAK               0x00004000
+#define DBG_CTL_COMP1_TYP_MASK      0x00003800
+#define DBG_CTL_COMP2_TYP_MASK      0x00000070
+#define DBG_CTL_EXT_BREAK           0x00000004
+#define DBG_CTL_INT_BREAK           0x00000002
+
+/*
+ * PTD Debug reg selector addresses
+ * This reg must be written with a value to show the contents of
+ * one of the desired internal register.
+ */
+#define PTD_DBG_REQ             0x00 /* shows the state of 31 initiators */
+#define PTD_DBG_TSK_VLD_INIT    0x01 /* shows which 16 tasks are valid and
+                                        have initiators asserted */
+
+
+/*
+ * General return values
+ */
+#define MCD_OK                   0
+#define MCD_ERROR               -1
+#define MCD_TABLE_UNALIGNED     -2
+#define MCD_CHANNEL_INVALID     -3
+
+/*
+ * MCD_initDma input flags
+ */
+#define MCD_RELOC_TASKS         0x00000001
+#define MCD_NO_RELOC_TASKS      0x00000000
+#define MCD_COMM_PREFETCH_EN    0x00000002  /* Commbus Prefetching - MCF547x/548x ONLY */
+
+/*
+ * MCD_dmaStatus Status Values for each channel
+ */
+#define MCD_NO_DMA  1 /* No DMA has been requested since reset */
+#define MCD_IDLE    2 /* DMA active, but the initiator is currently inactive */
+#define MCD_RUNNING 3 /* DMA active, and the initiator is currently active */
+#define MCD_PAUSED  4 /* DMA active but it is currently paused */
+#define MCD_HALTED  5 /* the most recent DMA has been killed with MCD_killTask() */
+#define MCD_DONE    6 /* the most recent DMA has completed. */
+
+
+/*
+ * MCD_startDma parameter defines
+ */
+
+/*
+ * Constants for the funcDesc parameter
+ */
+/* Byte swapping: */
+#define MCD_NO_BYTE_SWAP    0x00045670  /* to disable byte swapping. */
+#define MCD_BYTE_REVERSE    0x00076540  /* to reverse the bytes of each u32 of the DMAed data. */
+#define MCD_U16_REVERSE     0x00067450  /* to reverse the 16-bit halves of
+                                           each 32-bit data value being DMAed.*/
+#define MCD_U16_BYTE_REVERSE    0x00054760 /* to reverse the byte halves of each
+                                            16-bit half of each 32-bit data value DMAed */
+#define MCD_NO_BIT_REV  0x00000000  /* do not reverse the bits of each byte DMAed. */
+#define MCD_BIT_REV     0x00088880  /* reverse the bits of each byte DMAed */
+/* CRCing: */
+#define MCD_CRC16       0xc0100000  /* to perform CRC-16 on DMAed data. */
+#define MCD_CRCCCITT    0xc0200000  /* to perform CRC-CCITT on DMAed data. */
+#define MCD_CRC32       0xc0300000  /* to perform CRC-32 on DMAed data. */
+#define MCD_CSUMINET    0xc0400000  /* to perform internet checksums on DMAed data.*/
+#define MCD_NO_CSUM     0xa0000000  /* to perform no checksumming. */
+
+#define MCD_FUNC_NOEU1 (MCD_NO_BYTE_SWAP | MCD_NO_BIT_REV | MCD_NO_CSUM)
+#define MCD_FUNC_NOEU2 (MCD_NO_BYTE_SWAP | MCD_NO_CSUM)
+
+/*
+ * Constants for the flags parameter
+ */
+#define MCD_TT_FLAGS_RL   0x00000001 /* Read line */
+#define MCD_TT_FLAGS_CW   0x00000002 /* Combine Writes */
+#define MCD_TT_FLAGS_SP   0x00000004 /* Speculative prefetch(XLB) MCF547x/548x ONLY  */
+#define MCD_TT_FLAGS_MASK 0x000000ff
+#define MCD_TT_FLAGS_DEF  (MCD_TT_FLAGS_RL | MCD_TT_FLAGS_CW)
+
+#define MCD_SINGLE_DMA  0x00000100 /* Unchained DMA */
+#define MCD_CHAIN_DMA              /* TBD */
+#define MCD_EU_DMA                 /* TBD */
+#define MCD_FECTX_DMA   0x00001000 /* FEC TX ring DMA */
+#define MCD_FECRX_DMA   0x00002000 /* FEC RX ring DMA */
+
+
+/* these flags are valid for MCD_startDma and the chained buffer descriptors */
+#define MCD_BUF_READY   0x80000000 /* indicates that this buffer is now under the DMA's control */
+#define MCD_WRAP        0x20000000 /* to tell the FEC Dmas to wrap to the first BD */
+#define MCD_INTERRUPT   0x10000000 /* to generate an interrupt after completion of the DMA. */
+#define MCD_END_FRAME   0x08000000 /* tell the DMA to end the frame when transferring
+                                      last byte of data in buffer */
+#define MCD_CRC_RESTART 0x40000000 /* to empty out the accumulated checksum
+                                      prior to performing the DMA. */
+
+/* Defines for the FEC buffer descriptor control/status word*/
+#define MCD_FEC_BUF_READY   0x8000
+#define MCD_FEC_WRAP        0x2000
+#define MCD_FEC_INTERRUPT   0x1000
+#define MCD_FEC_END_FRAME   0x0800
+
+
+/*
+ * Defines for general intuitiveness
+ */
+
+#define MCD_TRUE  1
+#define MCD_FALSE 0
+
+/*
+ * Three different cases for destination and source.
+ */
+#define MINUS1          -1
+#define ZERO            0
+#define PLUS1           1
+
+#ifndef DEFINESONLY
+
+/* Task Table Entry struct*/
+typedef struct {
+    u32 TDTstart;   /* task descriptor table start */
+    u32 TDTend;     /* task descriptor table end */
+    u32 varTab;     /* variable table start */
+    u32 FDTandFlags;    /* function descriptor table start and flags */
+    volatile u32 descAddrAndStatus;
+    volatile u32 modifiedVarTab;
+    u32 contextSaveSpace;   /* context save space start */
+    u32 literalBases;
+} TaskTableEntry;
+
+
+/* Chained buffer descriptor */
+typedef volatile struct MCD_bufDesc_struct MCD_bufDesc;
+struct MCD_bufDesc_struct {
+   u32 flags;         /* flags describing the DMA */
+   u32 csumResult;    /* checksum from checksumming performed since last checksum reset */
+   s8  *srcAddr;      /* the address to move data from */
+   s8  *destAddr;     /* the address to move data to */
+   s8  *lastDestAddr; /* the last address written to */
+   u32 dmaSize;       /* the number of bytes to transfer independent of the transfer size */
+   MCD_bufDesc *next; /* next buffer descriptor in chain */
+   u32 info;          /* private information about this descriptor;  DMA does not affect it */
+};
+
+/* Progress Query struct */
+typedef volatile struct MCD_XferProg_struct {
+   s8 *lastSrcAddr;         /* the most-recent or last, post-increment source address */
+   s8 *lastDestAddr;        /* the most-recent or last, post-increment destination address */
+   u32  dmaSize;            /* the amount of data transferred for the current buffer */
+   MCD_bufDesc *currBufDesc;/* pointer to the current buffer descriptor being DMAed */
+} MCD_XferProg;
+
+
+/* FEC buffer descriptor */
+typedef volatile struct MCD_bufDescFec_struct {
+    u16 statCtrl;
+    u16 length;
+    u32 dataPointer;
+} MCD_bufDescFec;
+
+
+/*************************************************************************/
+/*
+ * API function Prototypes  - see MCD_dmaApi.c for further notes
+ */
+
+/*
+ * MCD_startDma starts a particular kind of DMA .
+ */
+int MCD_startDma (
+   int channel,   /* the channel on which to run the DMA */
+   s8  *srcAddr,  /* the address to move data from, or buffer-descriptor address */
+   s16 srcIncr,   /* the amount to increment the source address per transfer */
+   s8  *destAddr, /* the address to move data to */
+   s16 destIncr,  /* the amount to increment the destination address per transfer */
+   u32 dmaSize,   /* the number of bytes to transfer independent of the transfer size */
+   u32 xferSize,  /* the number bytes in of each data movement (1, 2, or 4) */
+   u32 initiator, /* what device initiates the DMA */
+   int priority,  /* priority of the DMA */
+   u32 flags,     /* flags describing the DMA */
+   u32 funcDesc   /* a description of byte swapping, bit swapping, and CRC actions */
+);
+
+/* 
+ * MCD_initDma() initializes the DMA API by setting up a pointer to the DMA 
+ * registers, relocating and creating the appropriate task structures, and 
+ * setting up some global settings
+ */
+int MCD_initDma (dmaRegs *sDmaBarAddr, void *taskTableDest, u32 flags);
+
+/* 
+ * MCD_dmaStatus() returns the status of the DMA on the requested channel.
+ */
+int MCD_dmaStatus (int channel);
+
+/* 
+ * MCD_XferProgrQuery() returns progress of DMA on requested channel
+ */
+int MCD_XferProgrQuery (int channel, MCD_XferProg *progRep);
+
+/* 
+ * MCD_killDma() halts the DMA on the requested channel, without any
+ * intention of resuming the DMA.
+ */
+int MCD_killDma (int channel);
+
+/* 
+ * MCD_continDma() continues a DMA which as stopped due to encountering an
+ * unready buffer descriptor.
+ */
+int MCD_continDma (int channel);
+
+/* 
+ * MCD_pauseDma() pauses the DMA on the given channel ( if any DMA is
+ * running on that channel). 
+ */
+int MCD_pauseDma (int channel);
+
+/* 
+ * MCD_resumeDma() resumes the DMA on a given channel (if any DMA is
+ * running on that channel).
+ */
+int MCD_resumeDma (int channel);
+
+/* 
+ * MCD_csumQuery provides the checksum/CRC after performing a non-chained DMA
+ */
+int MCD_csumQuery (int channel, u32 *csum);
+
+/* 
+ * MCD_getCodeSize provides the packed size required by the microcoded task
+ * and structures.
+ */
+int MCD_getCodeSize(void);
+
+/*
+ * MCD_getVersion provides a pointer to a version string and returns a
+ * version number.
+ */
+int MCD_getVersion(char **longVersion);
+
+/* macro for setting a location in the variable table */
+#define MCD_SET_VAR(taskTab,idx,value) ((u32 *)(taskTab)->varTab)[idx] = value
+   /* Note that MCD_SET_VAR() is invoked many times in firing up a DMA function,
+      so I'm avoiding surrounding it with "do {} while(0)" */
+
+#endif  /* DEFINESONLY */
+
+#endif /* _MCD_API_H */
--- /dev/null
+++ b/drivers/dma/MCD_dmaApi.c
@@ -0,0 +1,968 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+
+/*
+ * File:        MCD_dmaApi.c
+ * Purpose:     Main C file for multi-channel DMA API.
+ *
+ * Notes:
+ *
+ *
+ * Modifications:
+ *
+ *
+ */
+#include <asm/types.h>
+#include <asm/MCD_dma.h>
+#include <asm/virtconvert.h>
+#include "MCD_tasksInit.h"
+#include "MCD_progCheck.h"
+
+/********************************************************************/
+/*
+ * This is an API-internal pointer to the DMA's registers
+ */
+dmaRegs *MCD_dmaBar;
+
+/*
+ * These are the real and model task tables as generated by the
+ * build process
+ */
+extern TaskTableEntry MCD_realTaskTableSrc[NCHANNELS];
+extern TaskTableEntry MCD_modelTaskTableSrc[NUMOFVARIANTS];
+
+/*
+ * However, this (usually) gets relocated to on-chip SRAM, at which
+ * point we access them as these tables
+ */
+volatile TaskTableEntry *MCD_taskTable;
+TaskTableEntry *MCD_modelTaskTable;
+
+
+/*
+ * MCD_chStatus[] is an array of status indicators for remembering
+ * whether a DMA has ever been attempted on each channel, pausing
+ * status, etc.
+ */
+static int MCD_chStatus[NCHANNELS] =
+{
+    MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+    MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+    MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA,
+    MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA, MCD_NO_DMA
+};
+
+/*
+ * Prototypes for local functions
+ */
+static void MCD_memcpy (int *dest, int *src, u32 size);
+static void MCD_resmActions (int channel);
+
+/*
+ * Buffer descriptors used for storage of progress info for single Dmas
+ * Also used as storage for the DMA for CRCs for single DMAs
+ * Otherwise, the DMA does not parse these buffer descriptors
+ */
+#ifdef MCD_INCLUDE_EU
+extern MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#else
+MCD_bufDesc MCD_singleBufDescs[NCHANNELS];
+#endif
+MCD_bufDesc *MCD_relocBuffDesc;
+
+
+/*
+ * Defines for the debug control register's functions
+ */
+#define DBG_CTL_COMP1_TASK  (0x00002000) /* have comparator 1 look for a task # */
+#define DBG_CTL_ENABLE      (DBG_CTL_AUTO_ARM    | \
+                             DBG_CTL_BREAK       | \
+                             DBG_CTL_INT_BREAK   | \
+                             DBG_CTL_COMP1_TASK)
+#define DBG_CTL_DISABLE     (DBG_CTL_AUTO_ARM    | \
+                             DBG_CTL_INT_BREAK   | \
+                             DBG_CTL_COMP1_TASK)
+#define DBG_KILL_ALL_STAT   (0xFFFFFFFF)
+
+/*
+ * Offset to context save area where progress info is stored
+ */
+#define CSAVE_OFFSET        10
+
+/*
+ * Defines for Byte Swapping
+ */
+#define MCD_BYTE_SWAP_KILLER    0xFFF8888F
+#define MCD_NO_BYTE_SWAP_ATALL  0x00040000
+
+/*
+ * Execution Unit Identifiers
+ */
+#define MAC  0  /* legacy - not used */
+#define LUAC 1  /* legacy - not used */
+#define CRC  2  /* legacy - not used */
+#define LURC 3  /* Logic Unit with CRC */
+
+/*
+ * Task Identifiers
+ */
+#define TASK_CHAINNOEU  0
+#define TASK_SINGLENOEU 1
+#ifdef MCD_INCLUDE_EU
+#define TASK_CHAINEU    2
+#define TASK_SINGLEEU   3
+#define TASK_FECRX      4
+#define TASK_FECTX      5
+#else
+#define TASK_CHAINEU    0
+#define TASK_SINGLEEU   1
+#define TASK_FECRX      2
+#define TASK_FECTX      3
+#endif
+
+/*
+ * Structure to remember which variant is on which channel
+ * TBD- need this?
+ */
+typedef struct MCD_remVariants_struct MCD_remVariant;
+struct MCD_remVariants_struct
+{
+   int remDestRsdIncr[NCHANNELS];  /* -1,0,1 */
+   int remSrcRsdIncr[NCHANNELS];   /* -1,0,1 */
+   s16 remDestIncr[NCHANNELS];     /* DestIncr */
+   s16 remSrcIncr[NCHANNELS];      /* srcIncr */
+   u32 remXferSize[NCHANNELS];     /* xferSize */
+};
+
+/*
+ * Structure to remember the startDma parameters for each channel
+ */
+MCD_remVariant MCD_remVariants;
+/********************************************************************/
+/*
+ * Function: MCD_initDma
+ * Purpose:  Initializes the DMA API by setting up a pointer to the DMA
+ *           registers, relocating and creating the appropriate task
+ *           structures, and setting up some global settings
+ * Arguments:
+ *  dmaBarAddr    - pointer to the multichannel DMA registers
+ *  taskTableDest - location to move DMA task code and structs to
+ *  flags         - operational parameters
+ * Return Value:
+ *  MCD_TABLE_UNALIGNED if taskTableDest is not 512-byte aligned
+ *  MCD_OK otherwise
+ */
+extern u32 MCD_funcDescTab0[];
+
+int MCD_initDma (dmaRegs *dmaBarAddr, void *taskTableDest, u32 flags)
+{
+    int i;
+    TaskTableEntry *entryPtr;
+
+    /* setup the local pointer to register set */
+    MCD_dmaBar = dmaBarAddr;
+
+    /* do we need to move/create a task table */
+    if ((flags & MCD_RELOC_TASKS) != 0)
+    {
+        int fixedSize;
+        u32 *fixedPtr;
+        /*int *tablePtr = taskTableDest;TBD*/
+        int varTabsOffset, funcDescTabsOffset, contextSavesOffset;
+        int taskDescTabsOffset;
+        int taskTableSize, varTabsSize, funcDescTabsSize, contextSavesSize;
+        int taskDescTabSize;
+
+        int i;
+
+        /* check if physical address is aligned on 512 byte boundary */
+        if (((u32)taskTableDest & 0x000001ff) != 0)
+            return(MCD_TABLE_UNALIGNED);
+
+        MCD_taskTable = taskTableDest; /* set up local pointer to task Table */
+
+        /*
+         * Create a task table:
+         * - compute aligned base offsets for variable tables and
+         *   function descriptor tables, then
+         * - loop through the task table and setup the pointers
+         * - copy over model task table with the the actual task descriptor
+         *   tables
+         */
+
+        taskTableSize = NCHANNELS * sizeof(TaskTableEntry);
+        /* align variable tables to size */
+        varTabsOffset = taskTableSize + (u32)taskTableDest;
+        if ((varTabsOffset & (VAR_TAB_SIZE - 1)) != 0)
+            varTabsOffset = (varTabsOffset + VAR_TAB_SIZE) & (~VAR_TAB_SIZE);
+        /* align function descriptor tables */
+        varTabsSize = NCHANNELS * VAR_TAB_SIZE;
+        funcDescTabsOffset = varTabsOffset + varTabsSize;
+
+        if ((funcDescTabsOffset & (FUNCDESC_TAB_SIZE - 1)) != 0)
+            funcDescTabsOffset = (funcDescTabsOffset + FUNCDESC_TAB_SIZE) &
+            (~FUNCDESC_TAB_SIZE);
+
+        funcDescTabsSize = FUNCDESC_TAB_NUM * FUNCDESC_TAB_SIZE;
+        contextSavesOffset = funcDescTabsOffset + funcDescTabsSize;
+        contextSavesSize = (NCHANNELS * CONTEXT_SAVE_SIZE);
+        fixedSize = taskTableSize + varTabsSize + funcDescTabsSize +
+                    contextSavesSize;
+
+        /* zero the thing out */
+        fixedPtr = (u32 *)taskTableDest;
+        for (i = 0;i<(fixedSize/4);i++)
+            fixedPtr[i] = 0;
+
+        entryPtr = (TaskTableEntry*)MCD_taskTable;
+        /* set up fixed pointers */
+        for (i = 0; i < NCHANNELS; i++)
+        {
+            entryPtr[i].varTab = (u32)varTabsOffset; /* update ptr to local value */
+            entryPtr[i].FDTandFlags = (u32)funcDescTabsOffset | MCD_TT_FLAGS_DEF;
+            entryPtr[i].contextSaveSpace = (u32)contextSavesOffset;
+            varTabsOffset += VAR_TAB_SIZE;
+#ifdef MCD_INCLUDE_EU /* if not there is only one, just point to the same one */
+            funcDescTabsOffset += FUNCDESC_TAB_SIZE;
+#endif
+            contextSavesOffset += CONTEXT_SAVE_SIZE;
+        }
+        /* copy over the function descriptor table */
+        for ( i = 0; i < FUNCDESC_TAB_NUM; i++)
+        {
+            MCD_memcpy((void*)(entryPtr[i].FDTandFlags & ~MCD_TT_FLAGS_MASK),
+                       (void*)MCD_funcDescTab0, FUNCDESC_TAB_SIZE);
+        }
+
+        /* copy model task table to where the context saves stuff leaves off*/
+        MCD_modelTaskTable = (TaskTableEntry*)contextSavesOffset;
+
+        MCD_memcpy ((void*)MCD_modelTaskTable, (void*)MCD_modelTaskTableSrc,
+                    NUMOFVARIANTS * sizeof(TaskTableEntry));
+
+        entryPtr = MCD_modelTaskTable; /* point to local version of
+                                                            model task table */
+        taskDescTabsOffset = (u32)MCD_modelTaskTable +
+                            (NUMOFVARIANTS * sizeof(TaskTableEntry));
+
+        /* copy actual task code and update TDT ptrs in local model task table */
+        for (i = 0; i < NUMOFVARIANTS; i++)
+        {
+            taskDescTabSize = entryPtr[i].TDTend - entryPtr[i].TDTstart + 4;
+            MCD_memcpy ((void*)taskDescTabsOffset, (void*)entryPtr[i].TDTstart, taskDescTabSize);
+            entryPtr[i].TDTstart = (u32)taskDescTabsOffset;
+            taskDescTabsOffset += taskDescTabSize;
+            entryPtr[i].TDTend = (u32)taskDescTabsOffset - 4;
+        }
+#ifdef MCD_INCLUDE_EU /* Tack single DMA BDs onto end of code so API controls
+                         where they are since DMA might write to them */        
+        MCD_relocBuffDesc = (MCD_bufDesc*)(entryPtr[NUMOFVARIANTS - 1].TDTend + 4);
+#else /* DMA does not touch them so they can be wherever and we don't need to 
+         waste SRAM on them */
+        MCD_relocBuffDesc = MCD_singleBufDescs;
+#endif
+    }
+    else
+    {
+        /* point the would-be relocated task tables and the
+        buffer descriptors to the ones the linker generated */
+
+        if (((u32)MCD_realTaskTableSrc & 0x000001ff) != 0)
+            return(MCD_TABLE_UNALIGNED);
+
+        /* need to add code to make sure that every thing else is aligned properly TBD*/
+        /* this is problematic if we init more than once or after running tasks,
+            need to add variable to see if we have aleady init'd */
+        entryPtr = MCD_realTaskTableSrc;
+        for (i = 0; i < NCHANNELS; i++)
+        {
+            if (((entryPtr[i].varTab & (VAR_TAB_SIZE - 1)) != 0) ||
+                ((entryPtr[i].FDTandFlags & (FUNCDESC_TAB_SIZE - 1)) != 0))
+                return(MCD_TABLE_UNALIGNED);
+        }
+
+        MCD_taskTable = MCD_realTaskTableSrc;
+        MCD_modelTaskTable = MCD_modelTaskTableSrc;
+        MCD_relocBuffDesc = MCD_singleBufDescs;
+    }
+
+
+    /* Make all channels as totally inactive, and remember them as such: */
+
+    MCD_dmaBar->taskbar = (u32) MCD_taskTable;
+    for (i = 0;  i < NCHANNELS;  i++)
+    {
+        MCD_dmaBar->taskControl[i] = 0x0;
+        MCD_chStatus[i] = MCD_NO_DMA;
+    }
+
+   /* Set up pausing mechanism to inactive state: */
+    MCD_dmaBar->debugComp1 = 0;  /* no particular values yet for either comparator registers */
+    MCD_dmaBar->debugComp2 = 0;
+    MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+    MCD_dmaBar->debugStatus = DBG_KILL_ALL_STAT;
+
+    /* enable or disable commbus prefetch, really need an ifdef or
+       something to keep from trying to set this in the 8220 */
+    if ((flags & MCD_COMM_PREFETCH_EN) != 0)
+        MCD_dmaBar->ptdControl &= ~PTD_CTL_COMM_PREFETCH;
+    else
+        MCD_dmaBar->ptdControl |= PTD_CTL_COMM_PREFETCH;
+
+    return(MCD_OK);
+}
+/*********************** End of MCD_initDma() ***********************/
+
+/********************************************************************/
+/* Function:   MCD_dmaStatus
+ * Purpose:    Returns the status of the DMA on the requested channel
+ * Arguments:  channel - channel number
+ * Returns:    Predefined status indicators
+ */
+int MCD_dmaStatus (int channel)
+{
+    u16 tcrValue;
+
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    tcrValue = MCD_dmaBar->taskControl[channel];
+    if ((tcrValue & TASK_CTL_EN) == 0)
+    {  /* nothing running */
+        /* if last reported with task enabled */
+        if (   MCD_chStatus[channel] == MCD_RUNNING
+            || MCD_chStatus[channel] == MCD_IDLE)
+            MCD_chStatus[channel] = MCD_DONE;
+    }
+    else /* something is running */
+    {
+        /* There are three possibilities: paused, running or idle. */
+        if (   MCD_chStatus[channel] == MCD_RUNNING
+            || MCD_chStatus[channel] == MCD_IDLE)
+        {
+            MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT;
+            /* This register is selected to know which initiator is
+            actually asserted. */
+            if ((MCD_dmaBar->ptdDebug >> channel ) & 0x1 )
+                MCD_chStatus[channel] = MCD_RUNNING;
+            else
+                MCD_chStatus[channel] = MCD_IDLE;
+        /* do not change the status if it is already paused. */
+        }
+    }
+    return MCD_chStatus[channel];
+}
+/******************** End of MCD_dmaStatus() ************************/
+
+/********************************************************************/
+/* Function:    MCD_startDma
+ * Ppurpose:    Starts a particular kind of DMA
+ * Arguments:   see below
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+
+int MCD_startDma (
+    int  channel,   /* the channel on which to run the DMA */
+    s8   *srcAddr,  /* the address to move data from, or physical buffer-descriptor address */
+    s16  srcIncr,   /* the amount to increment the source address per transfer */
+    s8   *destAddr, /* the address to move data to */
+    s16  destIncr,  /* the amount to increment the destination address per transfer */
+    u32  dmaSize,   /* the number of bytes to transfer independent of the transfer size */
+    u32  xferSize,  /* the number bytes in of each data movement (1, 2, or 4) */
+    u32  initiator, /* what device initiates the DMA */
+    int  priority,  /* priority of the DMA */
+    u32  flags,     /* flags describing the DMA */
+    u32  funcDesc   /* a description of byte swapping, bit swapping, and CRC actions */
+#ifdef MCD_NEED_ADDR_TRANS
+    s8   *srcAddrVirt /* virtual buffer descriptor address TBD*/
+#endif
+)
+{
+    int srcRsdIncr, destRsdIncr;
+    int *cSave;
+    short xferSizeIncr;
+    int tcrCount = 0;
+#ifdef MCD_INCLUDE_EU
+    u32 *realFuncArray;
+#endif
+
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+        
+    /* tbd - need to determine the proper response to a bad funcDesc when not 
+       including EU functions, for now, assign a benign funcDesc, but maybe
+       should return an error */
+#ifndef MCD_INCLUDE_EU
+    funcDesc = MCD_FUNC_NOEU1;
+#endif
+        
+#ifdef MCD_DEBUG
+printf("startDma:Setting up params\n");
+#endif
+   /* Set us up for task-wise priority.  We don't technically need to do this on every start, but
+      since the register involved is in the same longword as other registers that users are in control
+      of, setting it more than once is probably preferable.  That since the documentation doesn't seem
+      to be completely consistent about the nature of the PTD control register. */
+    MCD_dmaBar->ptdControl |= (u16) 0x8000;
+#if 1 /* Not sure what we need to keep here rtm TBD */
+    /* Calculate additional parameters to the regular DMA calls. */
+    srcRsdIncr = srcIncr < 0 ? -1 : (srcIncr > 0 ? 1 : 0);
+    destRsdIncr = destIncr < 0 ? -1 : (destIncr > 0 ? 1 : 0);
+
+    xferSizeIncr = (xferSize & 0xffff) | 0x20000000;
+
+    /* Remember for each channel which variant is running. */
+    MCD_remVariants.remSrcRsdIncr[channel] = srcRsdIncr;
+    MCD_remVariants.remDestRsdIncr[channel] = destRsdIncr;
+    MCD_remVariants.remDestIncr[channel] = destIncr;
+    MCD_remVariants.remSrcIncr[channel] = srcIncr;
+    MCD_remVariants.remXferSize[channel] = xferSize;
+#endif
+
+    cSave = (int*)(MCD_taskTable[channel].contextSaveSpace) + CSAVE_OFFSET + CURRBD;
+
+#ifdef MCD_INCLUDE_EU /* may move this to EU specific calls */
+    realFuncArray = (u32 *) (MCD_taskTable[channel].FDTandFlags & 0xffffff00);
+    /* Modify the LURC's normal and byte-residue-loop functions according to parameter. */
+    realFuncArray[(LURC*16)] = xferSize == 4 ?
+                                 funcDesc : xferSize == 2 ?
+                                     funcDesc & 0xfffff00f : funcDesc & 0xffff000f;
+    realFuncArray[(LURC*16+1)] = (funcDesc & MCD_BYTE_SWAP_KILLER) | MCD_NO_BYTE_SWAP_ATALL;
+#endif
+   /* Write the initiator field in the TCR, and also set the initiator-hold
+      bit.  Note that,due to a hardware quirk, this could collide with an
+      MDE access to the initiator-register file, so we have to verify that the write
+      reads back correctly. */
+
+    MCD_dmaBar->taskControl[channel] =
+        (initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM;
+
+    while(((MCD_dmaBar->taskControl[channel] & 0x1fff) !=
+          ((initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM)) &&
+            (tcrCount < 1000))
+    {
+        tcrCount++;
+        /*MCD_dmaBar->ptd_tcr[channel] = (initiator << 8) | 0x0020;*/
+        MCD_dmaBar->taskControl[channel] =
+            (initiator << 8) | TASK_CTL_HIPRITSKEN | TASK_CTL_HLDINITNUM;
+    }
+
+    MCD_dmaBar->priority[channel] = (u8)priority & PRIORITY_PRI_MASK;
+    /* should be albe to handle this stuff with only one write to ts reg - tbd */
+    if (channel < 8 && channel >= 0)
+    {
+        MCD_dmaBar->taskSize0 &= ~(0xf << (7-channel)*4);
+        MCD_dmaBar->taskSize0 |= (xferSize & 3) << (((7 - channel)*4) + 2);
+        MCD_dmaBar->taskSize0 |= (xferSize & 3) << ((7 - channel)*4);
+    }
+    else
+    {
+        MCD_dmaBar->taskSize1 &= ~(0xf << (15-channel)*4);
+        MCD_dmaBar->taskSize1 |= (xferSize & 3) << (((15 - channel)*4) + 2);
+        MCD_dmaBar->taskSize1 |= (xferSize & 3) << ((15 - channel)*4);
+    }
+
+    /* setup task table flags/options which mostly control the line buffers */
+    MCD_taskTable[channel].FDTandFlags &= ~MCD_TT_FLAGS_MASK;
+    MCD_taskTable[channel].FDTandFlags |= (MCD_TT_FLAGS_MASK & flags);
+
+    if (flags & MCD_FECTX_DMA)
+    {
+        /* TDTStart and TDTEnd */
+        MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_FECTX].TDTstart;
+        MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_FECTX].TDTend;
+        MCD_startDmaENetXmit(srcAddr, srcAddr, destAddr, MCD_taskTable, channel);
+    }
+    else if (flags & MCD_FECRX_DMA)
+    {
+        /* TDTStart and TDTEnd */
+        MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_FECRX].TDTstart;
+        MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_FECRX].TDTend;
+        MCD_startDmaENetRcv(srcAddr, srcAddr, destAddr, MCD_taskTable, channel);
+    }
+    else if(flags & MCD_SINGLE_DMA)
+    {
+        /* this buffer descriptor is used for storing off initial parameters for later
+           progress query calculation and for the DMA to write the resulting checksum
+           The DMA does not use this to determine how to operate, that info is passed
+           with the init routine*/
+        MCD_relocBuffDesc[channel].srcAddr = srcAddr;
+        MCD_relocBuffDesc[channel].destAddr = destAddr;
+        MCD_relocBuffDesc[channel].lastDestAddr = destAddr;  /* definitely not its final value */
+        MCD_relocBuffDesc[channel].dmaSize = dmaSize;
+        MCD_relocBuffDesc[channel].flags = 0;       /* not used */
+        MCD_relocBuffDesc[channel].csumResult = 0;  /* not used */
+        MCD_relocBuffDesc[channel].next = 0;        /* not used */
+
+        /* Initialize the progress-querying stuff to show no progress:*/
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET] = (int)srcAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET] = (int)destAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] = 0;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] =
+                                             (u32) &(MCD_relocBuffDesc[channel]);
+        /* tbd - need to keep the user from trying to call the EU routine
+           when MCD_INCLUDE_EU is not defined */
+        if( funcDesc == MCD_FUNC_NOEU1 || funcDesc == MCD_FUNC_NOEU2)
+        {
+           /* TDTStart and TDTEnd */
+           MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLENOEU].TDTstart;
+           MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLENOEU].TDTend;
+           MCD_startDmaSingleNoEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize, dmaSize,
+                                xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), cSave,
+                                MCD_taskTable, channel);
+        }
+        else
+        {
+           /* TDTStart and TDTEnd */
+           MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_SINGLEEU].TDTstart;
+           MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_SINGLEEU].TDTend;
+           MCD_startDmaSingleEu(srcAddr, srcIncr, destAddr, destIncr, dmaSize, dmaSize,
+                              xferSizeIncr, flags, (int *)&(MCD_relocBuffDesc[channel]), cSave,
+                              MCD_taskTable, channel);
+        }
+    }
+    else
+    { /* chained DMAS */
+        /* Initialize the progress-querying stuff to show no progress:*/
+#if 1 /* (!defined(MCD_NEED_ADDR_TRANS)) */
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET]
+          = (int)((MCD_bufDesc*) phys_to_virt(srcAddr))->srcAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET]
+          = (int)((MCD_bufDesc*) phys_to_virt(srcAddr))->destAddr;
+#else /* if using address translation, need the virtual addr of the first buffdesc */
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET]
+          = (int)((MCD_bufDesc*) srcAddrVirt)->srcAddr;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET]
+          = (int)((MCD_bufDesc*) srcAddrVirt)->destAddr;
+#endif
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET] = 0;
+        ((volatile int *)MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET] = (u32) srcAddr;
+
+        if( funcDesc == MCD_FUNC_NOEU1 || funcDesc == MCD_FUNC_NOEU2)
+        {
+          /*TDTStart and TDTEnd*/
+          MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINNOEU].TDTstart;
+          MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINNOEU].TDTend;
+          MCD_startDmaChainNoEu((int *)srcAddr, srcIncr, destIncr, xferSize,
+                                    xferSizeIncr, cSave, MCD_taskTable, channel);
+        }
+        else
+        {
+          /*TDTStart and TDTEnd*/
+          MCD_taskTable[channel].TDTstart = MCD_modelTaskTable[TASK_CHAINEU].TDTstart;
+          MCD_taskTable[channel].TDTend = MCD_modelTaskTable[TASK_CHAINEU].TDTend;
+          MCD_startDmaChainEu((int *)srcAddr, srcIncr, destIncr, xferSize,
+                                 xferSizeIncr, cSave, MCD_taskTable, channel);
+        }
+    }
+    MCD_chStatus[channel] = MCD_IDLE;
+    return(MCD_OK);
+}
+
+/************************ End of MCD_startDma() *********************/
+
+/********************************************************************/
+/* Function:    MCD_XferProgrQuery
+ * Purpose:     Returns progress of DMA on requested channel
+ * Arguments:   channel - channel to retrieve progress for
+ *              progRep - pointer to user supplied MCD_XferProg struct
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  MCD_XferProgrQuery() upon completing or after aborting a DMA, or
+ *  while the DMA is in progress, this function returns the first
+ *  DMA-destination address not (or not yet) used in the DMA. When 
+ *  encountering a non-ready buffer descriptor, the information for
+ *  the last completed descriptor is returned.
+ *
+ *  MCD_XferProgQuery() has to avoid the possibility of getting
+ *  partially-updated information in the event that we should happen
+ *  to query DMA progress just as the DMA is updating it. It does that
+ *  by taking advantage of the fact context is not saved frequently for
+ *  the most part. We therefore read it at least twice until we get the
+ *  same information twice in a row.
+ *
+ *  Because a small, but not insignificant, amount of time is required
+ *  to write out the progress-query information, especially upon
+ *  completion of the DMA, it would be wise to guarantee some time lag
+ *  between successive readings of the progress-query information.
+ */
+
+/*
+ * How many iterations of the loop below to execute to stabilize values
+ */
+#define STABTIME 0
+
+int MCD_XferProgrQuery (int channel, MCD_XferProg *progRep)
+{
+    MCD_XferProg prevRep;
+    int again;  /* true if we are to try again to get consistent results */
+    int i;  /* used as a time-waste counter */
+    int destDiffBytes; /* Total number of bytes that we think actually got xfered. */
+    int numIterations; /* number of iterations */
+    int bytesNotXfered; /* bytes that did not get xfered. */
+    s8 *LWAlignedInitDestAddr, *LWAlignedCurrDestAddr;
+    int subModVal, addModVal; /* Mode values to added and subtracted from the
+                                final destAddr */
+
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    /* Read a trial value for the progress-reporting values*/
+    prevRep.lastSrcAddr =
+          (s8 *) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET];
+    prevRep.lastDestAddr =
+          (s8 *) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET];
+    prevRep.dmaSize = ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET];
+    prevRep.currBufDesc =
+          (MCD_bufDesc*) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
+    /* Repeatedly reread those values until they match previous values: */
+    do {
+        /* Waste a little bit of time to ensure stability: */
+        for (i = 0;  i < STABTIME;  i++)
+            i += i >> 2;  /* make sure this loop does something so that it doesn't get optimized out */
+        /* Check them again: */
+        progRep->lastSrcAddr =
+            (s8 *) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[SRCPTR + CSAVE_OFFSET];
+        progRep->lastDestAddr =
+            (s8 *) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DESTPTR + CSAVE_OFFSET];
+        progRep->dmaSize = ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[DCOUNT + CSAVE_OFFSET];
+        progRep->currBufDesc =
+            (MCD_bufDesc*) ((volatile int*) MCD_taskTable[channel].contextSaveSpace)[CURRBD + CSAVE_OFFSET];
+       /* See if they match: */
+       if (   prevRep.lastSrcAddr != progRep->lastSrcAddr
+           || prevRep.lastDestAddr != progRep->lastDestAddr
+           || prevRep.dmaSize != progRep->dmaSize
+           || prevRep.currBufDesc != progRep->currBufDesc)
+       {
+          /* If they don't match, remember previous values and try again:*/
+          prevRep.lastSrcAddr = progRep->lastSrcAddr;
+          prevRep.lastDestAddr = progRep->lastDestAddr;
+          prevRep.dmaSize = progRep->dmaSize;
+          prevRep.currBufDesc = progRep->currBufDesc;
+          again = MCD_TRUE;
+       }
+       else
+          again = MCD_FALSE;
+    } while (again == MCD_TRUE);
+
+
+    /* Update the dCount, srcAddr and destAddr */
+    /* To calculate dmaCount, we consider destination address. C
+       overs M1,P1,Z for destination */
+    switch(MCD_remVariants.remDestRsdIncr[channel]) {
+        case MINUS1:
+           subModVal = ((int)progRep->lastDestAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+           addModVal = ((int)progRep->currBufDesc->destAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+           LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr) - addModVal;
+           LWAlignedCurrDestAddr = (progRep->lastDestAddr) - subModVal;
+           destDiffBytes = LWAlignedInitDestAddr - LWAlignedCurrDestAddr;
+           bytesNotXfered = (destDiffBytes/MCD_remVariants.remDestIncr[channel]) *
+                            ( MCD_remVariants.remDestIncr[channel]
+                            + MCD_remVariants.remXferSize[channel]);
+           progRep->dmaSize = destDiffBytes - bytesNotXfered + addModVal - subModVal;
+           break;
+        case ZERO:
+           progRep->lastDestAddr = progRep->currBufDesc->destAddr;
+           break;
+        case PLUS1:
+           /* This value has to be subtracted from the final calculated dCount. */
+           subModVal = ((int)progRep->currBufDesc->destAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+           /* These bytes are already in lastDestAddr. */
+            addModVal = ((int)progRep->lastDestAddr) & ((MCD_remVariants.remXferSize[channel]) - 1);
+            LWAlignedInitDestAddr = (progRep->currBufDesc->destAddr) - subModVal;
+            LWAlignedCurrDestAddr = (progRep->lastDestAddr) - addModVal;
+            destDiffBytes = (progRep->lastDestAddr - LWAlignedInitDestAddr);
+            numIterations = ( LWAlignedCurrDestAddr - LWAlignedInitDestAddr)/MCD_remVariants.remDestIncr[channel];
+            bytesNotXfered =  numIterations *
+                ( MCD_remVariants.remDestIncr[channel]
+                  - MCD_remVariants.remXferSize[channel]);
+           progRep->dmaSize = destDiffBytes - bytesNotXfered - subModVal;
+           break;
+        default:
+           break;
+    }
+
+    /* This covers M1,P1,Z for source */
+    switch(MCD_remVariants.remSrcRsdIncr[channel]) {
+        case MINUS1:
+            progRep->lastSrcAddr =
+                progRep->currBufDesc->srcAddr +
+                 ( MCD_remVariants.remSrcIncr[channel] *
+                   (progRep->dmaSize/MCD_remVariants.remXferSize[channel]));
+            break;
+        case ZERO:
+            progRep->lastSrcAddr = progRep->currBufDesc->srcAddr;
+            break;
+       case PLUS1:
+            progRep->lastSrcAddr =
+                progRep->currBufDesc->srcAddr +
+                 ( MCD_remVariants.remSrcIncr[channel] *
+                   (progRep->dmaSize/MCD_remVariants.remXferSize[channel]));
+          break;
+       default: break;
+    }
+
+    return(MCD_OK);
+}
+/******************* End of MCD_XferProgrQuery() ********************/
+
+/********************************************************************/
+/* MCD_resmActions() does the majority of the actions of a DMA resume.
+ * It is called from MCD_killDma() and MCD_resumeDma().  It has to be
+ * a separate function because the kill function has to negate the task
+ * enable before resuming it, but the resume function has to do nothing
+ * if there is no DMA on that channel (i.e., if the enable bit is 0).
+ */
+static void MCD_resmActions (int channel)
+{
+   MCD_dmaBar->debugControl = DBG_CTL_DISABLE;
+   MCD_dmaBar->debugStatus = MCD_dmaBar->debugStatus;
+   MCD_dmaBar->ptdDebug = PTD_DBG_TSK_VLD_INIT; /* This register is selected to know
+                                        which initiator is actually asserted. */
+   if((MCD_dmaBar->ptdDebug >> channel ) & 0x1)
+       MCD_chStatus[channel] = MCD_RUNNING;
+   else
+       MCD_chStatus[channel] = MCD_IDLE;
+}
+/********************* End of MCD_resmActions() *********************/
+
+/********************************************************************/
+/* Function:    MCD_killDma
+ * Purpose:     Halt the DMA on the requested channel, without any
+ *              intention of resuming the DMA.
+ * Arguments:   channel - requested channel
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  A DMA may be killed from any state, including paused state, and it
+ *  always goes to the MCD_HALTED state even if it is killed while in
+ *  the MCD_NO_DMA or MCD_IDLE states.
+ */
+int MCD_killDma (int channel)
+{
+   /* MCD_XferProg progRep; */
+
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    MCD_dmaBar->taskControl[channel] = 0x0;
+    MCD_resumeDma (channel);
+    /*
+     * This must be after the write to the TCR so that the task doesn't
+     * start up again momentarily, and before the status assignment so
+     * as to override whatever MCD_resumeDma() may do to the channel
+     * status.
+     */
+    MCD_chStatus[channel] = MCD_HALTED;
+
+    /*
+     * Update the current buffer descriptor's lastDestAddr field
+     *
+     * MCD_XferProgrQuery (channel, &progRep);
+     * progRep.currBufDesc->lastDestAddr = progRep.lastDestAddr;
+     */
+    return(MCD_OK);
+}
+/************************ End of MCD_killDma() **********************/
+
+/********************************************************************/
+/* Function:    MCD_continDma
+ * Purpose:     Continue a DMA which as stopped due to encountering an
+ *              unready buffer descriptor.
+ * Arguments:   channel - channel to continue the DMA on
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *  This routine does not check to see if there is a task which can
+ *  be continued. Also this routine should not be used with single DMAs.
+ */
+int MCD_continDma (int channel)
+{
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    MCD_dmaBar->taskControl[channel] |= TASK_CTL_EN;
+    MCD_chStatus[channel] = MCD_RUNNING;
+
+    return(MCD_OK);
+}
+/********************** End of MCD_continDma() **********************/
+
+/*********************************************************************
+ * MCD_pauseDma() and MCD_resumeDma() below use the DMA's debug unit
+ * to freeze a task and resume it.  We freeze a task by breakpointing
+ * on the stated task.  That is, not any specific place in the task,
+ * but any time that task executes.  In particular, when that task
+ * executes, we want to freeze that task and only that task.
+ *
+ * The bits of the debug control register influence interrupts vs.
+ * breakpoints as follows:
+ * - Bits 14 and 0 enable or disable debug functions.  If enabled, you
+ *   will get the interrupt but you may or may not get a breakpoint.
+ * - Bits 2 and 1 decide whether you also get a breakpoint in addition
+ *   to an interrupt.
+ *
+ * The debug unit can do these actions in response to either internally
+ * detected breakpoint conditions from the comparators, or in response
+ * to the external breakpoint pin, or both.
+ * - Bits 14 and 1 perform the above-described functions for
+ *   internally-generated conditions, i.e., the debug comparators.
+ * - Bits 0 and 2 perform the above-described functions for external
+ *   conditions, i.e., the breakpoint external pin.
+ *
+ * Note that, although you "always" get the interrupt when you turn
+ * the debug functions, the interrupt can nevertheless, if desired, be
+ * masked by the corresponding bit in the PTD's IMR. Note also that
+ * this means that bits 14 and 0 must enable debug functions before
+ * bits 1 and 2, respectively, have any effect.
+ *
+ * NOTE: It's extremely important to not pause more than one DMA channel 
+ *  at a time.
+ ********************************************************************/
+
+/********************************************************************/
+/* Function:    MCD_pauseDma
+ * Purpose:     Pauses the DMA on a given channel (if any DMA is running
+ *              on that channel).
+ * Arguments:   channel
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+int MCD_pauseDma (int channel)
+{
+    /* MCD_XferProg progRep; */
+
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    if (MCD_dmaBar->taskControl[channel] & TASK_CTL_EN)
+    {
+        MCD_dmaBar->debugComp1 = channel;
+        MCD_dmaBar->debugControl = DBG_CTL_ENABLE | (1 << (channel + 16));
+        MCD_chStatus[channel] = MCD_PAUSED;
+
+        /*
+         * Update the current buffer descriptor's lastDestAddr field
+         *
+         * MCD_XferProgrQuery (channel, &progRep);
+         * progRep.currBufDesc->lastDestAddr = progRep.lastDestAddr;
+         */
+    }
+    return(MCD_OK);
+}
+/************************* End of MCD_pauseDma() ********************/
+
+/********************************************************************/
+/* Function:    MCD_resumeDma
+ * Purpose:     Resumes the DMA on a given channel (if any DMA is
+ *              running on that channel).
+ * Arguments:   channel - channel on which to resume DMA
+ * Returns:     MCD_CHANNEL_INVALID if channel is invalid, else MCD_OK
+ */
+int MCD_resumeDma (int channel)
+{
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    if (MCD_dmaBar->taskControl[channel] & TASK_CTL_EN)
+        MCD_resmActions (channel);
+
+    return(MCD_OK);
+}
+/************************ End of MCD_resumeDma() ********************/
+
+/********************************************************************/
+/* Function:    MCD_csumQuery
+ * Purpose:     Provide the checksum after performing a non-chained DMA
+ * Arguments:   channel - channel to report on
+ *              csum - pointer to where to write the checksum/CRC
+ * Returns:     MCD_ERROR if the channel is invalid, else MCD_OK
+ *
+ * Notes:
+ *
+ */
+int MCD_csumQuery (int channel, u32 *csum)
+{
+#ifdef MCD_INCLUDE_EU
+    if((channel < 0) || (channel >= NCHANNELS))
+        return(MCD_CHANNEL_INVALID);
+
+    *csum = MCD_relocBuffDesc[channel].csumResult;
+    return(MCD_OK);
+#else
+    return(MCD_ERROR);
+#endif
+}
+/*********************** End of MCD_resumeDma() *********************/
+
+/********************************************************************/
+/* Function:    MCD_getCodeSize
+ * Purpose:     Provide the size requirements of the microcoded tasks
+ * Returns:     Size in bytes
+ */
+int MCD_getCodeSize(void)
+{
+#ifdef MCD_INCLUDE_EU
+    return(0x2b5c);
+#else
+    return(0x173c);
+#endif
+}
+/********************** End of MCD_getCodeSize() ********************/
+
+/********************************************************************/
+/* Function:    MCD_getVersion
+ * Purpose:     Provide the version string and number
+ * Arguments:   longVersion - user supplied pointer to a pointer to a char
+ *                    which points to the version string
+ * Returns:     Version number and version string (by reference)
+ */
+char MCD_versionString[] = "Multi-channel DMA API Alpha v0.3 (2004-04-26)";
+#define MCD_REV_MAJOR   0x00
+#define MCD_REV_MINOR   0x03
+
+int MCD_getVersion(char **longVersion)
+{
+    *longVersion = MCD_versionString;
+    return((MCD_REV_MAJOR << 8) | MCD_REV_MINOR);
+}
+/********************** End of MCD_getVersion() *********************/
+
+/********************************************************************/
+/* Private version of memcpy()
+ * Note that everything this is used for is longword-aligned.
+ */
+static void MCD_memcpy (int *dest, int *src, u32 size)
+{
+    u32 i;
+
+    for (i = 0;  i < size;  i += sizeof(int), dest++, src++)
+        *dest = *src;
+}
+/********************************************************************/
--- /dev/null
+++ b/drivers/dma/MCD_progCheck.h
@@ -0,0 +1,33 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+ /* This file is autogenerated. Do not change */
+#define CURRBD 4
+#define DCOUNT 6
+#define DESTPTR 5
+#define SRCPTR 7
--- /dev/null
+++ b/drivers/dma/MCD_tasks.c
@@ -0,0 +1,2452 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+/*
+ * File:        MCD_tasks.c
+ * Purpose:     Contains task code and structures for Multi-channel DMA
+ *
+ * Notes:
+ *
+ *
+ * Modifications:
+ *
+ *
+ */
+
+#include <asm/MCD_dma.h>
+
+u32 MCD_varTab0[];
+u32 MCD_varTab1[];
+u32 MCD_varTab2[];
+u32 MCD_varTab3[];
+u32 MCD_varTab4[];
+u32 MCD_varTab5[];
+u32 MCD_varTab6[];
+u32 MCD_varTab7[];
+u32 MCD_varTab8[];
+u32 MCD_varTab9[];
+u32 MCD_varTab10[];
+u32 MCD_varTab11[];
+u32 MCD_varTab12[];
+u32 MCD_varTab13[];
+u32 MCD_varTab14[];
+u32 MCD_varTab15[];
+
+u32 MCD_funcDescTab0[];
+#ifdef MCD_INCLUDE_EU
+u32 MCD_funcDescTab1[];
+u32 MCD_funcDescTab2[];
+u32 MCD_funcDescTab3[];
+u32 MCD_funcDescTab4[];
+u32 MCD_funcDescTab5[];
+u32 MCD_funcDescTab6[];
+u32 MCD_funcDescTab7[];
+u32 MCD_funcDescTab8[];
+u32 MCD_funcDescTab9[];
+u32 MCD_funcDescTab10[];
+u32 MCD_funcDescTab11[];
+u32 MCD_funcDescTab12[];
+u32 MCD_funcDescTab13[];
+u32 MCD_funcDescTab14[];
+u32 MCD_funcDescTab15[];
+#endif
+
+u32 MCD_contextSave0[];
+u32 MCD_contextSave1[];
+u32 MCD_contextSave2[];
+u32 MCD_contextSave3[];
+u32 MCD_contextSave4[];
+u32 MCD_contextSave5[];
+u32 MCD_contextSave6[];
+u32 MCD_contextSave7[];
+u32 MCD_contextSave8[];
+u32 MCD_contextSave9[];
+u32 MCD_contextSave10[];
+u32 MCD_contextSave11[];
+u32 MCD_contextSave12[];
+u32 MCD_contextSave13[];
+u32 MCD_contextSave14[];
+u32 MCD_contextSave15[];
+
+u32 MCD_realTaskTableSrc[] =
+{
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab0,   /* Task 0 Variable Table */
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave0,  /* Task 0 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab1,   /* Task 1 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab1,  /* Task 1 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave1,  /* Task 1 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab2,   /* Task 2 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab2,  /* Task 2 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave2,  /* Task 2 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab3,   /* Task 3 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab3,  /* Task 3 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave3,  /* Task 3 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab4,   /* Task 4 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab4,  /* Task 4 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave4,  /* Task 4 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab5,   /* Task 5 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab5,  /* Task 5 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave5,  /* Task 5 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab6,   /* Task 6 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab6,  /* Task 6 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave6,  /* Task 6 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab7,   /* Task 7 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab7,  /* Task 7 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave7,  /* Task 7 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab8,   /* Task 8 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab8,  /* Task 8 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave8,  /* Task 8 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab9,   /* Task 9 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab9,  /* Task 9 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave9,  /* Task 9 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab10,  /* Task 10 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab10, /* Task 10 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave10, /* Task 10 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab11,  /* Task 11 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab11, /* Task 11 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave11, /* Task 11 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab12,  /* Task 12 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab12, /* Task 12 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave12, /* Task 12 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab13,  /* Task 13 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab13, /* Task 13 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave13, /* Task 13 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab14,  /* Task 14 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab14, /* Task 14 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave14, /* Task 14 context save space */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_varTab15,  /* Task 15 Variable Table */
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_funcDescTab15, /* Task 15 Function Descriptor Table & Flags */
+#else
+    (u32)MCD_funcDescTab0,  /* Task 0 Function Descriptor Table & Flags */
+#endif
+    0x00000000,
+    0x00000000,
+    (u32)MCD_contextSave15, /* Task 15 context save space */
+    0x00000000,
+};
+
+
+u32 MCD_varTab0[] =
+{   /* Task 0 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+
+u32 MCD_varTab1[] =
+{   /* Task 1 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab2[]=
+{   /* Task 2 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab3[]=
+{   /* Task 3 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab4[]=
+{   /* Task 4 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab5[]=
+{   /* Task 5 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab6[]=
+{   /* Task 6 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab7[]=
+{   /* Task 7 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab8[]=
+{   /* Task 8 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab9[]=
+{   /* Task 9 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab10[]=
+{   /* Task 10 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab11[]=
+{   /* Task 11 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab12[]=
+{   /* Task 12 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab13[]=
+{   /* Task 13 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab14[]=
+{   /* Task 14 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_varTab15[]=
+{   /* Task 15 Variable Table */
+    0x00000000, /* var[0] */
+    0x00000000, /* var[1] */
+    0x00000000, /* var[2] */
+    0x00000000, /* var[3] */
+    0x00000000, /* var[4] */
+    0x00000000, /* var[5] */
+    0x00000000, /* var[6] */
+    0x00000000, /* var[7] */
+    0x00000000, /* var[8] */
+    0x00000000, /* var[9] */
+    0x00000000, /* var[10] */
+    0x00000000, /* var[11] */
+    0x00000000, /* var[12] */
+    0x00000000, /* var[13] */
+    0x00000000, /* var[14] */
+    0x00000000, /* var[15] */
+    0x00000000, /* var[16] */
+    0x00000000, /* var[17] */
+    0x00000000, /* var[18] */
+    0x00000000, /* var[19] */
+    0x00000000, /* var[20] */
+    0x00000000, /* var[21] */
+    0x00000000, /* var[22] */
+    0x00000000, /* var[23] */
+    0xe0000000, /* inc[0] */
+    0x20000000, /* inc[1] */
+    0x2000ffff, /* inc[2] */
+    0x00000000, /* inc[3] */
+    0x00000000, /* inc[4] */
+    0x00000000, /* inc[5] */
+    0x00000000, /* inc[6] */
+    0x00000000, /* inc[7] */
+};
+
+u32 MCD_funcDescTab0[]=
+{   /* Task 0 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+#ifdef MCD_INCLUDE_EU
+u32 MCD_funcDescTab1[]=
+{   /* Task 1 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab2[]=
+{   /* Task 2 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab3[]=
+{   /* Task 3 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab4[]=
+{   /* Task 4 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab5[]=
+{   /* Task 5 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab6[]=
+{   /* Task 6 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab7[]=
+{   /* Task 7 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab8[]=
+{   /* Task 8 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab9[]=
+{   /* Task 9 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab10[]=
+{   /* Task 10 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab11[]=
+{   /* Task 11 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab12[]=
+{   /* Task 12 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab13[]=
+{   /* Task 13 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab14[]=
+{   /* Task 14 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+
+u32 MCD_funcDescTab15[]=
+{   /* Task 15 Function Descriptor Table */
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0xa0045670, /* mainFunc(), EU# 3 */
+    0xa0000000, /* rsduFunc(), EU# 3 */
+    0xa0000000, /* crcAccumVal(), EU# 3 */
+    0x20000000, /* setCrcAccum(), EU# 3 */
+    0x21800000, /* and(), EU# 3 */
+    0x21e00000, /* or(), EU# 3 */
+    0x20400000, /* add(), EU# 3 */
+    0x20500000, /* sub(), EU# 3 */
+    0x205a0000, /* andNot(), EU# 3 */
+    0x202fa000, /* andReadyBit(), EU# 3 */
+    0x202f9000, /* andNotReadyBit(), EU# 3 */
+    0x202ea000, /* andWrapBit(), EU# 3 */
+    0x202da000, /* andEndFrameBit(), EU# 3 */
+    0x202e2000, /* andInterruptBit(), EU# 3 */
+    0x202f2000, /* andLoopBit(), EU# 3 */
+    0x2020a000, /* andCrcRestartBit(), EU# 3 */
+};
+#endif /*MCD_INCLUDE_EU*/
+
+u32 MCD_contextSave0[128];  /* Task 0 context save space */
+u32 MCD_contextSave1[128];  /* Task 1 context save space */
+u32 MCD_contextSave2[128];  /* Task 2 context save space */
+u32 MCD_contextSave3[128];  /* Task 3 context save space */
+u32 MCD_contextSave4[128];  /* Task 4 context save space */
+u32 MCD_contextSave5[128];  /* Task 5 context save space */
+u32 MCD_contextSave6[128];  /* Task 6 context save space */
+u32 MCD_contextSave7[128];  /* Task 7 context save space */
+u32 MCD_contextSave8[128];  /* Task 8 context save space */
+u32 MCD_contextSave9[128];  /* Task 9 context save space */
+u32 MCD_contextSave10[128]; /* Task 10 context save space */
+u32 MCD_contextSave11[128]; /* Task 11 context save space */
+u32 MCD_contextSave12[128]; /* Task 12 context save space */
+u32 MCD_contextSave13[128]; /* Task 13 context save space */
+u32 MCD_contextSave14[128]; /* Task 14 context save space */
+u32 MCD_contextSave15[128]; /* Task 15 context save space */
+
+/* Task Descriptor Tables - the guts */
+u32 MCD_ChainNoEu_TDT[];
+u32 MCD_SingleNoEu_TDT[];
+#ifdef MCD_INCLUDE_EU
+u32 MCD_ChainEu_TDT[];
+u32 MCD_SingleEu_TDT[];
+#endif
+u32 MCD_ENetRcv_TDT[];
+u32 MCD_ENetXmit_TDT[];
+
+u32 MCD_modelTaskTableSrc[]=
+{
+    (u32)MCD_ChainNoEu_TDT,
+    (u32)&((u8*)MCD_ChainNoEu_TDT)[0x00000178],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_SingleNoEu_TDT,
+    (u32)&((u8*)MCD_SingleNoEu_TDT)[0x000000d4],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+#ifdef MCD_INCLUDE_EU
+    (u32)MCD_ChainEu_TDT,
+    (u32)&((u8*)MCD_ChainEu_TDT)[0x00000180],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_SingleEu_TDT,
+    (u32)&((u8*)MCD_SingleEu_TDT)[0x000000dc],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+#endif
+    (u32)MCD_ENetRcv_TDT,
+    (u32)&((u8*)MCD_ENetRcv_TDT)[0x0000009C],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    (u32)MCD_ENetXmit_TDT,
+    (u32)&((u8*)MCD_ENetXmit_TDT)[0x000000d0],
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+    0x00000000,
+};
+
+u32 MCD_ChainNoEu_TDT[]=
+{
+    0x80004000, /* 0000(:370):  LCDEXT: idx0 = 0x00000000; ; */
+    0x8118801b, /* 0004(:370):  LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0xb8ca0018, /* 0008(:371):    LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
+    0x10004b10, /* 000C(:372):      DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000c, /* 0010(:373):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x024cf89f, /* 0014(:373):      DRD2B1: var9 = EU3(); EU3(idx2)  */
+    0x60000009, /* 0018(:374):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf89f, /* 001C(:374):      DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 0020(:0):    NOP */
+    0x98180524, /* 0024(:378):  LCD: idx0 = idx0; idx0 != var20; idx0 += inc4 */
+    0x8118801b, /* 0028(:380):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0xf8ca001a, /* 002C(:381):      LCDEXT: idx2 = *(idx1 + var20 + 8); idx2 once var0; idx2 += inc3 */
+    0xb8ca601b, /* 0030(:382):      LCD: idx3 = *(idx1 + var20 + 12); ; idx3 += inc3 */
+    0x10004310, /* 0034(:384):        DRD1A: var16 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x00001718, /* 0038(:385):        DRD1A: var5 = idx3; FN=0 init=0 WS=0 RS=0 */
+    0xb8ca001d, /* 003C(:387):      LCD: idx2 = *(idx1 + var20 + 20); idx2 once var0; idx2 += inc3 */
+    0x10001f10, /* 0040(:388):        DRD1A: var7 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000007, /* 0044(:389):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=7 EXT init=0 WS=0 RS=0 */
+    0x020cf893, /* 0048(:389):        DRD2B1: var8 = EU3(); EU3(idx2,var19)  */
+    0x98ca001c, /* 004C(:391):      LCD: idx2 = idx1 + var20 + 4; idx2 once var0; idx2 += inc3 */
+    0x00000710, /* 0050(:392):        DRD1A: var1 = idx2; FN=0 init=0 WS=0 RS=0 */
+    0x98ca8018, /* 0054(:393):      LCD: idx2 = idx1 + var21; idx2 once var0; idx2 += inc3 */
+    0x10002b10, /* 0058(:394):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c828, /* 005C(:395):        DRD1A: *idx2 = var5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0060(:0):      NOP */
+    0xc14ae018, /* 0064(:399):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
+    0xc004a51d, /* 0068(:399):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var20; idx2 += inc3, idx3 += inc5 */
+    0x811a601b, /* 006C(:400):    LCD: idx4 = var2; ; idx4 += inc3 */
+    0xc28a21c2, /* 0070(:403):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
+    0x881be009, /* 0074(:403):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0x03fed7b8, /* 0078(:406):        DRD1A: *idx7; FN=0 init=31 WS=3 RS=3 */
+    0xda9b001b, /* 007C(:408):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0080(:408):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x1000cb20, /* 0084(:409):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0088(:410):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 008C(:410):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb28, /* 0090(:411):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0094(:412):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 0098(:412):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb30, /* 009C(:413):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00A0(:414):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00A4(:414):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb38, /* 00A8(:415):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 00AC(:416):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00B0(:0):      NOP */
+    0xc14ae018, /* 00B4(:420):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
+    0xc004a5dd, /* 00B8(:420):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var23; idx2 += inc3, idx3 += inc5 */
+    0x811a601b, /* 00BC(:421):    LCD: idx4 = var2; ; idx4 += inc3 */
+    0xda9b001b, /* 00C0(:424):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00C4(:424):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 00C8(:425):        DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc28a21c2, /* 00CC(:427):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
+    0x881be009, /* 00D0(:427):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0x0bfed7b8, /* 00D4(:430):        DRD1A: *idx7; FN=0 TFD init=31 WS=3 RS=3 */
+    0xda9b001b, /* 00D8(:432):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00DC(:432):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x1000cb20, /* 00E0(:433):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00E4(:434):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00E8(:434):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb28, /* 00EC(:435):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00F0(:436):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00F4(:436):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb30, /* 00F8(:437):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00FC(:438):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 0100(:438):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb38, /* 0104(:439):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 0108(:440):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 010C(:0):      NOP */
+    0x8118801b, /* 0110(:444):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0x8a19001b, /* 0114(:446):      LCD: idx2 = var20; idx2 once var0; idx2 += inc3 */
+    0x6000000e, /* 0118(:447):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x088cf49f, /* 011C(:447):        DRD2B1: idx2 = EU3(); EU3(var18)  */
+    0xd9190536, /* 0120(:448):      LCDEXT: idx2 = idx2; idx2 == var20; idx2 += inc6 */
+    0x98ca0018, /* 0124(:448):      LCD: idx3 = idx1 + var20; idx3 once var0; idx3 += inc3 */
+    0x6000000a, /* 0128(:450):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x0cccfcdf, /* 012C(:450):        DRD2B1: *idx3 = EU3(); EU3(*idx3)  */
+    0x000001f8, /* 0130(:0):      NOP */
+    0xa14a001e, /* 0134(:453):    LCD: idx1 = *(var2 + var20 + 24); idx1 once var0; idx1 += inc3 */
+    0x10000b08, /* 0138(:454):      DRD1A: var2 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x10002c90, /* 013C(:455):      DRD1A: var11 = var18; FN=0 MORE init=0 WS=0 RS=0 */
+    0xb8ca0018, /* 0140(:456):      LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
+    0x10004b10, /* 0144(:457):        DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000009, /* 0148(:458):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf89f, /* 014C(:458):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x6000000c, /* 0150(:459):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT init=0 WS=0 RS=0 */
+    0x024cf89f, /* 0154(:459):        DRD2B1: var9 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 0158(:0):      NOP */
+    0x8a18801b, /* 015C(:465):    LCD: idx1 = var20; idx1 once var0; idx1 += inc3 */
+    0x7000000d, /* 0160(:466):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x084cf2df, /* 0164(:466):      DRD2B1: idx1 = EU3(); EU3(var11)  */
+    0xd899053f, /* 0168(:467):      LCDEXT: idx2 = idx1; idx2 > var20; idx2 += inc7 */
+    0x8019801b, /* 016C(:467):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x040001f8, /* 0170(:468):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 0174(:0):      NOP */
+    0x000001f8, /* 0178(:0):    NOP */
+};
+u32 MCD_SingleNoEu_TDT[]=
+{
+    0x8318001b, /* 0000(:646):  LCD: idx0 = var6; idx0 once var0; idx0 += inc3 */
+    0x7000000c, /* 0004(:647):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf81f, /* 0008(:647):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
+    0x8318801b, /* 000C(:648):    LCD: idx1 = var6; idx1 once var0; idx1 += inc3 */
+    0x6000000d, /* 0010(:649):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x084cf85f, /* 0014(:649):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
+    0x000001f8, /* 0018(:0):    NOP */
+    0x8498001b, /* 001C(:653):  LCD: idx0 = var9; idx0 once var0; idx0 += inc3 */
+    0x7000000c, /* 0020(:654):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x020cf81f, /* 0024(:654):    DRD2B1: var8 = EU3(); EU3(idx0)  */
+    0x6000000d, /* 0028(:655):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x028cf81f, /* 002C(:655):    DRD2B1: var10 = EU3(); EU3(idx0)  */
+    0xc404601b, /* 0030(:658):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
+    0xc00423dc, /* 0034(:658):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var15; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0038(:659):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xc207a182, /* 003C(:662):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
+    0x869be009, /* 0040(:662):    LCD: idx7 = var13; ; idx7 += inc1 */
+    0x03fed7b8, /* 0044(:665):      DRD1A: *idx7; FN=0 init=31 WS=3 RS=3 */
+    0xda9b001b, /* 0048(:667):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 004C(:667):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 0050(:669):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 0054(:669):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb28, /* 0058(:670):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 005C(:671):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 0060(:671):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb30, /* 0064(:672):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0068(:673):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 006C(:673):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x0000cb38, /* 0070(:674):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0074(:0):    NOP */
+    0xc404601b, /* 0078(:678):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
+    0xc004245c, /* 007C(:678):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var17; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0080(:679):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xda9b001b, /* 0084(:682):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0088(:682):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 008C(:683):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc207a182, /* 0090(:685):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
+    0x869be009, /* 0094(:685):    LCD: idx7 = var13; ; idx7 += inc1 */
+    0x0bfed7b8, /* 0098(:688):      DRD1A: *idx7; FN=0 TFD init=31 WS=3 RS=3 */
+    0xda9b001b, /* 009C(:690):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00A0(:690):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 00A4(:692):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00A8(:692):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb28, /* 00AC(:693):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00B0(:694):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00B4(:694):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb30, /* 00B8(:695):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00BC(:696):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00C0(:696):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x0000cb38, /* 00C4(:697):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00C8(:0):    NOP */
+    0xc51803ed, /* 00CC(:701):  LCDEXT: idx0 = var10; idx0 > var15; idx0 += inc5 */
+    0x8018801b, /* 00D0(:701):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
+    0x040001f8, /* 00D4(:702):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+};
+#ifdef MCD_INCLUDE_EU
+u32 MCD_ChainEu_TDT[]=
+{
+    0x80004000, /* 0000(:928):  LCDEXT: idx0 = 0x00000000; ; */
+    0x8118801b, /* 0004(:928):  LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0xb8ca0018, /* 0008(:929):    LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
+    0x10004b10, /* 000C(:930):      DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x7000000c, /* 0010(:931):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x024cf89f, /* 0014(:931):      DRD2B1: var9 = EU3(); EU3(idx2)  */
+    0x60000009, /* 0018(:932):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf89f, /* 001C(:932):      DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 0020(:0):    NOP */
+    0x98180524, /* 0024(:936):  LCD: idx0 = idx0; idx0 != var20; idx0 += inc4 */
+    0x8118801b, /* 0028(:938):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0xf8ca001a, /* 002C(:939):      LCDEXT: idx2 = *(idx1 + var20 + 8); idx2 once var0; idx2 += inc3 */
+    0xb8ca601b, /* 0030(:940):      LCD: idx3 = *(idx1 + var20 + 12); ; idx3 += inc3 */
+    0x10004310, /* 0034(:942):        DRD1A: var16 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x00001718, /* 0038(:943):        DRD1A: var5 = idx3; FN=0 init=0 WS=0 RS=0 */
+    0xb8ca001d, /* 003C(:945):      LCD: idx2 = *(idx1 + var20 + 20); idx2 once var0; idx2 += inc3 */
+    0x10001f10, /* 0040(:946):        DRD1A: var7 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000007, /* 0044(:947):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=7 EXT init=0 WS=0 RS=0 */
+    0x020cf893, /* 0048(:947):        DRD2B1: var8 = EU3(); EU3(idx2,var19)  */
+    0x98ca001c, /* 004C(:949):      LCD: idx2 = idx1 + var20 + 4; idx2 once var0; idx2 += inc3 */
+    0x00000710, /* 0050(:950):        DRD1A: var1 = idx2; FN=0 init=0 WS=0 RS=0 */
+    0x98ca8018, /* 0054(:951):      LCD: idx2 = idx1 + var21; idx2 once var0; idx2 += inc3 */
+    0x10002b10, /* 0058(:952):        DRD1A: var10 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c828, /* 005C(:953):        DRD1A: *idx2 = var5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0060(:0):      NOP */
+    0xc14ae018, /* 0064(:957):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
+    0xc004a51d, /* 0068(:957):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var20; idx2 += inc3, idx3 += inc5 */
+    0x811a601b, /* 006C(:958):    LCD: idx4 = var2; ; idx4 += inc3 */
+    0xc28a21c2, /* 0070(:961):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
+    0x881be009, /* 0074(:961):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0x63fe0000, /* 0078(:964):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 007C(:964):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 0080(:966):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0084(:966):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x1000cb20, /* 0088(:967):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 008C(:968):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 0090(:968):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb28, /* 0094(:969):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0098(:970):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 009C(:970):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb30, /* 00A0(:971):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00A4(:972):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00A8(:972):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb38, /* 00AC(:973):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 00B0(:974):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00B4(:0):      NOP */
+    0xc14ae018, /* 00B8(:978):    LCDEXT: idx1 = var2 + var21; ; idx1 += inc3 */
+    0xc004a5dd, /* 00BC(:978):    LCDEXT: idx2 = var0, idx3 = var9; idx3 == var23; idx2 += inc3, idx3 += inc5 */
+    0x811a601b, /* 00C0(:979):    LCD: idx4 = var2; ; idx4 += inc3 */
+    0xda9b001b, /* 00C4(:982):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00C8(:982):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 00CC(:983):        DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc28a21c2, /* 00D0(:985):      LCDEXT: idx5 = var5, idx6 = var20; idx6 < var7; idx5 += inc0, idx6 += inc2 */
+    0x881be009, /* 00D4(:985):      LCD: idx7 = var16; ; idx7 += inc1 */
+    0x6bfe0000, /* 00D8(:988):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 00DC(:988):        DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 00E0(:990):      LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00E4(:990):      LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x1000cb20, /* 00E8(:991):        DRD1A: *idx2 = idx4; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00EC(:992):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00F0(:992):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb28, /* 00F4(:993):        DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00F8(:994):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 00FC(:994):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb30, /* 0100(:995):        DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0104(:996):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf896, /* 0108(:996):        DRD2B1: idx2 = EU3(); EU3(idx2,var22)  */
+    0x1000cb38, /* 010C(:997):        DRD1A: *idx2 = idx7; FN=0 MORE init=0 WS=0 RS=0 */
+    0x0000c728, /* 0110(:998):        DRD1A: *idx1 = idx5; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0114(:0):      NOP */
+    0x8118801b, /* 0118(:1002):    LCD: idx1 = var2; idx1 once var0; idx1 += inc3 */
+    0x8a19001b, /* 011C(:1004):      LCD: idx2 = var20; idx2 once var0; idx2 += inc3 */
+    0x6000000e, /* 0120(:1005):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=14 EXT init=0 WS=0 RS=0 */
+    0x088cf49f, /* 0124(:1005):        DRD2B1: idx2 = EU3(); EU3(var18)  */
+    0xd9190536, /* 0128(:1006):      LCDEXT: idx2 = idx2; idx2 == var20; idx2 += inc6 */
+    0x98ca0018, /* 012C(:1006):      LCD: idx3 = idx1 + var20; idx3 once var0; idx3 += inc3 */
+    0x6000000a, /* 0130(:1008):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x0cccfcdf, /* 0134(:1008):        DRD2B1: *idx3 = EU3(); EU3(*idx3)  */
+    0x000001f8, /* 0138(:0):      NOP */
+    0xa14a001e, /* 013C(:1011):    LCD: idx1 = *(var2 + var20 + 24); idx1 once var0; idx1 += inc3 */
+    0x10000b08, /* 0140(:1012):      DRD1A: var2 = idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x10002c90, /* 0144(:1013):      DRD1A: var11 = var18; FN=0 MORE init=0 WS=0 RS=0 */
+    0xb8ca0018, /* 0148(:1014):      LCD: idx2 = *(idx1 + var20); idx2 once var0; idx2 += inc3 */
+    0x10004b10, /* 014C(:1015):        DRD1A: var18 = idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000009, /* 0150(:1016):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf89f, /* 0154(:1016):        DRD2B1: idx0 = EU3(); EU3(idx2)  */
+    0x6000000c, /* 0158(:1017):        DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT init=0 WS=0 RS=0 */
+    0x024cf89f, /* 015C(:1017):        DRD2B1: var9 = EU3(); EU3(idx2)  */
+    0x000001f8, /* 0160(:0):      NOP */
+    0x8a18801b, /* 0164(:1023):    LCD: idx1 = var20; idx1 once var0; idx1 += inc3 */
+    0x7000000d, /* 0168(:1024):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x084cf2df, /* 016C(:1024):      DRD2B1: idx1 = EU3(); EU3(var11)  */
+    0xd899053f, /* 0170(:1025):      LCDEXT: idx2 = idx1; idx2 > var20; idx2 += inc7 */
+    0x8019801b, /* 0174(:1025):      LCD: idx3 = var0; idx3 once var0; idx3 += inc3 */
+    0x040001f8, /* 0178(:1026):        DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 017C(:0):      NOP */
+    0x000001f8, /* 0180(:0):    NOP */
+};
+u32 MCD_SingleEu_TDT[]=
+{
+    0x8318001b, /* 0000(:1204):  LCD: idx0 = var6; idx0 once var0; idx0 += inc3 */
+    0x7000000c, /* 0004(:1205):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x080cf81f, /* 0008(:1205):    DRD2B1: idx0 = EU3(); EU3(idx0)  */
+    0x8318801b, /* 000C(:1206):    LCD: idx1 = var6; idx1 once var0; idx1 += inc3 */
+    0x6000000d, /* 0010(:1207):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x084cf85f, /* 0014(:1207):      DRD2B1: idx1 = EU3(); EU3(idx1)  */
+    0x000001f8, /* 0018(:0):    NOP */
+    0x8498001b, /* 001C(:1211):  LCD: idx0 = var9; idx0 once var0; idx0 += inc3 */
+    0x7000000c, /* 0020(:1212):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x020cf81f, /* 0024(:1212):    DRD2B1: var8 = EU3(); EU3(idx0)  */
+    0x6000000d, /* 0028(:1213):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT init=0 WS=0 RS=0 */
+    0x028cf81f, /* 002C(:1213):    DRD2B1: var10 = EU3(); EU3(idx0)  */
+    0xc404601b, /* 0030(:1216):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
+    0xc00423dc, /* 0034(:1216):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var15; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0038(:1217):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xc207a182, /* 003C(:1220):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
+    0x869be009, /* 0040(:1220):    LCD: idx7 = var13; ; idx7 += inc1 */
+    0x63fe0000, /* 0044(:1223):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 0048(:1223):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 004C(:1225):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 0050(:1225):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 0054(:1227):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 0058(:1227):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb28, /* 005C(:1228):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 0060(:1229):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 0064(:1229):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb30, /* 0068(:1230):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 006C(:1231):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 0070(:1231):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x0000cb38, /* 0074(:1232):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 0078(:0):    NOP */
+    0xc404601b, /* 007C(:1236):  LCDEXT: idx0 = var8, idx1 = var8; ; idx0 += inc3, idx1 += inc3 */
+    0xc004245c, /* 0080(:1236):  LCDEXT: idx2 = var0, idx3 = var8; idx3 == var17; idx2 += inc3, idx3 += inc4 */
+    0x809a601b, /* 0084(:1237):  LCD: idx4 = var1; ; idx4 += inc3 */
+    0xda9b001b, /* 0088(:1240):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 008C(:1240):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x0000d3a0, /* 0090(:1241):      DRD1A: *idx4; FN=0 init=0 WS=0 RS=0 */
+    0xc207a182, /* 0094(:1243):    LCDEXT: idx5 = var4, idx6 = var15; idx6 < var6; idx5 += inc0, idx6 += inc2 */
+    0x869be009, /* 0098(:1243):    LCD: idx7 = var13; ; idx7 += inc1 */
+    0x6bfe0000, /* 009C(:1246):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=0 TFD EXT init=31 WS=3 RS=3 */
+    0x0d4cfddf, /* 00A0(:1246):      DRD2B1: *idx5 = EU3(); EU3(*idx7)  */
+    0xda9b001b, /* 00A4(:1248):    LCDEXT: idx5 = idx5, idx6 = idx6; idx5 once var0; idx5 += inc3, idx6 += inc3 */
+    0x9b9be01b, /* 00A8(:1248):    LCD: idx7 = idx7; ; idx7 += inc3 */
+    0x70000006, /* 00AC(:1250):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00B0(:1250):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb28, /* 00B4(:1251):      DRD1A: *idx2 = idx5; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00B8(:1252):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00BC(:1252):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x1000cb30, /* 00C0(:1253):      DRD1A: *idx2 = idx6; FN=0 MORE init=0 WS=0 RS=0 */
+    0x70000006, /* 00C4(:1254):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=6 EXT MORE init=0 WS=0 RS=0 */
+    0x088cf890, /* 00C8(:1254):      DRD2B1: idx2 = EU3(); EU3(idx2,var16)  */
+    0x0000cb38, /* 00CC(:1255):      DRD1A: *idx2 = idx7; FN=0 init=0 WS=0 RS=0 */
+    0x000001f8, /* 00D0(:0):    NOP */
+    0xc51803ed, /* 00D4(:1259):  LCDEXT: idx0 = var10; idx0 > var15; idx0 += inc5 */
+    0x8018801b, /* 00D8(:1259):  LCD: idx1 = var0; idx1 once var0; idx1 += inc3 */
+    0x040001f8, /* 00DC(:1260):    DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+};
+#endif
+u32 MCD_ENetRcv_TDT[]=
+{
+    0x80004000, /* 0000(:1334):  LCDEXT: idx0 = 0x00000000; ; */
+    0x82188000, /* 0004(:1334):  LCD: idx1 = var4; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 0008(:1335):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000009, /* 000C(:1336):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 0010(:1336):    DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0x98180249, /* 0014(:1339):  LCD: idx0 = idx0; idx0 != var9; idx0 += inc1 */
+    0x82448004, /* 0018(:1341):    LCD: idx1 = var4 + var9 + 4; idx1 once var0; idx1 += inc0 */
+    0x7000000d, /* 001C(:1342):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x014cf05f, /* 0020(:1342):      DRD2B1: var5 = EU3(); EU3(var1)  */
+    0x7000000b, /* 0024(:1343):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT MORE init=0 WS=0 RS=0 */
+    0x020cf05f, /* 0028(:1343):      DRD2B1: var8 = EU3(); EU3(var1)  */
+    0x70000004, /* 002C(:1344):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x018cf04a, /* 0030(:1344):      DRD2B1: var6 = EU3(); EU3(var1,var10)  */
+    0x70000004, /* 0034(:1345):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x004cf04b, /* 0038(:1345):      DRD2B1: var1 = EU3(); EU3(var1,var11)  */
+    0x00000b88, /* 003C(:1348):      DRD1A: var2 = *idx1; FN=0 init=0 WS=0 RS=0 */
+    0xc4838190, /* 0040(:1351):    LCDEXT: idx1 = var9, idx2 = var7; idx1 < var6; idx1 += inc2, idx2 += inc0 */
+    0x8119e012, /* 0044(:1351):    LCD: idx3 = var2; ; idx3 += inc2 */
+    0x03e0cf90, /* 0048(:1354):      DRD1A: *idx3 = *idx2; FN=0 init=31 WS=0 RS=0 */
+    0x81188000, /* 004C(:1357):    LCD: idx1 = var2; idx1 once var0; idx1 += inc0 */
+    0x000ac788, /* 0050(:1358):      DRD1A: *idx1 = *idx1; FN=0 init=0 WS=1 RS=1 */
+    0xc4838000, /* 0054(:1360):    LCDEXT: idx1 = var9, idx2 = var7; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x8219e000, /* 0058(:1360):    LCD: idx3 = var4; ; idx3 += inc0 */
+    0x70000004, /* 005C(:1368):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x084cfc8c, /* 0060(:1368):      DRD2B1: idx1 = EU3(); EU3(*idx2,var12)  */
+    0x60000005, /* 0064(:1371):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */
+    0x0cccf841, /* 0068(:1371):      DRD2B1: *idx3 = EU3(); EU3(idx1,var1)  */
+    0x82468000, /* 006C(:1377):    LCD: idx1 = var4 + var13; idx1 once var0; idx1 += inc0 */
+    0xc419025b, /* 0070(:1379):      LCDEXT: idx2 = var8; idx2 > var9; idx2 += inc3 */
+    0x80198000, /* 0074(:1379):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
+    0x00008400, /* 0078(:1380):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
+    0x00001308, /* 007C(:1381):      DRD1A: var4 = idx1; FN=0 init=0 WS=0 RS=0 */
+    0x82188000, /* 0080(:1384):    LCD: idx1 = var4; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 0084(:1385):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000009, /* 0088(:1386):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 008C(:1386):      DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0xc2988249, /* 0090(:1389):    LCDEXT: idx1 = var5; idx1 != var9; idx1 += inc1 */
+    0x80190000, /* 0094(:1389):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
+    0x040001f8, /* 0098(:1390):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 009C(:0):    NOP */
+};
+u32 MCD_ENetXmit_TDT[]=
+{
+    0x80004000, /* 0000(:1465):  LCDEXT: idx0 = 0x00000000; ; */
+    0x81988000, /* 0004(:1465):  LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 0008(:1466):    DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000009, /* 000C(:1467):    DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 0010(:1467):    DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0x98180309, /* 0014(:1470):  LCD: idx0 = idx0; idx0 != var12; idx0 += inc1 */
+    0x80004003, /* 0018(:1472):    LCDEXT: idx1 = 0x00000003; ; */
+    0x81c60004, /* 001C(:1472):    LCD: idx2 = var3 + var12 + 4; idx2 once var0; idx2 += inc0 */
+    0x7000000d, /* 0020(:1473):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=13 EXT MORE init=0 WS=0 RS=0 */
+    0x014cf05f, /* 0024(:1473):      DRD2B1: var5 = EU3(); EU3(var1)  */
+    0x7000000b, /* 0028(:1474):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=11 EXT MORE init=0 WS=0 RS=0 */
+    0x028cf05f, /* 002C(:1474):      DRD2B1: var10 = EU3(); EU3(var1)  */
+    0x7000000c, /* 0030(:1475):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=12 EXT MORE init=0 WS=0 RS=0 */
+    0x018cf05f, /* 0034(:1475):      DRD2B1: var6 = EU3(); EU3(var1)  */
+    0x70000004, /* 0038(:1476):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT MORE init=0 WS=0 RS=0 */
+    0x01ccf04d, /* 003C(:1476):      DRD2B1: var7 = EU3(); EU3(var1,var13)  */
+    0x10000b90, /* 0040(:1477):      DRD1A: var2 = *idx2; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000004, /* 0044(:1478):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=4 EXT init=0 WS=0 RS=0 */
+    0x020cf0a1, /* 0048(:1478):      DRD2B1: var8 = EU3(); EU3(var2,idx1)  */
+    0xc3188312, /* 004C(:1481):    LCDEXT: idx1 = var6; idx1 > var12; idx1 += inc2 */
+    0x83c70000, /* 0050(:1481):    LCD: idx2 = var7 + var14; idx2 once var0; idx2 += inc0 */
+    0x00001f10, /* 0054(:1482):      DRD1A: var7 = idx2; FN=0 init=0 WS=0 RS=0 */
+    0xc583a3c3, /* 0058(:1484):    LCDEXT: idx1 = var11, idx2 = var7; idx2 >= var15; idx1 += inc0, idx2 += inc3 */
+    0x81042325, /* 005C(:1484):    LCD: idx3 = var2, idx4 = var8; idx4 == var12; idx3 += inc4, idx4 += inc5 */
+    0x03e0c798, /* 0060(:1489):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=0 RS=0 */
+    0xd8990000, /* 0064(:1492):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x9999e000, /* 0068(:1492):    LCD: idx3 = idx3; ; idx3 += inc0 */
+    0x000acf98, /* 006C(:1493):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
+    0xd8992306, /* 0070(:1495):    LCDEXT: idx1 = idx1, idx2 = idx2; idx2 > var12; idx1 += inc0, idx2 += inc6 */
+    0x9999e03f, /* 0074(:1495):    LCD: idx3 = idx3; ; idx3 += inc7 */
+    0x03eac798, /* 0078(:1498):      DRD1A: *idx1 = *idx3; FN=0 init=31 WS=1 RS=1 */
+    0xd8990000, /* 007C(:1501):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x9999e000, /* 0080(:1501):    LCD: idx3 = idx3; ; idx3 += inc0 */
+    0x000acf98, /* 0084(:1502):      DRD1A: *idx3 = *idx3; FN=0 init=0 WS=1 RS=1 */
+    0xd8990000, /* 0088(:1504):    LCDEXT: idx1 = idx1, idx2 = idx2; idx1 once var0; idx1 += inc0, idx2 += inc0 */
+    0x99832302, /* 008C(:1504):    LCD: idx3 = idx3, idx4 = var6; idx4 > var12; idx3 += inc0, idx4 += inc2 */
+    0x0beac798, /* 0090(:1507):      DRD1A: *idx1 = *idx3; FN=0 TFD init=31 WS=1 RS=1 */
+    0x81988000, /* 0094(:1509):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x6000000a, /* 0098(:1510):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=10 EXT init=0 WS=0 RS=0 */
+    0x0c4cfc5f, /* 009C(:1510):      DRD2B1: *idx1 = EU3(); EU3(*idx1)  */
+    0x81c80000, /* 00A0(:1512):    LCD: idx1 = var3 + var16; idx1 once var0; idx1 += inc0 */
+    0xc5190312, /* 00A4(:1514):      LCDEXT: idx2 = var10; idx2 > var12; idx2 += inc2 */
+    0x80198000, /* 00A8(:1514):      LCD: idx3 = var0; idx3 once var0; idx3 += inc0 */
+    0x00008400, /* 00AC(:1515):        DRD1A: idx1 = var0; FN=0 init=0 WS=0 RS=0 */
+    0x00000f08, /* 00B0(:1516):      DRD1A: var3 = idx1; FN=0 init=0 WS=0 RS=0 */
+    0x81988000, /* 00B4(:1519):    LCD: idx1 = var3; idx1 once var0; idx1 += inc0 */
+    0x10000788, /* 00B8(:1520):      DRD1A: var1 = *idx1; FN=0 MORE init=0 WS=0 RS=0 */
+    0x60000009, /* 00BC(:1521):      DRD2A: EU0=0 EU1=0 EU2=0 EU3=9 EXT init=0 WS=0 RS=0 */
+    0x080cf05f, /* 00C0(:1521):      DRD2B1: idx0 = EU3(); EU3(var1)  */
+    0xc2988309, /* 00C4(:1524):    LCDEXT: idx1 = var5; idx1 != var12; idx1 += inc1 */
+    0x80190000, /* 00C8(:1524):    LCD: idx2 = var0; idx2 once var0; idx2 += inc0 */
+    0x040001f8, /* 00CC(:1525):      DRD1A: FN=0 INT init=0 WS=0 RS=0 */
+    0x000001f8, /* 00D0(:0):    NOP */
+};
+
--- /dev/null
+++ b/drivers/dma/MCD_tasksInit.c
@@ -0,0 +1,284 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *	MOTOROLA, INC. All Rights Reserved.  
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This 
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA 
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE 
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY 
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ * 
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING 
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS 
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.   
+ * 
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+/*
+ * Do not edit!
+ */
+ /*
+ * File:		MCD_tasksInit.c
+ * Purpose:		Function for initialize variable tables of different
+ *              types of tasks.
+ *
+ * Notes:
+ *
+ *
+ * Modifications:
+ *  	
+ *
+ */ 
+
+#include <asm/MCD_dma.h>
+
+extern dmaRegs *MCD_dmaBar;
+
+/*
+ * Task 0
+ */
+
+void  MCD_startDmaChainNoEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+{
+
+	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 19, (u32)xferSize);	/* var[19] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000000);	/* var[16] */
+	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000000);	/* var[17] */
+	MCD_SET_VAR(taskTable+channel, 18, (u32)0x00000000);	/* var[18] */
+	MCD_SET_VAR(taskTable+channel, 20, (u32)0x00000000);	/* var[20] */
+	MCD_SET_VAR(taskTable+channel, 21, (u32)0x00000010);	/* var[21] */
+	MCD_SET_VAR(taskTable+channel, 22, (u32)0x00000004);	/* var[22] */
+	MCD_SET_VAR(taskTable+channel, 23, (u32)0x00000080);	/* var[23] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x60000000);	/* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);	/* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000000);	/* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);	/* inc[7] */
+
+    /* Set the task's Enable bit in its Task Control Register */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+	
+
+}
+
+
+/*
+ * Task 1
+ */
+ 
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+{
+	
+	MCD_SET_VAR(taskTable+channel, 13, (u32)srcAddr);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)destAddr);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)dmaSize);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)dmaSizeMXferSize);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)flags);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)currBD);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000004);	/* var[16] */
+	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000080);	/* var[17] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);	/* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);	/* inc[5] */
+
+
+    /* enable the task */
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+}
+
+
+/*
+ * Task 2
+ */
+ 
+void  MCD_startDmaChainEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+{
+	
+	MCD_SET_VAR(taskTable+channel, 2, (u32)currBD);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 19, (u32)xferSize);	/* var[19] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000000);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000000);	/* var[16] */
+	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000000);	/* var[17] */
+	MCD_SET_VAR(taskTable+channel, 18, (u32)0x00000000);	/* var[18] */
+	MCD_SET_VAR(taskTable+channel, 20, (u32)0x00000000);	/* var[20] */
+	MCD_SET_VAR(taskTable+channel, 21, (u32)0x00000010);	/* var[21] */
+	MCD_SET_VAR(taskTable+channel, 22, (u32)0x00000004);	/* var[22] */
+	MCD_SET_VAR(taskTable+channel, 23, (u32)0x00000080);	/* var[23] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x60000000);	/* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000001);	/* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x80000000);	/* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0x40000000);	/* inc[7] */
+
+    /*enable the task*/
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+}
+
+
+/*
+ * Task 3
+ */
+ 
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel)
+{
+	
+	MCD_SET_VAR(taskTable+channel, 13, (u32)srcAddr);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)(0xe000 << 16) | (0xffff & srcIncr));	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)destAddr);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)(0xe000 << 16) | (0xffff & destIncr));	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)dmaSize);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)dmaSizeMXferSize);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)(0x2000 << 16) | (0xffff & xferSizeIncr));	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)flags);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)currBD);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 0, (u32)cSave);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x00000000);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0x00000000);	/* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000000);	/* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000004);	/* var[16] */
+	MCD_SET_VAR(taskTable+channel, 17, (u32)0x00000080);	/* var[17] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x00000000);	/* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0x80000001);	/* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x40000000);	/* inc[5] */
+
+    /*enable the task*/
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+
+}
+
+
+/*
+ * Task 4
+ */
+ 
+void  MCD_startDmaENetRcv(char *bDBase, char *currBD, char *rcvFifoPtr, volatile TaskTableEntry *taskTable, int channel)
+{
+	
+	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)currBD);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)rcvFifoPtr);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)0x00000000);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x0000ffff);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)0x30000000);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x0fffffff);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x00000008);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)0x20000004);	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0x40000000);	/* inc[3] */
+    /*enable the task*/
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+
+}
+
+
+/*
+ * Task 5
+ */
+ 
+void  MCD_startDmaENetXmit(char *bDBase, char *currBD, char *xmitFifoPtr, volatile TaskTableEntry *taskTable, int channel)
+{
+	
+	MCD_SET_VAR(taskTable+channel, 0, (u32)bDBase);	/* var[0] */
+	MCD_SET_VAR(taskTable+channel, 3, (u32)currBD);	/* var[3] */
+	MCD_SET_VAR(taskTable+channel, 11, (u32)xmitFifoPtr);	/* var[11] */
+	MCD_SET_VAR(taskTable+channel, 1, (u32)0x00000000);	/* var[1] */
+	MCD_SET_VAR(taskTable+channel, 2, (u32)0x00000000);	/* var[2] */
+	MCD_SET_VAR(taskTable+channel, 4, (u32)0x00000000);	/* var[4] */
+	MCD_SET_VAR(taskTable+channel, 5, (u32)0x00000000);	/* var[5] */
+	MCD_SET_VAR(taskTable+channel, 6, (u32)0x00000000);	/* var[6] */
+	MCD_SET_VAR(taskTable+channel, 7, (u32)0x00000000);	/* var[7] */
+	MCD_SET_VAR(taskTable+channel, 8, (u32)0x00000000);	/* var[8] */
+	MCD_SET_VAR(taskTable+channel, 9, (u32)0x00000000);	/* var[9] */
+	MCD_SET_VAR(taskTable+channel, 10, (u32)0x00000000);	/* var[10] */
+	MCD_SET_VAR(taskTable+channel, 12, (u32)0x00000000);	/* var[12] */
+	MCD_SET_VAR(taskTable+channel, 13, (u32)0x0000ffff);	/* var[13] */
+	MCD_SET_VAR(taskTable+channel, 14, (u32)0xffffffff);	/* var[14] */
+	MCD_SET_VAR(taskTable+channel, 15, (u32)0x00000004);	/* var[15] */
+	MCD_SET_VAR(taskTable+channel, 16, (u32)0x00000008);	/* var[16] */
+	MCD_SET_VAR(taskTable+channel, 24, (u32)0x00000000);	/* inc[0] */
+	MCD_SET_VAR(taskTable+channel, 25, (u32)0x60000000);	/* inc[1] */
+	MCD_SET_VAR(taskTable+channel, 26, (u32)0x40000000);	/* inc[2] */
+	MCD_SET_VAR(taskTable+channel, 27, (u32)0xc000fffc);	/* inc[3] */
+	MCD_SET_VAR(taskTable+channel, 28, (u32)0xe0000004);	/* inc[4] */
+	MCD_SET_VAR(taskTable+channel, 29, (u32)0x80000000);	/* inc[5] */
+	MCD_SET_VAR(taskTable+channel, 30, (u32)0x4000ffff);	/* inc[6] */
+	MCD_SET_VAR(taskTable+channel, 31, (u32)0xe0000001);	/* inc[7] */
+
+    /*enable the task*/
+    MCD_dmaBar->taskControl[channel] |= (u16)0x8000; /* add a MACRO HERE TBD*/
+
+}
--- /dev/null
+++ b/drivers/dma/MCD_tasksInit.h
@@ -0,0 +1,73 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+#ifndef MCD_TSK_INIT_H
+#define MCD_TSK_INIT_H 1
+
+/*
+ * Do not edit!
+ */
+
+
+
+/*
+ * Task 0
+ */
+void  MCD_startDmaChainNoEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 1
+ */
+void  MCD_startDmaSingleNoEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 2
+ */
+void  MCD_startDmaChainEu(int *currBD, short srcIncr, short destIncr, int xferSize, short xferSizeIncr, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 3
+ */
+void  MCD_startDmaSingleEu(char *srcAddr, short srcIncr, char *destAddr, short destIncr, int dmaSize, int dmaSizeMXferSize, short xferSizeIncr, int flags, int *currBD, int *cSave, volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 4
+ */
+void  MCD_startDmaENetRcv(char *bDBase, char *currBD, char *rcvFifoPtr, volatile TaskTableEntry *taskTable, int channel);
+
+
+/*
+ * Task 5
+ */
+void  MCD_startDmaENetXmit(char *bDBase, char *currBD, char *xmitFifoPtr, volatile TaskTableEntry *taskTable, int channel);
+
+#endif  /* MCD_TSK_INIT_H */
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -4,3 +4,5 @@ obj-$(CONFIG_INTEL_IOATDMA) += ioatdma.o
 ioatdma-objs := ioat.o ioat_dma.o ioat_dca.o
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_FSL_DMA) += fsldma.o
+obj-$(CONFIG_MCD_DMA) += mcddma.o
+mcddma-objs := MCD_dmaApi.o MCD_tasks.o MCD_tasksInit.o
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -351,6 +351,8 @@ config MACB
 
 source "drivers/net/arm/Kconfig"
 
+source "drivers/net/fec/Kconfig"
+
 config AX88796
 	tristate "ASIX AX88796 NE2000 clone support"
 	depends on ARM || MIPS || SUPERH
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -226,6 +226,8 @@ obj-$(CONFIG_ENC28J60) += enc28j60.o
 
 obj-$(CONFIG_MACB) += macb.o
 
+obj-$(CONFIG_FEC_548x) += fec/
+
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
 obj-$(CONFIG_TR) += tokenring/
--- /dev/null
+++ b/drivers/net/fec/Kconfig
@@ -0,0 +1,25 @@
+config FEC_548x
+	tristate "MCF547x/MCF548x Fast Ethernet Controller support"
+	depends on M547X_8X
+ 	help
+	  The MCF547x and MCF548x have a built-in Fast Ethernet Controller.
+	  Saying Y here will include support for this device in the kernel.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called fecm.
+
+config FEC_548x_AUTO_NEGOTIATION
+	bool "Enable Auto-Negotiation"
+	depends on FEC_548x
+	help
+	  This option enables the FEC to automatically detect the 
+	  half/full duplex mode and the network speed at initialization
+	  If you want this, say Y.
+
+config FEC_548x_ENABLE_FEC2
+	bool "Enable the second FEC"
+	depends on FEC_548x
+	help
+	  This enables the second FEC on the 547x/548x. If you want to use
+	  it, say Y.
+
--- /dev/null
+++ b/drivers/net/fec/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the FEC ethernet driver
+#
+
+obj-$(CONFIG_FEC_548x) += fecm.o
+
+fecm-objs := fec.o ks8721.o
--- /dev/null
+++ b/drivers/net/fec/fec.c
@@ -0,0 +1,1375 @@
+/*
+ * Performance and stability improvements: (C) Copyright 2008,
+ *      Daniel Krueger, SYSTEC electronic GmbH
+ *
+ * Code crunched to get it to work on 2.6.24 -- FEC cleanup coming
+ * soon -- Kurt Mahan
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/bitops.h>
+
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+#include <asm/dma.h>
+#include <asm/MCD_dma.h>
+#include <asm/m5485sram.h>
+#include <asm/virtconvert.h>
+#include <asm/irq.h>
+
+#include "fec.h"
+#include "ks8721.h"
+
+#ifdef	CONFIG_FEC_548x_ENABLE_FEC2
+#define	FEC_MAX_PORTS	2
+#define	FEC_2
+#else
+#define	FEC_MAX_PORTS	1
+#undef	FEC_2
+#endif
+
+#define VERSION "0.13"
+MODULE_DESCRIPTION( "DMA Fast Ethernet Controller driver ver " VERSION);
+
+// Private structure
+struct fec_priv {
+	struct net_device *netdev;		/* owning net device */
+	void* fecpriv_txbuf[FEC_TX_BUF_NUMBER];	//Array of transmission buffers
+	MCD_bufDescFec *fecpriv_txdesc;	// Array of transmission descriptors
+	volatile unsigned int fecpriv_current_tx;	// Inex of the transmission descriptor that is used by DMA
+	volatile unsigned int fecpriv_next_tx;	// Inex of the transmission descriptor that can be used for new data
+	unsigned int fecpriv_current_rx;	// Index of the reception descriptor that is used by DMA
+	MCD_bufDescFec *fecpriv_rxdesc;		// Array of reception descriptors
+//	unsigned char *fecpriv_rxbuf;		// Address of reception buffers
+	struct sk_buff *askb_rx[FEC_RX_BUF_NUMBER]; // Array of reception skb structure pointers
+	unsigned int fecpriv_initiator_rx;	// Reception DMA initiator
+	unsigned int fecpriv_initiator_tx;	// Transmission DMA initiator
+	int fecpriv_fec_rx_channel;	// DMA reception channel
+	int fecpriv_fec_tx_channel;	// DMA transmission channel
+	int fecpriv_rx_requestor;	// DMA reception requestor
+	int fecpriv_tx_requestor;	// DMA transmission requestor
+	void *fecpriv_interrupt_fec_rx_handler;	// DMA reception handler
+	void *fecpriv_interrupt_fec_tx_handler;	// DMA transmission handler
+	unsigned char *fecpriv_mac_addr;	// Private copy of FEC address
+	struct net_device_stats fecpriv_stat;	// Pointer to the statistical information
+	spinlock_t fecpriv_lock;
+	int fecpriv_rxflag;
+	struct tasklet_struct fecpriv_tasklet_reinit;
+	int index;
+};
+
+struct net_device *fec_dev[FEC_MAX_PORTS];
+
+// FEC functions
+int __init fec_init(void);
+struct net_device_stats *fec_get_stat(struct net_device *dev);
+
+int fec_open(struct net_device *dev);
+int fec_close(struct net_device *nd);
+int fec_tx(struct sk_buff *skb, struct net_device *dev);
+void fec_set_multicast_list(struct net_device *nd);
+int fec_set_mac_address(struct net_device *dev, void *p);
+void fec_tx_timeout(struct net_device *dev);
+void fec_interrupt_fec_tx_handler(struct net_device *dev);
+void fec_interrupt_fec_rx_handler(struct net_device *dev);
+irqreturn_t fec_interrupt_handler(int irq, void *dev_id);
+void fec_interrupt_fec_tx_handler_fec0(void);
+void fec_interrupt_fec_rx_handler_fec0(void);
+void fec_interrupt_fec_reinit(unsigned long data);
+
+unsigned char fec_mac_addr_fec0[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x50 };	// Default address of FEC0
+
+#ifdef   FEC_2
+unsigned char fec_mac_addr_fec1[6] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x51 };	// Default address of FEC1
+#endif
+
+#ifndef MODULE
+int fec_str_to_mac( char *str_mac, unsigned char* addr);
+int __init fec_mac_setup0 (char *s);
+#endif
+
+
+#ifdef   FEC_2
+void fec_interrupt_fec_tx_handler_fec1(void);
+void fec_interrupt_fec_rx_handler_fec1(void);
+
+#ifndef MODULE
+int __init fec_mac_setup1 (char *s);
+#endif
+
+#endif
+int fec_read_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int *data);
+int fec_write_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int data);
+
+module_init(fec_init);
+/* module_exit(fec_cleanup); */
+__setup("mac0=", fec_mac_setup0);
+
+#ifdef   FEC_2
+__setup("mac1=", fec_mac_setup1);
+#endif
+
+/*
+ * Initialize a FEC device
+ */
+int fec_enet_init(struct net_device *dev)
+{
+	static int index = 0;
+	struct fec_priv *fp = netdev_priv(dev);
+	int i;
+
+	fp->index = index;
+	fp->netdev = dev;
+	fec_dev[ index ] = dev;
+printk(KERN_INFO "FEI: index=%d\n", index);
+
+	if (index == 0) {
+		/* disable fec0 */
+		FEC_ECR(FEC_BASE_ADDR_FEC0) = FEC_ECR_DISABLE;
+
+		/* setup the interrupt handler */
+		dev->irq = 64 + ISC_FEC0;
+
+		if (request_irq(dev->irq, fec_interrupt_handler,
+		                IRQF_DISABLED, "ColdFire FEC 0", dev)) {
+			dev->irq = 0;
+			printk("Cannot allocate FEC0 IRQ\n");
+		} else {
+			/* interrupt priority and level */
+			MCF_ICR(ISC_FEC0) = ILP_FEC0;
+		}
+
+		/* fec base address */
+		dev->base_addr = FEC_BASE_ADDR_FEC0;
+
+		/* requestor numbers */
+		fp->fecpriv_rx_requestor = DMA_FEC0_RX;
+		fp->fecpriv_tx_requestor = DMA_FEC0_TX;
+
+		/* fec0 handlers */
+		fp->fecpriv_interrupt_fec_rx_handler = fec_interrupt_fec_rx_handler_fec0;
+		fp->fecpriv_interrupt_fec_tx_handler = fec_interrupt_fec_tx_handler_fec0;
+
+		/* tx descriptors */
+		fp->fecpriv_txdesc = (void*)FEC_TX_DESC_FEC0;
+
+		/* rx descriptors */
+		fp->fecpriv_rxdesc = (void*)FEC_RX_DESC_FEC0;
+
+printk(KERN_INFO "FEI: txdesc=0x%p  rxdesc=0x%p\n", fp->fecpriv_txdesc, fp->fecpriv_rxdesc);
+
+		/* mac addr */
+		fp->fecpriv_mac_addr = fec_mac_addr_fec0;
+	}
+	else {
+		/* disable fec1 */
+		FEC_ECR(FEC_BASE_ADDR_FEC1) = FEC_ECR_DISABLE;
+#ifdef FEC_2
+		/* setup the interrupt handler */
+		dev->irq = 64 + ISC_FEC1;
+
+		if (request_irq(dev->irq, fec_interrupt_handler,
+		                IRQF_DISABLED, "ColdFire FEC 1", dev)) {
+			dev->irq = 0;
+			printk("Cannot allocate FEC1 IRQ\n");
+		} else {
+			/* interrupt priority and level */
+			MCF_ICR(ISC_FEC1) = ILP_FEC1;
+		}
+
+		/* fec base address */
+		dev->base_addr = FEC_BASE_ADDR_FEC1;
+
+		/* requestor numbers */
+		fp->fecpriv_rx_requestor = DMA_FEC1_RX;
+		fp->fecpriv_tx_requestor = DMA_FEC1_TX;
+
+		/* fec1 handlers */
+		fp->fecpriv_interrupt_fec_rx_handler = fec_interrupt_fec_rx_handler_fec1;
+		fp->fecpriv_interrupt_fec_tx_handler = fec_interrupt_fec_tx_handler_fec1;
+
+		/* tx descriptors */
+		fp->fecpriv_txdesc = (void*)FEC_TX_DESC_FEC1;
+
+		/* rx descriptors */
+		fp->fecpriv_rxdesc = (void*)FEC_RX_DESC_FEC1;
+
+		/* mac addr */
+		fp->fecpriv_mac_addr = fec_mac_addr_fec1;
+#endif
+	}
+
+printk(KERN_INFO "FEI: index=%d base_addr=0x%lx\n", index, dev->base_addr);
+
+	/* clear MIB */
+	memset((void *) (dev->base_addr + 0x200), 0, FEC_MIB_LEN);
+
+	/* clear the statistics structure */
+	memset((void *) &(fp->fecpriv_stat), 0,
+	       sizeof(struct net_device_stats));
+
+	/* grab the FEC initiators */
+	dma_set_initiator(fp->fecpriv_tx_requestor);
+	fp->fecpriv_initiator_tx = dma_get_initiator(fp->fecpriv_tx_requestor);
+	dma_set_initiator(fp->fecpriv_rx_requestor);
+	fp->fecpriv_initiator_rx = dma_get_initiator(fp->fecpriv_rx_requestor);
+
+	/* reset the DMA channels */
+	fp->fecpriv_fec_rx_channel = -1;
+	fp->fecpriv_fec_tx_channel = -1;
+
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
+		fp->askb_rx[i] = NULL;
+
+	/* initialize the pointers to the socket buffers */
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
+		fp->fecpriv_txbuf[i] = NULL;
+
+	ether_setup(dev);
+
+	dev->open = fec_open;
+	dev->stop = fec_close;
+	dev->hard_start_xmit = fec_tx;
+	dev->get_stats = fec_get_stat;
+	dev->set_multicast_list = fec_set_multicast_list;
+	dev->set_mac_address = fec_set_mac_address;
+	dev->tx_timeout = fec_tx_timeout;
+	dev->watchdog_timeo = FEC_TX_TIMEOUT * HZ;
+
+	memcpy(dev->dev_addr, fp->fecpriv_mac_addr, ETH_ALEN);
+
+	spin_lock_init(&fp->fecpriv_lock);
+
+	// Initialize FEC/I2C/IRQ Pin Assignment Register
+	FEC_GPIO_PAR_FECI2CIRQ &= 0xF;
+	FEC_GPIO_PAR_FECI2CIRQ |= FEC_FECI2CIRQ;
+
+	index++;
+	return 0;
+}
+
+/*
+ * Module Initialization
+ */
+int __init fec_init(void)
+{
+	struct net_device *dev;
+	int i;
+	int err;
+	DECLARE_MAC_BUF(mac);
+
+	printk(KERN_INFO "FEC ENET (DMA) Version .00\n");
+
+
+	for (i = 0; i < FEC_MAX_PORTS; i++) {
+		dev = alloc_etherdev(sizeof(struct fec_priv));
+		if (!dev)
+			return -ENOMEM;
+		err = fec_enet_init(dev);
+		if (err) {
+			free_netdev(dev);
+			continue;
+		}
+		if (register_netdev(dev) != 0) {
+			free_netdev(dev);
+			return -EIO;
+		}
+
+		printk(KERN_INFO "%s: ethernet %s\n",
+		       dev->name, print_mac(mac, dev->dev_addr));
+	}
+	return 0;
+}
+
+/*
+ * Stop a device
+ */
+void fec_stop(struct net_device *dev)
+{
+	struct fec_priv *fp = netdev_priv(dev);
+
+	dma_remove_initiator(fp->fecpriv_initiator_tx);
+	dma_remove_initiator(fp->fecpriv_initiator_rx);
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+}
+
+/************************************************************************
+* NAME: fec_open
+*
+* DESCRIPTION: This function performs the initialization of
+*				of FEC and corresponding KS8721 transiver
+*
+* RETURNS: If no error occurs, this function returns zero.
+*************************************************************************/
+
+int fec_open(struct net_device *dev)
+{
+	struct fec_priv *fp = netdev_priv(dev);
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+	int fduplex;
+	int i;
+	int channel;
+	int error_code = -EBUSY;
+
+printk(KERN_INFO "FECOPEN: index=%d\n", fp->index);
+
+	//Receive the DMA channels
+	channel = dma_set_channel_fec(fp->fecpriv_rx_requestor);
+
+	if (channel == -1)
+	{
+		printk("Dma channel cannot be reserved\n");
+		goto ERRORS;
+	}
+
+	fp->fecpriv_fec_rx_channel = channel;
+
+	dma_connect(channel, (int) fp->fecpriv_interrupt_fec_rx_handler);
+
+	channel = dma_set_channel_fec(fp->fecpriv_tx_requestor);
+
+	if (channel == -1)
+	{
+		printk("Dma channel cannot be reserved\n");
+		goto ERRORS;
+	}
+printk(KERN_INFO "FECOPEN2\n");
+
+	fp->fecpriv_fec_tx_channel = channel;
+
+	dma_connect(channel, (int) fp->fecpriv_interrupt_fec_tx_handler);
+
+	// init tasklet for controller reinitialization
+	tasklet_init(&fp->fecpriv_tasklet_reinit, fec_interrupt_fec_reinit, (unsigned long) dev);
+printk(KERN_INFO "FECOPEN3\n");
+
+	// Reset FIFOs
+	FEC_FECFRST(base_addr) |= FEC_SW_RST | FEC_RST_CTL;
+	FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
+
+	// Reset and disable FEC
+	FEC_ECR(base_addr) = FEC_ECR_RESET;
+
+	// Wait
+	udelay(10);
+
+	// Clear all events
+	FEC_EIR(base_addr) = FEC_EIR_CLEAR;
+
+	// Reset FIFO status
+	FEC_FECTFSR(base_addr) = FEC_FECTFSR_MSK;
+	FEC_FECRFSR(base_addr) = FEC_FECRFSR_MSK;
+
+#if 0
+/* JKM -- move into HW init */
+	// Copy the default address to the device structure
+	memcpy(dev->dev_addr, fp->fecpriv_mac_addr, ETH_ALEN);
+#endif
+
+	// Set the default address
+	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) | (fp->fecpriv_mac_addr[1] << 16) | (fp->fecpriv_mac_addr[2] << 8) | fp->fecpriv_mac_addr[3];
+	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) | (fp->fecpriv_mac_addr[5] << 16) | 0x8808;
+
+	// Reset the group address descriptor
+	FEC_GALR(base_addr) = 0x00000000;
+	FEC_GAUR(base_addr) = 0x00000000;
+
+	// Reset the individual address descriptor
+	FEC_IALR(base_addr) = 0x00000000;
+	FEC_IAUR(base_addr) = 0x00000000;
+
+	// Set the receive control register
+	FEC_RCR(base_addr) = FEC_RCR_MAX_FRM_SIZE | FEC_RCR_MII;
+
+	// Set the receive FIFO control register
+//	FEC_FECRFCR(base_addr) = FEC_FECRFCR_FRM | FEC_FECRFCR_GR | FEC_FECRFCR_MSK;
+	FEC_FECRFCR(base_addr) = FEC_FECRFCR_FRM | FEC_FECRFCR_GR
+                             | (FEC_FECRFCR_MSK     // disable all but ...
+                                & ~FEC_FECRFCR_FAE  // enable frame accept error
+                                & ~FEC_FECRFCR_RXW  // enable receive wait condition
+//                                & ~FEC_FECRFCR_UF   // enable FIFO underflow
+                             );
+
+	//Set the receive FIFO alarm register
+	FEC_FECRFAR(base_addr) = FEC_FECRFAR_ALARM;
+
+	// Set the transmit FIFO control register
+//	FEC_FECTFCR(base_addr) = FEC_FECTFCR_FRM | FEC_FECTFCR_GR | FEC_FECTFCR_MSK;
+	FEC_FECTFCR(base_addr) = FEC_FECTFCR_FRM | FEC_FECTFCR_GR
+                             | (FEC_FECTFCR_MSK     // disable all but ...
+                                & ~FEC_FECTFCR_FAE  // enable frame accept error
+//                                & ~FEC_FECTFCR_TXW  // enable transmit wait condition
+//                                & ~FEC_FECTFCR_UF   // enable FIFO underflow
+                                & ~FEC_FECTFCR_OF); // enable FIFO overflow
+
+	//Set the transmit FIFO alarm register
+	FEC_FECTFAR(base_addr) = FEC_FECTFAR_ALARM;
+
+	// Set the Tx FIFO watermark
+	FEC_FECTFWR(base_addr) = FEC_FECTFWR_XWMRK;
+
+	// Enable the transmitter to append the CRC
+	FEC_CTCWR(base_addr) = FEC_CTCWR_TFCW_CRC;
+
+	// Enable the ethernet interrupts
+//	FEC_EIMR(base_addr) = FEC_EIMR_MASK;
+	FEC_EIMR(base_addr) = FEC_EIMR_DISABLE
+                            | FEC_EIR_LC
+                            | FEC_EIR_RL
+                            | FEC_EIR_HBERR
+                            | FEC_EIR_XFUN
+                            | FEC_EIR_XFERR
+                            | FEC_EIR_RFERR
+                            ;
+printk(KERN_INFO "FECOPEN4\n");
+
+#ifdef   CONFIG_FEC_548x_AUTO_NEGOTIATION
+	if ((error_code = init_transceiver(base_addr, &fduplex)) != 0)
+	{
+		printk("Initialization of the transceiver is failed\n");
+		goto ERRORS;
+	}
+#else
+	fduplex = 1;
+#endif
+printk(KERN_INFO "FECOPEN5\n");
+
+	if (fduplex)
+		// Enable the full duplex mode
+		FEC_TCR(base_addr) = FEC_TCR_FDEN | FEC_TCR_HBC;
+	else
+		// Disable reception of frames while transmitting
+		FEC_RCR(base_addr) |= FEC_RCR_DRT;
+
+	// Enable MIB
+	FEC_MIBC(base_addr) = FEC_MIBC_ENABLE;
+
+	// Enable FEC
+	FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
+
+	// Initialize transmission descriptors and start DMA for the transmission
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
+		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
+printk(KERN_INFO "FECOPEN6\n");
+
+	fp->fecpriv_txdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
+
+	fp->fecpriv_current_tx = fp->fecpriv_next_tx = 0;
+
+	MCD_startDma(fp->fecpriv_fec_tx_channel, (char *) fp->fecpriv_txdesc, 0,
+		     (unsigned char *) &(FEC_FECTFDR(base_addr)), 0,
+		     FEC_MAX_FRM_SIZE, 0, fp->fecpriv_initiator_tx,
+		     FEC_TX_DMA_PRI, MCD_FECTX_DMA | MCD_INTERRUPT,
+		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
+
+	// Initialize reception descriptors and start DMA for the reception
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
+	{
+		fp->askb_rx[i] = alloc_skb(FEC_MAXBUF_SIZE + 16, GFP_DMA);
+		if (!fp->askb_rx[i])
+		{
+    		fp->fecpriv_rxdesc[i].dataPointer = 0;
+    		fp->fecpriv_rxdesc[i].statCtrl = 0;
+	    	fp->fecpriv_rxdesc[i].length = 0;
+		}
+		else
+		{
+		    skb_reserve(fp->askb_rx[i], 16);
+			fp->askb_rx[i]->dev = dev;
+    		fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
+    		fp->fecpriv_rxdesc[i].statCtrl = MCD_FEC_BUF_READY | MCD_FEC_INTERRUPT;
+	    	fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
+	    }
+	}
+printk(KERN_INFO "FECOPEN7\n");
+
+	fp->fecpriv_rxdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
+	fp->fecpriv_current_rx = 0;
+
+	// flush entire data cache before restarting the DMA
+#if 0
+/* JKM -- currently running with cache turned off */
+	DcacheFlushInvalidate();
+#endif
+	
+	MCD_startDma(fp->fecpriv_fec_rx_channel, (char *) fp->fecpriv_rxdesc, 0,
+		     (unsigned char *) &(FEC_FECRFDR(base_addr)), 0,
+		     FEC_MAX_FRM_SIZE, 0, fp->fecpriv_initiator_rx,
+		     FEC_RX_DMA_PRI, MCD_FECRX_DMA | MCD_INTERRUPT,
+		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
+
+	netif_start_queue(dev);
+
+//	MOD_INC_USE_COUNT;
+printk(KERN_INFO "FECOPEN: finished\n");
+
+	return 0;
+
+ERRORS:
+
+	// Remove the channels and return with the error code
+	if (fp->fecpriv_fec_rx_channel != -1)
+	{
+		dma_disconnect(fp->fecpriv_fec_rx_channel);
+		dma_remove_channel_by_number(fp->fecpriv_fec_rx_channel);
+		fp->fecpriv_fec_rx_channel = -1;
+	}
+
+	if (fp->fecpriv_fec_tx_channel != -1)
+	{
+		dma_disconnect(fp->fecpriv_fec_tx_channel);
+		dma_remove_channel_by_number(fp->fecpriv_fec_tx_channel);
+		fp->fecpriv_fec_tx_channel = -1;
+	}
+
+	return error_code;
+
+}
+
+/************************************************************************
+* NAME: fec_close
+*
+* DESCRIPTION: This function performs the graceful stop of the
+*				transmission and disables FEC
+*
+* RETURNS: This function always returns zero.
+*************************************************************************/
+int fec_close(struct net_device *dev)
+{
+	//Receive the pointer to the private structure
+	struct fec_priv *fp = netdev_priv(dev);
+
+	// Receive the base address
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+
+	unsigned long time;
+
+	int i;
+
+	netif_stop_queue(dev);
+
+	// Perform the graceful stop
+	FEC_TCR(base_addr) |= FEC_TCR_GTS;
+
+	time = jiffies;
+
+	// Wait for the graceful stop
+	while (!(FEC_EIR(base_addr) & FEC_EIR_GRA) && jiffies - time < FEC_GR_TIMEOUT * HZ)
+		schedule();
+
+	// Disable FEC
+	FEC_ECR(base_addr) = FEC_ECR_DISABLE;
+
+	// Reset the DMA channels
+	spin_lock_irq(&fp->fecpriv_lock);
+	MCD_killDma(fp->fecpriv_fec_tx_channel);
+	spin_unlock_irq(&fp->fecpriv_lock);
+	dma_remove_channel_by_number(fp->fecpriv_fec_tx_channel);
+	dma_disconnect(fp->fecpriv_fec_tx_channel);
+	fp->fecpriv_fec_tx_channel = -1;
+
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
+		if (fp->fecpriv_txbuf[i])
+		{
+			kfree(fp->fecpriv_txbuf[i]);
+			fp->fecpriv_txbuf[i] = NULL;
+		}
+
+	spin_lock_irq(&fp->fecpriv_lock);
+	MCD_killDma(fp->fecpriv_fec_rx_channel);
+	spin_unlock_irq(&fp->fecpriv_lock);
+
+	dma_remove_channel_by_number(fp->fecpriv_fec_rx_channel);
+	dma_disconnect(fp->fecpriv_fec_rx_channel);
+	fp->fecpriv_fec_rx_channel = -1;
+
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
+	{
+		if (fp->askb_rx[i])
+		{
+		    kfree_skb(fp->askb_rx[i]);
+		    fp->askb_rx[i] = NULL;
+	    }
+	}
+//	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+/************************************************************************
+* +NAME: fec_get_stat
+*
+* RETURNS: This function returns the statistical information.
+*************************************************************************/
+struct net_device_stats * fec_get_stat(struct net_device *dev)
+{
+
+	//Receive the pointer to the private structure
+	struct fec_priv *fp = netdev_priv(dev);
+
+	// Receive the base address
+	unsigned long base_addr = dev->base_addr;
+
+	// Receive the statistical information
+	fp->fecpriv_stat.rx_packets = FECSTAT_RMON_R_PACKETS(base_addr);
+	fp->fecpriv_stat.tx_packets = FECSTAT_RMON_T_PACKETS(base_addr);
+	fp->fecpriv_stat.rx_bytes = FECSTAT_RMON_R_OCTETS(base_addr);
+	fp->fecpriv_stat.tx_bytes = FECSTAT_RMON_T_OCTETS(base_addr);
+
+	fp->fecpriv_stat.multicast = FECSTAT_RMON_R_MC_PKT(base_addr);
+	fp->fecpriv_stat.collisions = FECSTAT_RMON_T_COL(base_addr);
+
+	fp->fecpriv_stat.rx_length_errors = FECSTAT_RMON_R_UNDERSIZE(base_addr) + FECSTAT_RMON_R_OVERSIZE(base_addr) + FECSTAT_RMON_R_FRAG(base_addr) + FECSTAT_RMON_R_JAB(base_addr);
+	fp->fecpriv_stat.rx_crc_errors = FECSTAT_IEEE_R_CRC(base_addr);
+	fp->fecpriv_stat.rx_frame_errors = FECSTAT_IEEE_R_ALIGN(base_addr);
+	fp->fecpriv_stat.rx_over_errors = FECSTAT_IEEE_R_MACERR(base_addr);
+
+	fp->fecpriv_stat.tx_carrier_errors = FECSTAT_IEEE_T_CSERR(base_addr);
+	fp->fecpriv_stat.tx_fifo_errors = FECSTAT_IEEE_T_MACERR(base_addr);
+	fp->fecpriv_stat.tx_window_errors = FECSTAT_IEEE_T_LCOL(base_addr);
+
+	// I hope that one frame doesn't have more than one error
+	fp->fecpriv_stat.rx_errors = fp->fecpriv_stat.rx_length_errors + fp->fecpriv_stat.rx_crc_errors + fp->fecpriv_stat.rx_frame_errors + fp->fecpriv_stat.rx_over_errors + fp->fecpriv_stat.rx_dropped;
+	fp->fecpriv_stat.tx_errors = fp->fecpriv_stat.tx_carrier_errors + fp->fecpriv_stat.tx_fifo_errors + fp->fecpriv_stat.tx_window_errors + fp->fecpriv_stat.tx_aborted_errors + fp->fecpriv_stat.tx_heartbeat_errors + fp->fecpriv_stat.tx_dropped;
+
+	return &fp->fecpriv_stat;
+}
+
+/************************************************************************
+* NAME: fec_set_multicast_list
+*
+* DESCRIPTION: This function sets the frame filtering parameters
+*************************************************************************/
+void fec_set_multicast_list(struct net_device *dev)
+{
+	// Pointer to the address list
+	struct dev_mc_list *dmi;
+
+	unsigned int crc, data;
+	int i, j, k;
+
+	// Receive the base address
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+
+	if (dev->flags & IFF_PROMISC || dev->flags & IFF_ALLMULTI)
+	{
+		// Allow all incoming frames
+		FEC_GALR(base_addr) = 0xFFFFFFFF;
+		FEC_GAUR(base_addr) = 0xFFFFFFFF;
+		return;
+	}
+	// Reset the group address register
+	FEC_GALR(base_addr) = 0x00000000;
+	FEC_GAUR(base_addr) = 0x00000000;
+
+	// Process all addresses
+	for (i = 0, dmi = dev->mc_list; i < dev->mc_count; i++, dmi = dmi->next)
+	{
+		// Processing must be only for the group addresses
+		if (!(dmi->dmi_addr[0] & 1))
+			continue;
+
+		// Calculate crc value for the current address
+		crc = 0xFFFFFFFF;
+		for (j = 0; j < dmi->dmi_addrlen; j++)
+		{
+
+			for (k = 0, data = dmi->dmi_addr[j]; k < 8;  k++, data >>= 1)
+			{
+				if ((crc ^ data) & 1)
+					crc = (crc >> 1) ^ FEC_CRCPOL;
+				else
+					crc >>= 1;
+
+			}
+
+		}
+
+		// Add this value
+		crc >>= 26;
+		crc &= 0x3F;
+		if (crc > 31)
+			FEC_GAUR(base_addr) |= 0x1 << (crc - 32);
+		else
+			FEC_GALR(base_addr) |= 0x1 << crc;
+
+	}
+
+}
+
+/************************************************************************
+* NAME: fec_set_mac_address
+*
+* DESCRIPTION: This function sets the MAC address
+*************************************************************************/
+int fec_set_mac_address(struct net_device *dev, void *p)
+{
+	//Receive the pointer to the private structure
+	struct fec_priv *fp = netdev_priv(dev);
+
+	// Receive the base address
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+
+	struct sockaddr *addr = p;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	// Copy a new address to the device structure
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	// Copy a new address to the private structure
+	memcpy(fp->fecpriv_mac_addr, addr->sa_data, 6);
+
+	// Set the address to the registers
+	FEC_PALR(base_addr) = (fp->fecpriv_mac_addr[0] << 24) | (fp->fecpriv_mac_addr[1] << 16) | (fp->fecpriv_mac_addr[2] << 8) | fp->fecpriv_mac_addr[3];
+	FEC_PAUR(base_addr) = (fp->fecpriv_mac_addr[4] << 24) | (fp->fecpriv_mac_addr[5] << 16) | 0x8808;
+
+	return 0;
+}
+
+/************************************************************************
+* NAME: fec_tx
+*
+* DESCRIPTION: This function starts transmission of the frame using DMA
+*
+* RETURNS: This function always returns zero.
+*************************************************************************/
+int fec_tx(struct sk_buff *skb, struct net_device *dev)
+{
+
+	//Receive the pointer to the private structure
+	struct fec_priv *fp = netdev_priv(dev);
+
+	void *data, *data_aligned;
+	int offset;
+
+printk(KERN_INFO "fec_tx\n");
+	data = kmalloc(skb->len + 15, GFP_DMA | GFP_ATOMIC);
+
+	if (!data)
+	{
+		fp->fecpriv_stat.tx_dropped++;
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	offset = (((unsigned long)virt_to_phys(data) + 15) & 0xFFFFFFF0) - (unsigned long)virt_to_phys(data);
+	data_aligned = (void*)((unsigned long)data + offset);
+	memcpy(data_aligned, skb->data, skb->len);
+
+	// flush data cache before initializing the descriptor and starting DMA
+#if 0
+/* JKM -- currently running with cache turned off */
+	DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(data_aligned), skb->len);
+#endif
+
+	spin_lock_irq(&fp->fecpriv_lock);
+
+	// Initialize the descriptor
+	fp->fecpriv_txbuf[fp->fecpriv_next_tx] = data;
+	fp->fecpriv_txdesc[fp->fecpriv_next_tx].dataPointer = (unsigned int) virt_to_phys(data_aligned);
+	fp->fecpriv_txdesc[fp->fecpriv_next_tx].length = skb->len;
+	fp->fecpriv_txdesc[fp->fecpriv_next_tx].statCtrl |= (MCD_FEC_END_FRAME | MCD_FEC_BUF_READY);
+	fp->fecpriv_next_tx = (fp->fecpriv_next_tx + 1) & FEC_TX_INDEX_MASK;
+
+	if (fp->fecpriv_txbuf[fp->fecpriv_current_tx] && fp->fecpriv_current_tx == fp->fecpriv_next_tx)
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&fp->fecpriv_lock);
+
+	// Tell the DMA to continue the transmission
+	MCD_continDma(fp->fecpriv_fec_tx_channel);
+
+	dev_kfree_skb(skb);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+/************************************************************************
+* NAME: fec_tx_timeout
+*
+* DESCRIPTION: If the interrupt processing of received frames was lost
+*              and DMA stopped the reception, this function clears
+*              the transmission descriptors and starts DMA
+*
+*************************************************************************/
+void fec_tx_timeout(struct net_device *dev)
+{
+	int i;
+	struct fec_priv *fp = netdev_priv(dev);
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+
+printk(KERN_INFO "fec_tx_timeout\n");
+	spin_lock_irq(&fp->fecpriv_lock);
+	MCD_killDma(fp->fecpriv_fec_tx_channel);
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
+	{
+		if (fp->fecpriv_txbuf[i])
+		{
+
+			kfree(fp->fecpriv_txbuf[i]);
+			fp->fecpriv_txbuf[i] = NULL;
+
+		}
+		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
+	}
+	fp->fecpriv_txdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
+
+	fp->fecpriv_current_tx = fp->fecpriv_next_tx = 0;
+
+    // Reset FIFOs
+    FEC_FECFRST(base_addr) |= FEC_SW_RST;
+    FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
+
+	// Reset and disable FEC
+//	FEC_ECR(base_addr) = FEC_ECR_RESET;
+
+	// Enable FEC
+	FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
+
+	MCD_startDma(fp->fecpriv_fec_tx_channel, (char *) fp->fecpriv_txdesc, 0,
+		     (unsigned char *) &(FEC_FECTFDR(base_addr)), 0,
+		     FEC_MAX_FRM_SIZE, 0, fp->fecpriv_initiator_tx,
+		     FEC_TX_DMA_PRI, MCD_FECTX_DMA | MCD_INTERRUPT,
+		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
+
+	spin_unlock_irq(&fp->fecpriv_lock);
+
+	netif_wake_queue(dev);
+
+}
+
+/************************************************************************
+* NAME: fec_read_mii
+*
+* DESCRIPTION: This function reads the value from the MII register
+*
+* RETURNS: If no error occurs, this function returns zero.
+*************************************************************************/
+int fec_read_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int *data)
+{
+	unsigned long time;
+
+	// Clear the MII interrupt bit
+	FEC_EIR(base_addr) = FEC_EIR_MII;
+
+	// Write to the MII management frame register
+	FEC_MMFR(base_addr) = FEC_MMFR_READ | (pa << 23) | (ra << 18);
+
+	time = jiffies;
+
+	// Wait for the reading
+	while (!(FEC_EIR(base_addr) & FEC_EIR_MII))
+	{
+		if (jiffies - time > FEC_MII_TIMEOUT * HZ)
+			return -ETIME;
+		schedule();
+	}
+
+	// Clear the MII interrupt bit
+	FEC_EIR(base_addr) = FEC_EIR_MII;
+
+	*data = FEC_MMFR(base_addr) & 0x0000FFFF;
+
+	return 0;
+}
+
+/************************************************************************
+* NAME: fec_write_mii
+*
+* DESCRIPTION: This function writes the value to the MII register
+*
+* RETURNS: If no error occurs, this function returns zero.
+*************************************************************************/
+int fec_write_mii(unsigned int base_addr, unsigned int pa, unsigned int ra, unsigned int data)
+{
+	unsigned long time;
+
+	// Clear the MII interrupt bit
+	FEC_EIR(base_addr) = FEC_EIR_MII;
+
+	// Write to the MII management frame register
+	FEC_MMFR(base_addr) = FEC_MMFR_WRITE | (pa << 23) | (ra << 18) | data;
+
+	time = jiffies;
+
+	// Wait for the writing
+
+	while (!(FEC_EIR(base_addr) & FEC_EIR_MII))
+	{
+		if (jiffies - time > FEC_MII_TIMEOUT * HZ)
+			return -ETIME;
+
+		schedule();
+	}
+
+	// Clear the MII interrupt bit
+	FEC_EIR(base_addr) = FEC_EIR_MII;
+
+	return 0;
+}
+
+/************************************************************************
+* NAME: fec_interrupt_tx_handler
+*
+* DESCRIPTION: This function is called when the data
+*              transmission from the buffer to the FEC is completed.
+*
+*************************************************************************/
+void fec_interrupt_fec_tx_handler(struct net_device *dev)
+{
+	struct fec_priv *fp = netdev_priv(dev);
+
+printk(KERN_INFO "fectxint\n");
+	//Release the socket buffer
+	if(fp->fecpriv_txbuf[fp->fecpriv_current_tx])
+	{
+		kfree(fp->fecpriv_txbuf[fp->fecpriv_current_tx]);
+		fp->fecpriv_txbuf[fp->fecpriv_current_tx] = NULL;
+	}
+	fp->fecpriv_current_tx = (fp->fecpriv_current_tx + 1) & FEC_TX_INDEX_MASK;
+
+	if (MCD_dmaStatus(fp->fecpriv_fec_tx_channel) == MCD_DONE)
+		for (; fp->fecpriv_current_tx != fp->fecpriv_next_tx; fp->fecpriv_current_tx = (fp->fecpriv_current_tx + 1) & FEC_TX_INDEX_MASK)
+		{
+			if(fp->fecpriv_txbuf[fp->fecpriv_current_tx])
+			{
+				kfree(fp->fecpriv_txbuf[fp->fecpriv_current_tx]);
+				fp->fecpriv_txbuf[fp->fecpriv_current_tx] = NULL;
+			}
+		}
+
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+}
+
+/************************************************************************
+* NAME: fec_interrupt_rx_handler
+*
+* DESCRIPTION: This function is called when the data
+*              reception from the FEC to the reception buffer is completed.
+*
+*************************************************************************/
+void fec_interrupt_fec_rx_handler(struct net_device *dev)
+{
+	struct fec_priv *fp = netdev_priv(dev);
+	struct sk_buff *skb;
+
+printk(KERN_INFO "fecrxint\n");
+	fp->fecpriv_rxflag = 1;
+/*
+	// Some buffers can be missed
+	if(!(fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl & MCD_FEC_END_FRAME))
+	{
+		// Find a valid index
+		for(i = 0; i < FEC_RX_BUF_NUMBER && !(fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl & MCD_FEC_END_FRAME); i++, fp->fecpriv_current_rx = (fp->fecpriv_current_rx + 1) & FEC_RX_INDEX_MASK);
+
+		if(i == FEC_RX_BUF_NUMBER)
+		{
+			// There are no data to process
+			// Tell the DMA to continue the reception
+			MCD_continDma(fp->fecpriv_fec_rx_channel);
+
+			fp->fecpriv_rxflag = 0;
+
+			return;
+		}
+	}
+*/
+	for (; fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl & MCD_FEC_END_FRAME;	fp->fecpriv_current_rx = (fp->fecpriv_current_rx + 1) & FEC_RX_INDEX_MASK)
+	{
+	    if( (fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length <= FEC_MAXBUF_SIZE) &&
+		    (fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length > 4)) // --tym--
+	    {
+    		skb = fp->askb_rx[fp->fecpriv_current_rx];
+    		if (!skb)
+    		{
+    		    fp->fecpriv_stat.rx_dropped++;
+            }
+    		else
+    		{
+    		    // flush data cache before initializing the descriptor and starting DMA
+//		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), fp->askb_rx[fp->fecpriv_current_rx]->len);
+
+    			skb_put(skb, fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length - 4);
+//    			skb->dev = dev;
+    			skb->protocol = eth_type_trans(skb, dev);
+    			netif_rx(skb);
+    		}
+		    fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl &= ~MCD_FEC_END_FRAME;
+    		// allocate new skbuff
+    		fp->askb_rx[fp->fecpriv_current_rx] = alloc_skb(FEC_MAXBUF_SIZE + 16, /*GFP_ATOMIC |*/ GFP_DMA);
+		    if (!fp->askb_rx[fp->fecpriv_current_rx])
+    	    {
+        		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].dataPointer = 0;
+	    	    fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length = 0;
+    		    fp->fecpriv_stat.rx_dropped++;
+		    }
+    		else
+    		{
+    		    skb_reserve(fp->askb_rx[fp->fecpriv_current_rx], 16);
+    			fp->askb_rx[fp->fecpriv_current_rx]->dev = dev;
+
+    		    // flush data cache before initializing the descriptor and starting DMA
+#if 0
+/* JKM -- currently running with cache turned off */
+		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), FEC_MAXBUF_SIZE);
+#endif
+
+    	    	fp->fecpriv_rxdesc[fp->fecpriv_current_rx].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail);
+    	    	fp->fecpriv_rxdesc[fp->fecpriv_current_rx].length = FEC_MAXBUF_SIZE;
+        		fp->fecpriv_rxdesc[fp->fecpriv_current_rx].statCtrl |= MCD_FEC_BUF_READY;
+
+    		    // flush data cache before initializing the descriptor and starting DMA
+//		    DcacheFlushInvalidateCacheBlock((void*)virt_to_phys(fp->askb_rx[fp->fecpriv_current_rx]->tail), FEC_MAXBUF_SIZE);
+    	    }
+        }
+
+	}
+
+	// Tell the DMA to continue the reception
+	MCD_continDma(fp->fecpriv_fec_rx_channel);
+
+	fp->fecpriv_rxflag = 0;
+
+}
+
+/************************************************************************
+* NAME: fec_interrupt_handler
+*
+* DESCRIPTION: This function is called when some special errors occur
+*
+*************************************************************************/
+irqreturn_t fec_interrupt_handler(int irq, void *dev_id)
+{
+
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct fec_priv *fp = netdev_priv(dev);
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+	unsigned long events;
+
+printk(KERN_INFO "fecerrint\n");
+	// Read and clear the events
+	events = FEC_EIR(base_addr) & FEC_EIMR(base_addr);
+
+	if (events & FEC_EIR_HBERR)
+	{
+		fp->fecpriv_stat.tx_heartbeat_errors++;
+    	FEC_EIR(base_addr) = FEC_EIR_HBERR;
+	}
+
+    // receive/transmit FIFO error
+    if (((events & FEC_EIR_RFERR) != 0) || ((events & FEC_EIR_XFERR) != 0))
+    {
+        // kill DMA receive channel
+        MCD_killDma (fp->fecpriv_fec_rx_channel);
+        // kill running transmission by DMA
+        MCD_killDma (fp->fecpriv_fec_tx_channel);
+
+        // Reset FIFOs
+        FEC_FECFRST(base_addr) |= FEC_SW_RST;
+        FEC_FECFRST(base_addr) &= ~FEC_SW_RST;
+
+        // reset receive FIFO status register
+        FEC_FECRFSR(base_addr) = FEC_FECRFSR_FAE
+                                 | FEC_FECRFSR_RXW
+                                 | FEC_FECRFSR_UF;
+
+        // reset transmit FIFO status register
+        FEC_FECTFSR(base_addr) = FEC_FECTFSR_FAE
+                                 | FEC_FECTFSR_TXW
+                                 | FEC_FECTFSR_UF
+                                 | FEC_FECTFSR_OF;
+
+        // reset RFERR and XFERR event
+        FEC_EIR(base_addr) = FEC_EIR_RFERR | FEC_EIR_XFERR;
+
+	// stop queue
+	netif_stop_queue(dev);
+	
+        // execute reinitialization as tasklet
+    	tasklet_schedule(&fp->fecpriv_tasklet_reinit);
+
+        fp->fecpriv_stat.rx_dropped++;
+
+    }
+
+    // transmit FIFO underrun
+    if ((events & FEC_EIR_XFUN) != 0)
+    {
+        // reset XFUN event
+        FEC_EIR(base_addr) = FEC_EIR_XFUN;
+		fp->fecpriv_stat.tx_aborted_errors++;
+    }
+
+    // late collision
+    if ((events & FEC_EIR_LC) != 0)
+    {
+        // reset LC event
+        FEC_EIR(base_addr) = FEC_EIR_LC;
+		fp->fecpriv_stat.tx_aborted_errors++;
+    }
+
+    // collision retry limit
+    if ((events & FEC_EIR_RL) != 0)
+    {
+        // reset RL event
+        FEC_EIR(base_addr) = FEC_EIR_RL;
+		fp->fecpriv_stat.tx_aborted_errors++;
+    }
+
+    return 0;
+}
+
+/************************************************************************
+* NAME: fec_interrupt_reinit
+*
+* DESCRIPTION: This function is called from interrupt handler
+*              when controller must be reinitialized.
+*
+*************************************************************************/
+void fec_interrupt_fec_reinit(unsigned long data)
+{
+	int i;
+	struct net_device *dev = (struct net_device*)data;
+	struct fec_priv *fp = netdev_priv(dev);
+	unsigned long base_addr = (unsigned long) dev->base_addr;
+
+printk(KERN_INFO "fecreinit\n");
+	// Initialize reception descriptors and start DMA for the reception
+	for (i = 0; i < FEC_RX_BUF_NUMBER; i++)
+	{
+		if (!fp->askb_rx[i])
+		{
+    		fp->askb_rx[i] = alloc_skb(FEC_MAXBUF_SIZE + 16, GFP_ATOMIC | GFP_DMA);
+        	if (!fp->askb_rx[i])
+		    {
+        		fp->fecpriv_rxdesc[i].dataPointer = 0;
+	        	fp->fecpriv_rxdesc[i].statCtrl = 0;
+    	    	fp->fecpriv_rxdesc[i].length = 0;
+    	    	continue;
+	        }
+			fp->askb_rx[i]->dev = dev;
+    	    skb_reserve(fp->askb_rx[i], 16);
+	    }
+	    fp->fecpriv_rxdesc[i].dataPointer = (unsigned int) virt_to_phys(fp->askb_rx[i]->tail);
+		fp->fecpriv_rxdesc[i].statCtrl = MCD_FEC_BUF_READY | MCD_FEC_INTERRUPT;
+    	fp->fecpriv_rxdesc[i].length = FEC_MAXBUF_SIZE;
+	}
+
+	fp->fecpriv_rxdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
+	fp->fecpriv_current_rx = 0;
+
+    // restart frame transmission
+	for (i = 0; i < FEC_TX_BUF_NUMBER; i++)
+	{
+		if (fp->fecpriv_txbuf[i])
+		{
+
+			kfree(fp->fecpriv_txbuf[i]);
+			fp->fecpriv_txbuf[i] = NULL;
+    		fp->fecpriv_stat.tx_dropped++;
+		}
+		fp->fecpriv_txdesc[i].statCtrl = MCD_FEC_INTERRUPT;
+	}
+	fp->fecpriv_txdesc[i - 1].statCtrl |= MCD_FEC_WRAP;
+	fp->fecpriv_current_tx = fp->fecpriv_next_tx = 0;
+
+	// flush entire data cache before restarting the DMA
+#if 0
+/* JKM -- currently running with cache turned off */
+	DcacheFlushInvalidate();
+#endif
+	
+    // restart DMA from beginning
+	MCD_startDma(fp->fecpriv_fec_rx_channel,
+		     (char *) fp->fecpriv_rxdesc, 0,
+		     (unsigned char *) &(FEC_FECRFDR(base_addr)), 0,
+		     FEC_MAX_FRM_SIZE, 0, fp->fecpriv_initiator_rx,
+		     FEC_RX_DMA_PRI, MCD_FECRX_DMA | MCD_INTERRUPT,
+		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
+
+	MCD_startDma(fp->fecpriv_fec_tx_channel, (char *) fp->fecpriv_txdesc, 0,
+		     (unsigned char *) &(FEC_FECTFDR(base_addr)), 0,
+		     FEC_MAX_FRM_SIZE, 0, fp->fecpriv_initiator_tx,
+		     FEC_TX_DMA_PRI, MCD_FECTX_DMA | MCD_INTERRUPT,
+		     MCD_NO_CSUM | MCD_NO_BYTE_SWAP);
+
+    // Enable FEC
+    FEC_ECR(base_addr) |= FEC_ECR_ETHEREN;
+
+	netif_wake_queue(dev);
+
+}
+
+/************************************************************************
+* NAME: fec_interrupt_tx_handler_fec0
+*
+* DESCRIPTION: This is the DMA interrupt handler using  for FEC0
+*              transmission.
+*
+*************************************************************************/
+void fec_interrupt_fec_tx_handler_fec0(void)
+{
+	fec_interrupt_fec_tx_handler(fec_dev[0]);
+}
+
+#ifdef   FEC_2
+/************************************************************************
+* NAME: fec_interrupt_tx_handler_fec1
+*
+* DESCRIPTION: This is the DMA interrupt handler using for the FEC1
+*              transmission.
+*
+*************************************************************************/
+void fec_interrupt_fec_tx_handler_fec1(void)
+{
+	fec_interrupt_fec_tx_handler(fec_dev[1]);
+}
+#endif
+
+/************************************************************************
+* NAME: fec_interrupt_rx_handler_fec0
+*
+* DESCRIPTION: This is the DMA interrupt handler using for the FEC0
+*              reception.
+*
+*************************************************************************/
+void fec_interrupt_fec_rx_handler_fec0(void)
+{
+	fec_interrupt_fec_rx_handler(fec_dev[0]);
+}
+
+#ifdef   FEC_2
+/************************************************************************
+* NAME: fec_interrupt_rx_handler_fec1
+*
+* DESCRIPTION: This is the DMA interrupt handler using for the FEC1
+*              reception.
+*
+*************************************************************************/
+void fec_interrupt_fec_rx_handler_fec1(void)
+{
+	fec_interrupt_fec_rx_handler(fec_dev[1]);
+}
+
+#endif
+#ifndef MODULE
+
+/************************************************************************
+* NAME: fec_mac_setup0
+*
+* DESCRIPTION: This function sets the MAC address of FEC0 from command line
+*
+*************************************************************************/
+int __init fec_mac_setup0(char *s)
+{
+	if(!s || !*s)
+		return 1;
+
+	if(fec_str_to_mac(s, fec_mac_addr_fec0))
+		printk("The MAC address of FEC0 cannot be set from command line");
+	return 1;
+
+}
+
+#ifdef   FEC_2
+
+/************************************************************************
+* NAME: fec_mac_setup1
+*
+* DESCRIPTION: This function sets the MAC address of FEC1 from command line
+*
+*************************************************************************/
+int __init fec_mac_setup1(char *s)
+{
+	if(!s || !*s)
+		return 1;
+
+
+	if(fec_str_to_mac(s, fec_mac_addr_fec1))
+		printk("The MAC address of FEC1 cannot be set from command line");
+	return 1;
+
+}
+#endif
+
+/************************************************************************
+* NAME: fec_str_to_mac
+*
+* DESCRIPTION: This function interprets the character string into MAC addr
+*
+*************************************************************************/
+int fec_str_to_mac( char *str_mac, unsigned char* addr)
+{
+    unsigned long val;
+	char c;
+	unsigned long octet[6], *octetptr = octet;
+	int i;
+again:
+
+	val = 0;
+	while ((c = *str_mac) != '\0')
+	{
+		if ((c>='0')&&(c<='9'))
+		{
+			val = (val * 16) + (c - '0');
+			str_mac++;
+			continue;
+		}
+		else
+		if (((c>='a')&&(c<='f'))||((c>='A')&&(c<='F')))
+		{
+			val = (val << 4) + (c + 10 - (((c>='a')&&(c<='f')) ? 'a' : 'A'));
+			str_mac++;
+			continue;
+		}
+		break;
+	}
+	if (*str_mac == ':')
+	{
+		*octetptr++ = val, str_mac++;
+		if (octetptr >= octet + 6)
+			return 1;
+		goto again;
+	}
+
+	 //Check for trailing characters.
+	if (*str_mac && !(*str_mac==' '))
+		return 1;
+	*octetptr++ = val;
+
+	if ((octetptr - octet)==6)
+	{
+	   for(i=0;i<=6;i++)
+	      addr[i]=octet[i];
+	}
+    else
+		return 1;
+
+	return 0;
+
+}
+#endif
--- /dev/null
+++ b/drivers/net/fec/fec.h
@@ -0,0 +1,162 @@
+
+#define   FEC_BASE_ADDR_FEC0                ((unsigned int)MCF_MBAR + 0x9000)
+#define   FEC_BASE_ADDR_FEC1                ((unsigned int)MCF_MBAR + 0x9800)
+
+//#define   FEC_INTC_IMRH_INT_MASK38          (0x00000040)
+//#define   FEC_INTC_IMRH_INT_MASK39          (0x00000080)
+//#define   FEC_INTC_ICR_FEC0                 (0x30)
+//#define   FEC_INTC_ICR_FEC1                 (0x31)
+#define   FEC_FECI2CIRQ                     (0xFFC0)
+#define   FEC_GPIO_PAR_FECI2CIRQ            *(volatile unsigned short*)((unsigned int)MCF_MBAR + 0xA44)
+//#define   FEC_INTC_ICRn(x)                  (*(volatile unsigned char *)(void*)((unsigned int) MCF_MBAR + 0x000740+((x)*0x001)))
+//#define   FEC_INTC_IMRH                     *(volatile unsigned int*)((unsigned int)MCF_MBAR + 0x000708)
+
+#define   FEC_ECR_DISABLE                   (0x00000000)
+
+#define   FEC_ECR(x)                        *(volatile unsigned int *)(x + 0x024)
+#define   FEC_EIR(x)                        *(volatile unsigned int*)(x + 0x004)
+#define   FEC_PALR(x)                       *(volatile unsigned int*)(x + 0x0E4)
+#define   FEC_PAUR(x)                       *(volatile unsigned int*)(x + 0x0E8)
+#define   FEC_IALR(x)                       *(volatile unsigned int*)(x + 0x11C)
+#define   FEC_IAUR(x)                       *(volatile unsigned int*)(x + 0x118)
+#define   FEC_GALR(x)                       *(volatile unsigned int*)(x + 0x124)
+#define   FEC_GAUR(x)                       *(volatile unsigned int*)(x + 0x120)
+#define   FEC_RCR(x)                        *(volatile unsigned int*)(x + 0x084)
+#define   FEC_FECRFCR(x)                    *(volatile unsigned int*)(x + 0x18C)
+#define   FEC_FECRFAR(x)                    *(volatile unsigned int*)(x + 0x198)
+#define   FEC_FECTFCR(x)                    *(volatile unsigned int*)(x + 0x1AC)
+#define   FEC_FECTFAR(x)                    *(volatile unsigned int*)(x + 0x1B8)
+#define   FEC_FECTFWR(x)                    *(volatile unsigned int*)(x + 0x144)
+#define   FEC_CTCWR(x)                      *(volatile unsigned int*)(x + 0x1C8)
+#define   FEC_EIMR(x)                       *(volatile unsigned int*)(x + 0x008)
+#define   FEC_TCR(x)                        *(volatile unsigned int*)(x + 0x0C4)
+#define   FEC_MIBC(x)                       *(volatile unsigned int*)(x + 0x064)
+#define   FEC_MSCR(x)                       *(volatile unsigned int*)(x + 0x044)
+#define   FEC_FECTFDR(x)                    *(volatile unsigned int*)(x + 0x1A4)
+#define   FEC_FECRFDR(x)                    *(volatile unsigned int*)(x + 0x184)
+#define   FEC_FECTFSR(x)                    *(volatile unsigned int*)(x + 0x1A8)
+#define   FEC_FECRFSR(x)					*(volatile unsigned int*)(x + 0x188)
+#define   FECSTAT_RMON_R_PACKETS(x)         *(volatile unsigned int*)(x + 0x284)
+#define   FECSTAT_RMON_T_PACKETS(x)         *(volatile unsigned int*)(x + 0x204)
+#define   FECSTAT_RMON_R_OCTETS(x)          *(volatile unsigned int*)(x + 0x2C4)
+#define   FECSTAT_RMON_T_OCTETS(x)          *(volatile unsigned int*)(x + 0x244)
+#define   FECSTAT_RMON_R_UNDERSIZE(x)       *(volatile unsigned int*)(x + 0x294)
+#define   FECSTAT_RMON_R_OVERSIZE(x)        *(volatile unsigned int*)(x + 0x298)
+#define   FECSTAT_RMON_R_FRAG(x)            *(volatile unsigned int*)(x + 0x29C)
+#define   FECSTAT_RMON_R_JAB(x)             *(volatile unsigned int*)(x + 0x2A0)
+#define   FECSTAT_RMON_R_MC_PKT(x)          *(volatile unsigned int*)(x + 0x28C)
+#define   FECSTAT_RMON_T_COL(x)             *(volatile unsigned int*)(x + 0x224)
+#define   FECSTAT_IEEE_R_ALIGN(x)           *(volatile unsigned int*)(x + 0x2D4)
+#define   FECSTAT_IEEE_R_CRC(x)             *(volatile unsigned int*)(x + 0x2D0)
+#define   FECSTAT_IEEE_R_MACERR(x)          *(volatile unsigned int*)(x + 0x2D8)
+#define   FECSTAT_IEEE_T_CSERR(x)           *(volatile unsigned int*)(x + 0x268)
+#define   FECSTAT_IEEE_T_MACERR(x)          *(volatile unsigned int*)(x + 0x264)
+#define   FECSTAT_IEEE_T_LCOL(x)            *(volatile unsigned int*)(x + 0x25C)
+#define   FECSTAT_IEEE_R_OCTETS_OK(x)       *(volatile unsigned int*)(x + 0x2E0)
+#define   FECSTAT_IEEE_T_OCTETS_OK(x)       *(volatile unsigned int*)(x + 0x274)
+#define   FECSTAT_IEEE_R_DROP(x)            *(volatile unsigned int*)(x + 0x2C8)
+#define   FECSTAT_IEEE_T_DROP(x)            *(volatile unsigned int*)(x + 0x248)
+#define   FECSTAT_IEEE_R_FRAME_OK(x)        *(volatile unsigned int*)(x + 0x2CC)
+#define   FECSTAT_IEEE_T_FRAME_OK(x)        *(volatile unsigned int*)(x + 0x24C)
+#define   FEC_MMFR(x)                       *(volatile unsigned int*)(x + 0x040)
+#define   FEC_FECFRST(x)					*(volatile unsigned int*)(x + 0x1C4)
+
+#define   FEC_MAX_FRM_SIZE                  (1518)
+#define   FEC_MAXBUF_SIZE                   (1520)
+
+// Register values
+#define   FEC_ECR_RESET                     (0x00000001)
+#define   FEC_EIR_CLEAR                     (0xFFFFFFFF)
+#define   FEC_EIR_RL                        (0x00100000)
+#define   FEC_EIR_HBERR                     (0x80000000)
+#define   FEC_EIR_BABR						(0x40000000)   // babbling receive error
+#define   FEC_EIR_BABT						(0x20000000)   // babbling transmit error
+#define   FEC_EIR_TXF		              	(0x08000000)   // transmit frame interrupt
+#define   FEC_EIR_MII						(0x00800000)   // MII interrupt
+#define   FEC_EIR_LC						(0x00200000)   // late collision
+#define   FEC_EIR_XFUN						(0x00080000)   // transmit FIFO underrun
+#define   FEC_EIR_XFERR						(0x00040000)   // transmit FIFO error
+#define   FEC_EIR_RFERR						(0x00020000)   // receive FIFO error
+#define   FEC_RCR_MAX_FRM_SIZE              (FEC_MAX_FRM_SIZE << 16)
+#define   FEC_RCR_MII                       (0x00000004)
+#define   FEC_FECRFCR_FAE					(0x00400000)   // frame accept error
+#define   FEC_FECRFCR_RXW					(0x00200000)   // receive wait condition
+#define   FEC_FECRFCR_UF					(0x00100000)   // receive FIFO underflow
+#define   FEC_FECRFCR_FRM                   (0x08000000)
+#define   FEC_FECRFCR_GR                    (0x7 << 24)
+
+#define   FEC_EIMR_DISABLE					(0x00000000)
+
+#define   FEC_FECRFAR_ALARM                 (0x300)
+#define   FEC_FECTFCR_FRM                   (0x08000000)
+#define   FEC_FECTFCR_GR                    (0x7 << 24)
+#define   FEC_FECTFCR_FAE					(0x00400000)   // frame accept error
+#define   FEC_FECTFCR_TXW					(0x00040000)   // transmit wait condition
+#define   FEC_FECTFCR_UF					(0x00100000)   // transmit FIFO underflow
+#define   FEC_FECTFCR_OF					(0x00080000)   // transmit FIFO overflow
+
+#define   FEC_FECTFAR_ALARM                 (0x100)
+#define   FEC_FECTFWR_XWMRK                 (0x00000000)
+
+#define   FEC_FECTFSR_MSK                   (0xC0B00000)
+#define   FEC_FECTFSR_TXW                   (0x40000000)   // transmit wait condition
+#define   FEC_FECTFSR_FAE                   (0x00800000)   // frame accept error
+#define   FEC_FECTFSR_UF                    (0x00200000)   // transmit FIFO underflow
+#define   FEC_FECTFSR_OF                    (0x00100000)   // transmit FIFO overflow
+
+#define   FEC_FECRFSR_MSK                   (0x80F00000)
+#define   FEC_FECRFSR_FAE                   (0x00800000)   // frame accept error
+#define   FEC_FECRFSR_RXW                   (0x00400000)   // receive wait condition
+#define   FEC_FECRFSR_UF                    (0x00200000)   // receive FIFO underflow
+
+#define   FEC_CTCWR_TFCW_CRC                (0x03000000)
+#define   FEC_TCR_FDEN                      (0x00000004)
+#define   FEC_TCR_HBC                       (0x00000002)
+#define   FEC_RCR_DRT                       (0x00000002)
+#define   FEC_EIMR_MASK                     (FEC_EIR_RL | FEC_EIR_HBERR)
+#define   FEC_ECR_ETHEREN                   (0x00000002)
+#define   FEC_FECTFCR_MSK                   (0x00FC0000)
+#define   FEC_FECRFCR_MSK                   (0x00F80000)
+#define   FEC_EIR_GRA                       (0x10000000)
+#define   FEC_TCR_GTS                       (0x00000001)
+#define   FEC_MIBC_ENABLE                   (0x00000000)
+#define   FEC_MIB_LEN                       (228)
+#define   FEC_PHY_ADDR                      (0x01)
+
+#define FEC_RX_DMA_PRI                      (6)
+#define FEC_TX_DMA_PRI                      (6)
+
+#define   FEC_TX_BUF_NUMBER                 (8)
+#define   FEC_RX_BUF_NUMBER                 (64)
+
+#define   FEC_TX_INDEX_MASK                 (0x7)
+#define   FEC_RX_INDEX_MASK                 (0x3f)
+
+#define   FEC_RX_DESC_FEC0                  SYS_SRAM_FEC_START
+#define   FEC_TX_DESC_FEC0                  FEC_RX_DESC_FEC0 + FEC_RX_BUF_NUMBER * sizeof(MCD_bufDescFec)
+
+#define   FEC_RX_DESC_FEC1                  SYS_SRAM_FEC_START + SYS_SRAM_FEC_SIZE/2
+#define   FEC_TX_DESC_FEC1                  FEC_RX_DESC_FEC1 + FEC_RX_BUF_NUMBER * sizeof(MCD_bufDescFec)
+
+#define   FEC_EIR_MII                       (0x00800000)
+#define   FEC_MMFR_READ                     (0x60020000)
+#define   FEC_MMFR_WRITE                    (0x50020000)
+
+#define   FEC_FLAGS_RX                      (0x00000001)
+
+#define   FEC_CRCPOL                        (0xEDB88320)
+
+#define   FEC_MII_TIMEOUT                   (2)
+#define   FEC_GR_TIMEOUT                    (1)
+#define   FEC_TX_TIMEOUT                    (1)
+#define   FEC_RX_TIMEOUT                    (1)
+
+#define   FEC_SW_RST                        0x2000000
+#define   FEC_RST_CTL                       0x1000000
+
+int fec_read_mii(unsigned int base_addr, unsigned int pa, unsigned int ra,
+		 unsigned int *data);
+int fec_write_mii(unsigned int base_addr, unsigned int pa, unsigned int ra,
+		  unsigned int data);
+
+#define init_transceiver ks8721_init_transceiver
--- /dev/null
+++ b/drivers/net/fec/ks8721.c
@@ -0,0 +1,125 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/bitops.h>
+
+#if 0
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <asm/coldfire.h>
+#endif
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+#include   "fec.h"
+#include   "ks8721.h"
+
+#ifdef   CONFIG_FEC_548x_AUTO_NEGOTIATION
+#define   KS8721_AUTO_NEGOTIATION_ENABLE
+#endif
+
+/************************************************************************
+* +NAME: ks8721_init_transceiver
+*
+* DESCRIPTION: This function initializes the transceiver
+*
+* RETURNS: If no error occurs, this function returns zero.
+*          Otherwise, it returns 1
+*************************************************************************/
+
+int ks8721_init_transceiver(unsigned long base_addr, int *fduplex)
+{
+
+	int data;
+	unsigned long time;
+	int flag = 1;
+
+	int result;
+
+	// Set the frequency of MII
+	FEC_MSCR(base_addr) = FEC_MII_SPEED;
+
+	// Reset
+	if ((result = fec_write_mii(base_addr, FEC_PHY_ADDR, KS8721_CTRL, KS8721_CTRL_RESET)))
+		return result;
+
+	// Read back    
+	if ((result = fec_read_mii(base_addr, FEC_PHY_ADDR, KS8721_CTRL, &data)) != 0)
+		return result;
+
+	// If reset bit is set, return
+	if (data & KS8721_CTRL_RESET)
+		return -ETIME;
+
+#ifdef KS8721_AUTO_NEGOTIATION_ENABLE
+
+	// Disable  the auto-negotiation 
+	if ((result = fec_write_mii(base_addr, FEC_PHY_ADDR, KS8721_CTRL, 0)) != 0)
+		return result;
+
+	// Set the auto-negotiation advertisement register 
+	if ((result = fec_write_mii(base_addr, FEC_PHY_ADDR, KS8721_ANADV, KS8721_ANADV_ADV_ALL)) != 0)
+		return result;
+
+	// Enable the auto-negotiation
+	if ((result = fec_write_mii(base_addr, FEC_PHY_ADDR, KS8721_CTRL, KS8721_CTRL_AN_ENABLE)) != 0)
+		return result;
+
+	// Read PHY status register
+	if ((result = fec_read_mii(base_addr, FEC_PHY_ADDR, KS8721_STAT, &data)) != 0)
+		return result;
+	// Set the current time
+	time = jiffies;
+
+	// Wait for the auto-negotiation completion
+	while (!(data & KS8721_STAT_ANCOMPLETE))
+	{
+
+		if (jiffies - time > KS8721_TIMEOUT * HZ)
+		{
+			flag = 0;
+			break;
+		}
+
+		schedule();
+
+		// Read PHY status register
+		if ((result = fec_read_mii(base_addr, FEC_PHY_ADDR, KS8721_STAT, &data)) != 0)
+			return result;
+	}
+
+	if (flag)
+	{
+		// Set the duplex flag     
+		if (data & KS8721_STAT_FDUPLEX)
+			*fduplex = 1;
+		else
+			*fduplex = 0;
+
+		return 0;
+	}
+
+#endif
+
+	// Set the default mode (Full duplex, 100 Mbps) 
+	if ((result = fec_write_mii(base_addr, FEC_PHY_ADDR, KS8721_CTRL, KS8721_CTRL_DEFAULT_MODE)) != 0)
+		return result;
+	*fduplex = KS8721_CTRL_DEFAULT_MODE & 0x100;
+
+	return 0;
+
+}
--- /dev/null
+++ b/drivers/net/fec/ks8721.h
@@ -0,0 +1,21 @@
+
+#define   FEC_MII_SPEED              (((unsigned int)(MCF_BUSCLK / 5000000)) << 1)
+
+// Numbers of the transceiver registers 
+#define   KS8721_CTRL                0x00
+#define   KS8721_ANADV               0x04
+#define   KS8721_STAT                0x01
+
+// Register values
+#define   KS8721_CTRL_RESET          0x8000
+#define   KS8721_ANADV_ADV_ALL       0x01E1
+#define   KS8721_CTRL_AN_ENABLE      0x1280
+#define   KS8721_CTRL_DEFAULT_MODE   0x2100
+#define   KS8721_STAT_ANCOMPLETE     0x0020
+#define   KS8721_STAT_LINK           0x0004
+#define   KS8721_STAT_FDUPLEX        0x5000
+
+// Timeout for the auto-negotiation mode
+#define   KS8721_TIMEOUT             5
+
+int ks8721_init_transceiver(unsigned long base_addr, int *fduplex);
--- /dev/null
+++ b/include/asm-m68k/MCD_dma.h
@@ -0,0 +1,408 @@
+/*********************************************************************
+ *
+ * Copyright (C) 2004  Motorola, Inc.
+ *  MOTOROLA, INC. All Rights Reserved.
+ *  You are hereby granted a copyright license to use
+ *  the SOFTWARE so long as this entire notice is
+ *  retained without alteration in any modified and/or redistributed
+ *  versions, and that such modified versions are clearly identified
+ *  as such. No licenses are granted by implication, estoppel or
+ *  otherwise under any patents or trademarks of Motorola, Inc. This
+ *  software is provided on an "AS IS" basis and without warranty.
+ *
+ *  To the maximum extent permitted by applicable law, MOTOROLA
+ *  DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED, INCLUDING
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+ *  PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH REGARD TO THE
+ *  SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF) AND ANY
+ *  ACCOMPANYING WRITTEN MATERIALS.
+ *
+ *  To the maximum extent permitted by applicable law, IN NO EVENT
+ *  SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING
+ *  WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS
+ *  INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY
+ *  LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
+ *
+ *  Motorola assumes no responsibility for the maintenance and support
+ *  of this software
+ ********************************************************************/
+
+/*
+ * File:        MCD_dma.h
+ * Purpose:     Main header file for multi-channel DMA API.
+ *
+ * Notes:
+ *
+ * Modifications:
+ */
+#ifndef _MCD_API_H
+#define _MCD_API_H
+
+#include <asm/types.h>
+
+/*
+ * Turn Execution Unit tasks ON (#define) or OFF (#undef)
+ */
+#undef MCD_INCLUDE_EU
+
+/*
+ * Number of DMA channels
+ */
+#define NCHANNELS 16
+
+/*
+ * Total number of variants
+ */
+#ifdef MCD_INCLUDE_EU
+#define NUMOFVARIANTS   6
+#else
+#define NUMOFVARIANTS   4
+#endif
+
+/*
+ * Define sizes of the various tables
+ */
+#define TASK_TABLE_SIZE     (NCHANNELS*32)
+#define VAR_TAB_SIZE        (128)
+#define CONTEXT_SAVE_SIZE   (128)
+#define FUNCDESC_TAB_SIZE   (256)
+
+#ifdef MCD_INCLUDE_EU
+#define FUNCDESC_TAB_NUM    16
+#else
+#define FUNCDESC_TAB_NUM    1
+#endif
+
+
+#ifndef DEFINESONLY
+
+/*
+ * Portability typedefs
+ */
+ /*
+#ifndef s32
+typedef int s32;
+#endif
+#ifndef u32
+typedef unsigned int u32;
+#endif
+#ifndef s16
+typedef short s16;
+#endif
+#ifndef u16
+typedef unsigned short u16;
+#endif
+#ifndef s8
+typedef char s8;
+#endif
+#ifndef u8
+typedef unsigned char u8;
+#endif
+*/
+/*
+ * These structures represent the internal registers of the
+ * multi-channel DMA
+ */
+struct dmaRegs_s {
+   u32 taskbar;         /* task table base address register */
+   u32 currPtr;
+   u32 endPtr;
+   u32 varTablePtr;
+   u16 dma_rsvd0;
+   u16 ptdControl;      /* ptd control */
+   u32 intPending;      /* interrupt pending register */
+   u32 intMask;         /* interrupt mask register */
+   u16 taskControl[16]; /* task control registers */
+   u8  priority[32];    /* priority registers */
+   u32 initiatorMux;    /* initiator mux control */
+   u32 taskSize0;       /* task size control register 0. */
+   u32 taskSize1;       /* task size control register 1. */
+   u32 dma_rsvd1;       /* reserved */
+   u32 dma_rsvd2;       /* reserved */
+   u32 debugComp1;      /* debug comparator 1 */
+   u32 debugComp2;      /* debug comparator 2 */
+   u32 debugControl;    /* debug control */
+   u32 debugStatus;     /* debug status */
+   u32 ptdDebug;        /* priority task decode debug */
+   u32 dma_rsvd3[31];   /* reserved */
+};
+typedef volatile struct dmaRegs_s dmaRegs;
+
+#endif
+
+/*
+ * PTD contrl reg bits
+ */
+#define PTD_CTL_TSK_PRI         0x8000
+#define PTD_CTL_COMM_PREFETCH   0x0001
+
+/*
+ * Task Control reg bits and field masks
+ */
+#define TASK_CTL_EN             0x8000
+#define TASK_CTL_VALID          0x4000
+#define TASK_CTL_ALWAYS         0x2000
+#define TASK_CTL_INIT_MASK      0x1f00
+#define TASK_CTL_ASTRT          0x0080
+#define TASK_CTL_HIPRITSKEN     0x0040
+#define TASK_CTL_HLDINITNUM     0x0020
+#define TASK_CTL_ASTSKNUM_MASK  0x000f
+
+/*
+ * Priority reg bits and field masks
+ */
+#define PRIORITY_HLD            0x80
+#define PRIORITY_PRI_MASK       0x07
+
+/*
+ * Debug Control reg bits and field masks
+ */
+#define DBG_CTL_BLOCK_TASKS_MASK    0xffff0000
+#define DBG_CTL_AUTO_ARM            0x00008000
+#define DBG_CTL_BREAK               0x00004000
+#define DBG_CTL_COMP1_TYP_MASK      0x00003800
+#define DBG_CTL_COMP2_TYP_MASK      0x00000070
+#define DBG_CTL_EXT_BREAK           0x00000004
+#define DBG_CTL_INT_BREAK           0x00000002
+
+/*
+ * PTD Debug reg selector addresses
+ * This reg must be written with a value to show the contents of
+ * one of the desired internal register.
+ */
+#define PTD_DBG_REQ             0x00 /* shows the state of 31 initiators */
+#define PTD_DBG_TSK_VLD_INIT    0x01 /* shows which 16 tasks are valid and
+                                        have initiators asserted */
+
+
+/*
+ * General return values
+ */
+#define MCD_OK                   0
+#define MCD_ERROR               -1
+#define MCD_TABLE_UNALIGNED     -2
+#define MCD_CHANNEL_INVALID     -3
+
+/*
+ * MCD_initDma input flags
+ */
+#define MCD_RELOC_TASKS         0x00000001
+#define MCD_NO_RELOC_TASKS      0x00000000
+#define MCD_COMM_PREFETCH_EN    0x00000002  /* Commbus Prefetching - MCF547x/548x ONLY */
+
+/*
+ * MCD_dmaStatus Status Values for each channel
+ */
+#define MCD_NO_DMA  1 /* No DMA has been requested since reset */
+#define MCD_IDLE    2 /* DMA active, but the initiator is currently inactive */
+#define MCD_RUNNING 3 /* DMA active, and the initiator is currently active */
+#define MCD_PAUSED  4 /* DMA active but it is currently paused */
+#define MCD_HALTED  5 /* the most recent DMA has been killed with MCD_killTask() */
+#define MCD_DONE    6 /* the most recent DMA has completed. */
+
+
+/*
+ * MCD_startDma parameter defines
+ */
+
+/*
+ * Constants for the funcDesc parameter
+ */
+/* Byte swapping: */
+#define MCD_NO_BYTE_SWAP    0x00045670  /* to disable byte swapping. */
+#define MCD_BYTE_REVERSE    0x00076540  /* to reverse the bytes of each u32 of the DMAed data. */
+#define MCD_U16_REVERSE     0x00067450  /* to reverse the 16-bit halves of
+                                           each 32-bit data value being DMAed.*/
+#define MCD_U16_BYTE_REVERSE    0x00054760 /* to reverse the byte halves of each
+                                            16-bit half of each 32-bit data value DMAed */
+#define MCD_NO_BIT_REV  0x00000000  /* do not reverse the bits of each byte DMAed. */
+#define MCD_BIT_REV     0x00088880  /* reverse the bits of each byte DMAed */
+/* CRCing: */
+#define MCD_CRC16       0xc0100000  /* to perform CRC-16 on DMAed data. */
+#define MCD_CRCCCITT    0xc0200000  /* to perform CRC-CCITT on DMAed data. */
+#define MCD_CRC32       0xc0300000  /* to perform CRC-32 on DMAed data. */
+#define MCD_CSUMINET    0xc0400000  /* to perform internet checksums on DMAed data.*/
+#define MCD_NO_CSUM     0xa0000000  /* to perform no checksumming. */
+
+#define MCD_FUNC_NOEU1 (MCD_NO_BYTE_SWAP | MCD_NO_BIT_REV | MCD_NO_CSUM)
+#define MCD_FUNC_NOEU2 (MCD_NO_BYTE_SWAP | MCD_NO_CSUM)
+
+/*
+ * Constants for the flags parameter
+ */
+#define MCD_TT_FLAGS_RL   0x00000001 /* Read line */
+#define MCD_TT_FLAGS_CW   0x00000002 /* Combine Writes */
+#define MCD_TT_FLAGS_SP   0x00000004 /* Speculative prefetch(XLB) MCF547x/548x ONLY  */
+#define MCD_TT_FLAGS_MASK 0x000000ff
+#define MCD_TT_FLAGS_DEF  (MCD_TT_FLAGS_RL | MCD_TT_FLAGS_CW)
+
+#define MCD_SINGLE_DMA  0x00000100 /* Unchained DMA */
+#define MCD_CHAIN_DMA              /* TBD */
+#define MCD_EU_DMA                 /* TBD */
+#define MCD_FECTX_DMA   0x00001000 /* FEC TX ring DMA */
+#define MCD_FECRX_DMA   0x00002000 /* FEC RX ring DMA */
+
+
+/* these flags are valid for MCD_startDma and the chained buffer descriptors */
+#define MCD_BUF_READY   0x80000000 /* indicates that this buffer is now under the DMA's control */
+#define MCD_WRAP        0x20000000 /* to tell the FEC Dmas to wrap to the first BD */
+#define MCD_INTERRUPT   0x10000000 /* to generate an interrupt after completion of the DMA. */
+#define MCD_END_FRAME   0x08000000 /* tell the DMA to end the frame when transferring
+                                      last byte of data in buffer */
+#define MCD_CRC_RESTART 0x40000000 /* to empty out the accumulated checksum
+                                      prior to performing the DMA. */
+
+/* Defines for the FEC buffer descriptor control/status word*/
+#define MCD_FEC_BUF_READY   0x8000
+#define MCD_FEC_WRAP        0x2000
+#define MCD_FEC_INTERRUPT   0x1000
+#define MCD_FEC_END_FRAME   0x0800
+
+
+/*
+ * Defines for general intuitiveness
+ */
+
+#define MCD_TRUE  1
+#define MCD_FALSE 0
+
+/*
+ * Three different cases for destination and source.
+ */
+#define MINUS1          -1
+#define ZERO            0
+#define PLUS1           1
+
+#ifndef DEFINESONLY
+
+/* Task Table Entry struct*/
+typedef struct {
+    u32 TDTstart;   /* task descriptor table start */
+    u32 TDTend;     /* task descriptor table end */
+    u32 varTab;     /* variable table start */
+    u32 FDTandFlags;    /* function descriptor table start and flags */
+    volatile u32 descAddrAndStatus;
+    volatile u32 modifiedVarTab;
+    u32 contextSaveSpace;   /* context save space start */
+    u32 literalBases;
+} TaskTableEntry;
+
+
+/* Chained buffer descriptor */
+typedef volatile struct MCD_bufDesc_struct MCD_bufDesc;
+struct MCD_bufDesc_struct {
+   u32 flags;         /* flags describing the DMA */
+   u32 csumResult;    /* checksum from checksumming performed since last checksum reset */
+   s8  *srcAddr;      /* the address to move data from */
+   s8  *destAddr;     /* the address to move data to */
+   s8  *lastDestAddr; /* the last address written to */
+   u32 dmaSize;       /* the number of bytes to transfer independent of the transfer size */
+   MCD_bufDesc *next; /* next buffer descriptor in chain */
+   u32 info;          /* private information about this descriptor;  DMA does not affect it */
+};
+
+/* Progress Query struct */
+typedef volatile struct MCD_XferProg_struct {
+   s8 *lastSrcAddr;         /* the most-recent or last, post-increment source address */
+   s8 *lastDestAddr;        /* the most-recent or last, post-increment destination address */
+   u32  dmaSize;            /* the amount of data transferred for the current buffer */
+   MCD_bufDesc *currBufDesc;/* pointer to the current buffer descriptor being DMAed */
+} MCD_XferProg;
+
+
+/* FEC buffer descriptor */
+typedef volatile struct MCD_bufDescFec_struct {
+    u16 statCtrl;
+    u16 length;
+    u32 dataPointer;
+} MCD_bufDescFec;
+
+
+/*************************************************************************/
+/*
+ * API function Prototypes  - see MCD_dmaApi.c for further notes
+ */
+
+/*
+ * MCD_startDma starts a particular kind of DMA .
+ */
+int MCD_startDma (
+   int channel,   /* the channel on which to run the DMA */
+   s8  *srcAddr,  /* the address to move data from, or buffer-descriptor address */
+   s16 srcIncr,   /* the amount to increment the source address per transfer */
+   s8  *destAddr, /* the address to move data to */
+   s16 destIncr,  /* the amount to increment the destination address per transfer */
+   u32 dmaSize,   /* the number of bytes to transfer independent of the transfer size */
+   u32 xferSize,  /* the number bytes in of each data movement (1, 2, or 4) */
+   u32 initiator, /* what device initiates the DMA */
+   int priority,  /* priority of the DMA */
+   u32 flags,     /* flags describing the DMA */
+   u32 funcDesc   /* a description of byte swapping, bit swapping, and CRC actions */
+);
+
+/* 
+ * MCD_initDma() initializes the DMA API by setting up a pointer to the DMA 
+ * registers, relocating and creating the appropriate task structures, and 
+ * setting up some global settings
+ */
+int MCD_initDma (dmaRegs *sDmaBarAddr, void *taskTableDest, u32 flags);
+
+/* 
+ * MCD_dmaStatus() returns the status of the DMA on the requested channel.
+ */
+int MCD_dmaStatus (int channel);
+
+/* 
+ * MCD_XferProgrQuery() returns progress of DMA on requested channel
+ */
+int MCD_XferProgrQuery (int channel, MCD_XferProg *progRep);
+
+/* 
+ * MCD_killDma() halts the DMA on the requested channel, without any
+ * intention of resuming the DMA.
+ */
+int MCD_killDma (int channel);
+
+/* 
+ * MCD_continDma() continues a DMA which as stopped due to encountering an
+ * unready buffer descriptor.
+ */
+int MCD_continDma (int channel);
+
+/* 
+ * MCD_pauseDma() pauses the DMA on the given channel ( if any DMA is
+ * running on that channel). 
+ */
+int MCD_pauseDma (int channel);
+
+/* 
+ * MCD_resumeDma() resumes the DMA on a given channel (if any DMA is
+ * running on that channel).
+ */
+int MCD_resumeDma (int channel);
+
+/* 
+ * MCD_csumQuery provides the checksum/CRC after performing a non-chained DMA
+ */
+int MCD_csumQuery (int channel, u32 *csum);
+
+/* 
+ * MCD_getCodeSize provides the packed size required by the microcoded task
+ * and structures.
+ */
+int MCD_getCodeSize(void);
+
+/*
+ * MCD_getVersion provides a pointer to a version string and returns a
+ * version number.
+ */
+int MCD_getVersion(char **longVersion);
+
+/* macro for setting a location in the variable table */
+#define MCD_SET_VAR(taskTab,idx,value) ((u32 *)(taskTab)->varTab)[idx] = value
+   /* Note that MCD_SET_VAR() is invoked many times in firing up a DMA function,
+      so I'm avoiding surrounding it with "do {} while(0)" */
+
+#endif  /* DEFINESONLY */
+
+#endif /* _MCD_API_H */
--- a/include/asm-m68k/coldfire.h
+++ b/include/asm-m68k/coldfire.h
@@ -7,6 +7,7 @@
 #define MCF_SRAM	0x80000000
 #elif defined(CONFIG_M547X_8X)
 #define MCF_MBAR	0xE0000000
+#define MCF_MMUBAR	0xE1000000
 #define MCF_RAMBAR0	0xE3000000
 #define MCF_RAMBAR1	0xE3001000
 #endif
--- a/include/asm-m68k/dma.h
+++ b/include/asm-m68k/dma.h
@@ -1,16 +1,120 @@
 #ifndef _M68K_DMA_H
 #define _M68K_DMA_H 1
 
-
 /* it's useless on the m68k, but unfortunately needed by the new
    bootmem allocator (but this should do it for this) */
 #define MAX_DMA_ADDRESS PAGE_OFFSET
 
+#ifndef CONFIG_COLDFIRE
 #define MAX_DMA_CHANNELS 8
 
 extern int request_dma(unsigned int dmanr, const char * device_id);	/* reserve a DMA channel */
 extern void free_dma(unsigned int dmanr);	/* release it again */
 
+#else /* not (defined(CONFIG_MCF5474) || defined(CONFIG_MCF5484) || defined(CONFIG_MCF5475) || defined(CONFIG_MCF5485)) */
+
+/************************************************
+ * 	Multichannel DMA definitions		*
+ ************************************************/
+#ifdef CONFIG_MCD_DMA
+#include <asm/MCD_dma.h>
+#include <asm/m5485dma.h>
+
+struct scatterlist;
+
+#define MAX_DMA_CHANNELS NCHANNELS
+/*
+ *  identifiers for each initiator/requestor
+ */
+#define DMA_ALWAYS      (0)
+#define DMA_DSPI_RX     (1)
+#define DMA_DSPI_TX     (2)
+#define DMA_DREQ0       (3)
+#define DMA_PSC0_RX     (4)
+#define DMA_PSC0_TX     (5)
+#define DMA_USBEP0      (6)
+#define DMA_USBEP1      (7)
+#define DMA_USBEP2      (8)
+#define DMA_USBEP3      (9)
+#define DMA_PCI_TX      (10)
+#define DMA_PCI_RX      (11)
+#define DMA_PSC1_RX     (12)
+#define DMA_PSC1_TX     (13)
+#define DMA_I2C_RX      (14)
+#define DMA_I2C_TX      (15)
+#define DMA_FEC0_RX     (16)
+#define DMA_FEC0_TX     (17)
+#define DMA_FEC1_RX     (18)
+#define DMA_FEC1_TX     (19)
+#define DMA_DREQ1       (20)
+#define DMA_CTM0        (21)
+#define DMA_CTM1        (22)
+#define DMA_CTM2        (23)
+#define DMA_CTM3        (24)
+#define DMA_CTM4        (25)
+#define DMA_CTM5        (26)
+#define DMA_CTM6        (27)
+#define DMA_CTM7        (28)
+#define DMA_USBEP4      (29)
+#define DMA_USBEP5      (30)
+#define DMA_USBEP6      (31)
+#define DMA_PSC2_RX     (32)
+#define DMA_PSC2_TX     (33)
+#define DMA_PSC3_RX     (34)
+#define DMA_PSC3_TX     (35)
+#define DMA_FEC_RX(x)   ((x == 0) ? DMA_FEC0_RX : DMA_FEC1_RX)
+#define DMA_FEC_TX(x)   ((x == 0) ? DMA_FEC0_TX : DMA_FEC1_TX)
+
+int  dma_set_initiator(int);
+unsigned int dma_get_initiator(int);
+void dma_remove_initiator(int);
+int dma_set_channel(int);
+int dma_get_channel(int);
+void dma_remove_channel(int);
+int dma_set_channel_fec(int requestor);
+int dma_connect(int channel, int address);
+int dma_disconnect(int channel);
+void dma_remove_channel_by_number(int channel);
+int dma_init(void);
+
+#endif /* CONFIG_MCD_DMA */
+
+extern spinlock_t dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+
+/*
+ *  Linux standard DMA stuff
+ */
+#if 0
+int  request_dma(unsigned int channel, const char * device_id);
+void free_dma(unsigned int channel);
+void enable_dma(unsigned int channel);
+void disable_dma(unsigned int channel);
+int  dma_channel_active(unsigned int channel);
+void set_dma_sg(unsigned int channel, struct scatterlist *sg, int nr_sg);
+void set_dma_page(unsigned int channel, char pagenr);
+void set_dma_addr(unsigned int channel, unsigned long physaddr);
+void set_dma_count(unsigned int channel, unsigned long count);
+void set_dma_mode(unsigned int channel, unsigned int mode);
+void set_dma_speed(unsigned int channel, int cycle_ns);
+int  get_dma_residue(unsigned int channel);
+#endif
+#define clear_dma_ff(channel)
+
+#endif /* not (defined(CONFIG_MCF5474) || defined(CONFIG_MCF5484) || defined(CONFIG_MCF5475) || defined(CONFIG_MCF5485)) */
+
 #ifdef CONFIG_PCI
 extern int isa_dma_bridge_buggy;
 #else
--- /dev/null
+++ b/include/asm-m68k/m5485dma.h
@@ -0,0 +1,97 @@
+/*
+ *	m5485dma.h -- ColdFire 547x/548x DMA controller support.
+ */
+#ifndef __MCF548X_DMA_H__
+#define __MCF548X_DMA_H__
+
+
+/* Register read/write macros */
+#define MCF_DMA_DIPR    (*(volatile u32*)(void*)(MCF_MBAR+0x008014))
+#define MCF_DMA_DIMR    (*(volatile u32*)(void*)(MCF_MBAR+0x008018))
+#define MCF_DMA_IMCR    (*(volatile u32*)(void*)(MCF_MBAR+0x00805C))
+
+/* Bit definitions and macros for MCF_DMA_DIPR */
+#define MCF_DMA_DIPR_TASK0           (0x00000001)
+#define MCF_DMA_DIPR_TASK1           (0x00000002)
+#define MCF_DMA_DIPR_TASK2           (0x00000004)
+#define MCF_DMA_DIPR_TASK3           (0x00000008)
+#define MCF_DMA_DIPR_TASK4           (0x00000010)
+#define MCF_DMA_DIPR_TASK5           (0x00000020)
+#define MCF_DMA_DIPR_TASK6           (0x00000040)
+#define MCF_DMA_DIPR_TASK7           (0x00000080)
+#define MCF_DMA_DIPR_TASK8           (0x00000100)
+#define MCF_DMA_DIPR_TASK9           (0x00000200)
+#define MCF_DMA_DIPR_TASK10          (0x00000400)
+#define MCF_DMA_DIPR_TASK11          (0x00000800)
+#define MCF_DMA_DIPR_TASK12          (0x00001000)
+#define MCF_DMA_DIPR_TASK13          (0x00002000)
+#define MCF_DMA_DIPR_TASK14          (0x00004000)
+#define MCF_DMA_DIPR_TASK15          (0x00008000)
+
+/* Bit definitions and macros for MCF_DMA_DIMR */
+#define MCF_DMA_DIMR_TASK0           (0x00000001)
+#define MCF_DMA_DIMR_TASK1           (0x00000002)
+#define MCF_DMA_DIMR_TASK2           (0x00000004)
+#define MCF_DMA_DIMR_TASK3           (0x00000008)
+#define MCF_DMA_DIMR_TASK4           (0x00000010)
+#define MCF_DMA_DIMR_TASK5           (0x00000020)
+#define MCF_DMA_DIMR_TASK6           (0x00000040)
+#define MCF_DMA_DIMR_TASK7           (0x00000080)
+#define MCF_DMA_DIMR_TASK8           (0x00000100)
+#define MCF_DMA_DIMR_TASK9           (0x00000200)
+#define MCF_DMA_DIMR_TASK10          (0x00000400)
+#define MCF_DMA_DIMR_TASK11          (0x00000800)
+#define MCF_DMA_DIMR_TASK12          (0x00001000)
+#define MCF_DMA_DIMR_TASK13          (0x00002000)
+#define MCF_DMA_DIMR_TASK14          (0x00004000)
+#define MCF_DMA_DIMR_TASK15          (0x00008000)
+
+/* Bit definitions and macros for MCF_DMA_IMCR */
+#define MCF_DMA_IMCR_SRC16(x)        (((x)&0x00000003)<<0)
+#define MCF_DMA_IMCR_SRC17(x)        (((x)&0x00000003)<<2)
+#define MCF_DMA_IMCR_SRC18(x)        (((x)&0x00000003)<<4)
+#define MCF_DMA_IMCR_SRC19(x)        (((x)&0x00000003)<<6)
+#define MCF_DMA_IMCR_SRC20(x)        (((x)&0x00000003)<<8)
+#define MCF_DMA_IMCR_SRC21(x)        (((x)&0x00000003)<<10)
+#define MCF_DMA_IMCR_SRC22(x)        (((x)&0x00000003)<<12)
+#define MCF_DMA_IMCR_SRC23(x)        (((x)&0x00000003)<<14)
+#define MCF_DMA_IMCR_SRC24(x)        (((x)&0x00000003)<<16)
+#define MCF_DMA_IMCR_SRC25(x)        (((x)&0x00000003)<<18)
+#define MCF_DMA_IMCR_SRC26(x)        (((x)&0x00000003)<<20)
+#define MCF_DMA_IMCR_SRC27(x)        (((x)&0x00000003)<<22)
+#define MCF_DMA_IMCR_SRC28(x)        (((x)&0x00000003)<<24)
+#define MCF_DMA_IMCR_SRC29(x)        (((x)&0x00000003)<<26)
+#define MCF_DMA_IMCR_SRC30(x)        (((x)&0x00000003)<<28)
+#define MCF_DMA_IMCR_SRC31(x)        (((x)&0x00000003)<<30)
+#define MCF_DMA_IMCR_SRC16_FEC0RX    (0x00000000)
+#define MCF_DMA_IMCR_SRC17_FEC0TX    (0x00000000)
+#define MCF_DMA_IMCR_SRC18_FEC0RX    (0x00000020)
+#define MCF_DMA_IMCR_SRC19_FEC0TX    (0x00000080)
+#define MCF_DMA_IMCR_SRC20_FEC1RX    (0x00000100)
+#define MCF_DMA_IMCR_SRC21_DREQ1     (0x00000000)
+#define MCF_DMA_IMCR_SRC21_FEC1TX    (0x00000400)
+#define MCF_DMA_IMCR_SRC22_FEC0RX    (0x00001000)
+#define MCF_DMA_IMCR_SRC23_FEC0TX    (0x00004000)
+#define MCF_DMA_IMCR_SRC24_CTM0      (0x00010000)
+#define MCF_DMA_IMCR_SRC24_FEC1RX    (0x00020000)
+#define MCF_DMA_IMCR_SRC25_CTM1      (0x00040000)
+#define MCF_DMA_IMCR_SRC25_FEC1TX    (0x00080000)
+#define MCF_DMA_IMCR_SRC26_USBEP4    (0x00000000)
+#define MCF_DMA_IMCR_SRC26_CTM2      (0x00200000)
+#define MCF_DMA_IMCR_SRC27_USBEP5    (0x00000000)
+#define MCF_DMA_IMCR_SRC27_CTM3      (0x00800000)
+#define MCF_DMA_IMCR_SRC28_USBEP6    (0x00000000)
+#define MCF_DMA_IMCR_SRC28_CTM4      (0x01000000)
+#define MCF_DMA_IMCR_SRC28_DREQ1     (0x02000000)
+#define MCF_DMA_IMCR_SRC28_PSC2RX    (0x03000000)
+#define MCF_DMA_IMCR_SRC29_DREQ1     (0x04000000)
+#define MCF_DMA_IMCR_SRC29_CTM5      (0x08000000)
+#define MCF_DMA_IMCR_SRC29_PSC2TX    (0x0C000000)
+#define MCF_DMA_IMCR_SRC30_FEC1RX    (0x00000000)
+#define MCF_DMA_IMCR_SRC30_CTM6      (0x10000000)
+#define MCF_DMA_IMCR_SRC30_PSC3RX    (0x30000000)
+#define MCF_DMA_IMCR_SRC31_FEC1TX    (0x00000000)
+#define MCF_DMA_IMCR_SRC31_CTM7      (0x80000000)
+#define MCF_DMA_IMCR_SRC31_PSC3TX    (0xC0000000)
+
+#endif /* __MCF548X_DMA_H__ */
--- /dev/null
+++ b/include/asm-m68k/m5485sram.h
@@ -0,0 +1,12 @@
+#ifndef SYS_SRAM_H
+#define SYS_SRAM_H
+
+
+#define SYS_SRAM_DMA_START        MCF_MBAR + 0x10000
+#define SYS_SRAM_DMA_SIZE         8192
+#define SYS_SRAM_FEC_START        SYS_SRAM_DMA_START + SYS_SRAM_DMA_SIZE
+#define SYS_SRAM_FEC_SIZE         2048
+#define SYS_SRAM_SEC_START        SYS_SRAM_FEC_START + SYS_SRAM_FEC_SIZE
+#define SYS_SRAM_SEC_SIZE         1280
+
+#endif /* SYS_SRAM_H */
