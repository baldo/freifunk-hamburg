--- /dev/null
+++ b/ChangeLog.csl
@@ -0,0 +1,5630 @@
+2009-05-21  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (mcf52235_ctrl): Remove non-existent CACR, ACR[01].
+	(mcf53017_ctrl): Fix RAMBAR.
+
+2009-04-30  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* release-notes-csl.xml: Add arm* TARGET for -mauto-it note.
+
+2009-04-23  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #5328
+
+	* release-notes-csl.xml: Document bug fix.
+
+	bfd/
+	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Don't attempt to
+	fix discarded sections.
+
+2009-04-22  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #4502
+
+	* release-notes-csl.xml (Assembler fix for -mauto-it): New note.
+
+	gas/
+	* config/tc-arm.c (handle_it_state): Use force_automatic_it_block_close
+	to close the previous IT block.  Only close the next IT block if we
+	opened a new one for an IT-only instruction.
+
+2009-04-22  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue 5271
+
+	Backport 2009-04-22  Nathan Sidwell  <nathan@codesourcery.com>
+	ld/testsuite/
+	* ld-scripts/rgn-at1.d: Cope with larger padding on sections.
+	* ld-scripts/rgn-at2.d: Likewise.
+	* ld-scripts/rgn-at3.d: Likewise.
+
+	Backport 2009-04-03  Nathan Sidwell  <nathan@codesourcery.com>
+	ld/testuite/
+	* ld-scripts/rgn-at.s: Use explicit .section pseudos.
+
+2009-04-21  Andrew Jenner  <andrew@codesourcery.com>
+
+	Issue #5270
+
+	* ld/testsuite/ld-elf/eh5.d: Accept 0b as well as 1b for the 
+	personality byte in the augmentation data.
+	
+2009-04-20  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #5050
+
+	binutils/
+	* readelf.c (get_arm_section_type_name): Added support for
+	new sections headers.
+
+	include/elf
+	* arm.h: (SHT_ARM_DEBUGOVERLAY): New define.
+	(SHT_ARM_OVERLAYSECTION): New define.
+
+	* release-notes-csl.xml: Document.
+
+2009-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* release-notes-csl.xml: Fix typo.
+
+2009-04-14  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #1956, #2786, #5144
+	* release-notes-csl.xml (Mapping symbols): New note.
+
+	gas/testsuite/
+	* gas/arm/mapdir.d, gas/arm/mapdir.s: New files.
+
+	gas/
+	* config/tc-arm.c (make_mapping_symbol): New function, from
+	mapping_state.  Save mapping symbols in the frag.
+	(insert_data_mapping_symbol): New.
+	(mapping_state): Use make_mapping_symbol.
+	(mapping_state_2): New.  Provide dummy definition.
+	(opcode_select): Do not call mapping_state.
+	(s_bss): Call md_elf_section_change_hook instead of mapping_state.
+	(arm_handle_align): Update use of tc_frag_data.
+	Call insert_data_mapping_symbol.
+	(arm_init_frag): Update use of tc_frag_data.  Call
+	mapping_state_2.
+	(check_mapping_symbols): New function.
+	(arm_adjust_symtab): Use check_mapping_symbols.
+	* config/tc-arm.h (struct arm_frag_type): New.
+	(TC_FRAG_TYPE): Change to struct arm_frag_type.
+	(TC_FRAG_INIT): Pass max_chars.
+	(arm_init_frag): Update prototype.
+
+	ld/testsuite/
+	* ld-arm/thumb2-bl-blx-interwork.d: Correct disassembly.
+	* ld-arm/script-type.sym: Add an additional $a mapping symbol.
+
+	binutils/testsuite/
+	* binutils-all/arm/thumb2-cond.s: Use instructions.
+
+2009-04-12  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #5185
+
+	* release-notes-csl.xml (Incorrect placement of linker-generated
+	functions): New note.
+
+	bfd/
+	* elf32-arm.c (elf32_arm_next_input_section): Skip flags without
+	SEC_CODE.
+	(group_sections): Handle empty lists.
+
+2009-04-09  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #4849
+
+	* release-notes-csl.xml (Assembler floating point format): New note.
+
+	gas/testsuite/
+	* gas/arm/mapmisc.d: Correct expected output for .double and .dcb.d.
+
+2009-04-09  Daniel Gutson  <dgutson@codesourcery.com>
+
+        Issue #4502
+
+        gas/testsuite/
+        * gas/arm/arm-it-auto.d: fixed test case dump.
+
+2009-04-09  Catherine Moore  <clm@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (check_for_24k_errata):  Adjust if block.
+	Remove return.
+
+2009-04-09  Daniel Gutson  <dgutson@codesourcery.com>
+	Issue #4502
+
+	gas/
+	* config/tc-arm.c (do_automatic_it): New variable.
+	(it_instruction_type): New enum.
+	(arm_it): New field.
+	(it_state): New enum.
+	(current_it): New struct and global variable.
+	(current_it_compatible): New function.
+	(conditional_insn): New function.
+	(set_it_insn_type): New macro.
+	(set_it_insn_type_last): New macro.
+	(do_t_add_sub): Call automatic IT machinery functions.
+	(do_t_arit3): Likewise.
+	(do_t_arit3c): Likewise.
+	(do_t_blx): Likewise.
+	(do_t_branch): Likewise.
+	(do_t_bkpt): Likewise.
+	(do_t_branch23): Likewise.
+	(do_t_bx): Likewise.
+	(do_t_bxj): Likewise.
+	(do_t_cps): Likewise.
+	(do_t_cpsi): Likewise.
+	(do_t_cbz): Likewise.
+	(do_t_it): Likewise.
+	(encode_thumb2_ldmstm): Likewise.
+	(do_t_ldst): Likewise.
+	(do_t_mov_cmp): Likewise.
+	(do_t_mvn_tst): Likewise.
+	(do_t_mul): Likewise.
+	(do_t_neg): Likewise.
+	(do_t_setend): Likewise.
+	(do_t_shift): Likewise.
+	(do_t_tb): Likewise.
+	(output_it_inst): New function.
+	(new_automatic_it_block): New function.
+	(close_automatic_it_block): New function.
+	(current_it_add_mask): New function.
+	(it_fsm_pre_encode): New function.
+	(handle_it_state): New function.
+	(it_fsm_post_encode): New function.
+	(force_automatic_it_block_close): New function.
+	(in_it_block): New function.
+	(md_assemble): Call automatic IT block machinery functions.
+	(arm_frob_label): Likewise.
+	(arm_opts): New element.
+	* doc/c-arm.texi: New option -mauto-it.
+
+	gas/testsuite/
+	* gas/arm/arm-it-auto.d: New test.
+	* gas/arm/arm-it-auto.s: New file.
+	* gas/arm/thumb2_it_auto.d: New test.
+	* gas/arm/thumb2_it_bad.l: Error message updated.
+	* gas/arm/thumb2_it_bad_auto.d: New test.
+	* gas/arm/thumb2_it.d: Comment added.
+	* gas/arm/thumb2_it_bad.d: Comment added.
+
+	* release-notes-csl.xml: Document. 
+
+2009-04-08  Daniel Gutson  <dgutson@codesourcery.com>
+
+	gas/testsuite/
+	* gas/arm/thumb2_it.d: Removed obsolete regex.
+
+2009-04-08  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5162
+	bfd/
+	* elf32-arm.c (make_branch_to_a8_stub): Ignore long branch stubs.
+
+2009-04-08 Catherine Moore <clm@codesourcery.com>
+
+	Issue #4593
+
+	gas/
+	* config/tc-mips.c (mips_fix_24k): Declare.
+	(check_for_24k_errata): New.
+	(mips_cleanup): Call check_for_24k_errata.
+	(start_noreorder): Likewise.
+	(md_mips_end): Likewise.
+	(s_change_sec): Likewise.
+	(s_change_section): Likewise.
+	(append_insn): Call check_for_24k_errata.  Prevent
+	ERET/DERET instructions from being moved into delay
+	slots.
+	(OPTION_FIX_24K): New.
+	(OPTION_NO_FIX_24k): New.
+	(md_longopts): Add "mfix-24k" and "mno-fix-24k".
+	(md_parse_option): Handle fix-24k options.
+	(md_show_usage): Display fix-24k options.
+	* doc/c-mips.texi: Document.
+	* testsuite/gas/mips/mips.exp: Run new tests.
+	* testsuite/gas/mips/eret.s: New test.
+	* testsuite/gas/mips/eret.d: New test output.
+	* testsuite/gas/mips/eret.l: New test output.
+
+	* release-notes-csl.xml: New note.
+
+2009-04-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #5170
+
+	* release-notes-csl.xml (tlbilx encoding fix): New note.
+
+	Backport from mainline:
+
+	gas/
+	2009-04-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* ppc-opc.c (powerpc_opcodes) <"tlbilxlpid", "tlbilxpid", "tlbilxva",
+	"tlbilx">: Use secondary opcode "18" as per the ISA 2.06 documentation.
+	Reorder entries so the extended mnemonics are listed before tlbilx.
+
+	opcodes/
+	2009-04-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* gas/ppc/e500mc.d: Update to match extended mnemonics.
+
+2009-04-06  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #5124
+
+	gas/
+	* config/tc-arm.c (arm_frag_align_code): Fixed the string message.
+	* config/tc-arm.h (MAX_MEM_ALIGNMENT_BYTES): New macro.
+	(MAX_MEM_FOR_RS_ALIGN_CODE): Macro changed to use the above.
+
+	gas/testsuite/
+	* gas/arm/align64.d: New file.
+	* gas/arm/align64.s: New file.
+
+	* release-notes-csl.xml: Document.
+
+2009-04-06  Andrew Jenner  <andrew@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c: Move sysdep.h to start of file.
+	
+2009-04-06  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from FSF:
+	ld/
+	2009-04-06  Kazu Hirata  <kazu@codesourcery.com>
+	* ld.texinfo (-L): Mention that -L options do not affect how ld
+	searches for a linker script unless -T option is specified.
+	* ldfile.c (ldfile_find_command_file): Append the path obtained
+	from the program name to the search path instead of
+	prepending. Add a new parameter "default_only". Restrict the
+	search to the default script location if the new parameter is
+	true.
+	(ldfile_open_command_file_1): New.
+	(ldfile_open_command_file): Call ldfile_open_command_file_1.
+	(ldfile_open_default_command_file): New.
+
+	* ldfile.c (ldfile_find_command_file): Initialize result.
+
+2009-04-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #5010
+	binutils/
+	* objcopy.c (maybe_sign_extend_vma): New.
+	(setup_section): Call maybe_sign_extend_vma after manipulating
+	addresses.
+
+	* release-notes-csl.xml: Mention the bug fix above.
+
+2009-04-03  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Cortex-A8 erratum workaround enabled
+	for ARMv7-A): Add note.
+
+2009-04-03  Julian Brown  <julian@codesourcery.com>
+
+	ld/
+	* emultempl/armelf.em (OPTION_NO_FIX_CORTEX_A8): New.
+	(PARSE_AND_LIST_LONGOPTS): Add --no-fix-cortex-a8 option. Remove
+	argument from --fix-cortex-a8.
+	(PARSE_AND_LIST_OPTIONS): Adjust for --[no-]fix-cortex-a8 syntax.
+	(PARSE_FIX_CORTEX_A8, PARSE_NO_FIX_CORTEX_A8): Handle
+	--[no-]fix-cortex-a8 syntax.
+	* ld.texinfo (--fix-cortex-a8): Document.
+
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_set_cortex_a8_fix): Re-enable fix by
+	default on ARM v7-A.
+
+2009-04-03  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #5022
+	ld/
+	* ldlang.c (lang_leave_output_section_statement): Set lma_region
+	if it is not overridden and section is for the same vma region as
+	the previous section.
+
+	ld/testsuite/
+	* ld-scripts/rgn-at.exp: New.
+	* ld-scripts/rgn-at.s: New.
+	* ld-scripts/rgn-at1.d: New.
+	* ld-scripts/rgn-at1.t: New.
+	* ld-scripts/rgn-at2.d: New.
+	* ld-scripts/rgn-at2.t: New.
+	* ld-scripts/rgn-at3.d: New.
+	* ld-scripts/rgn-at3.t: New.
+
+	* release-notes-csl.xml: Add note.
+
+2009-04-02  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issues #4842, #5076
+	gas/
+	* config/tc-armlinux-eabi.h (FPU_DEFAULT): Default to plain VFP.
+	* config/tc-armeabi.h (FPU_DEFAULT): Likewise.
+	* config/tc-arm.c (md_begin): If FPU_DEFAULT is set, don't infer
+	the default FPU from the processor.
+
+	gas/testsuite/
+	* gas/arm/attr-mcpu.d: Add -mfpu=neon.
+
+	* release-notes-csl.xml: Add note.
+	
+2009-03-31  Paul Brook  <paul@codesourcery.com>
+
+	Issue #1531
+
+	bfd/
+	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add prototype.
+	* bfd-in2.h: Regenerate.
+	* elf32-arm.c (arm_unwind_edit_type, arm_unwind_table_edit): Define.
+	(_arm_elf_section_data): Add text and exidx fields.
+	(add_unwind_table_edit, get_arm_elf_section_data, adjust_exidx_size,
+	insert_cantunwind_after, elf32_arm_fix_exidx_coverage, offset_prel31,
+	copy_exidx_entry): New functions.
+	(elf32_arm_write_section): Fixup .ARM.exidx contents.
+
+	ld/
+	* emultempl/armelf.em (compare_output_sec_vma): New function.
+	(gld${EMULATION_NAME}_finish): Add exidx munging code.
+
+	ld/testsuite/
+	* ld-arm/arm.ld: Add .ARM.exidx and .ARM.extab.
+	* ld-arm/arm-elf.exp: Add unwind-[1-4].
+	* ld-arm/unwind-1.d: New test.
+	* ld-arm/unwind-1.s: New test.
+	* ld-arm/unwind-2.d: New test.
+	* ld-arm/unwind-2.s: New test.
+	* ld-arm/unwind-3.d: New test.
+	* ld-arm/unwind-3.s: New test.
+	* ld-arm/unwind-4.d: New test.
+	* ld-arm/unwind-4.s: New test.
+
+2009-03-30  Andrew Jenner  <andrew@codesourcery.com>
+
+	ld/
+	* emultempl/octeonelf.em: Source mipself.em.
+
+	gas/
+	* config/tc-arm.c: Move as.h to start of file.
+
+2009-03-30  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5084
+
+	Backport from FSF:
+
+	gas/testsuite/
+	* gas/arm/mapsecs.d, gas/arm/mapsecs.s: New.
+
+	opcodes/
+	* arm-dis.c (print_insn): Also check section matches in backwards
+	search for mapping symbol.
+
+2009-03-30  Julian Brown  <julian@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (a8_erratum_fix): Add r_type, st_type, sym_name,
+	non_a8_stub fields.
+	(find_thumb_glue): Add forward declaration.
+	(elf32_arm_size_stubs): Improve integration of Cortex-A8 erratum
+	workaround and ARM/Thumb interworking.
+
+	ld/testsuite/
+	* ld-arm/cortex-a8-fix-b.s: Update for text at 0x8f00.
+	* ld-arm/cortex-a8-fix-bl.s: Likewise.
+	* ld-arm/cortex-a8-fix-bcc.s: Likewise.
+	* ld-arm/cortex-a8-fix-blx.s: Likewise.
+	* ld-arm/cortex-a8-fix-b.d: Update.
+	* ld-arm/cortex-a8-fix-bl.d: Update.
+	* ld-arm/cortex-a8-fix-bcc.d: Update.
+	* ld-arm/cortex-a8-fix-blx.d: Update.
+	* ld-arm/cortex-a8-arm-target.s: New.
+	* ld-arm/cortex-a8-thumb-target.s: New.
+	* ld-arm/cortex-a8-fix-b-rel.s: New.
+	* ld-arm/cortex-a8-fix-b-rel-arm.d: New.
+	* ld-arm/cortex-a8-fix-b-rel-thumb.d: New.
+	* ld-arm/cortex-a8-fix-bl-rel.s: New.
+	* ld-arm/cortex-a8-fix-bl-rel-arm.d: New.
+	* ld-arm/cortex-a8-fix-bl-rel-thumb.d: New.
+	* ld-arm/cortex-a8-fix-bcc-rel.s: New.
+	* ld-arm/cortex-a8-fix-bcc-rel-thumb.d: New.
+	* ld-arm/cortex-a8-fix-blx-rel.s: New.
+	* ld-arm/cortex-a8-fix-blx-rel-arm.d: New.
+	* ld-arm/cortex-a8-fix-blx-rel-thumb.d: New.
+	* ld-arm/arm-elf.exp: Move text section to 0x8f00 in existing
+	Cortex-A8 erratum workaround tests, and add above new tests.
+
+2009-03-29  Mark Mitchell  <mark@codesourcery.com>
+
+	Backport: 
+	
+	2009-03-28  Mark Mitchell  <mark@codesourcery.com>
+	bfd/
+	* coff-arm.c (coff_arm_merge_private_bfd_data): Use "error:", not
+	"ERROR:", in error messages.
+	* cpu-arm.c (bfd_arm_merge_machines): Likewise.
+	* elf-attrs.c (_bfd_elf_merge_object_attributes): Likewise.
+	* elf32-arm.c (tag_cpu_arch_combine): Likewise.
+	(elf32_arm_merge_eabi_attributes): Likewise.
+	(elf32_arm_merge_private_bfd_data): Likewise.
+
+2009-03-24  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (INTERWORK_FLAG): Check BFD_LINKER_CREATED.
+
+2009-03-22  Mark Mitchell  <mark@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armelftests): Use -EL for Cortex-A8 tests.
+
+2009-03-20  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Erratum workaround for Cortex-A8 processors):
+	Add note.
+
+2009-03-20  Julian Brown  <julian@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (Cortex-A8 erratum fix, b.w)
+	(Cortex-A8 erratum fix, bl.w, Cortex-A8 erratum fix, bcc.w)
+	(Cortex-A8 erratum fix, blx.w): Pass --fix-cortex-a8 option.
+
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_set_cortex_a8_fix): Disable fix by
+	default in all cases.
+
+2009-03-20  Julian Brown  <julian@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (do_t_blx): Always use BFD_RELOC_THUMB_PCREL_BLX.
+	(md_pcrel_from_section): Align address for BLX.
+	(tc_gen_reloc): Change BFD_RELOC_THUMB_PCREL_BLX relocations to
+	BFD_RELOC_THUMB_PCREL_BRANCH23 for EABI v4+.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armeabitests): Add thumb2-bl-blx-interwork test.
+	* ld-arm/thumb2-bl-blx-interwork.s: New.
+	* ld-arm/thumb2-bl-blx-interwork.d: New.
+
+2009-03-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	* release-note-csl.xml: Document issue #4250 changes.
+
+2009-03-20  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml (Incorrect linker-generated functions): New
+	note.
+
+2009-03-19  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #4727
+
+	ld/
+	* emultempl/armelf.em (bfd_for_interwork, arm_elf_after_open)
+	(arm_elf_set_bfd_for_interworking): Delete.
+	(arm_elf_before_allocation): Do not set the interworking BFD.
+	Move allocation inside not-dynamic block.
+	(arm_elf_create_output_section_statements): Create glue sections
+	and set the interworking BFD here.
+	(LDEMUL_AFTER_OPEN): Delete.
+
+	ld/testsuite/
+	* ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
+	ld-arm/farcall-group-size2.d, ld-arm/farcall-group.d: Update for
+	linker changes.
+
+	bfd/
+	* elf32-arm.c (elf32_arm_write_section): Declare early.
+	(elf32_arm_size_stubs): Skip non-stub sections in the stub BFD.
+	(arm_allocate_glue_section_space): Exclude empty sections.
+	(ARM_GLUE_SECTION_FLAGS): Add SEC_LINKER_CREATED.
+	(bfd_elf32_arm_add_glue_sections_to_bfd): Do not skip the stub
+	BFD.
+	(elf32_arm_output_glue_section, elf32_arm_final_link): New.
+	(elf32_arm_merge_eabi_attributes): Skip the stub BFD.
+	(elf32_arm_size_dynamic_sections): Allocate interworking
+	sections here.
+	(bfd_elf32_bfd_final_link): Define.
+
+2009-03-18  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #4753
+
+	gas/
+	* doc/c-arm.texi: Added entries for cpus ARM Cortex-M0 and Cortex-M1.
+
+2009-03-18  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #4250
+
+	gas/
+	* config/tc-arm.c (md_apply_fix): Check BFD_RELOC_ARM_IMMEDIATE and
+	BFD_RELOC_ARM_ADRL_IMMEDIATE value is in the correct section.
+	Check BFD_RELOC_ARM_ADRL_IMMEDIATE has a defined symbol.
+
+	gas/testsuites/
+	* gas/arm/adr-invalid.d: New file.
+	* gas/arm/adr-invalid.l: New file.
+	* gas/arm/adr-invalid.s: New file.
+
+2009-03-17  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #4753
+
+	gas/
+	* config/tc-arm.c (arm_cpus): Added cortex-m0. 
+
+2009-03-17  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_check_relocs): Correct symbian_p test.
+
+2009-03-16  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #4753
+
+	* gas/config/tc-arm.c (arm_cpus): Added cortex-m0. 
+
+2009-03-16  Julian Brown  <julian@codesourcery.com>
+
+	ld/
+	* emultempl/armelf.em (fix_cortex_a8): New.
+	(arm_elf_before_allocation): Call bfd_elf32_arm_set_cortex_a8_fix.
+	(arm_elf_create_output_section_statements): Add fix_cortex_a8 to
+	bfd_elf32_arm_set_target_relocs.
+	(OPTION_FIX_CORTEX_A8): New.
+	(PARSE_AND_LIST_LONGOPTS): Add fix-cortex-a8 options.
+	(PARSE_AND_LIST_OPTIONS): Add fix-cortex-a8 option.
+	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_FIX_CORTEX_A8.
+
+	bfd/
+	* elf32-arm.c (stub_reloc_type): Remove.
+	(THUMB32_INSN, THUMB32_B_INSN): New macros.
+	(insn_sequence): Change type of reloc_type.
+	(elf32_arm_stub_a8_veneer_b_cond, elf32_arm_stub_a8_veneer_b)
+	(elf32_arm_stub_a8_veneer_blx): New stub sequences.
+	(elf32_arm_stub_type): Add arm_stub_a8_veneer_b_cond,
+	arm_stub_a8_veneer_b, arm_stub_a8_veneer_bl and
+	arm_stub_a8_veneer_blx.
+	(_arm_elf_section_data): Add target_addend field.
+	(a8_erratum_fix, a8_erratum_reloc): New structs.
+	(elf32_arm_link_hash_table): Add a8_erratum_fixes,
+	num_a8_erratum_fixes, fix_cortex_a8.
+	(elf32_arm_link_hash_table_create): Zero fix_cortex_a8.
+	(elf32_arm_final_link_relocate): Add forward declaration.
+	(arm_build_one_stub): Add support for THUMB32_TYPE, Thumb-2
+	relocations, multiple relocations per stub.
+	(find_stub_size_and_template): New.
+	(arm_size_one_stub): Use find_stub_size_and_template.
+	(a8_reloc_compare): New.
+	(elf32_arm_size_stubs): Add Cortex-A8 erratum workaround support.
+	(bfd_elf32_arm_set_cortex_a8_fix): New.
+	(bfd_elf32_arm_set_target_relocs): Add fix_cortex_a8 argument.
+	(arm_map_one_stub): Add THUMB32_TYPE support.
+	(a8_branch_to_stub_data): New.
+	(make_branch_to_a8_stub): New.
+	(elf32_arm_write_section): Add Cortex-A8 erratum workaround support.
+	* bfd-in.h (bfd_elf32_arm_set_cortex_a8_fix): New.
+	* bfd-in2.h: Regenerate.
+
+	ld/testsuite/
+	* ld-arm/cortex-a8-fix-b.s: New.
+	* ld-arm/cortex-a8-fix-b.d: New.
+	* ld-arm/cortex-a8-fix-bl.s: New.
+	* ld-arm/cortex-a8-fix-bl.d: New.
+	* ld-arm/cortex-a8-fix-bcc.s: New.
+	* ld-arm/cortex-a8-fix-bcc.d: New.
+	* ld-arm/cortex-a8-fix-blx.s: New.
+	* ld-arm/cortex-a8-fix-blx.d: New.
+
+2009-03-16  Andrew Stubbs  <ams@codesourcery.com>
+
+	* release-notes-csl.xml: Document linker bug fix.
+
+2009-03-16  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* dwarf2.c (read_section): Always use rawsize, if available.
+
+	Backport
+	2009-03-16  Alan Modra  <amodra@bigpond.net.au>
+	* simple.c (bfd_simple_get_relocated_section_contents): Use larger
+	of rawsize and size for buffer.
+
+2009-03-12  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* dwarf2.c (read_section): Always check the offset, even when the
+	section has been read before.
+
+2009-03-11  Joseph Myers  <joseph@codesourcery.com>
+
+	binutils/testsuite/
+	* binutils-all/objdump.W, binutils-all/objdump.s: Don't match
+	literal "tmpdir/" in expected output.
+
+2009-03-09  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #4861
+
+	Backport from FSF:
+
+	2009-03-03  Alan Modra  <amodra@bigpond.net.au>
+	  
+	* objdump.c (disassemble_section): Mask address before sign
+	extending.
+
+2009-03-08  Mark Mitchell  <mark@codesourcery.com>
+
+	ld/testsuite/
+	* ld-elfcomm/elfcomm.exp: Compile with -fcommon.
+
+2009-03-06  Catherine Moore  <clm@codesourcery.com>
+
+	Issue # 4861
+
+	Backport from FSF:
+
+	2009-03-05  Nick Clifton  <nickc@redhat.com>
+
+	* objdump.c (disassemble_section): If the computed next offset is
+	not beyond the current offset then just continue to the end.
+
+2009-03-05  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #4808
+
+	Backport from FSF:
+
+	gas/
+	2009-03-05  Joseph Myers  <joseph@codesourcery.com>
+	* read.c (s_fill, s_space, s_float_space, float_cons, stringer,
+	s_incbin): Call md_cons_align (1).
+
+	gas/testsuite/
+	2009-03-05  Joseph Myers  <joseph@codesourcery.com>
+	* gas/arm/mapmisc.d, gas/arm/mapmisc.dat, gas/arm/mapmisc.s: New.
+
+2009-03-01  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #4781
+
+	* release-notes-csl.xml: Document change.
+	gas/
+	* config/tc-arm.c (md_assemble): Allow barrier instructions on
+	ARMv6-M cores.
+	gas/testsuite/
+	* arm/archv6m.s: Add dmb, dsb, and isb.
+	* arm/archv6m.d: Likewise.
+
+2009-02-24  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #2369
+	Patch applied simultaneously on mainline.
+
+	ld/
+	* ld.texinfo (Options): Correct typos in example.  Recommend
+	using joined forms of syntax for passing options with arguments 
+	from a driver.
+	(-a): Use consistent syntax for documenting option arguments.
+	Clean up indexing and markup.
+	(-A/--architecture): Likewise.
+	(-f/--auxiliary): Likewise.
+	(-F/--filter): Likewise.
+	(-fini): Likewise.
+	(-G/--gpsize): Likewise.
+	(-h/-soname):Likewise.
+	(-init): Likewise.
+	(-l/--library): Likewise.
+	(-L/--library-path): Likewise.
+	(-m): Likewise.
+	(--defsym): Likewise.
+	(-I/--dynamic-linker): Likewise.
+	(-Map): Likewise.
+	(--oformat): Likewise.
+	(--retain-symbols-file): Likewise.
+	(-rpath): Likewise.
+	(-rpath-link): Likewise.
+	(--sort-common): Likewise.
+	(--sort-section): Likewise.
+	(--split-by-file): Likewise.
+	(--split-by-reloc): Likewise.
+	(--sysroot): Likewise.
+	(--section-start): Likewise.
+	(-Tbss, -Tdata, -Ttext): Likewise.
+	(-Ttext-segment): Likewise.
+	(--version-script): Likewise.
+	(--wrap): Likewise.
+
+2009-02-24  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Revert:
+	
+	2009-02-19  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	Issue #4600
+
+	bfd/
+	* elf.c (_bfd_elf_map_sections_to_segments): Fix sanity check.
+
+	2008-03-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+
+	* elf.c (_bfd_elf_map_sections_to_segments): Check user's
+	mapping of section to segments.
+
+2009-02-22  Mark Mitchell  <mark@codesourcery.com>
+
+	* release-notes-csl.xml: Document change.
+	gas/
+	* config/tc-arm.c (warn_deprecated_sp): New macro.
+	(do_t_mov_cmp): Permit R13 as the second
+	argument to "cmp.n".
+	gas/testsuite/
+	* gas/arm/thumb2_bad_reg.s: Update.
+	* gas/arm/thumb2_bad_reg.l: Likewise.
+	
+2009-02-23  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_stub_long_branch_any_any_pic): Rename
+	to elf32_arm_stub_long_branch_any_arm_pic.
+	(elf32_arm_stub_long_branch_any_thumb_pic): New.
+	(enum elf32_arm_stub_type, arm_type_of_stub)
+	(arm_size_one_stub): Handle any to ARM PIC and any to Thumb PIC
+	separately.
+
+	ld/testsuite/
+	* ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
+	ld-arm/farcall-arm-thumb-pic-veneer.d,
+	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d: Update for fixed
+	Thumb PIC stub.
+
+2009-02-23  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (PREV_SEC): Update comment.
+	(group_sections): Rename argument to stubs_always_after_branch.
+	Reverse the list and place stubs at the end of input sections.
+	Undefine NEXT_SEC.
+	(elf32_arm_size_stubs): Update to use stubs_always_after_branch.
+
+	ld/
+	* ld.texinfo (ARM): Document changed meaning of --stub-group-size.
+	* emultempl/armelf.em (hook_in_stub): Insert after the input section.
+	(elf32_arm_add_stub_section): Update comment.
+	(PARSE_AND_LIST_OPTIONS): Update help for --stub-group-size.
+
+2009-02-23  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armeabitests): Update duplicate test names.
+	Use normal output files for big-endian.
+	* ld-arm/farcall-arm-arm-be.d, ld-arm/farcall-thumb-arm-be.d: Delete.
+	* ld-arm/farcall-arm-arm-be8.d, ld-arm/farcall-arm-arm-pic-veneer.d,
+	ld-arm/farcall-arm-arm.d, ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
+	ld-arm/farcall-arm-thumb-blx.d, ld-arm/farcall-arm-thumb-pic-veneer.d,
+	ld-arm/farcall-arm-thumb.d, ld-arm/farcall-group-size2.d,
+	ld-arm/farcall-group.d, ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
+	ld-arm/farcall-thumb-arm-be8.d,
+	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
+	ld-arm/farcall-thumb-arm-blx.d, ld-arm/farcall-thumb-arm-short.d,
+	ld-arm/farcall-thumb-arm.d,
+	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d,
+	ld-arm/farcall-thumb-thumb-blx.d, ld-arm/farcall-thumb-thumb-m.d,
+	ld-arm/farcall-thumb-thumb.d, ld-arm/thumb2-bl-as-thumb1-bad.d,
+	ld-arm/thumb2-bl-bad.d: Update for moved stubs.
+
+2009-02-23  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Backport:
+
+	2009-02-23  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (arm_build_one_stub): Initialize stub_reloc_offset.
+	Fix formatting.
+	(arm_size_one_stub): Remove unnecessary break.
+	(arm_map_one_stub): Fix formatting.  Return after BFD_FAIL.
+
+	2009-02-23  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armeabitests): Run new tests.  Correct BE8 output
+	filename.
+	* ld-arm/farcall-arm-arm-be.d, ld-arm/farcall-thumb-arm-be.d: New.
+
+	2009-02-23  Christophe Lyon  <christophe.lyon@st.com>
+
+	bfd/
+	* elf32-arm.c (stub_insn_type): New type.
+	(stub_reloc_type): Likewise.
+	(insn_sequence): Likewise.
+	(elf32_arm_stub_long_branch_any_any): Encode using insn_sequence.
+	(elf32_arm_stub_long_branch_v4t_arm_thumb): Likewise.
+	(elf32_arm_stub_long_branch_thumb_only): Likewise.
+	(elf32_arm_stub_long_branch_v4t_thumb_arm): Likewise.
+	(elf32_arm_stub_short_branch_v4t_thumb_arm): Likewise.
+	(elf32_arm_stub_long_branch_any_any_pic): Likewise.
+	(elf32_arm_stub_hash_entry): Add new helper fields.
+	(stub_hash_newfunc): Initialize these new fields.
+	(arm_build_one_stub): Encode Arm and Thumb instructions separately
+	to take endianness into account.
+	(arm_size_one_stub): Compute size of stubs using insn_sequence.
+	(arm_map_one_stub): Code is now more generic, thanks to
+	insn_sequence.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp: Add new farcall-thumb-arm-be8 test.
+	* ld-arm/farcall-thumb-arm-be8.d: New expected result.
+	* ld-arm/farcall-arm-arm-be8.d: Replace wildcards by instructions.
+
+	2009-02-23  Christophe Lyon  <christophe.lyon@st.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_stub_long_branch_thumb_only): Fix stub
+	code.
+	(elf32_arm_stub_long_branch_v4t_thumb_arm): Likewise.
+	(arm_type_of_stub): Use Thumb-only long branch stub (non-PIC) when
+	BLX is not available. Fix typo in warning message. Add comments
+	and improve formatting.
+	(arm_build_one_stub): Adjust to new
+	elf32_arm_stub_long_branch_v4t_thumb_arm stub.
+	(arm_map_one_stub): Likewise.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp: Rewrite non-EABI variants of
+	thumb2-bl-as-thumb1-bad and thumb2-bl-bad tests, which now
+	pass. farcall-thumb-thumb now passes in EABI mode.
+	* ld-arm/farcall-thumb-arm-pic-veneer.d: Fixed name, source, as
+	and ld flags to match intended test.
+	* ld-arm/farcall-thumb-arm.d: New expected result.
+	* ld-arm/farcall-thumb-thumb-m.d: Likewise.
+	* ld-arm/farcall-thumb-thumb-m-pic-veneer.d: Fixed name and ld
+	flags.
+	* ld-arm/farcall-thumb-thumb-pic-veneer.d: Likewise.
+	* ld-arm/farcall-thumb-thumb.d: New expected result, this test is
+	now expected to pass.
+	* ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d: Likewise.
+	* ld-arm/thumb2-bl-bad-noeabi.d: Likewise.
+	* ld-arm/thumb2-bl-as-thumb1-bad.d: Update addresses according to
+	new use.
+	* ld-arm/thumb2-bl-as-thumb1-bad.s: Update comment.
+
+	2009-02-18  Christophe Lyon  <christophe.lyon@st.com>
+
+	bfd/
+	* elf32-arm.c (arm_build_one_stub): Fix relocation target for pic
+	stub. Catch default case error.
+	(arm_map_one_stub): Add missing Thumb mapping symbol.
+
+	ld/testsuite/
+	* ld-arm/farcall-arm-arm-pic-veneer.d,
+	ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
+	ld-arm/farcall-arm-thumb-pic-veneer.d,
+	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
+	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d: Fix expected stub
+	target.
+
+	2009-02-16  Christophe Lyon  <christophe.lyon@st.com>
+
+	bfd/
+	* elf32-arm.c (arm_long_branch_stub,
+	arm_thumb_v4t_long_branch_stub,
+	arm_thumb_thumb_long_branch_stub,
+	arm_thumb_arm_v4t_long_branch_stub,
+	arm_thumb_arm_v4t_short_branch_stub,
+	arm_pic_long_branch_stub):
+	Renamed to elf32_arm_stub_long_branch_any_any,
+	elf32_arm_stub_long_branch_v4t_arm_thumb,
+	elf32_arm_stub_long_branch_thumb_only,
+	elf32_arm_stub_long_branch_v4t_thumb_arm,
+	elf32_arm_stub_short_branch_v4t_thumb_arm,
+	elf32_arm_stub_long_branch_any_any_pic.
+	(arm_stub_long_branch, arm_thumb_v4t_stub_long_branch,
+	arm_thumb_thumb_stub_long_branch,
+	arm_thumb_arm_v4t_stub_long_branch,
+	arm_thumb_arm_v4t_stub_short_branch, arm_stub_pic_long_branch):
+	Renamed to arm_stub_long_branch_any_any,
+	arm_stub_long_branch_v4t_arm_thumb,
+	arm_stub_long_branch_thumb_only,
+	arm_stub_long_branch_v4t_thumb_arm,
+	arm_stub_short_branch_v4t_thumb_arm,
+	arm_stub_long_branch_any_any_pic.
+
+2009-02-22  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #4694
+	* release-notes-csl.xml: Document fix.
+	Backport:
+	libiberty/
+	2009-02-21  Mark Mitchell  <mark@codesourcery.com>
+	* make-temp-file.c (<windows.h>): Include on Windows.
+	(choose_tmpdir): On Windows, use GetTempPath.
+
+2009-02-19  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #4600
+
+	bfd/
+	* elf.c (_bfd_elf_map_sections_to_segments): Fix sanity check.
+
+2009-02-18  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #4577
+	gas/
+	* config/tc-arm.c (do_nop): Generate v6k nops whenever possible.
+	(arm_handle_align): Generate v6k ARM, thumb2 wide & narrow nops
+	whenever possible.
+
+	gas/testsuite/
+	* gas/arm/align.s, gas/arm/align.d: New.
+	* gas/arm/thumb32.d, gas/arm/arch6zk.d, gas/arm/arch6zk.s,
+	arm/thumb2_relax.d: Adjust for align changes.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elf.c: Revert local version of issue 3598 patch.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elflink.c: Resync with upstream.
+
+	binutils/
+	* sysdep.h: Resync with upstream.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c: Resync whitespace with upstream.
+	* config/tc-mips.c: Remove duplicate 74kf3_2 entry.
+
+	gas/testsuite/
+	* gas/arm/backslash-at.d: Resync with upstream.
+
+	include/opcode/
+	* mips.h: Remove relics of old Octeon support.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c: Remove relics of old Octeon support.  Adjust
+	error checking in line with
+	<https://intranet.codesourcery.com/ml/gnu-mips-sgxx/2008-08/msg00069.html>.
+
+	gas/testsuite/
+	* gas/mips/octeon1.l, gas/mips/octeon3.d, gas/mips/octeon3.s:
+	Update for assembler changes.
+
+	opcodes/
+	* mips-dis.c: Remove relics of old Octeon support.
+	* mips-opc.c: Restore Octeon sync instructions.
+
+2009-02-04  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Clean up m68k TLS implementation after upstream contribution.
+	
+	ld/testsuite/
+	* ld-m68k/tls-gd-ie-1.d: Update.
+	* ld-m68k/tls-gd-3.d, ld-m68k/tls-gd-3.s: Move to gas testsuite.
+	* ld-m68k/m68k.exp (merge isa-a isa-a:nodiv): Fix test.
+	(tls-*): Run only for m68k-*-linux* targets.
+
+	gas/testsuite/
+	* gas/m68k/tls-gd-3.d, gas/m68k/tls-gd-3.s: New test.
+	* gas/m68k/all.exp: Run it.
+
+	gas/
+	* config/tc-m68k.c: Fix whitespace.
+
+	bfd/
+	* elf32-m68k.c: Fix formatting.
+	(elf_m68k_relocate_section): Remove duplicate code.  Use
+	SYMBOL_REFERENCES_LOCAL.
+	(elf_m68k_finish_dynamic_symbol): Use SYMBOL_REFERENCES_LOCAL.
+
+2009-02-04  Andrew Jenner  <andrew@codesourcery.com>
+
+        gas/
+        * configure.tgt: Handle mips-montavista-elf.
+
+2009-02-03  Kazu Hirata  <kazu@codesourcery.com>
+
+	config/
+	* mh-mingw (BOOT_CFLAGS): Remove -D__USE_MINGW_ACCESS.
+	(CFLAGS): Comment out.
+
+	libiberty/
+	* cygpath.c (msvcrt_dll): Change the return type to HMODULE.
+	(msvcrt_fopen): Use HMODULE for the return value from msvcrt_dll.OB
+
+2009-02-03  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #4540
+
+	bfd/
+	* elfxx-mips.c (_bfd_mips_elf_section_processing): Remove special
+	.sbss handling.
+
+2009-02-02  Kazu Hirata  <kazu@codesourcery.com>
+
+	gprof/
+	* gprof.h: Include gconfig.h.  #undef PACKAGE.
+
+	ld/
+	* gprof.h: Include config.h.
+
+2009-01-30  Catherine Moore  <clm@codesourcery.com>
+
+	bfd/
+	elf32-m68k.c (elf_m68k_relocate_section): Pass relocation
+	type to elf_m68k_init_got_entry_key.
+
+2009-01-29  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c: Resync whitespace with upstream.
+
+	gas/
+	* doc/c-mips.texi: Remove duplicate 74kf3_2 entry.
+
+	ld/
+	* configure.in: Replace AC_ERROR with AC_MSG_ERROR.
+	* emultempl/m68kelf.em: Resync whitespace with upstream.
+
+2009-01-29  Catherine Moore  <clm@codesourcery.com>
+
+	bfd/
+	elfxx-mips.c (mips_elf_calculate_relocation): Add check
+	for (h != NULL).
+
+2009-01-28  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (mips_mach_extensions): Remove duplicate Octeon
+	entry.
+
+	gas/
+	* config/tc-mips.c (CPU_HAS_DROR): Remove Octeon handling.
+	(CPU_HAS_INS): Remove.
+
+	gas/testsuite/
+	* gas/mips/mips.exp: Resync whitespace with upstream.
+
+	include/elf/
+	* mips.h: Resync whitespace with upstream.
+
+	include/opcode/
+	* mips.h (OPCODE_IS_MEMBER): Remove duplicate Octeon check.
+
+	opcodes/
+	* mips-opc.c (mips_builtin_opcodes): Remove duplicate pop
+	instruction.
+
+2009-01-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* config.sub: Remove XLR targets.
+	* configure.ac: Move mips*-sde-elf* case to upstream location.
+	Don't add target-sdemdi.
+	* configure: Regenerate.
+
+	bfd/
+	* elf.c: Remove duplicate if conditional.
+	* elf32-m68k.c: Remove conflict marker.
+	* elfxx-mips.c: Resync whitespace with upstream.  Remove duplicate
+	comment.
+
+	config/
+	* mt-sde: Revert difference from upstream.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp: Remove duplicate runs of some tests.
+
+	opcodes/
+	* ppc-dis.c: Remove duplicate if conditional.
+
+2009-01-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+	* elf32-m68k.c (elf_m68k_finalize_got_offsets): Fix condition.
+
+2009-01-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+	* elf32-m68k.c (struct elf_m68k_finalize_got_offsets_arg): Remove
+	use_neg_got_offsets_p field.
+	(elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets):
+	Update, don't use not initialized data, initialize data before
+	using it.
+
+2009-01-21  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #4300
+
+	gas/
+	* config/tc-arm.c (attributes_set_explicitly): New array.
+	(s_arm_eabi_attribute): Check return value from s_vendor_attribute.
+	(cpu_arch): Add ARM_ARCH_V5T.
+	(aeabi_set_attribute_int): New function.
+	(aeabi_set_attribute_string): New function.
+	(aeabi_set_public_attributes): Set attributes according to the user's
+	intentions, rather than the actual state of the binary.
+	Use aeabi_set_attribute_int and aeabi_set_attribute_string instead of
+	bfd_elf_add_proc_attr_int and bfd_elf_add_proc_attr_string.
+	Support WMMXv2. Use attribute names instead of numbers.
+	* read.c (s_vendor_attribute): Change return type to int.
+	Return the tag number that was set.
+	* read.h (s_vendor_attribute): Change return type to int.
+
+	gas/testsuite/
+	* gas/arm/attr-cpu-directive.d: New file.
+	* gas/arm/attr-cpu-directive.s: New file.
+	* gas/arm/attr-default.d: New file.
+	* gas/arm/attr-march-all.d: New file.
+	* gas/arm/attr-march-armv1.d: New file.
+	* gas/arm/attr-march-armv2.d: New file.
+	* gas/arm/attr-march-armv2a.d: New file.
+	* gas/arm/attr-march-armv2s.d: New file.
+	* gas/arm/attr-march-armv3.d: New file.
+	* gas/arm/attr-march-armv3m.d: New file.
+	* gas/arm/attr-march-armv4.d: New file.
+	* gas/arm/attr-march-armv4t.d: New file.
+	* gas/arm/attr-march-armv4txm.d: New file.
+	* gas/arm/attr-march-armv4xm.d: New file.
+	* gas/arm/attr-march-armv5.d: New file.
+	* gas/arm/attr-march-armv5t.d: New file.
+	* gas/arm/attr-march-armv5te.d: New file.
+	* gas/arm/attr-march-armv5tej.d: New file.
+	* gas/arm/attr-march-armv5texp.d: New file.
+	* gas/arm/attr-march-armv5txm.d: New file.
+	* gas/arm/attr-march-armv6-m.d: New file.
+	* gas/arm/attr-march-armv6.d: New file.
+	* gas/arm/attr-march-armv6j.d: New file.
+	* gas/arm/attr-march-armv6k.d: New file.
+	* gas/arm/attr-march-armv6kt2.d: New file.
+	* gas/arm/attr-march-armv6t2.d: New file.
+	* gas/arm/attr-march-armv6z.d: New file.
+	* gas/arm/attr-march-armv6zk.d: New file.
+	* gas/arm/attr-march-armv6zkt2.d: New file.
+	* gas/arm/attr-march-armv6zt2.d: New file.
+	* gas/arm/attr-march-armv7-a.d: New file.
+	* gas/arm/attr-march-armv7-m.d: New file.
+	* gas/arm/attr-march-armv7-r.d: New file.
+	* gas/arm/attr-march-armv7.d: New file.
+	* gas/arm/attr-march-armv7a.d: New file.
+	* gas/arm/attr-march-armv7m.d: New file.
+	* gas/arm/attr-march-armv7r.d: New file.
+	* gas/arm/attr-march-iwmmxt.d: New file.
+	* gas/arm/attr-march-iwmmxt2.d: New file.
+	* gas/arm/attr-march-marvell-f.d: New file.
+	* gas/arm/attr-march-xscale.d: New file.
+	* gas/arm/attr-mcpu.d: New file.
+	* gas/arm/attr-mfpu-arm1020e.d: New file.
+	* gas/arm/attr-mfpu-arm1020t.d: New file.
+	* gas/arm/attr-mfpu-arm1136jf-s.d: New file.
+	* gas/arm/attr-mfpu-arm1136jfs.d: New file.
+	* gas/arm/attr-mfpu-arm7500fe.d: New file.
+	* gas/arm/attr-mfpu-fpa.d: New file.
+	* gas/arm/attr-mfpu-fpa10.d: New file.
+	* gas/arm/attr-mfpu-fpa11.d: New file.
+	* gas/arm/attr-mfpu-fpe.d: New file.
+	* gas/arm/attr-mfpu-fpe2.d: New file.
+	* gas/arm/attr-mfpu-fpe3.d: New file.
+	* gas/arm/attr-mfpu-maverick.d: New file.
+	* gas/arm/attr-mfpu-neon-fp16.d: New file.
+	* gas/arm/attr-mfpu-neon.d: New file.
+	* gas/arm/attr-mfpu-softfpa.d: New file.
+	* gas/arm/attr-mfpu-softvfp+vfp.d: New file.
+	* gas/arm/attr-mfpu-softvfp.d: New file.
+	* gas/arm/attr-mfpu-vfp.d: New file.
+	* gas/arm/attr-mfpu-vfp10-r0.d: New file.
+	* gas/arm/attr-mfpu-vfp10.d: New file.
+	* gas/arm/attr-mfpu-vfp3.d: New file.
+	* gas/arm/attr-mfpu-vfp9.d: New file.
+	* gas/arm/attr-mfpu-vfpv2.d: New file.
+	* gas/arm/attr-mfpu-vfpv3-d16.d: New file.
+	* gas/arm/attr-mfpu-vfpv3.d: New file.
+	* gas/arm/attr-mfpu-vfpxd.d: New file.
+	* gas/arm/attr-order.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.
+	* gas/arm/attr-override-cpu-directive.d: New file.
+	* gas/arm/attr-override-cpu-directive.s: New file.
+	* gas/arm/attr-override-mcpu.d: New file.
+	* gas/arm/attr-override-mcpu.s: New file.
+	* gas/arm/blank.s: New file.
+	* gas/arm/eabi_attr_1.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.
+
+	ld/testsuite/
+	* ld-arm/attr-merge-3.attr: Update following gas change.
+	* ld-arm/attr-merge-2.attr: Update Tag_ARM_ISA_use and
+	Tag_THUMB_ISA_use following gas changes.
+	* ld-arm/attr-merge-4.attr: Likewise.
+	* ld-arm/attr-merge-5.attr: Likewise.
+	* ld-arm/attr-merge-arch-1.attr: Likewise.
+	* ld-arm/attr-merge-arch-2.attr: Likewise.
+	* ld-arm/attr-merge-unknown-2.d: Likewise.
+	* ld-arm/attr-merge-unknown-2r.d: Likewise.
+	* ld-arm/attr-merge-unknown-3.d: Likewise.
+	* ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-00.d: Likewise.
+	* ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-02.d: Likewise.
+	* ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-04.d: Likewise.
+	* ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-20.d: Likewise.
+	* ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-22.d: Likewise.
+	* ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-40.d: Likewise.
+	* ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
+	* ld-arm/attr-merge-wchar-44.d: Likewise.
+	* ld-arm/attr-merge.attr: Likewise.
+
+2009-01-21  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* elf-attrs.c (is_default_attr): Substitute magic numbers with macros.
+	(obj_attr_size): Likewise.
+	(write_obj_attribute): Likewise.
+	(_bfd_elf_copy_obj_attributes): Likewise.
+	(_bfd_elf_parse_attributes): Likewise.
+	* elf-bfd.h (ATTR_TYPE_FLAG_INT_VAL): New define.
+	(ATTR_TYPE_FLAG_STR_VAL, ATTR_TYPE_FLAG_NO_DEFAULT): New defines.
+	(ATTR_TYPE_HAS_INT_VAL, ATTR_TYPE_HAS_STR_VAL): New defines.
+	(ATTR_TYPE_HAS_NO_DEFAULT): New define.
+	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Replace magic numbers
+	with macros.
+
+2009-01-06  Andrew Stubbs   <ams@codesourcery.com>
+
+	* release-notes-csl.xml: Document ARM attributes improvements.
+
+2009-01-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	2008-12-23  Nick Clifton  <nickc@redhat.com>
+	PR 7093
+	* elf32-arm.c (bfd_elf32_arm_init_maps): Only process ARM ELF
+	object files.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armeabitests): Add EABI attribute merging 3,
+	EABI attribute merging 4, and EABI attribute merging 5,
+	EABI attribute arch merging 1, EABI attribute arch merging 1 reversed,
+	EABI attribute arch merging 2, EABI attribute arch merging 2 reversed.
+	Add attr-merge-unknown-1, attr-merge-unknown-2, attr-merge-unknown-2r,
+	and attr-merge-unknown-3 dump tests.
+	* ld-arm/arch-v6.s: New file.
+	* ld-arm/arch-v6k.s: New file.
+	* ld-arm/arch-v6t2.s: New file.
+	* ld-arm/attr-merge-3.attr: New file.
+	* ld-arm/attr-merge-3a.s: New file.
+	* ld-arm/attr-merge-3b.s: New file.
+	* ld-arm/attr-merge-4.attr: New file.
+	* ld-arm/attr-merge-4a.s: New file.
+	* ld-arm/attr-merge-4b.s: New file.
+	* ld-arm/attr-merge-5.attr: New file.
+	* ld-arm/attr-merge-5.s: New file.
+	* ld-arm/attr-merge-arch-1.attr: New file.
+	* ld-arm/attr-merge-arch-2.attr: New file.
+	* ld-arm/attr-merge-unknown-1.d: New file.
+	* ld-arm/attr-merge-unknown-1.s: New file.
+	* ld-arm/attr-merge-unknown-2.d: New file.
+	* ld-arm/attr-merge-unknown-2.s: New file.
+	* ld-arm/attr-merge-unknown-2r.d: New file.
+	* ld-arm/attr-merge-unknown-3.d: New file.
+	* ld-arm/blank.s: New file.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* elf-attrs.c (vendor_set_obj_attr_contents): Support tag ordering.
+	* elf-bfd.h (elf_backend_data): Add obj_attrs_order.
+	* elf32-arm.c (elf32_arm_obj_attrs_order): New function.
+	(elf_backend_obj_attrs_order): New define.
+	* elfxx-target.h (elf_backend_obj_attrs_order): New define.
+	(elfNN_bed): Add elf_backend_obj_attrs_order.
+
+	gas/testsuite/
+	* gas/arm/attr-order.d: New file.
+	* gas/arm/attr-order.s: New file.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* elf-attrs.c (is_default_attr): Support defaultless attributes.
+	(bfd_elf_add_obj_attr_int): Get type from _bfd_elf_obj_attrs_arg_type.
+	(bfd_elf_add_obj_attr_string): Likewise.
+	(bfd_elf_add_obj_attr_int_string): Likewise.
+	(_bfd_elf_parse_attributes): Allow for unknown flag bits in type.
+	* elf-bfd.h (struct obj_attribute): Document new flag bit.
+	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Specify that
+	Tag_nodefaults has no default value.
+	(elf32_arm_merge_eabi_attributes): Modify the Tag_nodefaults
+	comment to reflect the new state.
+
+	gas/
+	* read.c (s_vendor_attribute): Allow for unknown flag bits in type.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+	    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #1581
+
+	gas/
+	* config/tc-arm.c (arm_copy_symbol_attributes): New function.
+	* config/tc-arm.h (arm_copy_symbol_attributes): New prototype.
+	(CONVERT_SYMBOLIC_ATTRIBUTE): New define.
+	* read.c (s_vendor_attribute): Add support for symbolic tag names.
+	Improve string parser.
+	* doc/c-arm.texi (ARM Machine Directives): Document
+	.eabi_attribute symbolic tag names.
+
+	gas/testsuite/
+	* gas/arm/attr-syntax.d: New file.
+	* gas/arm/attr-syntax.s: New file.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+	    Julian Brown   <julian@codesourcery.com>
+
+	bfd/
+	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 71 to include all known
+	ARM attributes in ABI 2.07.
+	* elf32-arm.c (get_secondary_compatible_arch): New function.
+	(set_secondary_compatible_arch): New function.
+	(tag_cpu_arch_combine): New function.
+	(elf32_arm_copy_one_eabi_other_attribute): Delete function.
+	(elf32_arm_copy_eabi_other_attribute_list): Delete function.
+	(elf32_arm_merge_eabi_attributes): Rename order_312 to order_021 to
+	make it fit with order_01243.
+	Add support for Tag_also_compatible_with,
+	Tag_CPU_unaligned_access, Tag_T2EE_use, Tag_Virtualization_use,
+	Tag_MPextension_use, Tag_nodefaults and Tag_conformance.
+	Improve/tidy up support for Tag_CPU_raw_name, Tag_CPU_name,
+	Tag_CPU_arch, Tag_ABI_HardFP_use, Tag_VFP_HP_extension,
+	Tag_ABI_FP_denormal, Tag_ABI_PCS_GOT_use, Tag_ABI_align8_needed,
+	Tag_VFP_arch and Tag_ABI_FP_16bit_format.
+	Rework the way unknown attributes are handled.
+	Defer errors until all attributes have been processed.
+
+	gas/
+	* config/tc-arm.c (cpu_arch): Change ARM_ARCH_V6M to 11.
+
+	include/elf/
+	* arm.h (TAG_CPU_ARCH_V6_M, TAG_CPU_ARCH_V6S_M): New defines.
+	(MAX_TAG_CPU_ARCH, TAG_CPU_ARCH_V4T_PLUS_V6_M): New defines.
+	(Tag_NEON_arch): Rename to Tag_Advanced_SIMD_arch to match ARM ABI
+	version 2.07.
+	(Tag_undefined39, Tag_nodefaults): New enum values.
+	(Tag_also_compatible_with, Tag_T2EE_use): Likewise.
+	(Tag_conformance, Tag_Virtualization_use): Likewise.
+	(Tag_undefined69, Tag_MPextension_use): Likewise.
+
+2008-12-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	bfd/
+	* elf-attrs.c (bfd_elf_add_obj_attr_compat): Rename to
+	bfd_elf_add_obj_attr_int_string.
+	Read Tag_compatibility from its new location in the attribute array,
+	rather than the attribute list.
+	(_bfd_elf_copy_obj_attributes): bfd_elf_add_obj_attr_compat ->
+	bfd_elf_add_obj_attr_int_string.
+	(_bfd_elf_parse_attributes): Likewise.
+	(_bfd_elf_merge_object_attributes): There's now only one
+	Tag_compatibility, and it's in the array, not the list.
+	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 33 to include
+	Tag_compatibility.
+	(bfd_elf_add_obj_attr_compat): Rename to
+	bfd_elf_add_obj_attr_int_string.
+	(bfd_elf_add_proc_attr_compat): Rename to
+	bfd_elf_add_proc_attr_int_string.
+	elf32-arm.c (elf32_arm_merge_eabi_attributes): Explicitly don't handle
+	Tag_compatibility.
+
+	gas/
+	* read.c (s_vendor_attribute): bfd_elf_add_obj_attr_compat ->
+	bfd_elf_add_obj_attr_int_string.
+
+2008-12-11  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (m68k_cpus): Add 51jm.
+
+2008-12-09  Andrew Stubbs  <ams@codesourcery.com>
+
+	binutils/
+	* readelf.c (arm_attr_tag_CPU_arch): Add "v6-M" and "v6S-M".
+	(arm_attr_tag_WMMX_arch): Add "WMMXv2".
+	(arm_attr_tag_NEON_arch): Rename to ...
+	(arm_attr_tag_Advanced_SIMD_arch): ... official name.
+	(arm_attr_tag_ABI_PCS_config): Rename to ...
+	(arm_attr_tag_PCS_config): ... official name.
+	(arm_attr_tag_ABI_PCS_RO_DATA): Rename to ...
+	(arm_attr_tag_ABI_PCS_RO_data): ... official name.
+	(arm_attr_tag_ABI_FP_denormal): Add "Sign only".
+	(arm_attr_tag_CPU_unaligned_access): New array.
+	(arm_attr_tag_T2EE_use): New array.
+	(arm_attr_tag_Virtualization_use): New array.
+	(arm_attr_tag_MPextension_use): New array.
+	(arm_attr_publ): NEON_arch -> Advanced_SIMD_arch.
+	ABI_PCS_config -> PCS_config.
+	ABI_PCS_RO_DATA -> ABI_PCS_RO_data.
+	Add CPU_unaligned_access, nodefaults, also_compatible_with,
+	T2EE_use, conformance, Virtualization_use and MPextension_use.
+	(display_arm_attribute): Handle Tag_nodefaults and
+	Tag_also_compatible_with.
+
+2008-12-01  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #2968
+	* release-notes-csl.xml: Document attribute fix.
+
+	bfd/
+	* elf-attrs.c (elf_new_obj_attr, bfd_elf_get_obj_attr_int): Correct
+	comments.
+	(_bfd_elf_merge_object_attributes): Support final Tag_compatibility.
+
+2008-11-30  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+	* elf32-m68k.c (elf_m68k_relocate_section): Fix indentation,
+	adjust relocation when appropriate.
+
+2008-11-24  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_final_link_relocate): Do not turn
+	branches to undefine weak symbols into branches to the next
+	instruction if creating PLT entries for those symbols.
+
+	ld/testsuite/
+	* ld-arm/thumb2-bl-undefweak.d, ld-arm/thumb2-bl-undefweak.s: New.
+	* ld-arm/arm-elf.exp: Run thumb2-bl-undefweak test.
+
+2008-11-14  Catheirne Moore  <clm@codesourcery.com>
+
+	opcodes/
+	* mips-opc.c (sync, sync.p, sync.l, synci): Remove duplicates.
+
+2008-11-12  Catherine Moore  <clm@codesourcery.com>
+
+	gas/testsuite/
+	* gas/mips/mips.exp (mips32-sync):  Only run for mips targets.
+
+2008-11-09  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #4135
+
+	Backport from mainline:
+
+	2008-11-06  Chao-ying Fu  <fu@mips.com>
+
+	opcodes/
+	* mips-opc.c (synciobdma, syncs, syncw, syncws): Move these
+	before sync.
+	(sync): New instruction with 5-bit sync type.
+	* mips-dis.c (print_insn_args: Add case '1' to print 5-bit values.
+
+	gas/
+	* config/tc-mips.c (validate_mips_insn): Add case '1'.
+	(mips_ip): Add case '1' to process sync type.
+
+	gas/testsuite/
+	* gas/mips/mips32-sync.d, gas/mip/mips32-sync.s: New tests.
+	* gas/mips/mips.exp: Run them.
+
+	include/opcode/
+	* mips.h: Doucument '1' for 5-bit sync type.
+
+2008-11-07  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #3827
+
+	* bfd/elfxx-mips.c (_bfd_mips_elf_always_size_sections): Move
+	the sizing of the nonpic to pic stubs prior to the check for
+	the presence of a dynamic object.
+
+2008-10-24  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (md_pseudo_table): Use .long instead of .word
+	to handle TLS debug information.
+	(m68k_elf_cons): Remove workaround.
+
+2008-10-24  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (m68k_elf_cons): Force used.
+
+2008-10-23  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (md_pseudo_table): Disable .word override for
+	now.
+
+2008-10-13  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* release-notes-csl.xsl (Bug fix for assembly listing):
+	Conditionalize for windows host.
+	(Bug fix for objdump on Windows): Likewise.
+
+2008-10-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #3536
+
+	Backport from mainline:
+	bfd/
+	2008-10-08  Alan Modra  <amodra@bigpond.net.au>
+	
+	* elf.c (assign_file_positions_for_load_sections): When checking
+	a segment for contents, don't assume that a non-TLS nobits section
+	must only be followed by nobits sections.
+
+2008-10-13  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (mips_cpu_info_table): Add ice9.
+
+2008-10-11  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	M68K NPTL support.
+	gas/
+	* config/tc-m68k.c (m68k_elf_cons): New static function.
+	(md_pseudo_table): Use it.
+	(md_apply_fix): Fix to set thread local flag.
+	(m68k_elf_suffix): New static function; helper for m68k_elf_cons.
+
+	gas/testsuite/
+	* gas/m68k/tls-1.s: Remove.
+
+	bfd/
+	* elf32-m68k.c: Handle 2-slot GOT entries.  Rename variables and
+	fields from n_entries to n_slots where appropriate, update comments.
+	(struct elf_m68k_got_entry.type): Move field to ...
+	(struct elf_m68k_got_entry_key): ... here.  Update all uses.
+	(struct elf_m68k_got): Update comments.
+	(elf_m68k_reloc_got_tls_p): Rename to elf_m68k_reloc_tls_p, handle
+	all relocations.  Update all uses.
+	(elf_m68k_init_got, elf_m68k_init_got_entry_key): Update.
+	(elf_m68k_got_entry_hash, elf_m68k_got_entry_eq): Update,
+	handle key->type.
+	(ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT): Update name, update all uses.
+	(ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): Same.
+	(elf_m68k_get_got_entry, elf_m68k_update_got_entry_type): Update.
+	(elf_m68k_remove_got_entry_type, elf_m68k_add_entry_to_got): Update.
+	(elf_m68k_can_merge_gots_1, elf_m68k_can_merge_gots): Update.
+	(elf_m68k_merge_gots_1, elf_m68k_merge_gots): Update.
+	(struct elf_m68k_finalize_got_offsets_arg: n_ldm_entries): New field.
+	(elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets):
+	Update, handle TLS_LDM entries.
+	(struct elf_m68k_partition_multi_got_arg): Add slots_relas_diff
+	field, remove obsoleted local_n_entries field.
+	(elf_m68k_partition_multi_got_2): New static function.
+	(elf_m68k_partition_multi_got_1, elf_m68k_partition_multi_got): Use it,
+	update.
+	(elf_m68k_remove_got_entry): Update.
+	(elf_m68k_install_rela, dtpoff_base, tpoff): New static functions.
+	(elf_m68k_relocate_section, elf_m68k_finish_dynamic_symbol):
+	Handle TLS relocations.
+
+	ld/testsuite/
+	* ld-m68k/tls-gd-1.d, ld-m68k/tls-gd-2.d, ld-m68k/tls-gd-3.d:
+	New tests.
+	* ld-m68k/tls-gd-ie-1.d, ld-m68k/tls-ie-1.d: New tests.
+	* ld-m68k/tls-ld-1.d, ld-m68k/tls-ld-2.d: New tests.
+	* ld-m68k/tls-ld-1.s, ld-m68k/tls-ld-2.s, ld-m68k/tls-le-1.s:
+	New test sources.
+	* ld-m68k/tls-no-1.s, ld-m68k/tls-gd-ie-1.s, ld-m68k/tls-gd-1.s:
+	New test sources.
+	* ld-m68k/tls-gd-2.s, ld-m68k/tls-gd-3.s, ld-m68k/tls-ie-1.s:
+	New test sources.
+	* ld-m68k/m68k.exp: Run new tests.
+
+2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	binutils/
+	* readelf.c (display_mips_gnu_attribute): Move Power-specific
+	block of code...
+	(display_power_gnu_attribute): ...here.  Oops.
+
+2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #3928
+
+	Backport:
+
+	include/elf/
+	2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* ppc.h: Add Tag_GNU_Power_ABI_Struct_Return.
+
+	bfd/
+	2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Merge
+	Tag_GNU_Power_ABI_Struct_Return.
+
+	binutils/
+	2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* readelf.c (display_power_gnu_attribute): Decode
+	Tag_GNU_Power_ABI_Struct_Return.
+
+	ld/testsuite/
+	2008-10-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* ld-powerpc/gnu-attr-12-1.s: New file.
+	* ld-powerpc/gnu-attr-12-2.s: New file.
+	* ld-powerpc/gnu-attr-12-11.d: New file.
+	* ld-powerpc/gnu-attr-12-21.d: New file.
+	* ld-powerpc/powerpc.exp: Run new dump tests.
+
+
+2008-10-09  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
+	copy_link_hash_symbol_type initializers.
+
+2008-10-09  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	bfd/
+	2008-02-17  Mark Kettenis  <kettenis@gnu.org>
+	* elf.c (swap_out_syms): Avoid preprocessing directive within
+	macro arg.
+
+2008-10-03  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 1365
+	gas/
+	* listing.c (buffer_line): Open the source file with FOPEN_RB.
+	Manually process line ends.
+
+	* release-notes-csl.xml: Add a release note about the
+	assembler bug.
+
+2008-09-26  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Mixed-case NEON register aliases): Add note.
+
+2008-09-25  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	Issue #3634
+	gas/testsuite/
+	* gas/mips/mips.exp: Move the "ice9a" test to the target
+	section.
+
+2008-09-25  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* libbfd-in.h (_bfd_nolink_bfd_copy_link_hash_symbol_type):
+	Define.
+	* libbfd.h: Regenerate.
+
+2008-09-25  Julian Brown  <julian@codesourcery.com>
+
+	Issue #3893
+
+	gas/
+	* config/tc-arm.c (create_neon_reg_alias): Fix case-sensitivity for
+	Neon register aliases.
+
+2008-09-17  Catherine Moore  <clm@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (aeabi_set_public_attributes): Fix setting
+	of attribute 12 for neon fpus.  Set attributes 36 and 38 for
+	neon-fp16 fpus.
+
+	binutils/
+	* readelf.c (arm_attr_tag_ABI_FP_16bit_format): New.
+	(arm_attr_tag_VFP_HP_extension): New.
+	(arm_attr_public_tag arm_attr_public_tags): Support new
+	attributes.
+
+	bfd/
+	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Merge
+	half-precision attributes.
+	(elf32_arm_copy_one_eabi_other_attribute): New.
+	(elf32_arm_copy_other_attribute_list): New.
+
+2008-09-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #3598
+
+	* release-notes-csl.xml: Document.
+
+	bfd/
+	* elf.c (elf_fake_sections): Find the signature symbol for
+	SHT_GROUP sections when doing objcopy/strip.
+
+2008-09-24  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/
+	* emulparams/elf64ppc.sh (OTHER_GOT_RELOC_SECTIONS): Add .rela.opd
+	and .rela.branch_lt.
+
+2008-09-13  Maciej W. Rozycki  <macro@codesourcery.com>
+            Daniel Gutson  <daniel@codesourcery.com>
+
+	Issue #3634
+	gas/
+	* config/tc-mips.c (ICE9A_MOVNDS): New macro.
+	(MAX_NOPS): Rename to...
+	(MAX_HIST_INSNS): ... this.  Adjust references and comments
+	accordingly.
+	(mips_fix_ice9a): New variable.
+	(ice9a_fp_stall_hazard_p): New function.
+	(ice9a_fp_round_hazard_p): New function.
+	(ice9a_movnd_workaround_p): Likewise.
+	(ice9a_insn_accesses_f30_p): Likewise.
+	(check_for_ice9a): Likewise.
+	(mips_cleanup): Likewise.
+	(nops_for_insn): Call check_for_ice9a().
+	(OPTION_FIX_ICE9A): New macro.
+	(OPTION_NO_FIX_ICE9A): Likewise.
+	(OPTION_MISC_BASE): Adjust accordingly.
+	(md_longopts): Add "mfix-ice9a" and "mno-fix-ice9a".
+	(md_parse_option): Handle OPTION_FIX_ICE9A and
+	OPTION_NO_FIX_ICE9A.
+	(md_show_usage): Document "-mfix-ice9a".
+	* config/tc-mips.h (mips_cleanup): New declaration.
+	(md_cleanup): New macro.
+	* doc/c-mips.texi (MIPS Opts): Document "-mfix-ice9a" and
+	"-mno-fix-ice9a".
+	* doc/as.texinfo (Target MIPS options): Likewise.
+
+	gas/testsuite/
+	* gas/mips/ice9a.l: New test for the "-mfix-ice9a" option.
+	* gas/mips/ice9a.s: Source for the new test.
+	* gas/mips/mips.exp: Run the new test.
+
+2008-09-22  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #3806
+	* release-notes-csl.xml: Document.
+
+2008-09-22  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #3806
+	bfd/
+	* elfxx-mips.c (allocate_dynrelocs): Avoid a copy_reloc if
+	dynamic sections have not been created.
+
+2008-09-13  Catherine Moore  <clm@codesourcery.com>
+
+	gas/testsuite/
+	* gas/arm/half-prec-neon.d: New.
+	* gas/arm/half-prec-neon.s: New.
+	* gas/arm/half-prec-vfp3.d: New.
+	* gas/arm/half-prec-vfp3.s: New.
+	* gas/arm/half-prec-psyntax.d: New.
+	* gas/arm/half-prec-psyntax.s: New.
+
+	gas/
+	* config/tc-arm.c (neon_type_mask): Renumber.
+	(type_chk_of_el_type): Handle F_F16.
+	(neon_cvt_flavour): Recognize half-precision conversions.
+	(do_neon_cvt): New shapes NS_QD and NS_DQ.  Encode half-precision
+	conversions.
+	(do_neon_cvtt): Encode the T bit.
+	(asm_opcode_insns): vcvt, vcvtt support.
+	(arm_option_cpu_value): Add neon-fp16 support.
+
+        include/
+	* opcode/arm.h (FPU_NEON_FP16): New.
+	(FPU_ARCH_NEON_FP16): New.
+	* elf/arm.h (Tag_ABI_FP_16bit_format): Define.
+
+	opcodes/
+        * arm-dis.c (coprocessor_opcodes): Add half-precision vcvt
+	instructions.
+	(neon_opcodes): Likewise.
+	(print_insn_coprocessor): Print 't' or 'b' for
+	vcvt instructions.
+
+2008-09-10  Mark Mitchell  <mark@codesourcery.com>
+
+	* release-notes-csl.xml: Mention recent improvements.
+
+2008-09-09  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #2882
+	gas/
+	* config/tc-arm.c (BAD_SP): Define.
+	(s_arm_unwind_fnstart): Use REG_SP.
+	(s_arm_unwind_setfp): Likewise.
+	(reject_bad_reg): New macro.
+	(do_co_reg): Check for bad registers.
+	(do_co_reg2c): Likewise.
+	(do_srs): Use REG_SP.
+	(do_t_add_sub): Check for bad registers.
+	(do_t_adr): Likewise.
+	(do_t_arit3): Likewise.
+	(do_t_arit3c): Likewise.
+	(do_t_bfc): Likewise.
+	(do_t_bfi): Likewise.
+	(do_t_bfx): Likewise.
+	(do_t_blx): Likewise.
+	(do_t_bx): Likewise.
+	(do_t_bxj): Likewise.
+	(do_t_clz): Likewise.
+	(do_t_div): Likewise.
+	(do_t_mla): Likewise.
+	(do_t_mlal): Likewise.
+	(do_t_mov_cmp): Likewise.
+	(do_t_mov16): Likewise.
+	(do_t_mvn_tst): Likewise.
+	(do_t_mrs): Likewise.
+	(do_t_msr): Likewise.
+	(do_t_mul): Likewise.
+	(do_t_mull): Likewise.
+	(do_t_orn): Likewise.
+	(do_t_pkhbt): Likewise.
+	(do_t_pld): Likewise.
+	(do_t_rbit): Likewise.
+	(do_t_rev): Likewise.
+	(do_t_rrx): Likewise.
+	(do_t_rsb): Likewise.
+	(do_t_shift): Likewise.
+	(do_t_simd): Likewise.
+	(do_t_ssat): Likewise.
+	(do_t_ssat16): Likewise.
+	(do_t_sxtah): Likewise.
+	(do_t_sxth): Likewise.
+	(do_t_tb): Likewise.
+	(do_t_usat): Likewise.
+	(do_t_usat16): Likewise.
+	(nysn_insert_sp): Use REG_SP.
+	gas/testsuite/
+	* gas/arm/copro.s: Avoid using r15 where not permitted.
+	* gas/arm/copro.d: Adjust accordingly.
+	* gas/arm/thumb2_bad_reg.s: New.
+	* gas/arm/thumb2_bad_reg.l: Likewise.
+	* gas/arm/thumb2_bad_reg.d: Likewise.
+
+2008-09-10  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gas/testsuite/
+	* gas/m68k/br-isac.d: Fix whitespace.
+
+2008-09-09  Mark Mitchell  <mark@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (do_t_orn): New function.
+	(do_t_rrx): Likewise.
+	(insns): Add orn and rrx.
+	gas/testsuite/
+	* gas/arm/thumb32.s: Add tests for orn and rrx.
+	* gas/arm/thumb32.d: Adjust accordingly.
+	* gas/arm/thumb32.l: Likewise.
+	* gas/arm/thumb2_invert.s: Add tests for orn and orr.
+	* gas/arm/thumb2_invert.d: Adjust accordingly.
+	* gas/arm/tcompat.s: Add tests for rrx.
+	* gas/arm/tcompat.d: Adjust accordingly.
+
+2008-09-09  Mark Mitchell  <mark@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (insns): Add qasx, qsax, shasx, shsax, ssax,
+	uasx, uhasx, uhsx, uqasx, uqsax, usax. 
+	gas/testsuite/
+	* gas/arm/thumb32.s (qadd): Add tests for them.
+	* gas/arm/thumb32.d: Adjust accordingly.
+
+2008-09-09  Mark Mitchell  <mark@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (insns): Correct encoding of qadd, qdadd, qsub,
+	qdsub in Thumb-2 mode.
+	opcodes/
+	* arm-dis.c (thumb32_opcodes): Correct decoding for qadd, qdadd,
+	qsub, and qdsub.
+	gas/testsuite/
+	* gas/arm/thumb32.s (qadd): Add qadd, qdadd, qsub, and qdsub.
+	* gas/arm/thumb32.d: Likewise.
+
+2008-09-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #3318
+	ld/testsuite/
+	* ld-arm/mixed-lib.d, ld-arm/armthumb-lib.d: Loosen regexp.
+
+2008-09-08  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #2348, #3206
+
+	* release-notes-csl.xml: Add release note for DWARF 3 support.
+
+	Backport from mainline:
+
+	bfd/
+	2008-09-08  H.J. Lu  <hongjiu.lu@intel.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	PR ld/3191
+	* dwarf2.c (struct adjusted_section): Renamed from struct
+	loadable_section.
+	(struct dwarf2_debug): Adjust for renaming.  Add version field.
+	(read_attribute_value): Correctly handle DW_FORM_ref_addr for
+	DWARF3.
+	(find_abstract_instance_name): Pass a pointer to
+	attribute instead of offset.  For DW_FORM_ref_addr, get the
+	entry at the offset from the .debug_info section.
+	(scan_unit_for_symbols): Update.
+	(parse_comp_unit): Allow DWARF3.  Save the version.
+	(unset_sections): Update for renaming.
+	(place_sections): Likewise.  Set new VMAs for DWARF sections
+	also.
+
+2008-09-08  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* doc/c-arm.texi (ARM Directives): Document .2byte, .4byte,
+	.8byte, .bss, .even, .extend, .ldouble, .packed, .secrel32
+	directives.
+
+2008-09-06  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/m68k-parse.h (CPUCR): New register name.
+	* config/tc-m68k.c (mcf51qe_ctrl): Rename to ...
+	(mcf51_ctrl): ... here.  Add CPUCR.
+	(mcf52259_ctrl, mcf53017_ctrl): New.
+	(mcf5307_ctrl): Reorder canonically.
+	(m68k_cpus): Add 51, 51ac, 51cn, 51em, 5225x, 5301x.
+	(m68k_ip): Add CPUCR case.
+	(init_table): Add CPUCR.
+
+	opcodes/
+	* m68k-opc.c (m68k_opcodes): Add stldsr insn.
+
+	gas/testsuite/
+	* gas/m68k/br-isac.s: Add stldsr test case
+	* gas/m68k/br-isac.d: Add stldsr test case
+
+2008-09-05  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #1441
+	* release-notes-csl.xml: Copy note for issue #2963.
+
+	Issue #3213
+	gprof/
+	2004-09-07  David Ung  <davidu@mips.com>
+	* hist.c (hist_read_rec):  Load profiling rate into hz_int.
+	(hist_write_hist): Write hz_int into file.
+	(print_header): Adjust header for total_time >= 100000.
+	(print_line): Use wider fields it total_time >= 100000.
+	(hist_print): Skip excluded symbols when finding the highest
+	execution time in order to calculate the scaling factor. 
+	* gprof.h (hz): Now optionally a floating-point variable.
+	(hz_int): New variable, always integral.
+	* gprof.c (hz): Now optionally a floating-point variable.
+	(hz_int): New variable, always integral.
+	* gmon_io.c (gmon_out_read): Load profiling rate initially into
+	hz_int, not hz. Finally convert hz_int into floating-point hz
+	variable, where a negative hz_int is converted to a reciprocal to
+	handle cycles/count instead of counts/sec.
+	(gmon_out_write): Write hz_int to file, not hz.
+	* cg_print.c: (child_max): New variable to store maximum time
+	value. 
+	(self_wid): New var to hold width of self time field in report.
+	(child_wid): New var to hold width of child time field.
+	(prec): New var to hold precision of time fields.
+	(print_header): Adjust headers for wider fields.
+	(print_cycle): Use child_wid, self_wid and prec to format output. 
+	(print_members): Similarly.
+	(print_parents): Similarly.
+	(print_children): Similarly.
+	(print_line): Similarly.
+	(cg_print): Find maximum child time, then determine child/self
+	field widths and precision to cope with times >= 100000.
+
+2008-09-05  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* doc/c-arm.texi (ARM Directives): Alphabetize.
+
+2008-09-05  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #1737
+	gas/
+	* doc/c-arm.texi (): Document -mwarn-deprecated.
+	* config/tc-arm.c (WARN_DEPRECATED): Remove.  Replace with ...
+	(warn_on_deprecated): ... this.
+	(opcode_lookup, md_assemble): Check it before warning.
+	(arm_opts): Add m[no-]warn-deprecated.
+	(md_parse_option): Replace WARN_DEPRECATED with
+	warn_on_deprecated.
+
+2008-09-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Backport from mainline:
+
+	binutils/
+	2008-09-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* readelf.c (load_specific_debug_section): New function, from
+	load_debug_section.
+	(load_debug_section): Use load_specific_debug_section.
+	(display_debug_section): Use load_specific_debug_section.  Check for
+	multiple sections with the same name.
+
+2008-09-04  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #3213
+	gprof/
+	Format changes extracted from David Ung's histogram patch.
+	* cg_print.c (print_header, print_line): Fix formatting.
+	* hist.c (read_histogram_header, hist_read_rec, hist_print,
+	find_histogram_for_pc): Likewise.
+
+2008-09-03  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #3614
+
+	bfd/
+	* elf32-ppc.c (ppc_elf_relocate_section): Continue processing
+	relocations if the output section is NULL; this guards against
+	relocations against global undefined symbols bombing out.
+
+2008-09-02  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #3213
+	gprof/
+	2005-10-12  Nigel Stephens  <nigel@mips.com>
+	* mips.c (mips_find_call): Traverse MIPS16 functions, identifiable
+	by an odd address. Indicate in debug message when we're
+	traversing a mips16 function.
+	(mips_find_call): Use "restore" as end of function marker, not
+	"save".
+	* corefile.c (core_init): Set min_insn_size to 2 for MIPS.
+	(core_create_function_syms): Make the address of MIPS16 symbols
+	odd in the gprof symbol table, since after this point we can't
+	access the original bfd symbol information.
+
+2008-08-29  Julian Brown  <julian@codesourcery.com>
+
+	ld/
+	* ld.texinfo (--fix-janus-2cc): Document new option.
+
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_janus_2cc_erratum_scan): Use correct
+	insn when checking for PC operand.
+
+2008-08-28  Julian Brown  <julian@codesourcery.com>
+
+	ld/
+	* emultempl/armelf.em (fix_janus_2cc): New variable.
+	(arm_elf_before_allocation): Call
+	bfd_elf32_arm_validate_janus_2cc_fix and
+	bfd_elf32_arm_janus_2cc_erratum_scan.
+	(arm_elf_after_allocation): Call bfd_elf32_arm_fix_veneer_locations
+	not bfd_elf32_arm_vfp11_fix_veneer_locations.
+	(arm_elf_create_output_section_statements): Add fix_janus_2cc
+	argument.
+	(PARSE_AND_LIST_PROLOGUE): Add OPTION_FIX_JANUS_2CC.
+	(PARSE_AND_LIST_LONGOPTS): Add fix-janus-2cc option.
+	(PARSE_AND_LIST_OPTIONS): Likewise. (PARSE_AND_LIST_CASES): Add
+	OPTION_FIX_JANUS_2CC case.
+	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Add .janus_2cc_veneer
+	section.
+
+	bfd/
+	* bfd-in.h (bfd_elf32_arm_validate_janus_2cc_fix): Add prototype.
+	(bfd_elf32_arm_janus_2cc_erratum_scan): Add prototype.
+	(bfd_elf32_arm_vfp11_fix_veneer_locations): Rename to...
+	(bfd_elf32_arm_fix_veneer_locations): This.
+	(bfd_elf32_arm_set_target_relocs): Update prototype.
+	* bfd-in2.h: Regenerate.
+	* elf32-arm.c (VFP11_ERRATUM_VENEER_ENTRY_NAME): Adjust format.
+	(JANUS_2CC_ERRATUM_VENEER_SECTION_NAME)
+	(JANUS_2CC_ERRATUM_VENEER_ENTRY_NAME, MAX_ERRATUM_SYMBOL_LENGTH):
+	New macros.
+	(elf32_vfp11_erratum_type): Rename to...
+	(elf32_cpu_erratum_type): This. Add Janus 2CC entries.
+	(elf32_vfp11_erratum_list): Rename to...
+	(elf32_cpu_erratum_list): This. Rename vfp_insn field to orig_insn.
+	(_arm_elf_section_data): Update type of erratumlist field.
+	(elf32_arm_link_hash_table): Add janus_2cc_erratum_glue_size,
+	fix_janus_2cc fields. Rename num_vfp11_fixes to num_errata_fixes.
+	(elf32_arm_link_hash_table_create): Initialise above fields.
+	(JANUS_2CC_ERRATUM_VENEER_SIZE): New macro.
+	(bfd_elf32_arm_allocate_interworking_sections): Initialise Janus
+	2CC erratum veneer section.
+	(record_vfp11_erratum_veneer): Rename to...
+	(record_cpu_erratum_veneer): This. Add argument for type of erratum
+	to record. Expand to handle Janus 2CC erratum.
+	(bfd_elf32_arm_add_glue_sections_to_bfd): Make Janus 2CC erratum
+	veneer section.
+	(bfd_elf32_arm_validate_janus_2cc_fix): New.
+	(bfd_elf32_arm_vfp11_erratum_scan): Update for new type and field
+	names. Call record_cpu_erratum_veneer instead of
+	record_vfp11_erratum_veneer.
+	(bfd_elf32_arm_vfp11_fix_veneer_locations): Rename to...
+	(bfd_elf32_arm_fix_veneer_locations): This. Add Janus 2CC erratum
+	support.
+	(bfd_elf32_arm_janus_2cc_erratum_scan): New.
+	(bfd_elf32_arm_set_target_relocs): Add fix_janus_2cc option. Handle.
+	(elf32_arm_size_dynamic_sections): Call
+	bfd_elf32_arm_janus_2cc_erratum_scan.
+	(elf32_arm_write_section): Add Janus 2CC erratum support.
+
+2008-08-21  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (mcf52277_ctrl): New.
+	(m68k_cpus): Add 52274, 52277.
+
+2008-08-17  Catherine Moore  <clm@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (_bfd_mips_elf_final_link): Write out the
+	non-pic to pic stubs. 
+
+2008-08-08  Catherine Moore  <clm@codesourcery.com>
+
+	opcodes/
+	* mips-opc.c (jalx): Allow for ISA1 and above.
+
+	gas/
+	* testsuite/gas/mips/mips-no-jalx.l: Remove.
+	* testsuite/gas/mips/mips-no-jalx.s: Remove.
+	* testsuite/gas/mips/mips.exp: Remove invocation of mips-no-jalx.
+
+
+2008-08-03  Catherine Moore  <clm@codesourcery.com>
+
+	* release-notes-csl.xml:  Add missing "/" to <formalpara>.
+	Change csl-target to csl_target.  Change mips*- to mips*-*.
+
+2008-07-31  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+	binutils/
+	2008-04-28  M Thomas  <mthomas@rhrk.uni-kl.de>
+		    Nick Clifton  <nickc@redhat.com>
+
+	PR binutils/6449
+	* objdump.c (slurp_file): Open the file in binary mode.
+	* ar.c: Remove conditional definition of O_BINARY.
+	* bin2.c: Likewise.
+	* rename.c: Likewise.
+	* strings.c: Likewise.
+	* sysdep.h: Add conditional definition of O_BINARY.
+
+2008-07-29  Paul Brook  <paul@codesourcery.com>
+	    Mark Mitchell  <mark@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (do_t_mul): In Thumb-2 mode, use 16-bit encoding
+	of MUL when possible.
+	gas/testsuite/
+	* gas/arm/thumb2_mul.s: New file.
+	* gas/arm/thumb2_mul.d: Likewise.
+	* gas/arm/thumb2_mul-bad.s: Likewise.
+	* gas/arm/thumb2_mul-bad.d: Likewise.
+	* gas/arm/thumb2_mul-bad.l: Likewise.
+	* gas/arm/t16-bad.s: Add tests for"mul" with high registers.
+	* gas/arm/t16-bad.l: Update accordingly.
+
+	* release-notes-csl.xml: Document.
+
+2008-07-28  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #3380
+	* release-notes-csl.xml: Document.
+	
+	Issue #3166
+	* release-notes-csl.xml: Document.
+
+2008-07-28  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #3380
+	bfd/
+	* elfxx-mips.c (mips_elf_calculate_relocation): Avoid generating
+	relocations for undefined weak symbols with non-default visibility.
+	(_bfd_mips_elf_check_relocs): Use possibly_dynamic_relocs for
+	global symbols in shared libraries.
+	(allocate_dynrelocs): New function.
+	(_bfd_mips_elf_adjust_dynamic_symbol): Do not handle
+	possibly_dynamic_relocs here.
+	(_bfd_mips_elf_size_dynamic_sections): Call allocate_dynrelocs.
+
+2008-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	ld/testsuite/
+	* ld-m68k/got-multigot-12-13-14-34-35-ok.d: Update.
+	* ld-m68k/got-multigot-14-ok.d: Update.
+	* ld-m68k/m68k.exp: Update.
+	* ld-m68k/got-negative-12-13-14-34-ok.d: Update.
+	* ld-m68k/got-negative-14-ok.d: Update.
+
+	gas/testsuite/
+	* gas/m68k/tls-1.s: New.
+
+	gas/
+	* config/m68k-parse.h (enum pic_relocation): Add values for TLS
+	relocations.
+	* config/m68k-parse.y (yylex): Parse TLS relocations.
+	* config/tc-m68k.c (get_reloc_code, tc_m68k_fix_adjustable)
+	(tc_gen_reloc): Handle TLS relocations.
+
+	include/elf/
+	* m68k.h: Map TLS relocations to numbers.
+
+	bfd/
+	* bfd-in2.h: Regenerate.
+	* elf32-m68k.c (HOWTO): Add TLS relocations.
+	(reloc_map): Map BFD_RELOC_68K_TLS_* to R_68K_TLS_*.
+	(enum elf_m68k_got_offset_size): New enum.
+	(struct elf_m68k_got_entry: type) Move from nested union up.
+	(elf_m68k_reloc_got_type, elf_m68k_reloc_got_offset_size)
+	(elf_m68k_reloc_got_n_entries, elf_m68k_reloc_got_tls_p): New static
+	functions.
+	(struct elf_m68k_got): merge rel_8o_n_entries and rel_8o_16o_n_entries
+	fields into n_entries array.
+	(elf_m68k_init_got): Simplify, update all uses.
+	(elf_m68k_init_got_entry_key): Handle R_68K_TLS_LDM32 reloc.
+	(ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT)
+	(ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): Adjust to handle 2-slot
+	GOT entries.
+	(elf_m68k_get_got_entry): Update.
+	(elf_m68k_update_got_entry_type): Rewrite to handle TLS GOT entries,
+	simplify.
+	(elf_m68k_remove_got_entry_type): Simplify.
+	(elf_m68k_add_entry_to_got, elf_m68k_can_merge_gots_1)
+	(elf_m68k_can_merge_gots): Update.
+	(struct elf_m68k_finalize_got_offsets_arg)
+	(elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets):
+	Rewrite to handle 2-slot GOT entries, simplify.
+	(elf_m68k_partition_multi_got_1, elf_m68k_partition_multi_got): Update.
+	(elf_m68k_remove_got_entry_type): Update.
+	(elf_m68k_check_relocs): Handle TLS relocations.  Remove unnecessary 
+	update of sgot->size and srelgot->size.
+	(elf_m68k_gc_sweep_hook): Update.
+	(elf_m68k_relocate_section): Add dummy handling of TLS relocations.
+	* reloc.c (BFD_RELOC_68K_TLS_*): Declare TLS relocations.
+	* libbfd.h (bfd_reloc_code_real_names): Add BFD_RELOC_68K_TLS_*.
+
+2008-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+	* elf32-m68k.c: Apply cosmetic differences from FSF mainline.
+
+2008-07-26  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Backport:
+
+	ld/testsuite/
+	2008-07-11  H.J. Lu  <hongjiu.lu@intel.com>
+	
+	* ld-m68k/got-12.s: Removed.
+	* ld-m68k/got-13.s: Likewise.
+	* ld-m68k/got-14.s: Likewise.
+	* ld-m68k/got-15.s: Likewise.
+	* ld-m68k/got-34.s: Likewise.
+	* ld-m68k/got-35.s: Likewise.
+	* ld-m68k/xgot-15.s: Likewise.
+
+	* ld-m68k/got-multigot-12-13-14-34-35-ok.d: Remove #source
+	and expected relocations.
+	* ld-m68k/got-multigot-14-ok.d: Likewise.
+	* ld-m68k/got-negative-12-13-14-34-ok.d: Likewise.
+	* ld-m68k/got-negative-14-ok.d: Likewise.
+	* ld-m68k/got-single-12-ok.d: Likewise.
+	* ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: Likewise.
+	* ld-m68k/got-xgot-15-ok.d: Likewise.
+
+	* ld-m68k/got-multigot-15-er.d: Remove #source.
+	* ld-m68k/got-negative-12-13-14-35-er.d: Likewise.
+	* ld-m68k/got-negative-15-er.d: Likewise.
+	* ld-m68k/got-single-13-er.d: Likewise.
+
+	* ld-m68k/m68k.exp: Move GOT tests to ...
+	* ld-m68k/m68k-got.exp: This.  New.
+
+2008-07-26  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Backport:
+
+	bfd/
+	2008-06-29  Andreas Schwab  <schwab@suse.de>
+	* elf32-m68k.c (elf_m68k_relocate_section): Don't ignore existing
+	addend on _GLOBAL_OFFSET_TABLE_.
+
+	ld/testsuite/
+	2008-06-29  Andreas Schwab  <schwab@suse.de>
+	* ld-m68k/got-1.s: New file.
+	* ld-m68k/got-1.d: New dump test.
+	* ld-m68k/m68k.exp: Run it.
+
+2008-07-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* config.sub: Allow mips64octeon* targets.
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CAVIUM
+	bfd/
+	* config.bfd: Handle mips64octeon*-*-elf*.
+
+	gas/
+	* configure.tgt: Handle mips-wrs-elf*.
+
+	ld/
+	* configure.tgt: Handle mips64octeon*-*-elf*.
+	* Makefile.am (ALL_EMULATIONS): Add Octeon emulations.
+	(eelf32ebocteon.c, eelf32elocteon.c, eelf32ebocteonn32.c,
+	eelf32elocteonn32.c, eelf64ebocteon.c, eelf64elocteon.c): New.
+	* Makefile.in: Regenerate.
+	* scripttempl/elf.sc: Add ${OCTEON_SPECIAL_SECTIONS}.
+	* emulparams/elf32ebocteon.sh, emulparams/elf32ebocteonn32.sh,
+	emulparams/elf32elocteon.sh, emulparams/elf32elocteonn32.sh,
+	emulparams/elf64ebocteon.sh, emulparams/elf64elocteon.sh,
+	emultempl/octeonelf.em: New.
+
+2008-07-18  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	bfd/
+	2008-07-18  Joseph Myers  <joseph@codesourcery.com>
+	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add new parameter.
+	* bfd-in2.h: Regenerate.
+	* elf32-arm.c (struct elf_arm_obj_tdata): Add field
+	no_wchar_size_warning.
+	(bfd_elf32_arm_set_target_relocs): Add new parameter
+	no_wchar_warn.
+	(elf32_arm_merge_eabi_attributes): Give a warning, not an error,
+	for conflicting wchar_t attributes.  Do not warn if
+	--no-wchar-size-warning.  Make diagnostic text more specific.
+
+	ld/
+	2008-07-18  Joseph Myers  <joseph@codesourcery.com>
+	* ld.texinfo (--no-wchar-size-warning): Document new ARM option.
+	* emultempl/armelf.em (no_wchar_size_warning): New.
+	(arm_elf_create_output_section_statements): Pass
+	no_wchar_size_warning to arm_elf_create_output_section_statements.
+	(OPTION_NO_WCHAR_SIZE_WARNING): New.
+	(PARSE_AND_LIST_LONGOPTS): Add no-wchar-size-warning.
+	(PARSE_AND_LIST_OPTIONS): List --no-wchar-size-warning.
+	(PARSE_AND_LIST_ARGS_CASES): Handle --no-wchar-size-warning.
+
+	ld/testsuite/
+	2008-07-18  Joseph Myers  <joseph@codesourcery.com>
+	* ld-arm/attr-merge-wchar-0.s,ld-arm/attr-merge-wchar-2.s,
+	ld-arm/attr-merge-wchar-4.s, ld-arm/attr-merge-wchar-00-nowarn.d,
+	ld-arm/attr-merge-wchar-00.d, ld-arm/attr-merge-wchar-02-nowarn.d,
+	ld-arm/attr-merge-wchar-02.d, ld-arm/attr-merge-wchar-04-nowarn.d,
+	ld-arm/attr-merge-wchar-04.d, ld-arm/attr-merge-wchar-20-nowarn.d,
+	ld-arm/attr-merge-wchar-20.d, ld-arm/attr-merge-wchar-22-nowarn.d,
+	ld-arm/attr-merge-wchar-22.d, ld-arm/attr-merge-wchar-24-nowarn.d,
+	ld-arm/attr-merge-wchar-24.d, ld-arm/attr-merge-wchar-40-nowarn.d,
+	ld-arm/attr-merge-wchar-40.d, ld-arm/attr-merge-wchar-42-nowarn.d,
+	ld-arm/attr-merge-wchar-42.d, ld-arm/attr-merge-wchar-44-nowarn.d,
+	ld-arm/attr-merge-wchar-44.d: New.
+	* ld-arm/arm-elf.exp: Run new tests.
+
+2008-07-10  Joseph Myers  <joseph@codesourcery.com>
+
+	config/
+	* mh-mingw (LDFLAGS): Append to rather than replacing previous
+	value.
+
+2008-07-08  Stan Shebs  <stan@codesourcery.com>
+
+	BE8 disassembly.
+	include/
+        * dis-asm.h (struct disassemble_info): Add endian_code field.
+	opcodes/
+        * dis-init.c (init_disassemble_info): Init endian_code field.
+	* arm-dis.c (print_insn): Disassemble code according to
+        setting of endian_code.
+	(print_insn_big_arm): Detect when BE8 extension flag has been set.
+	ld/testsuite/
+        * ld-arm/arm-elf.exp: Use objdump -d for arm-be8 test.
+	* ld-arm/arm-be8.d: Change to test disassembly.
+
+2008-07-02  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/
+	* ld.h (args_type): Add error_poison_system_directories.
+	* ld.texinfo (--error-poison-system-directories): Document.
+	* ldfile.c (ldfile_add_library_path): Check
+	command_line.error_poison_system_directories.
+	* ldmain.c (main): Initialize
+	command_line.error_poison_system_directories.
+	* lexsup.c (enum option_values): Add
+	OPTION_ERROR_POISON_SYSTEM_DIRECTORIES.
+	(ld_options): Add --error-poison-system-directories.
+	(parse_args): Handle new option.	
+
+2008-06-30  Joseph Myers  <joseph@codesourcery.com>
+
+	config/
+	* mh-mingw (BOOT_CFLAGS): Do not use -D__USE_MINGW_ACCESS.
+
+2008-06-14  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #3166
+	bfd/
+	* elfxx-mips.c (bfd_mips_elf_maybe_create_non_pic_to_pic_stubs_section):
+	Set SEC_LINKER_CREATED for the stub section.
+
+2008-06-09  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	bfd/
+	* elf32-arm.c (elf32_arm_merge_private_bfd_data): Allow BE8 shared
+	libraries.
+
+2008-06-06  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	bfd/
+	* elf32-arm.c (elf32_arm_merge_private_bfd_data): Reject BE8 input.
+
+2008-06-03  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (do_t_rbit): Populate both rm fields.
+	gas/testsuite/
+	* gas/arm/thumb32.d: Update expected output.
+
+2008-06-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	ld/testsuite/
+	* ld-scripts/rgn-over8.s: Use .section .bss instead of .bss.
+
+2008-05-23  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (arm_fix_adjustable): Don't adjust MOVW/MOVT
+	relocations.
+
+	gas/testsuite/
+	* gas/arm/movw-local.d: New test.
+	* gas/arm/movw-local.s: New test.
+
+2008-05-23  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (parse_cond): Covert to lowercase before matching.
+
+2008-05-20  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	
+	2008-03-31  Edmar Wienskoski  <edmar@freescale.com>
+	bfd/
+        * archures.c: Add bfd_mach_ppc_e500mc.
+        * bfd-in2.h: Regenerate.
+
+	gas/
+        * config/tc-ppc.c (parse_cpu): Handle "e500mc". Extend "e500" to
+        accept e500mc instructions.
+        (md_show_usage): Document -me500mc.
+
+	gas/testsuite/
+        * gas/ppc/e500mc.s, gas/ppc/e500mc.d: New test.
+        * gas/ppc/ppc.exp: Run the new test
+
+	include/opcode/
+        * ppc.h: (PPC_OPCODE_E500MC): New.
+
+	opcodes/
+        * ppc-dis.c (powerpc_dialect): Handle "e500mc". Extend "e500" to
+        accept Power E500MC instructions.
+        (print_ppc_disassembler_options): Document -Me500mc.
+        * ppc-opc.c: (DUIS, DUI, T): New.
+        (XRT, XRTRA): Likewise.
+        (E500MC): Likewise.
+        (powerpc_opcodes): Add new Power E500MC instructions.
+
+2008-05-15  Nathan Sidwell  <nathan@codesourcery.com>
+
+	ld/testsuite/
+	Backport 2008-05-02  H.J. Lu  <hongjiu.lu@intel.com>
+	PR ld/6475
+	* ld-scripts/rgn-over8-ok.d: Accept any alignment.
+
+2008-05-09  Catherine Moore  <clm@codesourcery.com>
+
+	From binutils-mips:
+	Issue #2963
+	gas/
+	* config/tc-mips.c (mips_frob_file): Don't match MIPS16 relocs
+	with non-MIPS16 relocs.
+
+	gas/testsuite/
+	* gas/mips/mips16-hilo-match.s: New test.
+	* gas/mips/mip16-hilo-match.d: New test output.
+	* gas/mips/mips.exp: Run mips16-hilo-match.
+
+2008-05-05  Catherine Moore  <clm@codesourcery.com>
+
+	From binutils-mips:
+	2008-04-04  Catherine Moore  <clm@codesourcery.com>
+	gas/testsuite/
+	* gas/mips/mips.exp (ulw2-eb-ilocks, elw2-el-ilocks, uld2-el,
+	uld2-eb, mips64): Disable for octeon.
+
+2008-04-29  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #2950
+	* release-notes-csl.xml: Document Symbian relocation fix.
+
+	Backport from FSF:
+	2008-04-29  Daniel Jacobowitz  <dan@codesourcery.com>
+	bfd/
+	* elf.c (_bfd_elf_get_dynamic_reloc_upper_bound)
+	(_bfd_elf_canonicalize_dynamic_reloc): Find dynamic relocations
+	even if they are not loaded.
+	* elflink.c (_bfd_elf_init_2_index_sections): Set data_index_section
+	first.
+
+	2008-04-29  Daniel Jacobowitz  <dan@codesourcery.com>
+	ld/testsuite/
+	* ld-arm/symbian-seg1.s, ld-arm/symbian-seg1.d: New files.
+	* ld-arm/arm-elf.exp: Run symbian-seg1.
+
+2008-04-28  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #2928
+	* release-notes-csl.xml: Document.
+
+	ld/
+	* ldlang.c (lang_size_sections_1): Don't check LMA overflow on
+	non-load sections.
+
+	ld/testsuite/
+	* ld-scripts/rgn-over.exp: Allow -ok file names to pass.
+	* ld-scripts/rgn-over8.s: New.
+	* ld-scripts/rgn-over8.t: New.
+	* ld-scripts/rgn-over8-ok.d: New.
+
+2008-04-24  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Don't reject R_MIPS_HI16
+	relocations when they are a part of compound relocation.
+
+2008-04-07  Andrew Jenner  <andrew@codesourcery.com>
+
+	ld/
+	* emultempl/armelf.em: Correct formatting of help text for
+	--no-enum-size-warning option.
+
+2008-03-28  Catherine Moore <clm@codesourcery.com>
+
+	Backport:
+	2008-03-26  Daniel Jacobowitz  <dan@codesourcery.com>
+	ld/testsuite/
+	* ld-elf/flags1.d: Adjust for MIPS text alignment.
+
+2008-03-28  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (_bfd_mips_elf_create_nonpic_dynamic_sections): New.
+	(_bfd_mips_elf_create_dynamic_sections): Use it.
+	(_bfd_mips_elf_check_relocs): Likewise.  Reject shared libraries with
+	non-PIC relocations.
+	(_bfd_mips_elf_merge_private_bfd_data): Skip dynamic objects.
+
+2008-03-28  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (parse_neon_mov): Parse register before immediate
+	to avoid spurious symbols.
+
+2008-03-27  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/testsuite/
+	* ld-elfcomm/elfcomm.exp: Run $READELF not readelf.
+
+2008-03-27  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (md_begin): Disable -G for abicalls even without
+	PIC.
+
+2008-03-27  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #2742
+	gas/
+	* config/tc-m68k.c (md_convert_frag_1): Replace as_fatal with
+	as_bad_where.
+
+2008-03-26  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #2682
+	bfd/
+	* elfxx-mips.c (mips_elf_record_got_page_entry): Update comment.
+	(_bfd_mips_elf_check_relocs): Update comments.  Always call
+	mips_elf_record_got_page_entry for R_MIPS_GOT_PAGE.
+
+2008-03-26  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #2691
+	config/
+	* mt-sde (CFLAGS_FOR_TARGET, CXXFLAGS_FOR_TARGET): Replace
+	-minterlink-mips16 with -fno-optimize-sibling-calls.
+
+	convert/
+	* Makefile.am (convert.o): Add convert.c.
+	* Makefile.in: Rebuilt.
+
+2008-03-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+
+	* elf.c (_bfd_elf_map_sections_to_segments): Check user's
+	mapping of section to segments.
+
+2008-03-24  Kazu Hirata  <kazu@codesourcery.com>
+
+	libiberty/
+	* cygpath.c (cygpath): Special-case the empty path.
+
+2008-03-20  Nathan Sidwell  <nathan@codesourcery.com>
+
+	convert/
+	* Makefile.am (convert.o): Fix dependency typo.
+	* Makefile.in: Rebuilt.
+
+2008-03-18  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	libiberty/
+	* cygpath.c (chdir): New function.
+
+2008-03-14  Mark Shinwell  <shinwell@codesourcery.com>
+            Daniel Jacobowitz  <dan@codesourcery.com>
+            Catherine Moore  <clm@codesourcery.com>
+
+	bfd/
+	* bfd-in.h (bfd_mips_elf_set_non_pic): New prototype.
+	(bfd_mips_elf_check_non_pic): New prototype.
+	* bfd-in2.h: Regenerate.
+	* elf32-mips.c (elf_mips_copy_howto): New.
+	(elf_mips_jump_slot_howto): New.
+	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
+	and BFD_RELOC_MIPS_JUMP_SLOT.
+	(bfd_elf32_bfd_reloc_name_lookup): Handle new copy and jump slot
+	relocations.
+	(mips_elf32_rtype_to_howto): Likewise.
+	(elf_backend_want_plt_sym): Define.  Remove definition in VxWorks
+	clause.
+	(elf_backend_plt_readonly): Likewise.
+	(elf_backend_write_section): Define.
+	(elf_backend_plt_sym_val): Define, except for VxWorks.
+	(mips_vxworks_copy_howto_rela): Delete.
+	(mips_vxworks_jump_slot_howto_rela): Delete.
+	(mips_vxworks_bfd_reloc_type_lookup): Delete.
+	(mips_vxworks_bfd_reloc_name_lookup): Delete.
+	(mips_vxworks_rtype_to_howto): Delete.
+	(elf_backend_got_symbol_offset): Remove legacy definition.
+	(elf_backend_want_dynbss): Remove unnecessary definition.
+	(bfd_elf32_bfd_reloc_type_lookup): Delete macro definition for
+	VxWorks.
+	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
+	(elf_backend_mips_rtype_to_howto): Likewise.
+	(elf_backend_adjust_dynamic_symbol): Define to new function.
+	* elfxx-mips.c (mips_elf_link_hash_entry): Add plt_entry_offset and
+	has_non_pic_to_pic_stub members.  Delete is_relocation_target
+	member.
+	(mips_elf_link_hash_table): Add is_non_pic, non_pic_bfd,
+	snonpictopic and large_plt_entry_size members.  Update comments.
+	(NON_PIC_P): New.
+	(NON_PIC_TO_PIC_STUB_SECTION_NAME): New.
+	(MIPS_NONPIC_LARGE_PLT_THRESHOLD): New.
+	(mips_non_pic_exec_plt0_entry): New.
+	(mips_non_pic_exec_plt_entry): New.
+	(mips_non_pic_large_exec_plt_entry): New.
+	(mips_non_pic_to_pic_stub): New.
+	(mips_elf_link_hash_newfunc): Initialize new members.
+	(mips_elf_create_got_section): Don't create .got.plt for VxWorks.
+	(mips_elf_calculate_relocation): Handle cases for filling in
+	references to non-PIC to PIC call stubs and non-PIC PLT entries.
+	(_bfd_mips_elf_create_dynamic_sections): Create .plt, .rel.plt,
+	.dynbss and .rel.bss sections for non-PIC.  Create .got.plt for
+	non-PIC and VxWorks.
+	(_bfd_mips_elf_check_relocs): Update comments.  Check if we have
+	the first non-PIC file encountered during an executable link.
+	Don't add dynamic relocations for non-PIC.  Remove
+	is_relocation_target assignment.  Set non_got_ref as appropriate.
+	(mips_elf_next_plt_entry_size): New.
+	(mips_elf_create_old_style_stub): New.
+	(_bfd_mips_elf_adjust_dynamic_symbol): Call worker function to
+	handle VxWorks and non-PIC cases.  Move code for creating old-style
+	.MIPS.stubs entries to mips_elf_create_old_style_stub.
+	(_bfd_mips_vxworks_adjust_dynamic_symbol): Rename to...
+	(_bfd_mips_plt_adjust_dynamic_symbol): ...this.  New.  Extend code
+	to handle the non-PIC ABI.
+	(mips_elf_maybe_create_non_pic_to_pic_stub): New.
+	(_bfd_mips_elf_always_size_sections): Identify symbols requiring
+	non-PIC to PIC call stubs.  Allocate space for any such stubs.
+	(_bfd_mips_elf_size_dynamic_sections): Allocate space for delay slot
+	in a PLT section.  Update comments.  Add dynamic tags for non-PIC
+	if required.
+	(_bfd_mips_elf_finish_dynamic_symbol): Fill in .plt, .got.plt and
+	.rel.plt entries for symbols with PLT entries under non-PIC.
+	Tighten bound on h->plt.offset for old-style stubs.  Emit copy
+	relocations if required.
+	(mips_non_pic_finish_plt): New.
+	(_bfd_mips_elf_finish_dynamic_sections): Handle DT_MIPS_PLTGOT
+	and DT_MIPS_RWPLT dynamic tags.  Rework code handling DT_PLTGOT
+	dynamic tag.  Adjust assertions for DT_PLTREL, DT_PLTRELSZ and
+	DT_JMPREL.  Call mips_non_pic_finish_plt.
+	(_bfd_mips_elf_copy_indirect_symbol): Copy new members.
+	(_bfd_mips_elf_link_hash_table_create): Initialize new members.
+	(_bfd_mips_elf_merge_private_bfd_data): Remove extraneous
+	braces.
+	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
+	DT_MIPS_RWPLT cases.
+	(_bfd_mips_elf_plt_sym_val): New.
+	(mips_elf_nonpic_stub): New.
+	(_bfd_mips_elf_begin_write_processing): New.
+	(bfd_mips_elf_maybe_create_non_pic_to_pic_stubs_section): New.
+	(_bfd_mips_post_process_headers): Set correct ABI version for
+	non-PIC.
+	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Rename to...
+	(_bfd_mips_plt_adjust_dynamic_symbol): ...this.  New prototype.
+	(_bfd_mips_nonpic_finish_dynamic_symbol): New.
+	(_bfd_mips_elf_plt_sym_val): New prototype.
+	(_bfd_mips_elf_begin_write_processing): New prototype.
+	(bfd_mips_elf_maybe_create_non_pic_to_pic_stubs_section): New
+	prototype.
+	(_bfd_mips_post_process_headers): New prototype.
+	(elf_backend_post_process_headers): Define.
+	(elf_backend_begin_write_processing): Define.
+	* elflink.c (_bfd_elf_merge_symbol): Correct typo.
+	* reloc.c (MIPS ELF relocation): Add reference to non-PIC.
+
+	binutils/
+	* readelf.c (get_mips_dynamic_type): Handle DT_MIPS_PLTGOT
+	and DT_MIPS_RWPLT.
+	(get_mips_symbol_other): Handle STO_MIPS_PLT.
+
+	gas/
+	* config/tc-mips.c (mips_nonpic_option): New.
+	(md_longopts): Add mnon-pic-abicalls entry.
+	(md_parse_option): Add OPTION_NON_PIC_ABICALLS case.
+	(mips_elf_final_processing): Check mips_nonpic_option.
+
+	include/
+	* elf/mips.h (DT_MIPS_PLTGOT): New.
+	(DT_MIPS_RWPLT): New.
+	(STO_MIPS_PLT): New.
+
+	ld/
+	* emulparams/elf32btsmip.sh: Update comment.
+	(GOT): Define.
+	(GOTPLT): Define.
+	(DATA_GOTPLT): Define.
+	* emulparams/elf32ebmipvxworks.sh (GOT): Unset.
+	(GOTPLT): Likewise.
+	(DATA_GOTPLT): Likewise.
+	* emulparams/elf32elmipvxworks.sh (GOT): Unset.
+	(GOTPLT): Likewise.
+	(DATA_GOTPLT): Likewise.
+	* emultempl/mipself.em: Include elfxx-mips.h.
+	(mips_after_open): New.
+	(LDEMUL_AFTER_OPEN): Define.
+	* scripttempl/elf.sc: Update comments.  Handle DATA_GOT and
+	DATA_GOTPLT.
+
+2008-03-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (no_mac): New.
+	(m68k_extensions): Point to it for mac entry.
+	(m68k_set_extension): Allow for disabling different set of flags.
+
+2008-03-11  Catherine Moore  <clm@codesourcery.com>
+
+	bfd/
+	* elf.c ( _bfd_elf_print_private_bfd_data): Call
+	elf_backend_get_target_dtag if defined.
+	* elf32-mips.c (elf_backend_get_target_dtag): Define.
+	* elf64-mips.c: Likewise.
+	* elfn32-mips.c: Likewise.
+	* elfxx-mips.c (_bfd_mips_elf_get_target_dtag): New.
+	* elfxx-mips.h (_bfd_mips_elf_get_target_dtag): Declare.
+	* elf-bfd.h (elf_backend_get_target_dtag): Add prototype.
+	* elfxx-target.h (elf_backend_get_target_dtag): Add default.
+	(elf_backend_data): Add elf_backend_get_target_dtag.
+
+2008-03-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	2008-03-11  Thiemo Seufer  <ths@mips.com>
+
+	convert/
+	* bin.c, conv.texi, convert.c, elf.h, elfio.c, elfmips.h,
+	elfout.c, idtbin.c, lsifast.c, mipsflash.c, srec.c, stagbin.c:
+	Update license to GPL v3.
+
+2008-03-07  Julian Brown  <julian@codesourcery.com>
+
+	convert/
+	* convert.c (conv-version.h): Include.
+	(getopt.h): Include.
+	(usage): Add error argument. Print to stdout/stderr depending on
+	setting. Exit according to setting. Print bug URL.
+	(parselist): Add argument to usage() calls.
+	(long_opts): New array.
+	(main): Use getopt_long. Add argument to usage() invocations.
+	Handle --help, --version options.
+	* configure.ac (ACX_PKGVERSION, ACX_BUGURL): Add.
+	* Makefile.am (ACLOCAL_AMFLAGS): Add.
+	(conv_SOURCES): Add conv-version.h.
+	(conv-version.h): Add build rule.
+	(convert.c): Add dependency on conv-version.h.
+	* version.h: New.
+	* Makefile.in: Regenerate.
+	* configure.ac: Regenerate.
+	* aclocal.m4: Regenerate.
+
+2008-03-07  Julian Brown  <julian@codesourcery.com>
+
+	convert/
+	* Makefile.am (install-exec-local): Don't install "conv" binary with
+	no target triplet.
+	* Makefile.in: Regenerate.
+
+2008-03-06  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/testsuite/
+	* lib/ld-lib.exp (check_gc_sections_available): Return 0 for
+	*-*-mingw*.
+
+2008-03-06  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	bfd/
+
+	* elf32-m68k.c (elf_m68k_get_bfd2got_entry): Handle search mode.
+	(elf_m68k_relocate_section): Fix to handle _GLOBAL_OFFSET_TABLE_
+	relocations in case of empty local/global GOT.
+
+2008-03-04  Mark Shinwell  <shinwell@codesourcery.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_final_link_relocate):  Use correct formula
+	for sign-extending 16-bit offsets in MOVW/MOVT relocations.
+
+2008-03-02  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/
+	* emulparams/m68kelf.sh (GENERATE_PIE_SCRIPT): Define.
+
+2008-02-29  Paul Brook  <paul@codesourery.com>
+
+	bfd/
+	* elf32-arm.c (insert_thumb_branch): Rewrite.  Handle b.w.
+	(elf32_thumb_to_arm_stub): Adjust for new insert_thumb_branch.
+
+	ld/testsuite/
+	* ld-arm/arm-app.r: Updated expected outpu for new test.
+	* ld-arm/arm-elf.exp (armeabitests): Add thumb2-b-interwork.
+	* ld-arm/thumb2-b-interwork.d: New test.
+	* ld-arm/thumb2-b-interwork.s: New test.
+
+2008-02-29  Julian Brown  <julian@codesourcery.com>
+
+	convert/
+	* config.h.in: Regenerate.
+
+2008-02-29  Julian Brown  <julian@codesourcery.com>
+
+	convert/
+	* convert.c (xmalloc): Remove (duplicate definition in libiberty).
+
+2008-02-28  Julian Brown  <julian@codesourcery.com>
+
+	* configure.ac (mips*-sde-elf*): Merge duplicated cases into one.
+	Test --with-newlib for !yes rather than no.
+	* Makefile.def (all-convert): Add dependency on libiberty to fix
+	parallel make.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+	convert/
+	* Makefile.in: Disable HTML documentation, and HTML and PDF
+	documentation installation.
+	* Makefile.am: Regenerate.
+	* configure: Regenerate.
+	* aclocal.m4: Regenerate.
+
+2008-02-28  Julian Brown  <julian@codesourcery.com>
+
+	Revert: (moved to separate module)
+
+	2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	* sdemdi: New directory. SDE/MDI glue.
+	* Makefile.def: Add sdemdi target module.
+
+	sdemdi/
+	* ChangeLog: New.
+	* configure.ac: New.
+	* Makefile.am: New.
+	* config-ml.in: New.
+	* crt0.S: New.
+	* fileio.c: New.
+	* m32cache.S: New.
+	* mdi.h: New.
+	* mdilow.S: New.
+	* mdisyscall.S: New.
+	* mdixcpt.h: New.
+	* rtpxlite.c: New.
+	* rtpxliteasm.S: New.
+	* rtpxstub.c: New.
+	* sdemdi32.ld: New.
+	* sdemdi32hi.ld: New.
+	* sdemdi64.ld: New.
+	* sdemdi64hi.ld: New.
+	* simlow.S: New.
+
+2008-02-28  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Fix testcase to handle hack for SDElib below.
+	Don't push upstream.
+	
+	gas/testsuite/
+
+	* gas/mips/set-arch.d: Expect ehb.
+
+2008-02-27  Paul Brook  <paul@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_check_relocs): Only set h->needs_plt for
+	branch/call relocations.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armelftests): Add arm-app-movw.
+
+2008-02-27  Paul Brook  <paul@codesourcery.com>
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp (armelftests): Use arm.ld in movw-merge.
+
+2008-02-26  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	binutils/testsuite/
+	2008-02-26  Joseph Myers  <joseph@codesourcery.com>
+	* config/default.exp (gcc_gas_flag, dlltool_gas_flag): Define to
+	empty for testing an installed toolchain.
+
+2008-02-25  Sandra Loosemore  <sandra@codesourcery.com>
+
+	binutils/
+	Reapply:
+	2006-05-17  Carlos O'Donell  <carlos@codesourcery.com>
+
+	* doc/binutils.texi: Use "Binutils Index" for index name.
+
+2008-02-23  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	* release-notes-csl.xml (ColdFire multi-GOT support): Fix release
+	note to not include uClinux.
+
+2008-02-20  Mark Mitchell  <mark@codesourcery.com>
+
+	ld/testsuite/
+	* ld-elf/seg.d: Expect .reginfo section on MIPS.
+
+2008-02-16  Paul Brook  <paul@codesourcery.com>
+
+	Merged from //mirrors/binutils/trunk revision 193546.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	2005-03-21  Maciej W. Rozycki  <macro@mips.com>
+
+	* config/tc-mips.c (append_insn): Disable swapping of MIPS16
+	branches as it breaks DWARF-2 line information.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	bfd/
+	* elfxx-mips.c (mips_elf_merge_obj_attributes): Add support for
+	-mips32r2 -mfp64.
+	* readelf.c (display_mips_gnu_attribute): Add 64-bit float tag support.
+
+	include/
+	* elf/mips.h (Tag_GNU_MIPS_ABI_FP): Update comment.
+
+	ld/testsuite/
+	* ld-mips-elf/mips-elf.exp: Add run-dump-tests for attr-gnu-4-04,
+	attr-gnu-4-05, attr-gnu-4-15, attr-gnu-4-24, attr-gnu-4-25,
+	attr-gnu-4-34, attr-gnu-4-35, attr-gnu-4-40, attr-gnu-4-42,
+	attr-gnu-4-43, attr-gnu-4-44, attr-gnu-4-45, attr-gnu-4-51.
+	* ld-mips-elf/attr-gnu-4-14.d: Fix warning.
+	* ld-mips-elf/attr-gnu-4-41.d: Likewise.
+	* ld-mips-elf/attr-gnu-4-5.s: New.
+	* ld-mips-elf/attr-gnu-4-04.d: New.
+	* ld-mips-elf/attr-gnu-4-05.d: New.
+	* ld-mips-elf/attr-gnu-4-15.d: New.
+	* ld-mips-elf/attr-gnu-4-24.d: New.
+	* ld-mips-elf/attr-gnu-4-25.d: New.
+	* ld-mips-elf/attr-gnu-4-34.d: New.
+	* ld-mips-elf/attr-gnu-4-35.d: New.
+	* ld-mips-elf/attr-gnu-4-40.d: New.
+	* ld-mips-elf/attr-gnu-4-42.d: New.
+	* ld-mips-elf/attr-gnu-4-43.d: New.
+	* ld-mips-elf/attr-gnu-4-44.d: New.
+	* ld-mips-elf/attr-gnu-4-45.d: New.
+	* ld-mips-elf/attr-gnu-4-51.d: New.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	2004-09-09  Nigel Stephens  <nigel@mips.com>
+
+	bfd/
+	* ihex.c (ihex_write_object_contents): Truncate address to 32 bits
+	if the top 32 bits are a simple sign extension of the bottom.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	gas/
+	* config/tc-mips.c (OPTION_MIPS16E, OPTION_NOMIPS16E): Add
+	backward-compatibility options for SDE.
+	(OPTION_COMPAT_ARCH_BASE): Bump to +16.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	* sdemdi: New directory. SDE/MDI glue.
+	* Makefile.def: Add sdemdi target module.
+
+	sdemdi/
+	* ChangeLog: New.
+	* configure.ac: New.
+	* Makefile.am: New.
+	* config-ml.in: New.
+	* crt0.S: New.
+	* fileio.c: New.
+	* m32cache.S: New.
+	* mdi.h: New.
+	* mdilow.S: New.
+	* mdisyscall.S: New.
+	* mdixcpt.h: New.
+	* rtpxlite.c: New.
+	* rtpxliteasm.S: New.
+	* rtpxstub.c: New.
+	* sdemdi32.ld: New.
+	* sdemdi32hi.ld: New.
+	* sdemdi64.ld: New.
+	* sdemdi64hi.ld: New.
+	* simlow.S: New.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	* convert: New directory. Elf to binary converter.
+
+	convert/
+	* ChangeLog: New.
+	* Makefile.am: New.
+	* Makefile.def: New.
+	* acinclude.m4: New.
+	* configure.ac: New.
+	* convert.c: New.
+	* sysdep.h: New.
+	* srec.c: New.
+	* elf.h: New.
+	* stagbin.c: New.
+	* elfmips.h: New.
+	* alloca.c: New.
+	* bin.c: New.
+	* mipsflash.c: New.
+	* idtbin.c: New.
+	* elfout.c: New.
+	* lsifast.c: New.
+	* elfio.c: New.
+	* conv.1: New.
+	* conv.texi: New.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS (This patch is a hack to make SDElib happy);
+	don't push upstream:
+
+	2004-10-06  David Ung  <davidu@mips.com>
+
+	* mips-opc.c: Change membership to I1 for instructions ssnop and
+	ehb.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	* config/mt-sde (CFLAGS_FOR_TARGET): Add -mno-gpopt.
+	(CXXFLAGS_FOR_TARGET): Likewise.
+	* configure.ac (mips*-sde-elf*): Remove libgloss and libiberty when not
+	building Newlib. Add sde-conv host tool and MDI glue library.
+	* configure: Regenerate.
+
+2008-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS/backport from FSF:
+
+	2007-09-14  Alan Modra  <amodra@bigpond.net.au>
+
+	bfd/
+	* opncls.c (find_separate_debug_file): Ensure bfd_set_error has
+	been called on all error return paths.
+	(bfd_fill_in_gnu_debuglink_section): Use bfd_malloc, not malloc.
+	Clear padding after filename
+
+	2007-09-14  Alan Modra  <amodra@bigpond.net.au>
+
+	bfd/
+	* format.c (bfd_check_format_matches): Record matching targets even
+	when "matching" is NULL to allow bfd_associated_vector matches.
+	Consolidate error return code.  Consolidate ok return code.  Always
+	restore original target and format on error.
+
+2008-02-02  Sandra Loosemore  <sandra@codesourcery.com>
+	
+	* release-notes-csl.xml: Fix mistaken uses of &csl_prod; to use
+	&csl_sgxx; instead.
+
+2008-02-01  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	ld/testsuite/
+
+	* ld-m68k/got-12.s: Remove .ident.
+	* ld-m68k/got-13.s: Ditto.
+	* ld-m68k/got-14.s: Ditto.
+	* ld-m68k/got-15.s: Ditto.
+	* ld-m68k/got-34.s: Ditto.
+	* ld-m68k/got-35.s: Ditto.
+	* ld-m68k/xgot-15.s: Ditto.
+
+2008-02-01  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Add -mxgot tests to ld.
+
+	ld/testsuite/
+
+	* ld-m68k/xgot-15.s: New source.
+	* ld-m68k/got-xgot-15-ok.d: New test.
+	* ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
+	* ld-m68k/m68k.exp: Run new tests.
+
+2008-01-29  Julian Brown  <julian@codesourcery.com>
+
+	gas/
+	* read.c (cons_worker): Report error if user tries to specify string
+	after .byte, etc. directive.
+
+2008-01-28  Paul Brook  <paul@codesourcery.com>
+
+	ld/
+	* emultempl/armelf.em (OPTION_FIX_V4BX_INTERWORKING): Define.
+	(PARSE_AND_LIST_LONGOPTS): Add fix-v4bx-interworking.
+	(PARSE_AND_LIST_OPTIONS): Ditto.
+	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_FIX_V4BX_INTERWORKING.
+	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Add .v4_bx.
+	* emulparams/armelf_linux.sh (OTHER_TEXT_SECTIONS): Ditto.
+	* emulparams/armnto.sh (OTHER_TEXT_SECTIONS): Ditto.
+	* ld.texinfo: Document --fix-v4bx-interworking.
+
+	ld/testsuite/
+	* ld-arm/armv4-bx.d: New test.
+	* ld-arm/armv4-bx.s: New test.
+	* ld-arm/arm.ld: Add .v4bx.
+	* ld-arm/arm-elf.exp: Add armv4-bx.
+
+	gas/testsuite/
+	* gas/arm/thumb.d: Exclude EABI targets.
+	* gas/arm/arch4t.d: Exclude EABI targts.
+	* gas/arm/v4bx.d: New test.
+	* gas/arm/v4bx.s: New test.
+	* gas/arm/thumb-eabi.d: New test.
+	* gas/arm/arch4t-eabi.d: New test.
+
+	gas/
+	* config/tc-arm.c (fix_v4bx): New variable.
+	(do_bx): Generate V4BX relocations.
+	(md_assemble): Allow bx on v4 codes when fix_v4bx.
+	(md_apply_fix): Handle BFD_RELOC_ARM_V4BX.
+	(tc_gen_reloc): Ditto.
+	(OPTION_FIX_V4BX): Define.
+	(md_longopts): Add fix-v4bx.
+	(md_parse_option): Handle OPTION_FIX_V4BX.
+	(md_show_usage): Document --fix-v4bx.
+	* doc/c-arm.texi: Document --fix-v4bx.
+
+	bfd/
+	* reloc.c: Add BFD_RELOC_ARM_V4BX.
+	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_V4BX.
+	(ARM_BX_GLUE_SECTION_NAME, ARM_BX_GLUE_SECTION_NAME): Define.
+	(elf32_arm_link_hash_table): Add bx_glue_size and bx_glue_offset.
+	Update comment for fix_v4bx.
+	(elf32_arm_link_hash_table_create): Zero bx_glue_size and
+	bx_glue_offset.
+	(ARM_BX_VENEER_SIZE, armbx1_tst_insn, armbx2_moveq_insn,
+	armbx3_bx_insn): New.
+	(bfd_elf32_arm_allocate_interworking_sections): Allocate BX veneer
+	section.
+	(bfd_elf32_arm_add_glue_sections_to_bfd): Ditto.
+	(bfd_elf32_arm_process_before_allocation): Record BX veneers.
+	(record_arm_bx_glue, elf32_arm_bx_glue): New functions.
+	(elf32_arm_final_link_relocate): Handle BX veneers.
+	(elf32_arm_output_arch_local_syms): Output mapping symbol for .v4_bx.
+	* bfd-in2.h: Regenerate.
+	* libbfd.h: Regenerate.
+
+2008-01-28  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Handle weakdefs in copy_indirect hook.
+
+	bfd/
+
+	elf32-m68k.c (elf_m68k_copy_indirect_symbol): Handle weakdefs.
+
+2008-01-26  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Multi-GOT support for m68k.
+
+	* release-notes-csl.xml: Document feature.
+	
+	bfd/
+
+	* elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
+	glist): New fields.
+	(struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
+	struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
+	struct elf_m68k_multi_got): New data structures.
+	(struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
+	allow_multigot_p, multi_got_): New fields.
+	(elf_m68k_multi_got): New macro.
+	(elf_m68k_link_hash_newfunc): Initialize new fields of
+	struct elf_m68k_link_hash_entry.
+	(elf_m68k_link_hash_table_create): Initialize new fields of
+	struct elf_m68k_link_hash_table.
+	(elf_m68k_link_hash_table_free): New static function implementing hook.
+	(elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
+	static functions for struct elf_m68k_got.	
+	(elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
+	elf_m68k_got_entry_eq): New static functions for
+	struct elf_m68k_got_entry.
+	(ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
+	ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
+	(enum elf_m68k_get_entry_howto): New enum.
+	(elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
+	elf_m68k_remove_got_entry_type): New static functions for
+	struct elf_m68k_got_entry.
+	(elf_m68k_add_entry_to_got): New static function.
+	(elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
+	elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
+	functions for struct elf_m68k_bfd2got_entry.
+	(struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
+	elf_m68k_can_merge_gots): New traversal.
+	(struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
+	elf_m68k_merge_gots): Ditto.
+	(struct elf_m68k_finalize_got_offsets_arg,
+	elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
+	(struct elf_m68k_partition_multi_got_arg,
+	elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
+	elf_m68k_partition_multi_got): Ditto.
+	(elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
+	functions.
+	(elf_m68k_copy_indirect_symbol): New static function implementing
+	a hook.
+	(elf_m68k_check_relocs): Update to add entries to multi-GOT.
+	(elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
+	(elf_m68k_always_size_sections): Assign BFDs to GOTs.
+	(elf_m68k_relocate_section): Update to properly handle GOT relocations.
+	(elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
+	of a global symbol.
+	(bfd_elf_m68k_set_target_options): New function.
+	(bfd_elf32_bfd_link_hash_table_free): Define hook.
+	(bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
+	to skip generic calculation of GOT offsets.
+	(elf_backend_copy_indirect_symbol): Define hook.
+
+	* bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
+	* bfd-in2.h: Regenerate.
+	
+	ld/
+
+	* configure.in (--enable-got): New option.  Handle it.
+	* configure: Regenerate.
+	* config.in: Regenerate.
+
+	* emultempl/m68kelf.em: (got_handling_target_default): New shell
+	variable.
+	(GOT_HANDLING_TARGET_DEFAULT): New macro.
+	(GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
+	option if one was given.
+	(got_handling): New static variable.
+	(elf_m68k_create_output_section_statements): New static function
+	implementing hook.
+	(PARSE_AND_LIST_PROLOGUE): Define shell variable.
+	(OPTION_GOT): New macro.
+	(PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
+	--got option.
+	(got): New linker option.
+	(PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
+	for --got option.
+	(PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
+	option.
+	
+	* ld.texinfo: Document --got=<type> option.
+	* gen-doc.texi: Add M68K.
+
+	ld/testsuite/
+
+	* ld-m68k/got-12.s: New file.
+	* ld-m68k/got-13.s: New file.
+	* ld-m68k/got-14.s: New file.
+	* ld-m68k/got-15.s: New file.
+	* ld-m68k/got-34.s: New file.
+	* ld-m68k/got-35.s: New file.
+	* ld-m68k/got-single-12-ok.d: New dump test.
+	* ld-m68k/got-single-13-er.d: New dump test.
+	* ld-m68k/got-negative-14-ok.d: New dump test.
+	* ld-m68k/got-negative-15-er.d: New dump test.
+	* ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
+	* ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
+	* ld-m68k/got-multigot-14-ok.d: New dump test.
+	* ld-m68k/got-multigot-15-er.d: New dump test.
+	* ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
+	* ld-m68k/m68k.exp: Run new tests.
+
+2008-01-25  Joseph Myers  <joseph@codesourcery.com>
+
+	include/
+	* libiberty.h (cygpath): Declare.
+
+	libiberty/
+	* cygpath.c (cygpath): Remove static.  Return int.
+	* pex-win32.c (pex_win32_open_read, pex_win32_open_write): Use
+	open not _open.
+
+2008-01-22  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (arm_cpu_option_table): Add cortex-a9.
+
+	gas/doc/
+	* c-arm.texi: Add cortex-a9.
+
+2008-01-22  Paul Brook  <paul@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_relocate_section): Handle MOVW and MOVT
+	relocations.  Improve safety check for other weird relocations.
+	* elf32-arm.c (elf32_arm_howto_table): Fix masks for MOVW/MOVT.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp: Add movw-merge.
+	* ld-arm/movw-merge.d: New test.
+	* ld-arm/movw-merge.s: New test.
+
+2008-01-09  Joseph Myers  <joseph@codesourcery.com>
+
+	* configure.ac (host_makefile_frag): Use config/mh-mingw on
+	*-mingw32*.
+	* configure: Regenerate.
+
+	config/
+	* config/mh-mingw: New.
+
+2008-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CAVIUM
+	Merge from Cavium binutils-2.16.1.diff.gz:
+
+	gas/
+	* config/tc-mips.c (macro): Support M_SAA_AB and M_SAAD_AB.
+
+	gas/testsuite/
+	* gas/mips/mips.exp: Add octeon_saa_saad test.
+	* gas/mips/octeon_saa_saad.d: New.
+	* gas/mips/octeon_saa_saad.s: New.
+
+	include/opcode/
+	* mips.h (M_SAA_AB, M_SAAD_AB): New.
+
+	opcodes/
+	* mips-opc.c (mips_builtin_opcodes): Add saa and saad
+	instructions.
+
+2008-01-03  Catherine Moore  <clm@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (mips_ip): Check operands on jalr instruction.
+
+	gas/testsuite
+	* gas/mips/jalr.s: New test.
+	* gas/mips/jalr.l: New test output.
+	* gas/mips/mips.exp: Run new test.
+
+2007-12-19  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #2297
+	ld/testsuite/
+	* ld-elf/seg.t: New.
+	* ld-elf/seg.d: New.
+	* ld-elf/seg.s: New.
+
+2007-12-12  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	2007-09-15  Alan Modra  <amodra@bigpond.net.au>
+	* configure.ac: Correct makeinfo version check.
+	* configure: Regenerate.
+
+2007-12-12  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* doc/c-arm.texi: Document new VFP -mfpu= options.
+	* config/tc-arm.c (arm_option_cpu_value): Rename vfp3-d16 to
+	vfpv3-d16.  Add vfpv2 and vfpv3.
+
+	gas/testsuite/
+	* gas/arm/vfpv3-d16-bad.d: Rename vfp3-d16 to vfpv3-d16.
+
+2007-12-11  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (fpu_vfp_ext_d32): New vairable.
+	(parse_vfp_reg_list, encode_arm_vfp_reg): Use it.
+	(arm_option_cpu_value): Add vfpv3-d16.
+	(aeabi_set_public_attributes): Handle Tag_VFP_arch=VFPV3-D16.
+
+	gas/testsuite/
+	* gas/arm/vfpv3-d16-bad.d: New test.
+	* gas/arm/vfpv3-d16-bad.l: New test.
+
+	include/opcode/
+	* arm.h (FPU_VFP_EXT_D32, FPU_VFP_V3D16, FPU_ARCH_VFP_V3D16): Define.
+
+	binutils/
+	* readelf.c (arm_attr_tag_VFP_arch): Add "VFPv3-D16".
+	
+	bfd/
+	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle new
+	Tag_VFP_arch values.
+
+2007-12-10  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #2285
+	bfd/
+	* elf.c (bfd_copy_private_symbol_data): Do not copy if
+	the shndx is zero.
+
+	gas/testsuite/
+	* elf/elf.exp: Exceute symtab test.
+	* elf/symtab.s: New test.
+	* elf/symtab.d: New test output file.
+
+	* release-notes-csl.xml: Document fix.
+
+2007-11-29  Mark Shinwell  <shinwell@codesourcery.com>
+
+	include/opcode/
+	* mips.h (INSN_LOONGSON_2E, INSN_LOONGSON_2F,
+	INSN_OCTEON): Rearrange masks so Loongson flags match
+	upstream.
+
+2007-11-28  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #2297
+	include/elf/
+	* internal.h (ELF_IS_SECTION_IN_SEGMENT): Adjust to cope with
+	segments at the end of memory.
+
+2007-11-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+	bfd/
+	2007-11-05  Alan Modra  <amodra@bigpond.net.au>
+	* merge.c (sec_merge_hash_lookup): Revert last change.
+	(record_section): Likewise.
+	(_bfd_merge_sections): Likewise.
+	(_bfd_merged_section_offset): Properly handle NULL secinfo.
+	(_bfd_add_merge_section): Allocate extra space for a zero
+	terminator on SEC_STRINGS sections.
+
+	ld/testsuite/
+	2007-11-05  Alan Modra  <amodra@bigpond.net.au>
+	* ld-elf/merge3.d, ld-elf/merge3.s: Delete.
+
+2007-11-06  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (do_mull): Allow overlapping Rm for armv6.
+
+	gas/testsuite/
+	* gas/arm/mul-overlap.s: Add umull and smlal.
+	* gas/arm/mul-overlap.l: Update expected results.
+
+2007-10-30  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* merge.c (sec_merge_hash_lookup): Add parameter sec_end.  Check
+	for unterminated strings.  All callers changed.
+	(_bfd_write_merged_section, _bfd_merged_section_offset): Handle
+	NULL secinfo from merge failures.
+
+	ld/testsuite/
+	* ld-elf/merge3.d, ld-elf/merge3.s: New.
+
+2007-10-24  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Do not add
+	PT_NULL header when not linking.
+
+2007-10-18  Joseph Myers  <joseph@codesourcery.com>
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT RAZA
+	* config.sub (mipsisa64xlr, ipsisa64xlrel): Add new machine names.
+
+	bfd/
+	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
+	* archures.c (bfd_mach_mips_xlr): New.
+	* cpu-mips.c (I_xlr): New enum value.
+	(arch_info_struct): Add XLR entry.
+	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
+	(mips_set_isa_flags): Handle bfd_mach_mips_xlr.
+	(mips_mach_extensions): Add XLR entry.
+	* bfd-in2.h: Regenerate.
+
+	binutils/
+	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.
+
+	gas/
+	* config/tc-mips.c (macro): Handle XLR instructions.
+	(mips_cpu_info_table): Add xlr.
+	* doc/c-mips.texi (MIPS architecture options): Add xlr to list of
+	-march options.
+
+	gas/testsuite/
+	* gas/mips/xlr-ext.d, /gas/mips/xlr-ext.s: New.
+	* gas/mips/mips.exp (xlr): New arch.
+	(xlr-ext): Run test.
+
+	include/elf/
+	* mips.h (E_MIPS_MACH_XLR): Define.
+
+	include/opcode/
+	* mips.h (INSN_XLR, CPU_XLR): Define.
+	(OPCODE_IS_MEMBER): Handle XLR.
+	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define
+	enum values.
+
+	opcodes/
+	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): New.
+	(mips_arch_choices): Add XLR entry.
+	* mips-opc.c (XLR): Define.
+	(mips_builtin_opcodes): Add XLR opcodes.
+
+2007-10-17  Nathan Sidwell  <nathan@codesourcery.com>
+
+	opcodes/
+	* m68k-opc.c (m68k_opcodes): Correct move sr and ccr masks for
+	coldfire.
+
+	gas/testsuite/
+	* gas/m68k/mcf-movsr.s: New.
+	* gas/m68k/mcf-movsr.d: New.
+	* gas/m68k/all.exp: Add mcf-movsr test.
+
+2007-10-09  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (mips_elf_sort_hash_table_f): Handle forced
+	local symbols specially.
+	(mips_elf_set_global_got_offset): Skip forced local symbols.
+
+	Revert:
+	2007-10-04  Joseph Myers  <joseph@codesourcery.com>
+	bfd/
+	* elfxx-mips.c (struct mips_got_info): Add forced_local_count.
+	(struct mips_elf_hash_sort_data): Add forced_local and
+	prev_forced_local.
+	(mips_elf_sort_hash_table): Subtract g->forced_local_count in
+	computing hsd.min_got_dynindx.  Initialize hsd.forced_local and
+	hsd.prev_forced_local.  Set g->forced_local_count after sorting.
+	(mips_elf_sort_hash_table_f): Count forced-local symbols.  Handle
+	them as unreferenced where allowed for in calculation of
+	min_got_dynindx.
+	(mips_elf_make_got_per_bfd, mips_elf_multi_got,
+	mips_elf_create_got_section): Initialize forced_local_count.
+	(_bfd_mips_elf_always_size_sections): Subtract forced_local_count
+	in calculating global_gotno.
+	(_bfd_mips_elf_final_link): Subtract forced_local_count in
+	assertion.
+	(mips_elf_set_global_got_offset): Check for forced-local symbols
+	before assigning global GOT offsets.
+
+2007-10-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml: Add lost </para>.
+
+2007-10-05  Carlos O'Donell  <carlos@codesourcery.com>
+
+	binutils/
+	* resrc.c (read_rc_file): Rename e to edit, and c to dir.
+	Pass dir to windres_add_include_dir.  Add comments.
+	(close_input_stream): Check pclose error, and call fatal if
+	the preprocessor failed.
+	* windres.c (windres_add_include_dir): Assert that p is non-NULL,
+	and not an empty string. 
+
+2007-10-04  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (struct mips_got_info): Add forced_local_count.
+	(struct mips_elf_hash_sort_data): Add forced_local and
+	prev_forced_local.
+	(mips_elf_sort_hash_table): Subtract g->forced_local_count in
+	computing hsd.min_got_dynindx.  Initialize hsd.forced_local and
+	hsd.prev_forced_local.  Set g->forced_local_count after sorting.
+	(mips_elf_sort_hash_table_f): Count forced-local symbols.  Handle
+	them as unreferenced where allowed for in calculation of
+	min_got_dynindx.
+	(mips_elf_make_got_per_bfd, mips_elf_multi_got,
+	mips_elf_create_got_section): Initialize forced_local_count.
+	(_bfd_mips_elf_always_size_sections): Subtract forced_local_count
+	in calculating global_gotno.
+	(_bfd_mips_elf_final_link): Subtract forced_local_count in
+	assertion.
+	(mips_elf_set_global_got_offset): Check for forced-local symbols
+	before assigning global GOT offsets.
+
+	ld/testsuite/
+	* ld-mips-elf/multi-got-hidden-1.d,
+	ld-mips-elf/multi-got-hidden-1.s,
+	ld-mips-elf/multi-got-hidden-2.d,
+	ld-mips-elf/multi-got-hidden-2.s: New.
+	* ld-mips-elf/mips-elf.exp: Run multi-got-hidden tests.
+
+2007-10-01  Carlos O'Donell  <carlos@codesourcery.com>
+
+	Backport:
+	binutils/
+	2007-09-17  Alon Bar-Lev  <alon.barlev@gmail.com>
+
+        PR binutils/4987
+        * resrc.c: (read_rc_file): Move 'filename' default initialization
+        to start of function.
+
+2007-09-28  Carlos O'Donell  <carlos@codesourcery.com>
+
+	Backport:
+	gas/
+	2007-09-24  Carlos O'Donell  <carlos@codesourcery.com>
+	* config/tc-mips.c (s_align): Set max_alignment to 28.
+	gas/testsuite/
+	2007-09-24  Carlos O'Donell  <carlos@codesourcery.com>
+	* gas/mips/align.s, gas/mips/align.d: New test.
+	* gas/mips/mips.exp: Run it.
+
+2007-09-25  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c: Enforce register constraints on Thumb-1 add.
+
+	gas/testsuite/
+	* gas/arm/t16-bad.s: Add low reg non flags setting add.
+	* gas/arm/t16-bad.l: Update expected output.
+	* gas/arm/archv6m.s: Add low reg non flags setting add.
+	* gas/arm/archv6m.d: Update expected output.
+
+2007-09-24  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Backport:
+	bfd/
+	2007-09-24  Daniel Jacobowitz  <dan@codesourcery.com>
+	* elf.c (assign_file_positions_for_load_sections): Trust
+	p_align_valid.
+	(copy_elf_program_header): Copy PT_NULL segments.
+
+2007-09-24  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gas/testsuite/
+	* gas/mips/loongson-2f.d: Specify a 64-bit ABI.
+	* gas/mips/loongson-2e.d: Likewise.
+
+2007-09-21  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml: Add release notes for GOT patch.
+
+	ld/testsuite/
+	* ld-mips-elf/got-page-3.d: Assemble with -mips3.
+
+2007-09-21  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from
+	<http://sourceware.org/ml/binutils/2007-09/msg00308.html>:
+
+	bfd/
+	2007-09-21  Richard Sandiford  <rsandifo@nildram.co.uk>
+	* elfxx-mips.c (mips_got_page_range): New structure.
+	(mips_got_page_entry): Likewise.
+	(mips_got_info): Add page_gotno and got_page_entries fields.
+	(mips_elf_got_per_bfd_arg): Add max_pages field.  Delete
+	primary_count and current_count fields.
+	(mips_got_page_entry_hash, mips_got_page_entry_eq): New functions.
+	(mips_elf_pages_for_range, mips_elf_record_got_page_entry): Likewise.
+	(mips_elf_get_got_for_bfd): New function, split out from
+	mips_elf_make_got_per_bfd.  Initialize the page_gotno and
+	got_page_entries fields when creating a new GOT structure.
+	(mips_elf_make_got_pages_per_bfd): New function.
+	(mips_elf_merge_got_with): New function, split out from
+	mips_elf_make_got_per_bfd.  Merge page entries as well as
+	non-page entries.  Use the minimum of max_pages and the sum
+	of the page_gotnos to estimate the number of page entries.
+	(mips_elf_merge_gots): Use the minimum of max_pages and the
+	bfd's page_gotno to estimate the number of page entries.
+	Use the above functions.
+	(mips_elf_multi_got): Add page entries as well as non-page entries
+	to the individual per-bfd GOTs.  Initialize got_per_bfd_arg.max_pages.
+	Initialize the page_gotno and got_page_entries fields when creating
+	a new primary GOT.  Use the minimum of pages and page_gotno when
+	adding the number of pages entries to local_gotno.
+	(mips_elf_create_got_section): Initialize the page_gotno and
+	got_page_entries fields of the GOT structure.
+	(mips_elf_rel_relocation_p, mips_elf_read_rel_addend)
+	(mips_elf_add_lo16_rel_addend, mips_elf_get_section_contents): New
+	functions, split out from...
+	(_bfd_mips_elf_relocate_section): ...here.
+	(_bfd_mips_elf_check_relocs): Record GOT page entries too.
+	(_bfd_mips_relax_section): Use mips_elf_get_section_contents.
+	(_bfd_mips_elf_always_size_sections): Use the smaller of the
+	loadable_size- and page_gotno-derived estimates.
+
+	ld/testsuite/
+	2007-09-21  Richard Sandiford  <rsandifo@nildram.co.uk>
+	            Joseph Myers  <joseph@codesourcery.com>
+	* ld-mips-elf/got-page-1.d, ld-mips-elf/got-page-1.s,
+	* ld-mips-elf/got-page-2.d, ld-mips-elf/got-page-2.s,
+	* ld-mips-elf/got-page-3.d, ld-mips-elf/got-page-3a.s,
+	* ld-mips-elf/got-page-3b.s, ld-mips-elf/got-page-3c.s,
+	* ld-mips-elf/got-page-1.ld: New tests.
+	* ld-mips-elf/mips-elf.exp: Run them.
+	* ld-mips-elf/multi-got-1.d, ld-mips-elf/multi-got-no-shared.d,
+	* ld-mips-elf/tls-hidden2-got.d, ld-mips-elf/tls-hidden2.d,
+	* ld-mips-elf/tls-hidden3.d, ld-mips-elf/tls-hidden3.got,
+	* ld-mips-elf/tls-hidden3.r, ld-mips-elf/tls-hidden4.got,
+	* ld-mips-elf/tls-hidden4.r, ld-mips-elf/tls-multi-got-1.d,
+	* ld-mips-elf/tls-multi-got-1.got, ld-mips-elf/tls-multi-got-1.r,
+	* ld-mips-elf/tlsbin-o32.d, ld-mips-elf/tlsbin-o32.got,
+	* ld-mips-elf/tlsdyn-o32-1.d, ld-mips-elf/tlsdyn-o32-1.got,
+	* ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-2.got,
+	* ld-mips-elf/tlsdyn-o32-3.d, ld-mips-elf/tlsdyn-o32-3.got,
+	* ld-mips-elf/tlsdyn-o32.d, ld-mips-elf/tlsdyn-o32.got,
+	* ld-mips-elf/tlslib-o32-hidden.got, ld-mips-elf/tlslib-o32-ver.got,
+	* ld-mips-elf/tlslib-o32.d, ld-mips-elf/tlslib-o32.got: Update for
+	GOT allocation changes.
+
+2007-09-19  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-scripts/rgn-over.s: Use sections .txt and .dat.
+	* ld-scripts/rgn-over1.t, ld-scripts/rgn-over2.t,
+	ld-scripts/rgn-over3.t, ld-scripts/rgn-over4.t, ld-scripts/rgn-over5.t,
+	ld-scripts/rgn-over6.t, ld-scripts/rgn-over7.t: Discard other
+	sections.  Handle changed names.
+	* ld-scripts/rgn-over1.d, ld-scripts/rgn-over2.d,
+	ld-scripts/rgn-over3.d, ld-scripts/rgn-over4.d, ld-scripts/rgn-over5.d,
+	ld-scripts/rgn-over6.d, ld-scripts/rgn-over7.d: Expect discarded
+	sections and changed names.
+
+2007-09-19  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	bfd/
+	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Make sure .got
+	will be output.
+
+2007-09-18  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	* release-notes-csl.xml (ColdFire 51QE support): New.
+	
+2007-09-07  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gas/
+	* config/tc-ppc.c (parse_cpu): Handle -mpmr option.
+
+2007-08-31  Joseph Myers  <joseph@codesourcery.com>
+
+	Revert:
+	2007-06-04  Joseph Myers  <joseph@codesourcery.com>
+	bfd/
+	* elflink.c (bfd_elf_link_record_dynamic_symbol): Do not set
+	dynindx for indirect symbols.
+
+2007-08-30  Brooks Moses  <brooks@codesourcery.com>
+
+	Add files missing from 2007-08-20 merge from FSF trunk:
+	* ld/emultempl/cr16elf.em: New.
+	* ld/testsuite/ld-elf/dl2a.list: New.
+	* ld/testsuite/ld-ia64/merge1.d: New.
+	* ld/testsuite/ld-ia64/merge1.s: New.
+	* ld/testsuite/ld-ia64/merge2.d: New.
+	* ld/testsuite/ld-ia64/merge2.s: New.
+	* ld/testsuite/ld-ia64/merge3.d: New.
+	* ld/testsuite/ld-ia64/merge3.s: New.
+	* ld/testsuite/ld-ia64/merge4.d: New.
+	* ld/testsuite/ld-ia64/merge4.s: New.
+	* ld/testsuite/ld-ia64/merge5.d: New.
+	* ld/testsuite/ld-ia64/merge5.s: New.
+	* ld/testsuite/ld-pe/secrel_64.d: New.
+	* compile: New.
+	* lt~obsolete.m4: New.
+
+2007-08-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-elf/weak-dyn-1.rd: Resolve merge conflict.
+
+2007-08-29  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #1771
+	Backport:
+	2007-08-29  Daniel Jacobowitz  <dan@codesourcery.com>
+	gas/
+	* dwarf2dbg.c (dwarf2_directive_loc): Emit duplicate .loc directives.
+
+	gas/testsuite/
+	* gas/lns/lns-duplicate.d, gas/lns/lns-duplicate.s: New.
+	* gas/lns/lns.exp: Run lns-duplicate.
+
+2007-08-28  Mark Shinwell  <shinwell@codesourcery.com>
+            Joseph Myers  <joseph@codesourcery.com>
+
+	ld/testsuite/
+	* ld-scripts/rgn-over1.d: Disallow space before "ld" at start of
+	line, not ":".
+	* ld-scripts/rgn-over2.d: Likewise.
+	* ld-scripts/rgn-over3.d: Likewise.
+	* ld-scripts/rgn-over4.d: Likewise.
+	* ld-scripts/rgn-over5.d: Likewise.
+	* ld-scripts/rgn-over6.d: Likewise.
+	* ld-scripts/rgn-over7.d: Likewise.
+
+	Backport from FSF:
+
+	bfd/
+	* elf32-arm.c (elf32_arm_compare_mapping): Compare first on vma,
+	then on type.
+
+	binutils/testsuite/
+	* binutils-all/ar.exp (long_filenames): Delete temporary files on
+	the host.
+	* binutils-all/arm/objdump.exp: Only check "which $OBJDUMP" if
+	host is local.
+	* binutils-all/objcopy.exp: Use ${srecfile} to get the name of the
+	srec file to be passed to binutils_run.
+	(objcopy_test_readelf): Use remote_exec.
+	* binutils-all/readelf.exp (readelf_find_size): Use remote_exec.
+	(readelf_test): Likewise.
+	(readelf_wi_test): Likewise.
+	* lib/utils-lib.exp (run_dump_test): Only check "which $binary" if
+	host is local.  Use remote_exec.  Use $tempfile not
+	tmpdir/bintest.o.
+
+	gas/
+	* as.c (main): Flush stderr before printing listings to ensure
+	consistent output order across platforms.
+
+	gas/testsuite/
+	* lib/gas-defs.exp (gas_version): Use remote_* functions instead
+	of exec.
+	(gas_host_run): New.
+	(gas_run): Use gas_host_run.
+	(gas_start): Likewise.
+	(run_dump_test): Likewise.
+	(objdump): Use gas_host_run.
+	(objdump_start_no_subdir): Likewise.
+	* lib/gas-dg.exp (gas-dg-test): Use "remote_file host delete".
+	* lib/run: Remove.
+	* gas/macros/macros.exp: Download app4b.s to host.
+	* gas/i386/i386.exp (gas_64_check): Use gas_host_run.
+	(gas_32_check): Likewise.
+	* gas/maxq10/maxq10.exp (gas_64_check): Likewise
+	(gas_32_check): Likewise.
+	* gas/maxq20/maxq20.exp (gas_64_check): Likewise
+	(gas_32_check): Likewise.
+	* gas/sparc/sparc.exp (gas_64_check): Likewise.
+	* gas/cfi/cfi.exp: Likewise.
+	* gas/elf/elf.exp (run_list_test): Likewise.  Use temporary file
+	for readelf output in place of pipe.
+	* gas/all/gas.exp: Download incbin.dat to host.
+	(do_comment): Allow \r\r\n.
+
+	ld/
+	* ldlang.c (sort_sections_by_lma): Sort by internal id after lma
+	for stable sort.
+
+	ld/testsuite/
+	* ld-elfcomm/elfcomm.exp: Use run_host_cmd.  Only check "which
+	$CC" if host is local.
+	* ld-checks/checks.exp: Use run_host_cmd.
+	* ld-elf/exclude.exp: Likewise.
+	* ld-elf/elf.exp: Download merge.ld if host is remote.
+	* ld-elf/binutils.exp (binutils_test): Use remote_exec.
+	* ld-elf/tls_common.exp: Use run_host_cmd.
+	* lib/ld-lib.exp (ld_version): Only check "which $ld" if host is
+	local.  Use remote_exec.
+	(run_host_cmd): New.
+	(run_host_cmd_yesno): New.
+	(default_ld_relocate): Use run_host_cmd_yesno.
+	(default_ld_link): Likewise.
+	(default_ld_simple_link): Use run_host_cmd.
+	(default_ld_compile): Only check "which $ccprog" if host is local.
+	Use remote_file and remote_exec.
+	(default_ld_assemble): Only check "which $as" if host is local.
+	Use run_host_cmd.
+	(default_ld_nm): Use remote_exec, remote_upload and remote_file.
+	(run_dump_test): Use remote_exec, remote_upload and remote_file.
+	Only check "which $binary" if host is local.
+	(run_ld_link_tests): Use remote_exec, remote_upload and
+	remote_file.
+	* ld-selective/selective.exp: Only check "which $CXX" if host is
+	local.  Use remote_exec.
+	* ld-scripts/phdrs.exp: Only check "which $objdump" if host is
+	local.  Use run_host_cmd.
+	* ld-scripts/phdrs2.exp: Likewise.
+	* ld-scripts/weak.exp: Likewise.
+	* ld-undefined/weak-undef.exp: Likewise.
+	* ld-scripts/crossref.exp: Only check "which $CC" if host is local.
+	Use run_host_cmd.
+	* ld-scripts/map-address.exp: Upload map_address.map if host is
+	remote.
+	* ld-srec/srec.exp (run_srec_tests): Use run_host_cmd.  Only check
+	"which $CC" and "which $CXX" if host is local.
+	* ld-undefined/undefined.exp: Only check "which $CC" if host is
+	local.  Use remote_file and run_host_cmd.
+	* config/default.exp: Use remote_exec to create tmpdir.
+
+2007-08-28  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (m68k_ip): Add mcfisa_c case.
+	(m68k_elf_final_processing): Add EF_M68K_CF_ISA_C_NODIV.
+
+	include/elf/
+	* m68k.h (EF_M68K_CF_ISA_C_NODIV): New.
+
+	bfd/
+	* elf32-m68k.c (elf32_m68k_object_p): Add EF_M68K_CF_ISA_C_NODIV.
+	(elf32_m68k_print_private_bfd_data): Likewise.
+
+2007-08-25  Mark Shinwell  <shinwell@codesourcery.com>
+
+	Add files missing from previous commit:
+	gas/testsuite/
+	* gas/mips/loongson-2e.d: New.
+	* gas/mips/loongson-2e.s: New.
+	* gas/mips/loongson-2f.d: New.
+	* gas/mips/loongson-2f.s: New.
+
+2007-08-25  Mark Shinwell  <shinwell@codesourcery.com>
+
+	* release-notes-csl.xml
+	(Loongson-2E and Loongson-2F processor support): New.
+
+2007-08-25  Mark Shinwell  <shinwell@codesourcery.com>
+
+        bfd/
+	* archures.c (bfd_mach_mips_loongson_2e): New.
+	(bfd_mach_mips_loongson_2f): New.
+	* bfd-in2.h (bfd_mach_mips_loongson_2e): New.
+	(bfd_mach_mips_loongson_2f): New.
+	* cpu-mips.c: Add I_loongson_2e and I_loongson_2f to
+	anonymous enum.
+	(arch_info_struct): Add Loongson-2E and Loongson-2F entries.
+	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Loongson-2E
+	and Loongson-2F flags.
+	(mips_set_isa_flags): Likewise.
+	(mips_mach_extensions): Add Loongson-2E and Loongson-2F
+	entries.
+
+	binutils/
+	* readelf.c (get_machine_flags): Handle Loongson-2E and -2F
+	flags.
+	
+	gas/
+	* config/tc-mips.c (mips_cpu_info_table): Add loongson2e
+	and loongson2f entries.
+	* doc/c-mips.texi: Document -march=loongson{2e,2f} options.
+
+	gas/testsuite/
+	* gas/mips/mips.exp: Add loongson-2e and -2f tests.
+	* gas/mips/loongson-2e.d: New.
+	* gas/mips/loongson-2e.s: New.
+	* gas/mips/loongson-2f.d: New.
+	* gas/mips/loongson-2f.s: New.
+
+	include/elf/
+	* mips.h (E_MIPS_MACH_LS2E): New.
+	(E_MIPS_MACH_LS2F): New.
+
+	include/opcode/
+	* mips.h (INSN_LOONGSON_2E): New.
+	(INSN_LOONGSON_2F): New.
+	(CPU_LOONGSON_2E): New.
+	(CPU_LOONGSON_2F): New.
+	(OPCODE_IS_MEMBER): Update for Loongson-2E and -2F flags.
+
+	opcodes/
+	* mips-dis.c (mips_arch_choices): Add Loongson-2E and -2F
+	entries.
+	* mips-opc.c (IL2E): New.
+	(IL2F): New.
+	(mips_builtin_opcodes): Add Loongson-2E and -2F instructions.
+	Allow movz and movn for Loongson-2E and -2F.  Add movnz entry.
+	Move coprocessor encodings to the end of the table.  Allow
+	certain MIPS V .ps instructions on the Loongson-2E and -2F.
+
+2007-08-24  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Rename 51QE to 51qe.
+
+	binutils/
+
+	* gas/config/tc-m68k.c (mcf51QE_ctrl): Rename to mcf51qe_ctrl.
+	(m68k_cpus): Update.
+
+2007-08-24  Mark Shinwell  <shinwell@codesourcery.com>
+
+	include/opcode/
+	* mips.h (INSN_ISA*): Redefine certain values as an
+	enumeration.  Update comments.
+	(mips_isa_table): New.
+	(ISA_MIPS*): Redefine to match enumeration.
+	(OPCODE_IS_MEMBER): Modify to correctly test new INSN_ISA*
+	values.
+
+	opcodes/
+	* mips-opc.c (I3_32, I3_33, I4_32, I4_33, I5_33): New.
+	(mips_builtin_opcodes): Use these new I* values.
+
+2007-08-23  Nathan Sidwell  <nathan@codesourcery.com>
+
+	bfd/
+	* archures.c: Add bfd_mach_mcf_isa_c_nodiv,
+	bfd_mach_mcf_isa_c_nodiv_mac & bfd_mach_mcf_isa_c_nodiv_emac.
+	* bfd/ieee.c (ieee_write_processor): Update coldfire architecture
+	list.
+	* bfd-in2.h: Rebuilt.
+	* cpu-m68k.c (arch_info_struct): Add isa_c nodiv architectures.
+	(m68k_arch_features): Likewise.
+
+2007-08-22  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml: Mention GDB support for MIPS -msoft-float
+	tags.
+
+2007-08-21  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Add ColdFire V1 devices.
+
+	binutils/gas
+
+	* config/tc-m68k.c (mcf51QE_ctrl): Define 51QE control registers.
+	(m68k_cpus): Define 51QE cpu.
+
+2007-08-20  Brooks Moses  <brooks@codesourcery.com>
+
+        Merged from //mirrors/binutils/trunk revision 179541.
+
+2007-08-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml: Mention MIPS linker warnings.
+
+2007-08-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-powerpc/attr-gnu-8-31.d, ld-powerpc/attr-gnu-8-1.s,
+	ld-powerpc/attr-gnu-8-11.d, ld-powerpc/attr-gnu-8-3.s: New.
+
+	include/elf/
+	* ppc.h (Tag_GNU_Power_ABI_Vector): New.
+
+	binutils/
+	* readelf.c (display_power_gnu_attribute): Handle
+	Tag_GNU_Power_ABI_Vector.
+
+	bfd/
+	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Handle
+	Tag_GNU_Power_ABI_Vector.
+
+2007-08-11  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-08-11  Richard Sandiford  <richard@codesourcery.com>
+
+	* config.bfd (sh-*-vxworks): Define targ_underscore to "yes".
+
+2007-08-09  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (relaxed_symbol_addr): Compensate for alignment.
+
+	gas/testsuite/
+	* gas/arm/relax_load_align.d: new test.
+	* gas/arm/relax_load_align.s: new test.
+
+2007-08-07  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+	ld/testsuite/
+	2007-05-17  Paul Brook  <paul@codesourcery.com>
+	* ld-elf/multibss1.s: Use %nobits instead of @nobits.
+
+2007-08-03  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Backport from mainline:
+	ld/testsuite/
+	2007-08-03  Daniel Jacobowitz  <dan@codesourcery.com>
+	* ld-srec/srec.exp: XFAIL for powerpc*-*-*.
+
+2007-07-23  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-07-23  Richard Sandiford  <richard@codesourcery.com>
+
+	* elflink.c (_bfd_elf_fix_symbol_flags): Only assert the type
+	of weakdef->root.type if weakdef has no regular definition.
+
+	ld/testsuite/
+	2007-07-23  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-elf/weak-dyn-1a.s, ld-elf/weak-dyn-1b.s, ld-elf/weak-dyn-1.ld,
+	* ld-elf/weak-dyn-1.rd: New test.
+	* ld-elf/elf.exp: Run it.
+
+2007-07-18  Zack Weinberg  <zack@codesourcery.com>
+
+	Issue 1494
+	ld/
+	* ldlang.c (lang_check_section_addresses): Also report size of
+	overflow for any overflowed memory regions.
+	(os_region_check): Diagnose an overflowed region only once per
+	region.  Do not reset region->current on overflow. 
+
+	ld/testsuite/
+	* ld-scripts/rgn-over.exp: New driver.
+	* ld-scripts/rgn-over.s: New file.
+	* ld-scripts/rgn-over1.d, ld-scripts/rgn-over1.t
+	* ld-scripts/rgn-over2.d, ld-scripts/rgn-over2.t
+	* ld-scripts/rgn-over3.d, ld-scripts/rgn-over3.t
+	* ld-scripts/rgn-over4.d, ld-scripts/rgn-over4.t
+	* ld-scripts/rgn-over5.d, ld-scripts/rgn-over5.t
+	* ld-scripts/rgn-over6.d, ld-scripts/rgn-over6.t
+	* ld-scripts/rgn-over7.d, ld-scripts/rgn-over7.t:
+	New test cases.
+
+2007-07-13  Nathan Sidwell  <nathan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-scripts/assert.t: Tweak to avoid relying on empty's VMA being
+	zero.
+
+2007-07-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	#1765
+	ld/
+	* scripttempl/pe.sc: Don't include .gcc_except_table and
+	.eh_frame on partial links.
+
+2007-07-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue 1702
+	bfd/
+	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't eliminate
+	copy relocs on vxworks.
+
+2007-07-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 1775
+	gas/
+	* config/m68k-parse.h (m68k_register): Use MBO instead of MBB.
+	(last_movec_reg): Change to MBO.
+	* config/tc-m68k.c (fido_ctrl): Use MBO instead of MBB.
+	(m68k_ip): Use MBO instead of MBO.
+	(init_table): Use MBO instead of MBO.  Add an entry for mbo.
+
+	gas/testsuite/
+	* gas/m68k/fido.s: Add tests for %mbo.
+	* gas/m68k/fido.d: Update accordingly.
+
+	opcodes/
+	* m68k-dis.c (print_insn_arg): Use %mbo instead of %mbb.
+
+	* release-notes-csl.xml: Add a note for the addition of %mbo.
+
+2007-07-05  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* opcodes/ppc-opc (PPC7450): New.
+	(powerpc_opcodes): Use it in dcba.
+
+2007-07-04  Richard Sandiford  <richard@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (mips_cpu_info_table): Add 74kf3_2.
+	* doc/c-mips.texi: Document it.
+
+2007-07-04  Richard Sandiford  <richard@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (mips_cpu_info_table): Add new entries for
+	{24k,24ke,34k,74k}f{2_1,1_1,x}.
+	* doc/c-mips.texi: Document them.
+
+2007-07-03  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Copy type from
+	input attributes if value has been copied.
+
+	ld/testsuite/
+	* ld-arm/attr-merge-2a.s, ld-arm/attr-merge-2b.s,
+	ld-arm/attr-merge-2.attr: New.
+	* ld-arm/arm-elf.exp (armelftests): Add new test.
+
+2007-07-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elf32-ppc.c (ppc_elf_info_to_howto): Check for invalid relocation
+	types.
+
+2007-07-02  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Suppress
+	call veneers for call relocations against undefined symbols.
+	(elf32_arm_final_link_relocate): Turn call to undefined symbol
+	into a jump to the next instruction.
+
+	ld/testuite/
+	* ld-arm/arm-elf.exp (armelftests): Add callweak.
+	* ld-arm/callweak.d: New test.
+	* ld-arm/callweak.s: New test.
+
+2007-07-02  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elfxx-mips.c (mips_elf_calculate_relocation): Handle
+	R_MIPS_TLS_DTPREL32 and R_MIPS_TLS_DTPREL64.
+	* elf64-mips.c (mips_elf64_howto_table_rela): Support
+	R_MIPS_TLS_DTPREL64.
+
+	gas/
+	* config/tc-mips.c (s_dtprelword, s_dtpreldword,
+	s_dtprel_internal): New.
+	(mips_pseudo_table): Add .dtprelword and .dtpreldword.
+	(md_apply_fix): Handle BFD_RELOC_MIPS_TLS_DTPREL32 and
+	BFD_RELOC_MIPS_TLS_DTPREL64.
+
+2007-06-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elf32-ppc.c (ppc_elf_merge_obj_attributes): New.
+	(ppc_elf_merge_private_bfd_data): Call it.
+
+	binutils/
+	* readelf.c (display_power_gnu_attribute, process_power_specific):
+	New.
+	(process_arch_specific): Call process_power_specific.
+
+	include/elf/
+	* ppc.h (Tag_GNU_Power_ABI_FP): Define.
+
+	ld/testsuite/
+	* ld-powerpc/attr-gnu-4-0.s, ld-powerpc/attr-gnu-4-00.d,
+	ld-powerpc/attr-gnu-4-01.d, ld-powerpc/attr-gnu-4-02.d,
+	ld-powerpc/attr-gnu-4-1.s, ld-powerpc/attr-gnu-4-10.d,
+	ld-powerpc/attr-gnu-4-11.d, ld-powerpc/attr-gnu-4-12.d,
+	ld-powerpc/attr-gnu-4-13.d, ld-powerpc/attr-gnu-4-2.s,
+	ld-powerpc/attr-gnu-4-20.d, ld-powerpc/attr-gnu-4-21.d,
+	ld-powerpc/attr-gnu-4-22.d, ld-powerpc/attr-gnu-4-3.s,
+	ld-powerpc/attr-gnu-4-31.d: New.
+	* ld-powerpc/powerpc.exp: Run these new tests.
+
+2007-06-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	gas/
+	* as.c (main): Only call create_obj_attrs_section if IS_ELF.
+
+2007-06-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elfxx-mips.c (mips_elf_merge_obj_attributes): New.
+	(_bfd_mips_elf_merge_private_bfd_data): Call it.
+
+	binutils/
+	* readelf.c (display_mips_gnu_attribute): New.
+	(process_mips_specific): Call process_attributes.
+
+	include/elf/
+	* mips.h (Tag_GNU_MIPS_ABI_FP): Define.
+
+	ld/testsuite/
+	* ld-mips-elf/attr-gnu-4-0.s, ld-mips-elf/attr-gnu-4-00.d,
+	ld-mips-elf/attr-gnu-4-01.d, ld-mips-elf/attr-gnu-4-02.d,
+	ld-mips-elf/attr-gnu-4-03.d, ld-mips-elf/attr-gnu-4-1.s,
+	ld-mips-elf/attr-gnu-4-10.d, ld-mips-elf/attr-gnu-4-11.d,
+	ld-mips-elf/attr-gnu-4-12.d, ld-mips-elf/attr-gnu-4-13.d,
+	ld-mips-elf/attr-gnu-4-14.d, ld-mips-elf/attr-gnu-4-2.s,
+	ld-mips-elf/attr-gnu-4-20.d, ld-mips-elf/attr-gnu-4-21.d,
+	ld-mips-elf/attr-gnu-4-22.d, ld-mips-elf/attr-gnu-4-23.d,
+	ld-mips-elf/attr-gnu-4-3.s, ld-mips-elf/attr-gnu-4-30.d,
+	ld-mips-elf/attr-gnu-4-31.d, ld-mips-elf/attr-gnu-4-32.d,
+	ld-mips-elf/attr-gnu-4-33.d, ld-mips-elf/attr-gnu-4-4.s,
+	ld-mips-elf/attr-gnu-4-41.d: New.
+	* ld-mips-elf/mips-elf.exp: Run these new tests.
+
+2007-06-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	bfd/
+	* elf-attrs.c: New.
+	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
+	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
+	(elf-attrs.lo): Generate dependencies.
+	* Makefile.in: Regenerate.
+	* configure.in (elf): Add elf-attrs.lo.
+	* configure: Regenerate.
+	* elf-bfd.h (struct elf_backend_data): Add entries for object
+	attributes.
+	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
+	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
+	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
+	New.
+	(struct elf_obj_tdata): Add entries for object attributes.
+	(elf_known_obj_attributes, elf_other_obj_attributes,
+	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
+	New.
+	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
+	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
+	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
+	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
+	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
+	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
+	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
+	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
+	(bfd_section_from_shdr): Handle attributes sections.
+	* elflink.c (bfd_elf_final_link): Handle attributes sections.
+	* elfxx-target.h (elf_backend_obj_attrs_vendor,
+	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
+	elf_backend_obj_attrs_section_type): New.
+	(elfNN_bed): Update.
+	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
+	aeabi_attribute_list): Remove.
+	(struct elf32_arm_obj_tdata): Remove object attributes fields.
+	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
+	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
+	Update for new object attributes interfaces.
+	(uleb128_size, is_default_attr, eabi_attr_size,
+	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
+	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
+	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
+	elf32_arm_add_eabi_attr_int, attr_strdup,
+	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
+	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
+	to generic code in elf-attrs.c.
+	(elf32_arm_obj_attrs_arg_type): New.
+	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
+	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
+	(bfd_elf32_bfd_final_link): Remove.
+	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
+	elf_backend_obj_attrs_arg_type,
+	elf_backend_obj_attrs_section_type): New.
+	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
+	attributes.
+	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
+	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
+	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
+	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
+	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
+	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.
+
+	binutils/
+	* readelf.c (display_gnu_attribute): New.
+	(process_arm_specific): Rearrange as process_attributes.
+	(process_arm_specific): Replace by wrapper of process_attributes.
+
+	gas/
+	* as.c (create_obj_attrs_section): New.
+	(main): Call create_obj_attrs_section for ELF.
+	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
+	skip_past_comma, s_vendor_attribute): New.
+	(potable): Add gnu_attribute for ELF.
+	* read.h (s_vendor_attribute): Declare.
+	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
+	round s_vendor_attribute.
+	(aeabi_set_public_attributes): Update for new attributes
+	interfaces.
+	(arm_md_end): Remove attributes contents setting now done
+	generically.
+
+	include/elf/
+	* arm.h (elf32_arm_add_eabi_attr_int,
+	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
+	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
+	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
+	Tag_Symbol, Tag_compatibility): Remove.
+	* common.h (SHT_GNU_ATTRIBUTES): Define.
+
+	ld/
+	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
+	(ATTRS_SECTIONS): Define.
+	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
+	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
+	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
+
+2007-06-26  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (parse_operands): Accept generic coprocessor regs
+	for OP_RVC.
+	(reg_names): Add fpinst, pfinst2, mvfr0 and mvfr1.
+
+	gas/testsuite/
+	* gas/arm/vfp1xD.d: Add new fmrx/fmxr tests.
+	* gas/arm/vfp1xD.s: Ditto.
+	* gas/arm/vfp1xD_t2.d: Ditto.
+	* gas/arm/vfp1xD_t2.s: Ditto.
+
+	opcodes/
+	* arm-dis.c (coprocessor_opcodes): Add fmxr/fmrx mvfr0/mvfr1.
+
+2007-06-26  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml: Add release notes for attribute merging
+	fix.
+
+2007-06-26  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (copy_eabi_attributes): Copy type of attributes.
+
+	ld/testsuite/
+	* ld-arm/attr-merge.s, ld-arm/attr-merge.attr: New.
+	* ld-arm/arm-elf.exp (armelftests): Add new test.
+
+2007-06-25  Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (do_t_mov_cmp): Handle shift by register and
+	narrow shift by immediate.
+
+	gas/testsuite/
+	* gas/arm/thumb32.s: Add tests for shift instructions.
+	* gas/arm/thumb32.d: Ditto.
+
+2007-06-25  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-06-25  Richard Sandiford  <richard@codesourcery.com>
+
+	* elfxx-mips.c (mips_elf_calculate_relocation): Allow local stubs
+	to be used for calls from MIPS16 code.
+
+	gas/
+	2007-06-25  Richard Sandiford  <richard@codesourcery.com>
+
+	* config/tc-mips.h (TC_SYMFIELD_TYPE): New.
+	* config/tc-mips.c (append_insn): Record which symbols have
+	R_MIPS16_26 relocations against them.
+	(mips_fix_adjustable): Don't reduce relocations against such symbols.
+
+	ld/testsuite/
+	2007-06-25  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-mips-elf/mips16-local-stubs-1.s,
+	* ld-mips-elf/mips16-local-stubs-1.d: New tests.
+	* ld-mips-elf/mips-elf.exp: Run them.
+
+2007-06-18  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Bug 1722
+	gas/testsuite/
+	* gas/m68k/mcf-coproc.d: New.
+	* gas/m68k/mcf-coproc.s: New.
+	* gas/m68k/all.exp: Add it.
+
+	gas/
+	* config/tc-m68k.c (m68k_ip): Add j & K operand types.
+	(install_operand): Add E encoding.
+	(md_begin): Check and skip initial '.' arg character.
+	(get_num): Add 0..511 case.
+
+	include/
+	* opcode/m68k.h: Document j K & E.
+
+	opcodes/
+	* m68k-dis.c (fetch_arg): Add E.  Replace length switch with
+	direct masking.
+	(print_ins_arg): Add j & K operand types.
+	(match_insn_m68k): Check and skip initial '.' arg character.
+	(m68k_scan_mask): Likewise.
+	* m68k-opc.c (m68k_opcodes): Add coprocessor instructions.
+
+2007-06-14  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (mcf52235_ctrl): Add cache registers.
+	(mcf5253_ctrl): Add RAMBAR, MBAR, MBAR2.
+	(mcf5407_ctrl): New.
+	(m68k_cpus): Adjust 5407 entry.
+
+2007-06-13  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/
+	* config.in: Regenerate.
+	* ld.h (args_type): Add poison_system_directories.
+	* ld.texinfo (--no-poison-system-directories): Document.
+	* ldfile.c (ldfile_add_library_path): Check
+	command_line.poison_system_directories.
+	* ldmain.c (main): Initialize
+	command_line.poison_system_directories.
+	* lexsup.c (enum option_values): Add
+	OPTION_NO_POISON_SYSTEM_DIRECTORIES.
+	(ld_options): Add --no-poison-system-directories.
+	(parse_args): Handle new option.
+
+2007-06-13  Nathan Sidwell  <nathan@codesourcery.com>
+
+	ld/
+	* ldexp.c (foldname): ALIGNOF should not be divided by opb.
+
+2007-06-11  Julian Brown  <julian@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_vfp11_erratum_scan): Skip BFDs with
+	EXEC_P or DYNAMIC flags, and skip sections which are being linked
+	with --just-symbols (-R).
+
+2007-06-11  Nathan Sidwell  <nathan@codesourcery.com>
+
+	binutils/
+	* dwarf.c (decode_location_expression): Add DW_OP_form_tls_address.
+
+	ld/
+	* ldlex.l, ldgram.y: Add ALIGNOF.
+	* ldexp.c (exp_print_token, foldname): Likewise.
+	* ld.texinfo: Likewise.
+
+	ld/testsuite/
+	* ld-scripts/alignof.s: New.
+	* ld-scripts/alignof.t: New
+	* ld-scripts/alignof.exp: New.
+
+2007-06-06  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (s_align): Pad code sections appropriately.
+
+	gas/testsuite/
+	* gas/arm/thumb.d: Update expected output.
+	* gas/arm/thumb2_relax.d: Ditto.
+
+2007-06-06  Joseph Myers  <joseph@codesourcery.com>
+            Paul Brook  <paul@codesourcery.com>
+
+	gas/
+	* remap.c: New.
+	* as.h (remap_debug_filename, add_debug_prefix_map): Declare.
+	* as.c (show_usage): Document --debug-prefix-map option.
+	(parse_args): Handle --debug-prefix-map.
+	* dwarf2dbg.c (out_file_list, out_debug_info): Remap debug paths.
+	* stabs.c (stabs_generate_asm_file): Remap debug paths.
+	* Makefile.am (GAS_CFILES): Add remap.c
+	(GENERIC_OBJS): Add remap.o.
+	* Makefile.in: Regenerate.
+	* doc/as.texinfo (--debug-prefix-map): Document.
+
+2007-06-05  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (insns): Correct Thumb-2 ldrd/strd opcodes.
+
+	gas/testsuite/
+	* gas/arm/thumb32.d: Add writeback addressing mode tests.
+	* gas/arm/thumb32.s: Update expected output.
+
+	opcodes/
+	* arm-dis.c (thumb32_opcodes): Display writeback ldrd/strd addresses.
+
+2007-06-04  Joseph Myers  <joseph@codesourcery.com>
+
+	bfd/
+	* elflink.c (bfd_elf_link_record_dynamic_symbol): Do not set
+	dynindx for indirect symbols.
+
+2007-05-31  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (insns): Allow strex on M profile cores.
+
+2007-05-27  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Bug 1652
+	gas/
+	* app.c (do_scrub_chars): Cope with \ at end of buffer.
+	
+	* release-notes-csl.xml: Document fix.
+
+2007-03-25  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	gas/
+	* config/tc-arm.c (T2_SUBS_PC_LR): Define.
+	(do_t_add_sub): Correctly encode subs pc, lr, #const.
+	(do_t_mov_cmp): Correctly encode movs pc, lr.
+
+	gas/testsulte/
+	* gas/arm/thumb32.s: Add tests for subs pc, lr.
+	* gas/arm/thumb32.d: Change error-output: to stderr:.
+	Update expected output.
+
+2007-05-24  Nathan Sidwell  <nathan@codesourcery.com>
+
+	ld/
+	* ldlex.l: ASSERT is recognized in SCRIPT env.  NAMES cannot
+	contain commas in EXP env.
+	* ldgram.y (extern_name_list): Push to EXP env, move body to ...
+	(extern_name_list_body): ... here.
+	(script_file, ifile_list): Reformat.
+	(statement): Add ASSERT.
+
+	ld/testsuite/
+	* ld/ld-scripts/assert.t: Add additional cases.
+	* ld-scripts/extern.t, ld-scripts/extern.s,
+	ld-scripts/extern.exp: New.
+
+2007-05-22  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	ld/testsuite/
+	* ld-arm/arm-pic-veneer.d: Update expected output.
+	* ld-arm/arm-call.d: Ditto.
+
+	bfd/
+	* elf32-arm.c (output_arch_syminfo): Replace plt_shndx and plt_offset
+	with sec and sec_shndx.
+	(elf32_arm_ouput_plt_map_sym): Use them.
+	(elf32_arm_output_arch_local_syms): Output mapping symbols for
+	interworking glue.
+
+2007-05-22  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF.
+	bunutils/
+	* objdump.c (find_symbol_for_address): Merge section and target
+	specific filtering code.
+
+	ld/testsuite/
+	* ld-arm-mixed-lib.d: Update expected output.
+	* ld-arm/arm-app.d: Ditto.
+	* ld-arm/mixed-app.d: Ditto.
+	* ld-arm/arm-lib-plt32.d: Ditto.
+	* ld-arm/arm-app-abs32.d: Ditto.
+	* ld-arm/mixed-app-v5.d: Ditto.
+	* ld-arm/armthumb-lib.d: Ditto.
+	* ld-arm/arm-lib.d: Ditto.
+
+	gas/testsuite/
+	* gas/arm/backslash-at.d: Update expected output.
+
+2007-05-21  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	binutils/
+	2007-05-21  Richard Sandiford  <richard@codesourcery.com>
+
+	* objdump.c (disassemble_bytes): Ignore disassembler_needs_relocs
+	for executables and shared libraries.
+
+	ld/testsuite/
+	2007-05-21  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-arm/emit-relocs1.d, ld-arm/emit-relocs1.s,
+	* ld-arm/emit-relocs1-vxworks.d: New tests.
+	* ld-arm/arm-elf.exp: Run them.
+	* ld-arm/vxworks1.dd: Expect proper branch targets.
+
+2007-05-18  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (LONG_BRANCH_VIA_COND): New.
+	(BRANCHBWPL, FRAG_VAR_SIZE): New.
+	(md_relax_table): Add BRANCHBWPL entries.
+	(m68k_ip): Choose BRANCHBWPL relaxation if necessary.
+	(md_assemble): Use FRAG_VAR_SIZE.
+	(md_convert_frag_1): Add BRANCHBWPL cases.
+	(md_estimate_size_before_relaz): Likewise.
+
+	gas/testsuite/
+	* gas/m68k/br-isaa.d: Dump relocs too.
+	* gas/m68k/br-isab.d: Likewise.
+	* gas/m68k/br-isac.d: Likewise.  Adjust for long branch relaxation.
+
+2007-05-18  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml: Add release notes for .set change.
+
+2007-05-18  Joseph Myers  <joseph@codesourcery.com>
+
+	ld/testsuite/
+	* ld-elf/group.ld: Discard .reginfo.
+
+2007-05-18  Joseph Myers  <joseph@codesourcery.com>
+
+	gas/
+	* config/tc-mips.c (s_mipsset): Use generic s_set for directives
+	containing a comma.
+
+2007-05-18  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	ld/
+	2007-05-18  Richard Sandiford  <richard@codesourcery.com>
+
+	* emulparams/elf32ebmipvxworks.sh (OTHER_READONLY_SECTIONS)
+	(OTHER_READWRITE_SECTIONS): Define.  Add .rdata sections.
+
+2007-05-18  Paul Brook  <paul@codesourcery.com>
+
+	Backport from FSF:
+	bfd/
+	* elf32-arm.c (ARM2THUMB_V5_STATIC_GLUE_SIZE): Define.
+	(a2t1v5_ldr_insn, a2t1v5_ldr_insn): New.
+	(record_arm_to_thumb_glue): Add v5t non-pic glue.
+	(elf32_arm_create_thumb_stub): Ditto.
+
+	ld/testsuite/
+	* ld-arm/arm-call.d: Update expected output.
+
+2007-05-16  Paul Brook  <paul@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (elf32_arm_link_hash_entry): Add
+	plt_maybe_thumb_refcount.
+	(elf32_arm_link_hash_newfunc): Set plt_maybe_thumb_refcount.
+	(elf32_arm_copy_indirect_symbol): Ditto.
+	(elf32_arm_adjust_dynamic_symbol): Ditto.
+	(bfd_elf32_arm_process_before_allocation): Handle R_ARM_THM_JUMP24.
+	(arm_add_to_rel): Ditto.
+	(elf32_arm_final_link_relocate): Merge R_ARM_THM_JUMP24 with
+	R_ARM_THM_CALL.  Handle R_ARM_THM_JUMP19 against a PLT stub.
+	(elf32_arm_gc_sweep_hook): Call check_use_blx.  Update plt counts
+	for R_ARM_THM_JUMP24 and R_ARM_THM_JUMP19.
+	(elf32_arm_check_relocs): Update plt counts for R_ARM_THM_JUMP24
+	and R_ARM_THM_JUMP19.  
+	(allocate_dynrelocs): Use plt_maybe_thumb_refcount.
+	(elf32_arm_finish_dynamic_symbol): Ditto.
+	(elf32_arm_output_plt_map): Ditto.
+
+2007-05-16  Paul Brook  <paul@codesourcery.com>
+
+	* config/tc-arm.c (v7m_psrs): Add uppercase PSR names and xpsr.
+
+2007-05-16  Joseph Myers  <joseph@codesourcery.com>
+
+	binutils/testsuite/
+	* binutils-all/strip-3.d: Strip .pdr section.
+
+2007-05-16  Nathan Sidwell  <nathan@codesourcery.com>
+
+	ld/testsuite/
+	* ld-m68k-merge-error-1a.d: Mismatch is an error.
+	* ld-m68k-merge-error-1b.d: Likewise.
+	* ld-m68k-merge-error-1c.d: Likewise.
+	* ld-m68k-merge-error-1d.d: Likewise.
+	* ld-m68k-merge-error-1e.d: Likewise.
+
+	gas/
+	* config/tc-m68k.c (md_apply_fix): Show value of out of range
+	fixups in error message.
+	(md_conver_frag_1): Propagate the fix source location and use
+	as_bad_where rather than fatal, for better error messages.
+
+2007-05-15  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	ld/testsuite/
+	2007-05-15  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-arm/vxworks1.ld: Swap .bss and .data.
+	* ld-arm/vxworks1-lib.rd: Update accordingly.
+	* ld-arm/vxworks1-lib.td: New test.
+	* ld-arm/arm-elf.exp: Run it.
+
+	* ld-i386/vxworks1.ld: Swap .bss and .data.
+	* ld-i386/vxworks1-lib.rd: Update accordingly.
+	* ld-i386/vxworks1-lib.td: New test.
+	* ld-i386/i386.exp: Run it.
+
+	* ld-mips-elf/vxworks1.ld: Swap .bss and .data.
+	* ld-mips-elf/vxworks1-lib.rd: Update accordingly.
+	* ld-mips-elf/vxworks1.rd: Likewise.
+
+	* ld-powerpc/vxworks1.ld: Swap .bss and .data.
+	* ld-powerpc/vxworks1-lib.rd: Update accordingly.
+	* ld-powerpc/vxworks1-lib.td: New test.
+	* ld-powerpc/powerpc.exp: Run it.
+
+	* ld-sh/vxworks1.ld: Swap .bss and .data.
+	* ld-sh/vxworks1-lib.rd: Update accordingly.
+	* ld-sh/vxworks1-lib.td: New test.
+	* ld-sh/sh-vxworks.exp: Run it.
+
+	* ld-sparc/vxworks1.ld: Swap .bss and .data.
+	* ld-sparc/vxworks1-lib.rd: Update accordingly.
+	* ld-sparc/vxworks1-lib.td: New test.
+	* ld-sparc/sparc.exp: Run it.
+
+2007-05-15  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-05-15  Richard Sandiford  <richard@codesourcery.com>
+
+	* elfxx-mips.c (mips_elf_create_local_got_entry): Remove
+	input_section argument.  Create .rela.dyn relocations against
+	symbol 0 rather than the section symbol.
+	(mips_elf_local_got_index): Remove input_section argument.
+	Update call to mips_elf_create_local_got_entry.
+	(mips_elf_got_page, mips_elf_got16_entry): Likewise.
+	(mips_elf_calculate_relocation): Update calls to
+	mips_elf_local_got_index, mips_elf_got16_entry and mips_elf_got_page.
+
+	ld/testsuite/
+	2007-05-15  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-mips-elf/vxworks1-lib.rd: Expect the GOT relocation to be
+	against symbol 0.
+
+2007-05-14  Richard Sandiford  <richard@codesourcery.com>
+
+	bfd/
+	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Initialize
+	_bfd_copy_link_hash_symbol_type.
+
+2007-05-14  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	bfd/
+	2007-05-12  Alan Modra  <amodra@bigpond.net.au>
+	PR 4497
+	* elf-eh-frame.c (struct cie): Add "local_personality".  Make
+	"personality" a union.
+	(cie_eq): Compare local_personality too.  Adjust personality
+	comparison.
+	(_bfd_elf_discard_section_eh_frame): Check binding on personality
+	reloc sym to allow for bad symtab.  Use stashed local syms rather
+	than reading personality local sym.  Handle discarded sections.
+
+2007-05-14  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	ld/testsuite/
+	2007-05-14  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-sh/vxworks1.dd: Remove hexadecimal prefixes from constant pool
+	contents.  Consistently use "!" as the comment character.
+	Consistently use _PROCEDURE_LINKAGE_TABLE_ in the first PLT entry.
+	* ld-sh/vxworks1-le.dd: Likewise.
+	* ld-sh/vxworks1-lib.dd: Likewise.
+	* ld-sh/vxworks1-lib-le.dd: Likewise.
+	* ld-sh/vxworks3.dd: Likewise.
+	* ld-sh/vxworks3-le.dd: Likewise.
+
+2007-05-11  Paul Brook  <paul@codesourcery.com>
+
+	ld/
+	* ldexp.c (exp_fold_tree_1): Copy symbol type for simple
+	assignments.
+
+	ld/testsuite/
+	* ld-arm/script-type.s: New test.
+	* ld-arm/arm-elf.exp: New test.
+	* ld-arm/script-type.ld: New test.
+
+	bfd/
+	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
+	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
+	prototype.
+	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
+	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New
+	function.
+	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
+	_copy_link_hash_symbol_type.
+	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
+	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
+	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
+	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
+	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
+	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
+	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
+	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
+	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
+	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
+	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
+	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
+	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
+	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
+	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
+	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
+	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
+	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
+	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
+	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
+	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
+	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
+	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
+	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
+	* bfd-in2.h: Regenerate.
+	* libbfd.h: Regenerate.
+
+2007-05-11  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline:
+	gas/
+	2007-04-30  Alan Modra  <amodra@bigpond.net.au>
+	PR 4436
+	* config/tc-ppc.c (ppc_insert_operand): Disable range check if
+	min > max.
+
+	opcodes/
+	2007-04-30  Alan Modra  <amodra@bigpond.net.au>
+	PR 4436
+	* ppc-opc.c (powerpc_operands): Correct bitm for second entry of MBE.
+
+	gas/
+	2007-05-02  Alan Modra  <amodra@bigpond.net.au>
+	PR 4448
+	* config/tc-ppc.c (ppc_insert_operand): Don't increase min for
+	PPC_OPERAND_PLUS1.
+
+	include/opcode/
+	2007-05-02  Alan Modra  <amodra@bigpond.net.au>
+	* ppc.h (PPC_OPERAND_PLUS1): Update comment.
+
+2007-05-10  Carlos O'Donell  <carlos@codesourcery.com>
+
+	* Makefile.tpl: Add install-pdf to install target deps.
+	* Makefile.in: Regenerate.
+
+2007-05-10  Carlos O'Donell  <carlos@codesourcery.com>
+
+	bfd/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am 
+	and install-pdf-recursive targets. Define pdfdir.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target. 
+	* configure: Regenerate.
+	* Makefile.in: Regenerate
+	* doc/Makefile.in: Regenerate.
+
+	binutils/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* doc/Makefile.in: Regenerate.
+
+	etc/
+	* configure.in: ACSUBST pdfdir.
+	* configure: Regenerate.
+
+	opcodes/
+	* Makefile.am: Add install-pdf target.
+	* po/Make-in: Add install-pdf target.
+	* Makefile.in: Regenerate.
+
+	gas/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* doc/Makefile.in: Regenerate.
+
+	gprof/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets. Define pdf__strip_dir.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+	ld/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets. Define pdf__strip_dir.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2007-05-10  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 1569
+	Backport from mainline:
+	bfd/
+	2007-05-11  Alan Modra  <amodra@bigpond.net.au>
+	PR 4454
+	* elf-eh-frame.c (struct cie): Make "personality" a bfd_vma.
+	(_bfd_elf_discard_section_eh_frame): Handle local syms on
+	personality relocation.
+
+2007-05-10  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* Makefile.tpl: Add install-pdf to install target deps.
+	* Makefile.in: Regenerate.
+
+2007-05-10  Carlos O'Donell  <carlos@codesourcery.com>
+
+	bfd/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am 
+	and install-pdf-recursive targets. Define pdfdir.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target. 
+	* configure: Regenerate.
+	* Makefile.in: Regenerate
+	* doc/Makefile.in: Regenerate.
+
+	binutils/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* doc/Makefile.in: Regenerate.
+
+	etc/
+	* configure.in: ACSUBST pdfdir.
+	* configure: Regenerate.
+
+	opcodes/
+	* Makefile.am: Add install-pdf target.
+	* po/Make-in: Add install-pdf target.
+	* Makefile.in: Regenerate.
+
+	gas/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets.
+	* doc/Makefile.am: Define pdf__strip_dir. Add
+	install-pdf and install-pdf-am targets.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* doc/Makefile.in: Regenerate.
+
+	gprof/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets. Define pdf__strip_dir.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+	ld/
+	* configure.in: ACSUBST pdfdir.
+	* Makefile.am: Add install-pdf, install-pdf-am,
+	and install-pdf-recursive targets. Define pdf__strip_dir.
+	* po/Make-in: Add install-pdf target.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	* elf32-arm.c (elf32_arm_check_relocs): Don't create PLT entries
+	for R_ARM_ABS12 relocs.
+	(elf32_arm_finish_dynamic_symbol): Fix the loop that creates
+	non-shared VxWorks PLT entries.
+
+	ld/testsuite/
+	2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-arm/vxworks1-lib.dd: Expect "push" instead of stmdb and
+	"pop" instead of ldmia.  Don't require specific symbolic addresses
+	for in-text addresses.  Expect data to be rendered as .words rather
+	than disassembled.
+	* ld-arm/vxworks1.dd: Likewise.
+
+2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	Backport from mainline:
+
+	bfd/
+	2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	* elf.c (assign_file_positions_for_load_sections): Use p_memsz
+	rather than p_filesz to calculate the LMA of the end of a segment.
+
+	ld/testsuite/
+	2007-05-10  Richard Sandiford  <richard@codesourcery.com>
+
+	* ld-elf/multibss1.d, ld-elf/multibss1.s: New test.
+
+2007-05-10  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 1569
+	Backport from mainline:
+	bfd/
+	2007-05-11  Alan Modra  <amodra@bigpond.net.au>
+	PR 4454
+	* elf-eh-frame.c (struct cie): Make "personality" a bfd_vma.
+	(_bfd_elf_discard_section_eh_frame): Handle local syms on
+	personality relocation.
+
+2007-05-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* release-notes-csl.xml: Document fix.
+
+	opcodes/
+	* m68k-opc.c (m68k_opcodes): Add wdebugl variants.
+
+2007-05-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	* release-notes-csl.xml: Insert a blank line before the first
+	release note fragment.
+
+2007-05-04  Mark Shinwell  <shinwell@codesourcery.com>
+
+	* release-notes-csl.xml (ARM EABI compliance): New.
+
+	gas/
+	* config/te-armeabi.h (EABI_DEFAULT): Use EF_ARM_EABI_VER5.
+	* config/te-armlinuxeabi.h (EABI_DEFAULT): Likewise.
+
+2007-05-04  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+	gas/testsuite/
+	* gas/m68k/all.exp: Skip fmoveml on fido.
+
+2007-05-04  Mark Shinwell  <shinwell@codesourcery.com>
+
+	binutils/testsuite/
+	* binutils-all/strip-3.d: Strip .ARM.attributes section.
+
+2007-05-04  Mark Shinwell  <shinwell@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-04-20  Mark Shinwell  <shinwell@codesourcery.com>
+
+	* release-notes-csl.xml (Conditional Thumb-2 branch
+	instructions): New.
+
+	bfd/
+	* elf32-arm.c (elf32_arm_final_link_relocate): Correctly
+	handle the Thumb-2 JUMP19 relocation.
+
+	ld/testsuite/
+	* ld-arm/arm-elf.exp: Add jump19 testcase.
+	* ld-arm/jump19.d: New.
+	* ld-arm/jump19.s: New.
+
+2007-05-04  Mark Shinwell  <shinwell@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-04-20  Mark Shinwell  <shinwell@codesourcery.com>
+ 
+	* release-notes-csl.xml (Linking of non-ELF images): New.
+
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_vfp11_erratum_scan): Don't
+	attempt to scan if the bfd doesn't correspond to an ELF image.
+	(bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
+
+2007-05-03  Mark Shinwell  <shinwell@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-04-27  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (md_apply_fix): Generate more accurate
+	diagnostic when 8-bit immediate range is exceeded for
+	BFD_RELOC_ARM_OFFSET_IMM8.
+
+2007-05-03  Sandra Loosemore  <sandra@codesourcery.com>
+
+	bfd/
+	* elf32-arm.c (allocate_dynrelocs): Fix typo in comment.
+
+2007-05-03  Paul Brook  <paul@codesourcery.com>
+
+	Merge from CSL-2.17 branch.
+	2007-04-17  Paul Brook  <paul@codesourcery.com>
+	gas/
+	* config/tc-arm.c (arm_ext_msr): New variable.
+	(md_assemble): Allow v6-M 32-bit instructions without requiring
+	Thumb-2.
+	(insns): Use arm_ext_msr for Thumb MSR and MRS.
+	(cpu_arch): Add V6M. Fix numbering of V6K and V6T2.
+	gas/testsuite/
+	* gas/arm/archv6m.d: New test.
+	* gas/arm/archv6m.s: New test.
+	include/opcode/
+	* arm.h (ARM_EXT_THUMB_MSR): Define.
+	(ARM_AEXT_V6T2, ARM_AEXT_V6M): Use it.
+
+	2006-12-15  Paul Brook  <paul@codesourcery.com>
+	gas/
+	* config/tc-arm.c (arm_ext_barrier, arm_ext_m): New.
+	(do_t_mrs): Use arm_ext_m.
+	(insns): Allow dmb, dsb and isb on ARMv6-M.
+	(arm_cpu_option_table): Add cortex-m1.
+	(arm_arch_option_table): Add armv6-m.
+	(aeabi_set_public_attributes): Use arm_ext_m.
+	include/
+	* opcode/arm.h (ARM_EXT_V6M, ARM_EXT_BARRIER, ARM_AEXT_V6M,
+	ARM_ARCH_V6M): Define.
+	(ARM_AEXT_V7_ARM, ARM_AEXT_V7M): Include ARM_EXT_BARRIER.
+
+2007-04-27  Mark Shinwell  <shinwell@codesourcery.com>
+
+	* release-notes-csl.xml (The \@ assembler pseudo-variable):
+	New.
+
+	gas/
+	* app.c (do_scrub_chars): Don't damage \@ pseudo-variables.
+
+	gas/testsuite/
+	* gas/arm/backslash-at.d: New.
+	* gas/arm/backslash-at.s: New.
+
+2007-04-25  Mark Mitchell  <mark@codesourcery.com>
+
+	libiberty/
+	* cygpath.c (<process.h>): Include it.
+	(cygpath_log): New variable.
+	(cygpath_log_msg_arg): New function.
+	(cygpath_log_msg): Likewise.
+	(cygpath_perror): Likewise.
+	(cygpath_close): Declare as prototyped function.  Close the log
+	file.
+	(cygpath): Log interaction with cygpath.  If cygpath dies
+	unexpectedly, restart it.
+	(set_errno_from_windows_code): Avoid signed/unsigned comparison.
+
+2007-04-23  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-01-24  Joseph Myers  <joseph@codesourcery.com>
+	bfd/
+	* config.bfd (mips*el-*-linux*, mips*-*-linux*): Remove
+	ecoff_little_vec and ecoff_big_vec.
+
+2007-04-23  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* release-notes-csl.xml (Binutils update): New.
+
+2007-04-23  Richard Sandiford  <richard@codesourcery.com>
+
+	gas/testsuite/
+	* gas/mips/ulh3.s, gas/mips/ulh3-el.d, gas/mips/ulh3-eb.d,
+	* gas/mips/octeon1.s, gas/mips/octeon1.l, gas/mips/octeon2.s,
+	* gas/mips/octeon2-un.d, gas/mips/octeon2-noun.d,
+	* gas/mips/octeon2-mix.d, gas/mips/octeon3.s,
+	* gas/mips/octeon3.d: New tests.
+	* gas/mips/mips.exp: Run them.  Don't run ulh2 on mips32r2 targets.
+
+2007-04-23  Richard Sandiford  <richard@codesourcery.com>
+
+	Adapted from a patch by Cavium Networks.
+
+	include/elf/
+	* mips.h (E_MIPS_MACH_OCTEON): New macro.
+
+	include/opcode/
+	* mips.h: Document '^', ';' and 'y'.
+	(OP_MASK_BITIND, OP_SH_BITIND): New macros.
+	(INSN_OCTEON, CPU_OCTEON): Likewise.
+	(OPCODE_IS_MEMBER): Handle CPU_OCTEON.
+
+	bfd/
+	* archures.c (bfd_mach_mips_octeon): Define.
+	* bfd-in2.h: Regenerate.
+	* cpu-mips.c (I_mipsocteon): Define.
+	(arch_info_struct): Add a "mips:octeon" entry.
+	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_OCTEON.
+	(mips_set_isa_flags): Handle bfd_mach_mips_octeon.
+	(mips_mach_extensions): List bfd_mach_mips_octeon as an extension
+	of bfd_mach_mipsisa64.
+
+	binutils/
+	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_OCTEON.
+
+	opcodes/
+	* mips-dis.c (octeon_use_unalign): New variable.
+	(mips_cp0_names_octeon, mips_cp0sel_names_octeon): New tables.
+	(mips_arch_choices): Add an octeon entry.
+	(parse_mips_dis_option): Handle octeon-useun and no-octeon-useun.
+	(print_insn_args): Handle '^' and 'y'.
+	(print_insn_mips): Skip aliases of uld, ulw, usd and usw when
+	unaligned octeon instructions are allowed.  Print ldr, lwr,
+	sdr and swr as nops in that case.
+	(print_mips_disassembler_options): Print help for octeon-useun and
+	no-octeon-useun.
+	* mips-opc.c (IOCTEON): Define.
+	(mips_builtin_opcodes): Add Octeon baddu, bbit032, bbit0, bbit132,
+	bbit1, cins32, cins, dmul, dpop, exts32, exts, exts, mtm0, mtm1,
+	mtm2, mtp0, mtp1, mtp2, pop, seq, seqi, sne, snei, syncio,
+	synciobdma, syncioall, syncs, syncw, syncws, uld, ulw, usd, usw,
+	v3mulu, vmm0, vmulu, dmfc2 and dmtc2 instructions.
+
+	gas/
+	* config/tc-mips.c (octeon_use_unalign): New variable.
+	(ISA_HAS_INS): New macro.
+	(CPU_HAS_DROR): Return true for CPU_OCTEON.
+	(CPU_HAS_INS): New macro.
+	(macro_build): Handle '^' and 'y'.
+	(macro2): Try to use "ins" instead of "sll" and "or" in the
+	implementation of ulh and ulhu.  Treat uld, ulw, usd and usw
+	as normal stores if the Octeon unaligned instructions are allowed.
+	(validate_mips_insn): Handle '^', ';' and 'y'.
+	(mips_ip): Ignore the uld, ulw, usd and usw hardware instructions
+	unless they have been enabled.  Refuse to assemble left/right stores
+	when uld, ulw, usd and usw are enabled.  Handle '^', ';' and 'y'.
+	(OPTION_OCTEON_UNALIGNED, OPTION_NO_OCTEON_UNALIGNED): New macros.
+	(OPTION_ELF_BASE): Bump by two.
+	(md_longopts): Add -mocteon-useun and -mno-octeon-useun.
+	(md_parse_option): Handle them.
+	(mips_cpu_info_table): Add an "octeon" entry.
+	(md_show_usage): Mention -mocteon-useun and -mno-octeon-useun.
+
+2007-04-22  Mark Shinwell  <shinwell@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-02-02  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gas/
+	* config/tc-arm.c (arm_ext_marvell_f): New.
+	(do_marvell_div): New.
+	(insns): Add entries for Marvell-specific sdiv and udiv encodings.
+	(arm_cpu_option_table): Add marvell-f entry.
+	(arm_arch_option_table): Add marvell-f entry.
+	* include/opcode/arm.h (ARM_CEXT_MARVELL_F): New.
+	(ARM_ARCH_MARVELL_F): New.
+	
+	gas/testsuite/
+	* gas/arm/marvell-f-div.d: New.
+	* gas/arm/marvell-f-div.s: New.
+
+	2007-01-03  Mark Shinwell  <shinwell@codesourcery.com>
+
+	NOT ASSIGNED TO FSF
+	Port from Marvell compiler:
+	gas/
+	* config/tc-arm.c (arm_cpus): Add marvell-f entry.
+
+2007-04-20  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/testsuite/
+	* gas/m68k/br-isaa.s: New.
+	* gas/m68k/br-isaa.d: New.
+	* gas/m68k/br-isab.s: New.
+	* gas/m68k/br-isab.d: New.
+	* gas/m68k/br-isac.s: New.
+	* gas/m68k/br-isac.d: New.
+	* gas/m68k/all.exp: Adjust.
+
+	gas/
+	* config/tc-m68k.c (mcf54455_ctrl): New.
+	(HAVE_LONG_DISP, HAVE_LONG_CALL, HAVE_LONG_COND): New.
+	(m68k_archs): Add isac.
+	(m68k_cpus): Add 54455 family.
+	(m68k_ip): Split Bg into Bb, Bs, Bg.
+	(m68k_elf_final_processing): Add ISA_C.
+	* doc/c-m68k.texi (M680x0 Options): Add isac.
+
+	include/opcode/
+	* m68k.h (mcfisa_c): New.
+	(mcfusp, mcf_mask): Adjust.
+
+	bfd/
+	* archures.c (bfd_mach_mcf_isa_c, bfd_mach_mcf_isa_c_mac,
+	bfd_mach_mcf_isa_c_emac): New.
+	* elf32-m68k.c (ISAC_PLT_ENTRY_SIZE, elf_isac_plt0_entry,
+	elf_isac_plt_entry, elf_isac_plt_info): New.
+	(elf32_m68k_object_p): Add ISA_C.
+	(elf32_m68k_print_private_bfd_data): Print ISA_C.
+	(elf32_m68k_get_plt_info): Detect ISA_C.
+	* cpu-m68k.c (arch_info): Add ISAC.
+	(m68k_arch_features): Likewise,
+	(bfd_m68k_compatible): ISAs B & C are not compatible.
+
+	opcodes/
+	* m68k-opc.c: Mark mcfisa_c instructions.
+
+2007-04-20  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-03-20  Joseph Myers  <joseph@codesourcery.com>
+	Based on patch by Mark Hatle <mark.hatle@windriver.com>.
+	ld/
+	* configure.in (--enable-poison-system-directories): New option.
+	* configure, config.in: Regenerate.
+	* ldfile.c (ldfile_add_library_path): If
+	ENABLE_POISON_SYSTEM_DIRECTORIES defined, warn for use of /lib,
+	/usr/lib, /usr/local/lib or /usr/X11R6/lib.
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-03-22  Julian Brown  <julian@codesourcery.com>
+	bfd/
+	* elf32-arm.c (bfd_elf32_arm_set_vfp11_fix): Default to fixing for
+	scalar code on pre-ARMv7.
+	ld/
+	* ld.texinfo: Document this default.
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-03-23  Richard Sandiford  <richard@codesourcery.com>
+	bfd/
+	From Phil Edwards <phil@codesourcery.com>:
+	* cache.c (bfd_cache_delete): Work around ClearCase bug.
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2006-04-12  Carlos O'Donell  <carlos@codesourcery.com>
+	* Makefile.tpl: Add install-html to install target deps.
+	* Makefile.in: Regenerate.
+
+2007-04-20  Mark Mitchell  <mark@codesourcery.com>
+            Vladimir Prus  <vladimir@codesourcery.com>
+            Carlos O'Donell  <carlos@codesourcery.com>
+            Joseph Myers  <joseph@codesourcery.com>
+
+	libiberty/
+	* configure.ac: Add cygpath for mingw hosts.
+	* configure: Rebuilt.
+	* Makefile.in: Add cygpath.
+	* cygpath.c: New.
+
+2007-04-20  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ binutils 2.17:
+
+	2007-03-01  Joseph Myers  <joseph@codesourcery.com>
+	gas/
+	* configure.in (mips64el-sicortex-linux-gnu): Set
+	mips_default_abi=N64_ABI.
+	* configure: Regenerate.
+
+	2007-02-20  Carlos O'Donell  <carlos@codesourcery.com>
+	Issue #1271
+	ld/
+	* configure.tgt (mips64el-sicortex-linux-gnu): Set targ_emul to
+	elf64ltsmip, and set targ_extra_emuls appropriately.
+
+2007-04-20  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gas/
+	* config/tc-m68k.c (mcf5253_ctrl): New.
+	(mcf52223_ctrl): New.
+	(m68k_cpus): Add 5253, 52221, 52223.
+
+	gas/
+	* config/m68k-parse.h (RAMBAR_ALT): New.
+	* config/tc-m68k.c (mcf5206_ctrl, mcf5307_ctrl): New.
+	(mcf_ctrl, mcf5208_ctrl, mcf5210a_ctrl, mcf5213_ctrl, mcf52235_ctrl,
+	mcf5225_ctrl, mcf5235_ctrl, mcf5271_ctrl, mcf5275_ctrl,
+	mcf5282_ctrl, mcf5329_ctrl, mcf5373_ctrl, mcfv4e_ctrl,
+	mcf5475_ctrl, mcf5485_ctrl): Add RAMBAR synonym for
+	RAMBAR1.
+	(mcf5272_ctrl): Add RAMBAR0, replace add RAMBAR with RAMBAR_ALT.
+	(m68k_cpus): Adjust 5206, 5206e & 5307 entries.
+	(m68k_ip) <Case J>: Detect when RAMBAR_ALT should be used.  Add it
+	to control register mapping.
+
+	gas/testsuite/
+	* gas/m68k/ctrl-1.d, gas/m68k/ctrl-1.s: New.
+	* gas/m68k/ctrl-2.d, gas/m68k/ctrl-2.s: New.
+	* gas/m68k/all.exp: Add them.
+
+	opcodes/
+	* m68k-dis.c (print_insn_arg): Show c04 as rambar0 and c05 as
+	rambar1.
+
+
+Local Variables:
+mode: change-log
+change-log-default-name: "ChangeLog.csl"
+End:
--- a/Makefile.def
+++ b/Makefile.def
@@ -128,6 +128,7 @@ host_modules= { module= libtermcap; no_c
                 missing=distclean;
                 missing=maintainer-clean; };
 host_modules= { module= utils; no_check=true; };
+host_modules= { module= convert; no_check=true; };
 host_modules= { module= gnattools; };
 
 target_modules = { module= libstdc++-v3; lib_path=.libs; raw_cxx=true; };
@@ -485,6 +486,9 @@ dependencies = { module=all-send-pr; on=
 dependencies = { module=all-tar; on=all-build-texinfo; };
 dependencies = { module=all-uudecode; on=all-build-texinfo; };
 
+// MIPS special
+dependencies = { module=all-convert; on=all-libiberty; };
+
 // Target modules.  These can also have dependencies on the language
 // environment (e.g. on libstdc++).  By default target modules depend
 // on libgcc and newlib/libgloss.
--- a/Makefile.in
+++ b/Makefile.in
@@ -744,6 +744,7 @@ configure-host:  \
     maybe-configure-tk \
     maybe-configure-libtermcap \
     maybe-configure-utils \
+    maybe-configure-convert \
     maybe-configure-gnattools
 .PHONY: configure-target
 configure-target:  \
@@ -903,6 +904,7 @@ all-host: maybe-all-guile
 all-host: maybe-all-tk
 all-host: maybe-all-libtermcap
 all-host: maybe-all-utils
+all-host: maybe-all-convert
 all-host: maybe-all-gnattools
 
 .PHONY: all-target
@@ -1019,6 +1021,7 @@ info-host: maybe-info-guile
 info-host: maybe-info-tk
 info-host: maybe-info-libtermcap
 info-host: maybe-info-utils
+info-host: maybe-info-convert
 info-host: maybe-info-gnattools
 
 .PHONY: info-target
@@ -1128,6 +1131,7 @@ dvi-host: maybe-dvi-guile
 dvi-host: maybe-dvi-tk
 dvi-host: maybe-dvi-libtermcap
 dvi-host: maybe-dvi-utils
+dvi-host: maybe-dvi-convert
 dvi-host: maybe-dvi-gnattools
 
 .PHONY: dvi-target
@@ -1237,6 +1241,7 @@ pdf-host: maybe-pdf-guile
 pdf-host: maybe-pdf-tk
 pdf-host: maybe-pdf-libtermcap
 pdf-host: maybe-pdf-utils
+pdf-host: maybe-pdf-convert
 pdf-host: maybe-pdf-gnattools
 
 .PHONY: pdf-target
@@ -1346,6 +1351,7 @@ html-host: maybe-html-guile
 html-host: maybe-html-tk
 html-host: maybe-html-libtermcap
 html-host: maybe-html-utils
+html-host: maybe-html-convert
 html-host: maybe-html-gnattools
 
 .PHONY: html-target
@@ -1455,6 +1461,7 @@ TAGS-host: maybe-TAGS-guile
 TAGS-host: maybe-TAGS-tk
 TAGS-host: maybe-TAGS-libtermcap
 TAGS-host: maybe-TAGS-utils
+TAGS-host: maybe-TAGS-convert
 TAGS-host: maybe-TAGS-gnattools
 
 .PHONY: TAGS-target
@@ -1564,6 +1571,7 @@ install-info-host: maybe-install-info-gu
 install-info-host: maybe-install-info-tk
 install-info-host: maybe-install-info-libtermcap
 install-info-host: maybe-install-info-utils
+install-info-host: maybe-install-info-convert
 install-info-host: maybe-install-info-gnattools
 
 .PHONY: install-info-target
@@ -1673,6 +1681,7 @@ install-pdf-host: maybe-install-pdf-guil
 install-pdf-host: maybe-install-pdf-tk
 install-pdf-host: maybe-install-pdf-libtermcap
 install-pdf-host: maybe-install-pdf-utils
+install-pdf-host: maybe-install-pdf-convert
 install-pdf-host: maybe-install-pdf-gnattools
 
 .PHONY: install-pdf-target
@@ -1782,6 +1791,7 @@ install-html-host: maybe-install-html-gu
 install-html-host: maybe-install-html-tk
 install-html-host: maybe-install-html-libtermcap
 install-html-host: maybe-install-html-utils
+install-html-host: maybe-install-html-convert
 install-html-host: maybe-install-html-gnattools
 
 .PHONY: install-html-target
@@ -1891,6 +1901,7 @@ installcheck-host: maybe-installcheck-gu
 installcheck-host: maybe-installcheck-tk
 installcheck-host: maybe-installcheck-libtermcap
 installcheck-host: maybe-installcheck-utils
+installcheck-host: maybe-installcheck-convert
 installcheck-host: maybe-installcheck-gnattools
 
 .PHONY: installcheck-target
@@ -2000,6 +2011,7 @@ mostlyclean-host: maybe-mostlyclean-guil
 mostlyclean-host: maybe-mostlyclean-tk
 mostlyclean-host: maybe-mostlyclean-libtermcap
 mostlyclean-host: maybe-mostlyclean-utils
+mostlyclean-host: maybe-mostlyclean-convert
 mostlyclean-host: maybe-mostlyclean-gnattools
 
 .PHONY: mostlyclean-target
@@ -2109,6 +2121,7 @@ clean-host: maybe-clean-guile
 clean-host: maybe-clean-tk
 clean-host: maybe-clean-libtermcap
 clean-host: maybe-clean-utils
+clean-host: maybe-clean-convert
 clean-host: maybe-clean-gnattools
 
 .PHONY: clean-target
@@ -2218,6 +2231,7 @@ distclean-host: maybe-distclean-guile
 distclean-host: maybe-distclean-tk
 distclean-host: maybe-distclean-libtermcap
 distclean-host: maybe-distclean-utils
+distclean-host: maybe-distclean-convert
 distclean-host: maybe-distclean-gnattools
 
 .PHONY: distclean-target
@@ -2327,6 +2341,7 @@ maintainer-clean-host: maybe-maintainer-
 maintainer-clean-host: maybe-maintainer-clean-tk
 maintainer-clean-host: maybe-maintainer-clean-libtermcap
 maintainer-clean-host: maybe-maintainer-clean-utils
+maintainer-clean-host: maybe-maintainer-clean-convert
 maintainer-clean-host: maybe-maintainer-clean-gnattools
 
 .PHONY: maintainer-clean-target
@@ -2490,6 +2505,7 @@ check-host:  \
     maybe-check-tk \
     maybe-check-libtermcap \
     maybe-check-utils \
+    maybe-check-convert \
     maybe-check-gnattools
 
 .PHONY: check-target
@@ -2625,6 +2641,7 @@ install-host-nogcc:  \
     maybe-install-tk \
     maybe-install-libtermcap \
     maybe-install-utils \
+    maybe-install-convert \
     maybe-install-gnattools
 
 .PHONY: install-host
@@ -2701,6 +2718,7 @@ install-host:  \
     maybe-install-tk \
     maybe-install-libtermcap \
     maybe-install-utils \
+    maybe-install-convert \
     maybe-install-gnattools
 
 .PHONY: install-target
@@ -42242,6 +42260,424 @@ maintainer-clean-utils: 
 
 
 
+.PHONY: configure-convert maybe-configure-convert
+maybe-configure-convert:
+@if gcc-bootstrap
+configure-convert: stage_current
+@endif gcc-bootstrap
+@if convert
+maybe-configure-convert: configure-convert
+configure-convert: 
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	test ! -f $(HOST_SUBDIR)/convert/Makefile || exit 0; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/convert ; \
+	$(HOST_EXPORTS) \
+	echo Configuring in $(HOST_SUBDIR)/convert; \
+	cd "$(HOST_SUBDIR)/convert" || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/convert/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/convert"; \
+	libsrcdir="$$s/convert"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption}  \
+	  || exit 1
+@endif convert
+
+
+
+
+
+.PHONY: all-convert maybe-all-convert
+maybe-all-convert:
+@if gcc-bootstrap
+all-convert: stage_current
+@endif gcc-bootstrap
+@if convert
+TARGET-convert=all
+maybe-all-convert: all-convert
+all-convert: configure-convert
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(FLAGS_TO_PASS)  $(TARGET-convert))
+@endif convert
+
+
+
+
+.PHONY: check-convert maybe-check-convert
+maybe-check-convert:
+@if convert
+maybe-check-convert: check-convert
+
+check-convert:
+
+@endif convert
+
+.PHONY: install-convert maybe-install-convert
+maybe-install-convert:
+@if convert
+maybe-install-convert: install-convert
+
+install-convert: installdirs
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(FLAGS_TO_PASS)  install)
+
+@endif convert
+
+# Other targets (info, dvi, pdf, etc.)
+
+.PHONY: maybe-info-convert info-convert
+maybe-info-convert:
+@if convert
+maybe-info-convert: info-convert
+
+info-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing info in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          info) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-dvi-convert dvi-convert
+maybe-dvi-convert:
+@if convert
+maybe-dvi-convert: dvi-convert
+
+dvi-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing dvi in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          dvi) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-pdf-convert pdf-convert
+maybe-pdf-convert:
+@if convert
+maybe-pdf-convert: pdf-convert
+
+pdf-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing pdf in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          pdf) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-html-convert html-convert
+maybe-html-convert:
+@if convert
+maybe-html-convert: html-convert
+
+html-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing html in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          html) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-TAGS-convert TAGS-convert
+maybe-TAGS-convert:
+@if convert
+maybe-TAGS-convert: TAGS-convert
+
+TAGS-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing TAGS in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          TAGS) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-install-info-convert install-info-convert
+maybe-install-info-convert:
+@if convert
+maybe-install-info-convert: install-info-convert
+
+install-info-convert: \
+    configure-convert \
+    info-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-info in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-info) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-install-pdf-convert install-pdf-convert
+maybe-install-pdf-convert:
+@if convert
+maybe-install-pdf-convert: install-pdf-convert
+
+install-pdf-convert: \
+    configure-convert \
+    pdf-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-pdf in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-pdf) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-install-html-convert install-html-convert
+maybe-install-html-convert:
+@if convert
+maybe-install-html-convert: install-html-convert
+
+install-html-convert: \
+    configure-convert \
+    html-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-html in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-html) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-installcheck-convert installcheck-convert
+maybe-installcheck-convert:
+@if convert
+maybe-installcheck-convert: installcheck-convert
+
+installcheck-convert: \
+    configure-convert 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing installcheck in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          installcheck) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-mostlyclean-convert mostlyclean-convert
+maybe-mostlyclean-convert:
+@if convert
+maybe-mostlyclean-convert: mostlyclean-convert
+
+mostlyclean-convert: 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing mostlyclean in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          mostlyclean) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-clean-convert clean-convert
+maybe-clean-convert:
+@if convert
+maybe-clean-convert: clean-convert
+
+clean-convert: 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing clean in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          clean) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-distclean-convert distclean-convert
+maybe-distclean-convert:
+@if convert
+maybe-distclean-convert: distclean-convert
+
+distclean-convert: 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing distclean in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          distclean) \
+	  || exit 1
+
+@endif convert
+
+.PHONY: maybe-maintainer-clean-convert maintainer-clean-convert
+maybe-maintainer-clean-convert:
+@if convert
+maybe-maintainer-clean-convert: maintainer-clean-convert
+
+maintainer-clean-convert: 
+	@: $(MAKE); $(unstage)
+	@[ -f ./convert/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing maintainer-clean in convert" ; \
+	(cd $(HOST_SUBDIR)/convert && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          maintainer-clean) \
+	  || exit 1
+
+@endif convert
+
+
+
 .PHONY: configure-gnattools maybe-configure-gnattools
 maybe-configure-gnattools:
 @if gcc-bootstrap
@@ -55724,6 +56160,7 @@ all-sed: maybe-all-build-texinfo
 all-send-pr: maybe-all-prms
 all-tar: maybe-all-build-texinfo
 all-uudecode: maybe-all-build-texinfo
+all-convert: maybe-all-libiberty
 configure-target-boehm-gc: maybe-configure-target-qthreads
 configure-target-boehm-gc: maybe-all-target-libstdc++-v3
 configure-target-fastjar: maybe-configure-target-zlib
--- a/bfd/aout-adobe.c
+++ b/bfd/aout-adobe.c
@@ -467,6 +467,8 @@ aout_adobe_sizeof_headers (bfd *ignore_a
 #define aout_32_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
 #define aout_32_bfd_link_add_symbols	            _bfd_generic_link_add_symbols
 #define aout_32_bfd_link_just_syms	            _bfd_generic_link_just_syms
+#define aout_32_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define aout_32_bfd_final_link		            _bfd_generic_final_link
 #define aout_32_bfd_link_split_section	            _bfd_generic_link_split_section
 
--- a/bfd/aout-target.h
+++ b/bfd/aout-target.h
@@ -520,6 +520,10 @@ MY_bfd_final_link (bfd *abfd, struct bfd
 #ifndef MY_bfd_link_just_syms
 #define MY_bfd_link_just_syms _bfd_generic_link_just_syms
 #endif
+#ifndef MY_bfd_copy_link_hash_symbol_type
+#define MY_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
+#endif
 #ifndef MY_bfd_link_split_section
 #define MY_bfd_link_split_section  _bfd_generic_link_split_section
 #endif
--- a/bfd/aout-tic30.c
+++ b/bfd/aout-tic30.c
@@ -977,6 +977,10 @@ tic30_aout_set_arch_mach (bfd *abfd,
 #ifndef MY_bfd_link_just_syms
 #define MY_bfd_link_just_syms _bfd_generic_link_just_syms
 #endif
+#ifndef MY_bfd_copy_link_hash_symbol_type
+#define MY_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
+#endif
 #ifndef MY_bfd_link_split_section
 #define MY_bfd_link_split_section  _bfd_generic_link_split_section
 #endif
--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -821,10 +821,19 @@ extern void bfd_elf32_arm_init_maps
 extern void bfd_elf32_arm_set_vfp11_fix
   (bfd *, struct bfd_link_info *);
 
+extern void bfd_elf32_arm_validate_janus_2cc_fix
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_set_cortex_a8_fix
+  (bfd *, struct bfd_link_info *);
+
 extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
   (bfd *, struct bfd_link_info *);
 
-extern void bfd_elf32_arm_vfp11_fix_veneer_locations
+extern bfd_boolean bfd_elf32_arm_janus_2cc_erratum_scan
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_fix_veneer_locations
   (bfd *, struct bfd_link_info *);
 
 /* ARM Interworking support.  Called from linker.  */
@@ -856,7 +865,7 @@ extern bfd_boolean bfd_elf32_arm_process
 
 void bfd_elf32_arm_set_target_relocs
   (bfd *, struct bfd_link_info *, int, char *, int, int, bfd_arm_vfp11_fix,
-   int, int, int);
+   int, int, int, int, int);
 
 extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
   (bfd *, struct bfd_link_info *);
@@ -894,7 +903,11 @@ extern bfd_boolean elf32_arm_size_stubs
    struct bfd_section * (*) (const char *, struct bfd_section *), void (*) (void));
 extern bfd_boolean elf32_arm_build_stubs
   (struct bfd_link_info *);
-  
+
+/* ARM unwind section editing support.  */
+extern bfd_boolean elf32_arm_fix_exidx_coverage
+  (struct bfd_section **, unsigned int, struct bfd_link_info *);
+
 /* TI COFF load page support.  */
 extern void bfd_ticoff_set_section_load_page
   (struct bfd_section *, int);
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -828,10 +828,19 @@ extern void bfd_elf32_arm_init_maps
 extern void bfd_elf32_arm_set_vfp11_fix
   (bfd *, struct bfd_link_info *);
 
+extern void bfd_elf32_arm_validate_janus_2cc_fix
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_set_cortex_a8_fix
+  (bfd *, struct bfd_link_info *);
+
 extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
   (bfd *, struct bfd_link_info *);
 
-extern void bfd_elf32_arm_vfp11_fix_veneer_locations
+extern bfd_boolean bfd_elf32_arm_janus_2cc_erratum_scan
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_fix_veneer_locations
   (bfd *, struct bfd_link_info *);
 
 /* ARM Interworking support.  Called from linker.  */
@@ -863,7 +872,7 @@ extern bfd_boolean bfd_elf32_arm_process
 
 void bfd_elf32_arm_set_target_relocs
   (bfd *, struct bfd_link_info *, int, char *, int, int, bfd_arm_vfp11_fix,
-   int, int, int);
+   int, int, int, int, int);
 
 extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
   (bfd *, struct bfd_link_info *);
@@ -901,7 +910,11 @@ extern bfd_boolean elf32_arm_size_stubs
    struct bfd_section * (*) (const char *, struct bfd_section *), void (*) (void));
 extern bfd_boolean elf32_arm_build_stubs
   (struct bfd_link_info *);
-  
+
+/* ARM unwind section editing support.  */
+extern bfd_boolean elf32_arm_fix_exidx_coverage
+  (struct bfd_section **, unsigned int, struct bfd_link_info *);
+
 /* TI COFF load page support.  */
 extern void bfd_ticoff_set_section_load_page
   (struct bfd_section *, int);
@@ -5406,6 +5419,7 @@ typedef struct bfd_target
   NAME##_bfd_link_hash_table_free, \
   NAME##_bfd_link_add_symbols, \
   NAME##_bfd_link_just_syms, \
+  NAME##_bfd_copy_link_hash_symbol_type, \
   NAME##_bfd_final_link, \
   NAME##_bfd_link_split_section, \
   NAME##_bfd_gc_sections, \
@@ -5436,6 +5450,12 @@ typedef struct bfd_target
   /* Indicate that we are only retrieving symbol values from this section.  */
   void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
 
+  /* Copy the symbol type of a linker hash table entry.  */
+#define bfd_copy_link_hash_symbol_type(b, t, f) \
+  BFD_SEND (b, _bfd_copy_link_hash_symbol_type, (b, t, f))
+  void (*_bfd_copy_link_hash_symbol_type)
+    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+
   /* Do a link based on the link_order structures attached to each
      section of the BFD.  */
   bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
--- a/bfd/binary.c
+++ b/bfd/binary.c
@@ -319,6 +319,8 @@ binary_sizeof_headers (bfd *abfd ATTRIBU
 #define binary_bfd_link_hash_table_create         _bfd_generic_link_hash_table_create
 #define binary_bfd_link_hash_table_free           _bfd_generic_link_hash_table_free
 #define binary_bfd_link_just_syms                 _bfd_generic_link_just_syms
+#define binary_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define binary_bfd_link_add_symbols               _bfd_generic_link_add_symbols
 #define binary_bfd_final_link                     _bfd_generic_final_link
 #define binary_bfd_link_split_section             _bfd_generic_link_split_section
--- a/bfd/bout.c
+++ b/bfd/bout.c
@@ -1382,6 +1382,8 @@ b_out_bfd_get_relocated_section_contents
 #define b_out_bfd_link_hash_table_free         _bfd_generic_link_hash_table_free
 #define b_out_bfd_link_add_symbols             _bfd_generic_link_add_symbols
 #define b_out_bfd_link_just_syms               _bfd_generic_link_just_syms
+#define b_out_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define b_out_bfd_final_link                   _bfd_generic_final_link
 #define b_out_bfd_link_split_section           _bfd_generic_link_split_section
 #define b_out_bfd_gc_sections                  bfd_generic_gc_sections
--- a/bfd/cache.c
+++ b/bfd/cache.c
@@ -120,6 +120,13 @@ bfd_cache_delete (bfd *abfd)
 
   if (fclose ((FILE *) abfd->iostream) == 0)
     ret = TRUE;
+  /* ClearCase has an entertaining bug where close will fail and set
+     errno to EROFS when applied to any file in a read-only view, even
+     if the file was opened for reading.  Detect this situation and
+     ignore the error.  */
+  else if (errno == EROFS && (abfd->direction == no_direction
+			      || abfd->direction == read_direction))
+    ret = TRUE;
   else
     {
       ret = FALSE;
--- a/bfd/coff-arm.c
+++ b/bfd/coff-arm.c
@@ -2208,7 +2208,7 @@ coff_arm_merge_private_bfd_data (bfd * i
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
-		(_("ERROR: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
+		(_("error: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
 		 ibfd, obfd,
 		 APCS_26_FLAG (ibfd) ? 26 : 32,
 		 APCS_26_FLAG (obfd) ? 26 : 32
@@ -2224,10 +2224,10 @@ coff_arm_merge_private_bfd_data (bfd * i
 
 	      if (APCS_FLOAT_FLAG (ibfd))
 		/* xgettext: c-format */
-		msg = _("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers");
+		msg = _("error: %B passes floats in float registers, whereas %B passes them in integer registers");
 	      else
 		/* xgettext: c-format */
-		msg = _("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers");
+		msg = _("error: %B passes floats in integer registers, whereas %B passes them in float registers");
 
 	      _bfd_error_handler (msg, ibfd, obfd);
 
@@ -2241,10 +2241,10 @@ coff_arm_merge_private_bfd_data (bfd * i
 
 	      if (PIC_FLAG (ibfd))
 		/* xgettext: c-format */
-		msg = _("ERROR: %B is compiled as position independent code, whereas target %B is absolute position");
+		msg = _("error: %B is compiled as position independent code, whereas target %B is absolute position");
 	      else
 		/* xgettext: c-format */
-		msg = _("ERROR: %B is compiled as absolute position code, whereas target %B is position independent");
+		msg = _("error: %B is compiled as absolute position code, whereas target %B is position independent");
 	      _bfd_error_handler (msg, ibfd, obfd);
 
 	      bfd_set_error (bfd_error_wrong_format);
--- a/bfd/coff-rs6000.c
+++ b/bfd/coff-rs6000.c
@@ -4212,6 +4212,7 @@ const bfd_target rs6000coff_vec =
     _bfd_generic_link_hash_table_free,
     _bfd_xcoff_bfd_link_add_symbols,
     _bfd_generic_link_just_syms,
+    _bfd_generic_copy_link_hash_symbol_type,
     _bfd_xcoff_bfd_final_link,
     _bfd_generic_link_split_section,
     bfd_generic_gc_sections,
@@ -4464,6 +4465,7 @@ const bfd_target pmac_xcoff_vec =
     _bfd_generic_link_hash_table_free,
     _bfd_xcoff_bfd_link_add_symbols,
     _bfd_generic_link_just_syms,
+    _bfd_generic_copy_link_hash_symbol_type,
     _bfd_xcoff_bfd_final_link,
     _bfd_generic_link_split_section,
     bfd_generic_gc_sections,
--- a/bfd/coff64-rs6000.c
+++ b/bfd/coff64-rs6000.c
@@ -2762,6 +2762,7 @@ const bfd_target rs6000coff64_vec =
     _bfd_generic_link_hash_table_free,
     _bfd_xcoff_bfd_link_add_symbols,
     _bfd_generic_link_just_syms,
+    _bfd_generic_copy_link_hash_symbol_type,
     _bfd_xcoff_bfd_final_link,
     _bfd_generic_link_split_section,
     bfd_generic_gc_sections,
@@ -3015,6 +3016,7 @@ const bfd_target aix5coff64_vec =
     _bfd_generic_link_hash_table_free,
     _bfd_xcoff_bfd_link_add_symbols,
     _bfd_generic_link_just_syms,
+    _bfd_generic_copy_link_hash_symbol_type,
     _bfd_xcoff_bfd_final_link,
     _bfd_generic_link_split_section,
     bfd_generic_gc_sections,
--- a/bfd/coffcode.h
+++ b/bfd/coffcode.h
@@ -5169,6 +5169,8 @@ dummy_reloc16_extra_cases (bfd *abfd ATT
 #endif /* ! defined (coff_relocate_section) */
 
 #define coff_bfd_link_just_syms      _bfd_generic_link_just_syms
+#define coff_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define coff_bfd_link_split_section  _bfd_generic_link_split_section
 
 #ifndef coff_start_final_link
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -959,6 +959,10 @@ case "${targ}" in
     targ_selvecs="bfd_elf32_tradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradbigmips_vec bfd_elf64_tradlittlemips_vec"
     want64=true
     ;;
+  mips64octeon*-*-elf*)
+    targ_defvec=bfd_elf32_tradbigmips_vec
+    targ_selvecs="bfd_elf32_tradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradbigmips_vec bfd_elf64_tradlittlemips_vec"
+    ;;
   mips*el-*-elf* | mips*el-*-vxworks* | mips*-*-chorus*)
     targ_defvec=bfd_elf32_littlemips_vec
     targ_selvecs="bfd_elf32_bigmips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec"
@@ -1000,12 +1004,12 @@ case "${targ}" in
 #endif
   mips*el-*-linux*)
     targ_defvec=bfd_elf32_tradlittlemips_vec
-    targ_selvecs="bfd_elf32_tradbigmips_vec ecoff_little_vec ecoff_big_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf64_tradbigmips_vec"
+    targ_selvecs="bfd_elf32_tradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf64_tradbigmips_vec"
     want64=true
     ;;
   mips*-*-linux*)
     targ_defvec=bfd_elf32_tradbigmips_vec
-    targ_selvecs="bfd_elf32_tradlittlemips_vec ecoff_big_vec ecoff_little_vec bfd_elf32_ntradbigmips_vec bfd_elf64_tradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradlittlemips_vec"
+    targ_selvecs="bfd_elf32_tradlittlemips_vec bfd_elf32_ntradbigmips_vec bfd_elf64_tradbigmips_vec bfd_elf32_ntradlittlemips_vec bfd_elf64_tradlittlemips_vec"
     want64=true
     ;;
 #ifdef BFD64
--- a/bfd/cpu-arm.c
+++ b/bfd/cpu-arm.c
@@ -187,7 +187,7 @@ bfd_arm_merge_machines (bfd *ibfd, bfd *
 	       || out == bfd_mach_arm_iWMMXt2))
     {
       _bfd_error_handler (_("\
-ERROR: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
+error: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
 			  ibfd, obfd);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
@@ -198,7 +198,7 @@ ERROR: %B is compiled for the EP9312, wh
 	       || in == bfd_mach_arm_iWMMXt2))
     {
       _bfd_error_handler (_("\
-ERROR: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
+error: %B is compiled for the EP9312, whereas %B is compiled for XScale"),
 			  obfd, ibfd);
       bfd_set_error (bfd_error_wrong_format);
       return FALSE;
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -417,48 +417,47 @@ read_section (bfd *           abfd,
   bfd_boolean section_is_compressed = FALSE;
 
   /* read_section is a noop if the section has already been read.  */
-  if (*section_buffer)
-    return TRUE;
-
-  msec = bfd_get_section_by_name (abfd, section_name);
-  if (! msec && compressed_section_name)
-    {
-      msec = bfd_get_section_by_name (abfd, compressed_section_name);
-      section_is_compressed = TRUE;
-    }
-  if (! msec)
+  if (!*section_buffer)
     {
-      (*_bfd_error_handler) (_("Dwarf Error: Can't find %s section."), section_name);
-      bfd_set_error (bfd_error_bad_value);
-      return FALSE;
-    }
+      msec = bfd_get_section_by_name (abfd, section_name);
+      if (! msec && compressed_section_name)
+	{
+	  msec = bfd_get_section_by_name (abfd, compressed_section_name);
+	  section_is_compressed = TRUE;
+	}
+      if (! msec)
+	{
+	  (*_bfd_error_handler) (_("Dwarf Error: Can't find %s section."), section_name);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
 
-  if (syms)
-    {
-      *section_size = msec->size;
-      *section_buffer
-	  = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
-      if (! *section_buffer)
-	return FALSE;
-    }
-  else
-    {
       *section_size = msec->rawsize ? msec->rawsize : msec->size;
-      *section_buffer = bfd_malloc (*section_size);
-      if (! *section_buffer)
-	return FALSE;
-      if (! bfd_get_section_contents (abfd, msec, *section_buffer,
-				      0, *section_size))
-	return FALSE;
-    }
+      if (syms)
+	{
+	  *section_buffer
+	      = bfd_simple_get_relocated_section_contents (abfd, msec, NULL, syms);
+	  if (! *section_buffer)
+	    return FALSE;
+	}
+      else
+	{
+	  *section_buffer = bfd_malloc (*section_size);
+	  if (! *section_buffer)
+	    return FALSE;
+	  if (! bfd_get_section_contents (abfd, msec, *section_buffer,
+					  0, *section_size))
+	    return FALSE;
+	}
 
-  if (section_is_compressed)
-    {
-      if (! bfd_uncompress_section_contents (section_buffer, section_size))
+      if (section_is_compressed)
 	{
-	  (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
-	  bfd_set_error (bfd_error_bad_value);
-	  return FALSE;
+	  if (! bfd_uncompress_section_contents (section_buffer, section_size))
+	    {
+	      (*_bfd_error_handler) (_("Dwarf Error: unable to decompress %s section."), compressed_section_name);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
 	}
     }
 
--- a/bfd/elf-attrs.c
+++ b/bfd/elf-attrs.c
@@ -564,7 +564,7 @@ _bfd_elf_merge_object_attributes (bfd *i
       if (in_attr->i > 0 && strcmp (in_attr->s, "gnu") != 0)
 	{
 	  _bfd_error_handler
-		(_("ERROR: %B: Must be processed by '%s' toolchain"),
+		(_("error: %B: Must be processed by '%s' toolchain"),
 		 ibfd, in_attr->s);
 	  return FALSE;
 	}
@@ -572,7 +572,7 @@ _bfd_elf_merge_object_attributes (bfd *i
       if (in_attr->i != out_attr->i
 	  || (in_attr->i != 0 && strcmp (in_attr->s, out_attr->s) != 0))
 	{
-	  _bfd_error_handler (_("ERROR: %B: Object tag '%d, %s' is "
+	  _bfd_error_handler (_("error: %B: Object tag '%d, %s' is "
 				"incompatible with tag '%d, %s'"),
 			      ibfd,
 			      in_attr->i, in_attr->s ? in_attr->s : "",
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -1705,6 +1705,8 @@ extern asection *_bfd_elf_check_kept_sec
   (asection *, struct bfd_link_info *);
 extern void _bfd_elf_link_just_syms
   (asection *, struct bfd_link_info *);
+extern void _bfd_elf_copy_link_hash_symbol_type
+  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
 extern bfd_boolean _bfd_elf_copy_private_header_data
   (bfd *, bfd *);
 extern bfd_boolean _bfd_elf_copy_private_symbol_data
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -20,6 +20,8 @@
    MA 02110-1301, USA.  */
 
 #include "sysdep.h"
+#include <limits.h>
+
 #include "bfd.h"
 #include "libiberty.h"
 #include "libbfd.h"
@@ -61,6 +63,11 @@
 
 static struct elf_backend_data elf32_arm_vxworks_bed;
 
+static bfd_boolean elf32_arm_write_section (bfd *output_bfd,
+					    struct bfd_link_info *link_info,
+					    asection *sec,
+					    bfd_byte *contents);
+
 /* Note: code such as elf32_arm_reloc_type_lookup expect to use e.g.
    R_ARM_PC24 as an index into this, and find the R_ARM_PC24 HOWTO
    in that slot.  */
@@ -1881,7 +1888,8 @@ typedef unsigned short int insn16;
    interworkable.  */
 #define INTERWORK_FLAG(abfd)  \
   (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) >= EF_ARM_EABI_VER4 \
-  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK))
+  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK) \
+  || ((abfd)->flags & BFD_LINKER_CREATED))
 
 /* The linker script knows the section names for placement.
    The entry_names are used to do simple name mangling on the stubs.
@@ -1894,7 +1902,12 @@ typedef unsigned short int insn16;
 #define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"
 
 #define VFP11_ERRATUM_VENEER_SECTION_NAME ".vfp11_veneer"
-#define VFP11_ERRATUM_VENEER_ENTRY_NAME   "__vfp11_veneer_%x"
+#define VFP11_ERRATUM_VENEER_ENTRY_NAME   "__vfp11_veneer_%x%s"
+
+#define JANUS_2CC_ERRATUM_VENEER_SECTION_NAME ".janus_2cc_veneer"
+#define JANUS_2CC_ERRATUM_VENEER_ENTRY_NAME   "__janus_2cc_veneer_%x%s"
+
+#define MAX_ERRATUM_SYMBOL_LENGTH 64
 
 #define ARM_BX_GLUE_SECTION_NAME ".v4_bx"
 #define ARM_BX_GLUE_ENTRY_NAME   "__bx_r%d"
@@ -2010,53 +2023,129 @@ static const bfd_vma elf32_arm_symbian_p
 #define THM2_MAX_FWD_BRANCH_OFFSET (((1 << 24) - 2) + 4)
 #define THM2_MAX_BWD_BRANCH_OFFSET (-(1 << 24) + 4)
 
-static const bfd_vma arm_long_branch_stub[] =
+enum stub_insn_type
   {
-    0xe51ff004,         /* ldr   pc, [pc, #-4] */
-    0x00000000,         /* dcd   R_ARM_ABS32(X) */
+    THUMB16_TYPE = 1,
+    THUMB32_TYPE,
+    ARM_TYPE,
+    DATA_TYPE
+  };
+
+#define THUMB16_INSN(X)          {(X), THUMB16_TYPE, R_ARM_NONE, 0}
+/* A bit of a hack.  A Thumb conditional branch, in which the proper condition
+   is inserted in arm_build_one_stub().  */
+#define THUMB16_BCOND_INSN(X)	 {(X), THUMB16_TYPE, R_ARM_NONE, 1}
+#define THUMB32_INSN(X)          {(X), THUMB32_TYPE, R_ARM_NONE, 0}
+#define THUMB32_B_INSN(X, Z)     {(X), THUMB32_TYPE, R_ARM_THM_JUMP24, (Z)}
+#define ARM_INSN(X)              {(X), ARM_TYPE, R_ARM_NONE, 0}
+#define ARM_REL_INSN(X, Z)       {(X), ARM_TYPE, R_ARM_JUMP24, (Z)}
+#define DATA_WORD(X,Y,Z)         {(X), DATA_TYPE, (Y), (Z)}
+
+typedef struct
+{
+  bfd_vma data;
+  enum stub_insn_type type;
+  unsigned int reloc_type;
+  int reloc_addend;
+}  insn_sequence;
+
+/* Arm/Thumb -> Arm/Thumb long branch stub. On V5T and above, use blx
+   to reach the stub if necessary.  */
+static const insn_sequence elf32_arm_stub_long_branch_any_any[] =
+  {
+    ARM_INSN(0xe51ff004),            /* ldr   pc, [pc, #-4] */
+    DATA_WORD(0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
+  };
+
+/* V4T Arm -> Thumb long branch stub. Used on V4T where blx is not
+   available.  */
+static const insn_sequence elf32_arm_stub_long_branch_v4t_arm_thumb[] =
+  {
+    ARM_INSN(0xe59fc000),            /* ldr   ip, [pc, #0] */
+    ARM_INSN(0xe12fff1c),            /* bx    ip */
+    DATA_WORD(0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
+  };
+
+/* Thumb -> Thumb long branch stub. Used on architectures which
+   support only this mode, or on V4T where it is expensive to switch
+   to ARM.  */
+static const insn_sequence elf32_arm_stub_long_branch_thumb_only[] =
+  {
+    THUMB16_INSN(0xb401),             /* push {r0} */
+    THUMB16_INSN(0x4802),             /* ldr  r0, [pc, #8] */
+    THUMB16_INSN(0x4684),             /* mov  ip, r0 */
+    THUMB16_INSN(0xbc01),             /* pop  {r0} */
+    THUMB16_INSN(0x4760),             /* bx   ip */
+    THUMB16_INSN(0xbf00),             /* nop */
+    DATA_WORD(0, R_ARM_ABS32, 0),     /* dcd  R_ARM_ABS32(X) */
+  };
+
+/* V4T Thumb -> ARM long branch stub. Used on V4T where blx is not
+   available.  */
+static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_arm[] =
+  {
+    THUMB16_INSN(0x4778),             /* bx   pc */
+    THUMB16_INSN(0x46c0),             /* nop   */
+    ARM_INSN(0xe51ff004),             /* ldr   pc, [pc, #-4] */
+    DATA_WORD(0, R_ARM_ABS32, 0),     /* dcd   R_ARM_ABS32(X) */
   };
 
-static const bfd_vma arm_thumb_v4t_long_branch_stub[] =
+/* V4T Thumb -> ARM short branch stub. Shorter variant of the above
+   one, when the destination is close enough.  */
+static const insn_sequence elf32_arm_stub_short_branch_v4t_thumb_arm[] =
   {
-    0xe59fc000,         /* ldr   ip, [pc, #0] */
-    0xe12fff1c,         /* bx    ip */
-    0x00000000,         /* dcd   R_ARM_ABS32(X) */
+    THUMB16_INSN(0x4778),             /* bx   pc */
+    THUMB16_INSN(0x46c0),             /* nop   */
+    ARM_REL_INSN(0xea000000, -8),     /* b    (X-8) */
   };
 
-static const bfd_vma arm_thumb_thumb_long_branch_stub[] =
+/* ARM/Thumb -> ARM long branch stub, PIC.  On V5T and above, use
+   blx to reach the stub if necessary.  */
+static const insn_sequence elf32_arm_stub_long_branch_any_arm_pic[] =
   {
-    0x4e02b540,         /* push {r6, lr} */
-                        /* ldr  r6, [pc, #8] */
-    0x473046fe,         /* mov  lr, pc */
-                        /* bx   r6 */
-    0xbf00bd40,         /* pop  {r6, pc} */
-                        /* nop */
-    0x00000000,         /* dcd  R_ARM_ABS32(X) */
+    ARM_INSN(0xe59fc000),             /* ldr   r12, [pc] */
+    ARM_INSN(0xe08ff00c),             /* add   pc, pc, ip */
+    DATA_WORD(0, R_ARM_REL32, -4),    /* dcd   R_ARM_REL32(X-4) */
   };
 
-static const bfd_vma arm_thumb_arm_v4t_long_branch_stub[] =
+/* ARM/Thumb -> Thumb long branch stub, PIC.  On V5T and above, use
+   blx to reach the stub if necessary.  We can not add into pc;
+   it is not guaranteed to mode switch (different in ARMv6 and
+   ARMv7).  */
+static const insn_sequence elf32_arm_stub_long_branch_any_thumb_pic[] =
+  {
+    ARM_INSN(0xe59fc004),             /* ldr   r12, [pc, #4] */
+    ARM_INSN(0xe08fc00c),             /* add   ip, pc, ip */
+    ARM_INSN(0xe12fff1c),             /* bx    ip */
+    DATA_WORD(0, R_ARM_REL32, 0),     /* dcd   R_ARM_REL32(X) */
+  };
+
+/* Cortex-A8 erratum-workaround stubs.  */
+
+/* Stub used for conditional branches (which may be beyond +/-1MB away, so we
+   can't use a conditional branch to reach this stub).  */
+
+static const insn_sequence elf32_arm_stub_a8_veneer_b_cond[] =
   {
-    0x4e03b540,         /* push {r6, lr} */
-                        /* ldr  r6, [pc, #12] */
-    0x473046fe,         /* mov  lr, pc */
-                        /* bx   r6 */
-    0xe8bd4040,         /* pop  {r6, pc} */
-    0xe12fff1e,         /* bx   lr */
-    0x00000000,         /* dcd  R_ARM_ABS32(X) */
+    THUMB16_BCOND_INSN(0xd001),		/* b<cond>.n true.  */
+    THUMB32_B_INSN(0xf000b800, -4),	/* b.w insn_after_original_branch.  */
+    THUMB32_B_INSN(0xf000b800, -4)	/* b.w original_branch_dest.  */
   };
 
-static const bfd_vma arm_thumb_arm_v4t_short_branch_stub[] =
+/* Stub used for b.w and bl.w instructions.  */
+
+static const insn_sequence elf32_arm_stub_a8_veneer_b[] =
   {
-    0x46c04778,         /* bx   pc */
-                        /* nop   */
-    0xea000000,         /* b    (X) */
+    THUMB32_B_INSN(0xf000b800, -4)
   };
 
-static const bfd_vma arm_pic_long_branch_stub[] =
+/* Stub used for Thumb-2 blx.w instructions.  We modified the original blx.w
+   instruction to point to this stub, which switches to ARM mode.  Jump to the
+   real destination using an ARM-mode branch.  */
+
+static const insn_sequence elf32_arm_stub_a8_veneer_blx[] =
   {
-    0xe59fc000,         /* ldr   r12, [pc] */
-    0xe08ff00c,         /* add   pc, pc, ip */
-    0x00000000,         /* dcd   R_ARM_REL32(X) */
+    ARM_REL_INSN(0xea000000, -8)
   };
 
 /* Section name for stubs is the associated section name plus this
@@ -2066,12 +2155,17 @@ static const bfd_vma arm_pic_long_branch
 enum elf32_arm_stub_type
 {
   arm_stub_none,
-  arm_stub_long_branch,
-  arm_thumb_v4t_stub_long_branch,
-  arm_thumb_thumb_stub_long_branch,
-  arm_thumb_arm_v4t_stub_long_branch,
-  arm_thumb_arm_v4t_stub_short_branch,
-  arm_stub_pic_long_branch,
+  arm_stub_long_branch_any_any,
+  arm_stub_long_branch_v4t_arm_thumb,
+  arm_stub_long_branch_thumb_only,
+  arm_stub_long_branch_v4t_thumb_arm,
+  arm_stub_short_branch_v4t_thumb_arm,
+  arm_stub_long_branch_any_arm_pic,
+  arm_stub_long_branch_any_thumb_pic,
+  arm_stub_a8_veneer_b_cond,
+  arm_stub_a8_veneer_b,
+  arm_stub_a8_veneer_bl,
+  arm_stub_a8_veneer_blx
 };
 
 struct elf32_arm_stub_hash_entry
@@ -2090,7 +2184,21 @@ struct elf32_arm_stub_hash_entry
   bfd_vma target_value;
   asection *target_section;
 
+  /* Offset to apply to relocation referencing target_value.  */
+  bfd_vma target_addend;
+  
+  /* The instruction which caused this stub to be generated (only valid for
+     Cortex-A8 erratum workaround stubs at present).  */
+  unsigned long orig_insn;
+
+  /* The stub type.  */
   enum elf32_arm_stub_type stub_type;
+  /* Its encoding size in bytes.  */
+  int stub_size;
+  /* Its template.  */
+  const insn_sequence *stub_template;
+  /* The size of the template (number of entries).  */
+  int stub_template_size;
 
   /* The symbol table entry, if any, that this was derived from.  */
   struct elf32_arm_link_hash_entry *h;
@@ -2124,43 +2232,111 @@ typedef enum
 {
   VFP11_ERRATUM_BRANCH_TO_ARM_VENEER,
   VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER,
+  JANUS_2CC_ERRATUM_BRANCH_TO_ARM_VENEER,
   VFP11_ERRATUM_ARM_VENEER,
-  VFP11_ERRATUM_THUMB_VENEER
+  VFP11_ERRATUM_THUMB_VENEER,
+  JANUS_2CC_ERRATUM_ARM_VENEER
 }
-elf32_vfp11_erratum_type;
+elf32_cpu_erratum_type;
 
-typedef struct elf32_vfp11_erratum_list
+typedef struct elf32_cpu_erratum_list
 {
-  struct elf32_vfp11_erratum_list *next;
+  struct elf32_cpu_erratum_list *next;
   bfd_vma vma;
   union
   {
     struct
     {
-      struct elf32_vfp11_erratum_list *veneer;
-      unsigned int vfp_insn;
+      struct elf32_cpu_erratum_list *veneer;
+      unsigned int orig_insn;
     } b;
     struct
     {
-      struct elf32_vfp11_erratum_list *branch;
+      struct elf32_cpu_erratum_list *branch;
       unsigned int id;
     } v;
   } u;
-  elf32_vfp11_erratum_type type;
+  elf32_cpu_erratum_type type;
+}
+elf32_cpu_erratum_list;
+
+typedef enum
+{
+  DELETE_EXIDX_ENTRY,
+  INSERT_EXIDX_CANTUNWIND_AT_END
 }
-elf32_vfp11_erratum_list;
+arm_unwind_edit_type;
+
+/* A (sorted) list of edits to apply to an unwind table.  */
+typedef struct arm_unwind_table_edit
+{
+  arm_unwind_edit_type type;
+  /* Note: we sometimes want to insert an unwind entry corresponding to a
+     section different from the one we're currently writing out, so record the
+     (text) section this edit relates to here.  */
+  asection *linked_section;
+  unsigned int index;
+  struct arm_unwind_table_edit *next;
+}
+arm_unwind_table_edit;
 
 typedef struct _arm_elf_section_data
 {
+  /* Information about mapping symbols.  */
   struct bfd_elf_section_data elf;
   unsigned int mapcount;
   unsigned int mapsize;
   elf32_arm_section_map *map;
+  /* Information about CPU errata.  */
   unsigned int erratumcount;
-  elf32_vfp11_erratum_list *erratumlist;
+  elf32_cpu_erratum_list *erratumlist;
+  /* Information about unwind tables.  */
+  union
+  {
+    /* Unwind info attached to a text section.  */
+    struct
+    {
+      asection *arm_exidx_sec;
+    } text;
+
+    /* Unwind info attached to an .ARM.exidx section.  */
+    struct
+    {
+      arm_unwind_table_edit *unwind_edit_list;
+      arm_unwind_table_edit *unwind_edit_tail;
+    } exidx;
+  } u;
 }
 _arm_elf_section_data;
 
+/* A fix which might be required for Cortex-A8 Thumb-2 branch/TLB erratum.
+   These fixes are subject to a relaxation procedure (in elf32_arm_size_stubs),
+   so may be created multiple times: we use an array of these entries whilst
+   relaxing which we can refresh easily, then create stubs for each potentially
+   erratum-triggering instruction once we've settled on a solution.  */
+
+struct a8_erratum_fix {
+  bfd *input_bfd;
+  asection *section;
+  bfd_vma offset;
+  bfd_vma addend;
+  unsigned long orig_insn;
+  char *stub_name;
+  enum elf32_arm_stub_type stub_type;
+};
+
+/* A table of relocs applied to branches which might trigger Cortex-A8
+   erratum.  */
+
+struct a8_erratum_reloc {
+  bfd_vma from;
+  bfd_vma destination;
+  unsigned int r_type;
+  unsigned char st_type;
+  const char *sym_name;
+  bfd_boolean non_a8_stub;
+};
+
 #define elf32_arm_section_data(sec) \
   ((_arm_elf_section_data *) elf_section_data (sec))
 
@@ -2295,6 +2471,16 @@ struct elf32_arm_link_hash_table
      veneers.  */
   bfd_size_type vfp11_erratum_glue_size;
 
+  /* The size in bytes of the section containing glue for Janus 2CC erratum
+     veneers.  */
+  bfd_size_type janus_2cc_erratum_glue_size;
+
+  /* A table of fix locations for Cortex-A8 Thumb-2 branch/TLB erratum.  This
+     holds Cortex-A8 erratum fix locations between elf32_arm_size_stubs() and
+     elf32_arm_write_section().  */
+  struct a8_erratum_fix *a8_erratum_fixes;
+  unsigned int num_a8_erratum_fixes;
+
   /* An arbitrary input BFD chosen to hold the glue sections.  */
   bfd * bfd_of_glue_owner;
 
@@ -2313,6 +2499,15 @@ struct elf32_arm_link_hash_table
      2 = Generate v4 interworing stubs.  */
   int fix_v4bx;
 
+  /* Whether we should fix/report Janus 2CC errata for ARM/Thumb.  */
+  int fix_janus_2cc;
+
+  /* Whether we should fix the Cortex-A8 Thumb-2 branch/TLB erratum.  */
+  int fix_cortex_a8;
+
+  /* Global counter for the number of fixes we have emitted.  */
+  int num_errata_fixes;
+
   /* Nonzero if the ARM/Thumb BLX instructions are available for use.  */
   int use_blx;
 
@@ -2459,6 +2654,9 @@ stub_hash_newfunc (struct bfd_hash_entry
       eh->target_value = 0;
       eh->target_section = NULL;
       eh->stub_type = arm_stub_none;
+      eh->stub_size = 0;
+      eh->stub_template = NULL;
+      eh->stub_template_size = 0;
       eh->h = NULL;
       eh->id_sec = NULL;
     }
@@ -2648,7 +2846,10 @@ elf32_arm_link_hash_table_create (bfd *a
   memset (ret->bx_glue_offset, 0, sizeof (ret->bx_glue_offset));
   ret->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
   ret->vfp11_erratum_glue_size = 0;
-  ret->num_vfp11_fixes = 0;
+  ret->fix_janus_2cc = 0;
+  ret->fix_cortex_a8 = 0;
+  ret->janus_2cc_erratum_glue_size = 0;
+  ret->num_errata_fixes = 0;
   ret->bfd_of_glue_owner = NULL;
   ret->byteswap_code = 0;
   ret->target1_is_rel = 0;
@@ -2731,9 +2932,9 @@ arm_stub_is_thumb (enum elf32_arm_stub_t
 {
   switch (stub_type)
     {
-    case arm_thumb_thumb_stub_long_branch:
-    case arm_thumb_arm_v4t_stub_long_branch:
-    case arm_thumb_arm_v4t_stub_short_branch:
+    case arm_stub_long_branch_thumb_only:
+    case arm_stub_long_branch_v4t_thumb_arm:
+    case arm_stub_short_branch_v4t_thumb_arm:
       return TRUE;
     case arm_stub_none:
       BFD_FAIL ();
@@ -2806,20 +3007,27 @@ arm_type_of_stub (struct bfd_link_info *
 	      if (!thumb_only)
 		{
 		  stub_type = (info->shared | globals->pic_veneer)
+		    /* PIC stubs.  */
 		    ? ((globals->use_blx)
-		       ? arm_stub_pic_long_branch
+		       /* V5T and above.  */
+		       ? arm_stub_long_branch_any_thumb_pic
+		       /* not yet supported on V4T.  */
 		       : arm_stub_none)
-		    : (globals->use_blx)
-		    ? arm_stub_long_branch
-		    : arm_stub_none;
+
+		    /* non-PIC stubs.  */
+		    : ((globals->use_blx)
+		       /* V5T and above.  */
+		       ? arm_stub_long_branch_any_any
+		       /* V4T.  */
+		       : arm_stub_long_branch_thumb_only);
 		}
 	      else
 		{
 		  stub_type = (info->shared | globals->pic_veneer)
+		    /* PIC stub not yet supported on V4T.  */
 		    ? arm_stub_none
-		    : (globals->use_blx)
-		    ? arm_thumb_thumb_stub_long_branch
-		    : arm_stub_none;
+		    /* non-PIC stub.  */
+		    : arm_stub_long_branch_thumb_only;
 		}
 	    }
 	  else
@@ -2836,18 +3044,25 @@ arm_type_of_stub (struct bfd_link_info *
 		}
 
 	      stub_type = (info->shared | globals->pic_veneer)
+		/* PIC stubs.  */
 		? ((globals->use_blx)
-		   ? arm_stub_pic_long_branch
+		   /* V5T and above.  */
+		   ? arm_stub_long_branch_any_arm_pic
+		   /* not yet supported on V4T.  */
 		   : arm_stub_none)
-		: (globals->use_blx)
-		? arm_stub_long_branch
-		: arm_thumb_arm_v4t_stub_long_branch;
+
+		/* non-PIC stubs.  */
+		: ((globals->use_blx)
+		   /* V5T and above.  */
+		   ? arm_stub_long_branch_any_any
+		   /* V4T.  */
+		   : arm_stub_long_branch_v4t_thumb_arm);
 
 	      /* Handle v4t short branches.  */
-	      if ((stub_type == arm_thumb_arm_v4t_stub_long_branch)
+	      if ((stub_type == arm_stub_long_branch_v4t_thumb_arm)
 		  && (branch_offset <= THM_MAX_FWD_BRANCH_OFFSET)
 		  && (branch_offset >= THM_MAX_BWD_BRANCH_OFFSET))
-		stub_type = arm_thumb_arm_v4t_stub_short_branch;
+		stub_type = arm_stub_short_branch_v4t_thumb_arm;
 	    }
 	}
     }
@@ -2863,7 +3078,7 @@ arm_type_of_stub (struct bfd_link_info *
 	    {
 	      (*_bfd_error_handler)
 		(_("%B(%s): warning: interworking not enabled.\n"
-		   "  first occurrence: %B: Thumb call to ARM"),
+		   "  first occurrence: %B: ARM call to Thumb"),
 		 sym_sec->owner, input_bfd, name);
 	    }
 
@@ -2874,10 +3089,14 @@ arm_type_of_stub (struct bfd_link_info *
 	      || !globals->use_blx)
 	    {
 	      stub_type = (info->shared | globals->pic_veneer)
-		? arm_stub_pic_long_branch
-		: (globals->use_blx)
-		? arm_stub_long_branch
-		: arm_thumb_v4t_stub_long_branch;
+		/* PIC stubs.  */
+		? arm_stub_long_branch_any_thumb_pic
+		/* non-PIC stubs.  */
+		: ((globals->use_blx)
+		   /* V5T and above.  */
+		   ? arm_stub_long_branch_any_any
+		   /* V4T.  */
+		   : arm_stub_long_branch_v4t_arm_thumb);
 	    }
 	}
       else
@@ -2887,8 +3106,10 @@ arm_type_of_stub (struct bfd_link_info *
 	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET))
 	    {
 	      stub_type = (info->shared | globals->pic_veneer)
-		? arm_stub_pic_long_branch
-		: arm_stub_long_branch;
+		/* PIC stubs.  */
+		? arm_stub_long_branch_any_arm_pic
+		/* non-PIC stubs.  */
+		: arm_stub_long_branch_any_any;
 	    }
 	}
     }
@@ -3064,10 +3285,16 @@ put_thumb_insn (struct elf32_arm_link_ha
     bfd_putb16 (val, ptr);
 }
 
+static bfd_reloc_status_type elf32_arm_final_link_relocate
+  (reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *,
+   Elf_Internal_Rela *, bfd_vma, struct bfd_link_info *, asection *,
+   const char *, int, struct elf_link_hash_entry *, bfd_boolean *, char **);
+
 static bfd_boolean
 arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 		    void * in_arg)
 {
+#define MAXRELOCS 2
   struct elf32_arm_stub_hash_entry *stub_entry;
   struct bfd_link_info *info;
   struct elf32_arm_link_hash_table *htab;
@@ -3078,9 +3305,12 @@ arm_build_one_stub (struct bfd_hash_entr
   bfd_vma sym_value;
   int template_size;
   int size;
-  const bfd_vma *template;
+  const insn_sequence *template;
   int i;
   struct elf32_arm_link_hash_table * globals;
+  int stub_reloc_idx[MAXRELOCS] = {-1, -1};
+  int stub_reloc_offset[MAXRELOCS] = {0, 0};
+  int nrelocs = 0;
 
   /* Massage our args to the form they really have.  */
   stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
@@ -3106,102 +3336,229 @@ arm_build_one_stub (struct bfd_hash_entr
 	       + stub_entry->target_section->output_offset
 	       + stub_entry->target_section->output_section->vma);
 
-  switch (stub_entry->stub_type)
-    {
-    case arm_stub_long_branch:
-      template = arm_long_branch_stub;
-      template_size = (sizeof (arm_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_v4t_stub_long_branch:
-      template =  arm_thumb_v4t_long_branch_stub;
-      template_size = (sizeof (arm_thumb_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_thumb_stub_long_branch:
-      template =  arm_thumb_thumb_long_branch_stub;
-      template_size = (sizeof (arm_thumb_thumb_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_arm_v4t_stub_long_branch:
-      template =  arm_thumb_arm_v4t_long_branch_stub;
-      template_size = (sizeof (arm_thumb_arm_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_arm_v4t_stub_short_branch:
-      template =  arm_thumb_arm_v4t_short_branch_stub;
-      template_size = (sizeof(arm_thumb_arm_v4t_short_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_stub_pic_long_branch:
-      template = arm_pic_long_branch_stub;
-      template_size = (sizeof (arm_pic_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    default:
-      BFD_FAIL ();
-      return FALSE;
-    }
+  template = stub_entry->stub_template;
+  template_size = stub_entry->stub_template_size;
 
   size = 0;
-  for (i = 0; i < (template_size / 4); i++)
+  for (i = 0; i < template_size; i++)
     {
-      /* A 0 pattern is a placeholder, every other pattern is an
-	 instruction.  */
-      if (template[i] != 0)
-	put_arm_insn (globals, stub_bfd, template[i], loc + size);
-      else
-	bfd_put_32 (stub_bfd, template[i], loc + size);
+      switch (template[i].type)
+	{
+	case THUMB16_TYPE:
+	  {
+	    bfd_vma data = template[i].data;
+	    if (template[i].reloc_addend != 0)
+	      {
+		/* We've borrowed the reloc_addend field to mean we should
+		   insert a condition code into this (Thumb-1 branch)
+		   instruction.  See THUMB16_BCOND_INSN.  */
+		BFD_ASSERT ((data & 0xff00) == 0xd000);
+		data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
+	      }
+	    put_thumb_insn (globals, stub_bfd, data, loc + size);
+	    size += 2;
+	  }
+	  break;
+
+	case THUMB32_TYPE:
+	  put_thumb_insn (globals, stub_bfd, (template[i].data >> 16) & 0xffff,
+	                  loc + size);
+	  put_thumb_insn (globals, stub_bfd, template[i].data & 0xffff,
+			  loc + size + 2);
+	  if (template[i].reloc_type != R_ARM_NONE)
+	    {
+	      stub_reloc_idx[nrelocs] = i;
+	      stub_reloc_offset[nrelocs++] = size;
+	    }
+	  size += 4;
+	  break;
+
+	case ARM_TYPE:
+	  put_arm_insn (globals, stub_bfd, template[i].data, loc + size);
+	  /* Handle cases where the target is encoded within the
+	     instruction.  */
+	  if (template[i].reloc_type == R_ARM_JUMP24)
+	    {
+	      stub_reloc_idx[nrelocs] = i;
+	      stub_reloc_offset[nrelocs++] = size;
+	    }
+	  size += 4;
+	  break;
+
+	case DATA_TYPE:
+	  bfd_put_32 (stub_bfd, template[i].data, loc + size);
+	  stub_reloc_idx[nrelocs] = i;
+	  stub_reloc_offset[nrelocs++] = size;
+	  size += 4;
+	  break;
 
-      size += 4;
+	default:
+	  BFD_FAIL ();
+	  return FALSE;
+	}
     }
+
   stub_sec->size += size;
 
+  /* Stub size has already been computed in arm_size_one_stub. Check
+     consistency.  */
+  BFD_ASSERT (size == stub_entry->stub_size);
+
   /* Destination is Thumb. Force bit 0 to 1 to reflect this.  */
   if (stub_entry->st_type == STT_ARM_TFUNC)
     sym_value |= 1;
 
-  switch (stub_entry->stub_type)
+  /* Assume there is at least one and at most MAXRELOCS entries to relocate
+     in each stub.  */
+  BFD_ASSERT (nrelocs != 0 && nrelocs <= MAXRELOCS);
+
+  for (i = 0; i < nrelocs; i++)
+    if (template[stub_reloc_idx[i]].reloc_type == R_ARM_THM_JUMP24
+	|| template[stub_reloc_idx[i]].reloc_type == R_ARM_THM_JUMP19
+	|| template[stub_reloc_idx[i]].reloc_type == R_ARM_THM_CALL
+	|| template[stub_reloc_idx[i]].reloc_type == R_ARM_THM_XPC22)
+      {
+	Elf_Internal_Rela rel;
+	bfd_boolean unresolved_reloc;
+	char *error_message;
+	int sym_flags
+	  = (template[stub_reloc_idx[i]].reloc_type != R_ARM_THM_XPC22)
+	    ? STT_ARM_TFUNC : 0;
+	bfd_vma points_to = sym_value + stub_entry->target_addend;
+
+	rel.r_offset = stub_entry->stub_offset + stub_reloc_offset[i];
+	rel.r_info = ELF32_R_INFO (0, template[stub_reloc_idx[i]].reloc_type);
+	rel.r_addend = template[stub_reloc_idx[i]].reloc_addend;
+
+	if (stub_entry->stub_type == arm_stub_a8_veneer_b_cond && i == 0)
+	  /* The first relocation in the elf32_arm_stub_a8_veneer_b_cond[]
+	     template should refer back to the instruction after the original
+	     branch.  */
+	   points_to = sym_value;
+
+	/* Note: _bfd_final_link_relocate doesn't handle these relocations
+	   properly.  We should probably use this function unconditionally,
+	   rather than only for certain relocations listed in the enclosing
+	   conditional.  Attempt to avoid perturbing existing code too much
+	   pending more testing.  */
+	elf32_arm_final_link_relocate (elf32_arm_howto_from_type
+	    (template[stub_reloc_idx[i]].reloc_type),
+	  stub_bfd, info->output_bfd, stub_sec, stub_sec->contents, &rel,
+	  points_to, info, stub_entry->target_section, "", sym_flags,
+	  (struct elf_link_hash_entry *) stub_entry, &unresolved_reloc,
+	  &error_message);
+      }
+    else
+      {
+	_bfd_final_link_relocate (elf32_arm_howto_from_type
+	    (template[stub_reloc_idx[i]].reloc_type), stub_bfd, stub_sec,
+	  stub_sec->contents, stub_entry->stub_offset + stub_reloc_offset[i],
+	  sym_value + stub_entry->target_addend,
+	  template[stub_reloc_idx[i]].reloc_addend);
+      }
+
+  return TRUE;
+#undef MAXRELOCS
+}
+
+/* Calculate the template, template size and instruction size for a stub. 
+   Return value is the instruction size.  */
+
+static unsigned int
+find_stub_size_and_template (enum elf32_arm_stub_type stub_type,
+			     const insn_sequence **stub_template,
+			     int *stub_template_size)
+{
+  const insn_sequence *template = NULL;
+  int template_size = 0, i;
+  unsigned int size;
+
+  switch (stub_type)
     {
-    case arm_stub_long_branch:
-      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
-				stub_bfd, stub_sec, stub_sec->contents,
-				stub_entry->stub_offset + 4, sym_value, 0);
+    case arm_stub_long_branch_any_any:
+      template =  elf32_arm_stub_long_branch_any_any;
+      template_size = sizeof (elf32_arm_stub_long_branch_any_any)
+		      / sizeof (insn_sequence);
       break;
-    case arm_thumb_v4t_stub_long_branch:
-      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
-				stub_bfd, stub_sec, stub_sec->contents,
-				stub_entry->stub_offset + 8, sym_value, 0);
+    case arm_stub_long_branch_v4t_arm_thumb:
+      template =  elf32_arm_stub_long_branch_v4t_arm_thumb;
+      template_size = sizeof (elf32_arm_stub_long_branch_v4t_arm_thumb)
+		      / sizeof (insn_sequence);
       break;
-    case arm_thumb_thumb_stub_long_branch:
-      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
-				stub_bfd, stub_sec, stub_sec->contents,
-				stub_entry->stub_offset + 12, sym_value, 0);
+    case arm_stub_long_branch_thumb_only:
+      template =  elf32_arm_stub_long_branch_thumb_only;
+      template_size = sizeof (elf32_arm_stub_long_branch_thumb_only)
+		      / sizeof (insn_sequence);
       break;
-    case arm_thumb_arm_v4t_stub_long_branch:
-      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
-				stub_bfd, stub_sec, stub_sec->contents,
-				stub_entry->stub_offset + 16, sym_value, 0);
+    case arm_stub_long_branch_v4t_thumb_arm:
+      template =  elf32_arm_stub_long_branch_v4t_thumb_arm;
+      template_size = sizeof (elf32_arm_stub_long_branch_v4t_thumb_arm)
+		      / sizeof (insn_sequence);
       break;
-    case arm_thumb_arm_v4t_stub_short_branch:
-      {
-	long int rel_offset;
-	static const insn32 t2a3_b_insn = 0xea000000;
-
-	rel_offset = sym_value - (stub_addr + 8 + 4);
-
-	put_arm_insn (globals, stub_bfd,
-		      (bfd_vma) t2a3_b_insn | ((rel_offset >> 2) & 0x00FFFFFF),
-		      loc + 4);
-      }
+    case arm_stub_short_branch_v4t_thumb_arm:
+      template =  elf32_arm_stub_short_branch_v4t_thumb_arm;
+      template_size = sizeof (elf32_arm_stub_short_branch_v4t_thumb_arm)
+		      / sizeof (insn_sequence);
       break;
-
-    case arm_stub_pic_long_branch:
-      /* We want the value relative to the address 8 bytes from the
-	 start of the stub.  */
-      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_REL32),
-				stub_bfd, stub_sec, stub_sec->contents,
-				stub_entry->stub_offset + 8, sym_value, 0);
+    case arm_stub_long_branch_any_arm_pic:
+      template = elf32_arm_stub_long_branch_any_arm_pic;
+      template_size = sizeof (elf32_arm_stub_long_branch_any_arm_pic)
+		      / sizeof (insn_sequence);
       break;
-    default:
+    case arm_stub_long_branch_any_thumb_pic:
+      template = elf32_arm_stub_long_branch_any_thumb_pic;
+      template_size = sizeof (elf32_arm_stub_long_branch_any_thumb_pic)
+		      / sizeof (insn_sequence);
       break;
+    case arm_stub_a8_veneer_b_cond:
+      template = elf32_arm_stub_a8_veneer_b_cond;
+      template_size = sizeof (elf32_arm_stub_a8_veneer_b_cond)
+		      / sizeof (insn_sequence);
+      break;
+    case arm_stub_a8_veneer_b:
+    case arm_stub_a8_veneer_bl:
+      template = elf32_arm_stub_a8_veneer_b;
+      template_size = sizeof (elf32_arm_stub_a8_veneer_b)
+		      / sizeof (insn_sequence);
+      break;
+    case arm_stub_a8_veneer_blx:
+      template = elf32_arm_stub_a8_veneer_blx;
+      template_size = sizeof (elf32_arm_stub_a8_veneer_blx)
+		      / sizeof (insn_sequence);
+      break;
+    default:
+      BFD_FAIL ();
+      return 0;
     }
 
-  return TRUE;
+  size = 0;
+  for (i = 0; i < template_size; i++)
+    {
+      switch (template[i].type)
+	{
+	case THUMB16_TYPE:
+	  size += 2;
+	  break;
+
+	case ARM_TYPE:
+	case THUMB32_TYPE:
+	case DATA_TYPE:
+	  size += 4;
+	  break;
+
+	default:
+	  BFD_FAIL ();
+	  return 0;
+	}
+    }
+
+  if (stub_template)
+    *stub_template = template;
+  
+  if (stub_template_size)
+    *stub_template_size = template_size;
+
+  return size;
 }
 
 /* As above, but don't actually build the stub.  Just bump offset so
@@ -3213,52 +3570,24 @@ arm_size_one_stub (struct bfd_hash_entry
 {
   struct elf32_arm_stub_hash_entry *stub_entry;
   struct elf32_arm_link_hash_table *htab;
-  const bfd_vma *template;
+  const insn_sequence *template;
   int template_size;
   int size;
-  int i;
 
   /* Massage our args to the form they really have.  */
   stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
   htab = (struct elf32_arm_link_hash_table *) in_arg;
 
-  switch (stub_entry->stub_type)
-    {
-    case arm_stub_long_branch:
-      template =  arm_long_branch_stub;
-      template_size = (sizeof (arm_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_v4t_stub_long_branch:
-      template =  arm_thumb_v4t_long_branch_stub;
-      template_size = (sizeof (arm_thumb_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_thumb_stub_long_branch:
-      template =  arm_thumb_thumb_long_branch_stub;
-      template_size = (sizeof (arm_thumb_thumb_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_arm_v4t_stub_long_branch:
-      template =  arm_thumb_arm_v4t_long_branch_stub;
-      template_size = (sizeof (arm_thumb_arm_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_thumb_arm_v4t_stub_short_branch:
-      template =  arm_thumb_arm_v4t_short_branch_stub;
-      template_size = (sizeof(arm_thumb_arm_v4t_short_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    case arm_stub_pic_long_branch:
-      template = arm_pic_long_branch_stub;
-      template_size = (sizeof (arm_pic_long_branch_stub) / sizeof (bfd_vma)) * 4;
-      break;
-    default:
-      BFD_FAIL ();
-      return FALSE;
-      break;
-    }
+  size = find_stub_size_and_template (stub_entry->stub_type, &template,
+				      &template_size);
+
+  stub_entry->stub_size = size;
+  stub_entry->stub_template = template;
+  stub_entry->stub_template_size = template_size;
 
-  size = 0;
-  for (i = 0; i < (template_size / 4); i++)
-      size += 4;
   size = (size + 7) & ~7;
   stub_entry->stub_sec->size += size;
+
   return TRUE;
 }
 
@@ -3355,12 +3684,12 @@ elf32_arm_next_input_section (struct bfd
     {
       asection **list = htab->input_list + isec->output_section->index;
 
-      if (*list != bfd_abs_section_ptr)
+      if (*list != bfd_abs_section_ptr && (isec->flags & SEC_CODE) != 0)
 	{
 	  /* Steal the link_sec pointer for our list.  */
 #define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
 	  /* This happens to make the list in reverse order,
-	     which is what we want.  */
+	     which we reverse later.  */
 	  PREV_SEC (isec) = *list;
 	  *list = isec;
 	}
@@ -3369,7 +3698,7 @@ elf32_arm_next_input_section (struct bfd
 
 /* See whether we can group stub sections together.  Grouping stub
    sections may result in fewer stubs.  More importantly, we need to
-   put all .init* and .fini* stubs at the beginning of the .init or
+   put all .init* and .fini* stubs at the end of the .init or
    .fini output sections respectively, because glibc splits the
    _init and _fini functions into multiple parts.  Putting a stub in
    the middle of a function is not a good idea.  */
@@ -3377,68 +3706,104 @@ elf32_arm_next_input_section (struct bfd
 static void
 group_sections (struct elf32_arm_link_hash_table *htab,
 		bfd_size_type stub_group_size,
-		bfd_boolean stubs_always_before_branch)
+		bfd_boolean stubs_always_after_branch)
 {
-  asection **list = htab->input_list + htab->top_index;
+  asection **list = htab->input_list;
 
   do
     {
       asection *tail = *list;
+      asection *head;
+      asection *tp;
 
       if (tail == bfd_abs_section_ptr)
 	continue;
 
-      while (tail != NULL)
+      /* Reverse the list: we must avoid placing stubs at the
+	 beginning of the section because the beginning of the text
+	 section may be required for an interrupt vector in bare metal
+	 code.  */
+#define NEXT_SEC PREV_SEC
+      head = tail;
+      tp = NULL;
+      while (head != NULL)
+	{
+	  asection *h = PREV_SEC (head);
+	  NEXT_SEC (head) = tp;
+	  if (h == NULL)
+	    break;
+	  tp = head;
+	  head = h;
+	}
+
+      while (head != NULL)
 	{
 	  asection *curr;
-	  asection *prev;
+	  asection *next;
 	  bfd_size_type total;
 
-	  curr = tail;
-	  total = tail->size;
-	  while ((prev = PREV_SEC (curr)) != NULL
-		 && ((total += curr->output_offset - prev->output_offset)
+	  curr = head;
+	  total = head->size;
+	  while ((next = NEXT_SEC (curr)) != NULL
+		 && ((total += next->output_offset - curr->output_offset)
 		     < stub_group_size))
-	    curr = prev;
+	    curr = next;
 
-	  /* OK, the size from the start of CURR to the end is less
+	  /* OK, the size from the start to the start of CURR is less
 	     than stub_group_size and thus can be handled by one stub
-	     section.  (Or the tail section is itself larger than
+	     section.  (Or the head section is itself larger than
 	     stub_group_size, in which case we may be toast.)
 	     We should really be keeping track of the total size of
 	     stubs added here, as stubs contribute to the final output
 	     section size.  */
 	  do
 	    {
-	      prev = PREV_SEC (tail);
+	      next = NEXT_SEC (head);
 	      /* Set up this stub group.  */
-	      htab->stub_group[tail->id].link_sec = curr;
+	      htab->stub_group[head->id].link_sec = curr;
 	    }
-	  while (tail != curr && (tail = prev) != NULL);
+	  while (head != curr && (head = next) != NULL);
 
 	  /* But wait, there's more!  Input sections up to stub_group_size
-	     bytes before the stub section can be handled by it too.  */
-	  if (!stubs_always_before_branch)
+	     bytes after the stub section can be handled by it too.  */
+	  if (!stubs_always_after_branch)
 	    {
 	      total = 0;
-	      while (prev != NULL
-		     && ((total += tail->output_offset - prev->output_offset)
+	      while (next != NULL
+		     && ((total += next->output_offset - head->output_offset)
 			 < stub_group_size))
 		{
-		  tail = prev;
-		  prev = PREV_SEC (tail);
-		  htab->stub_group[tail->id].link_sec = curr;
+		  head = next;
+		  next = NEXT_SEC (head);
+		  htab->stub_group[head->id].link_sec = curr;
 		}
 	    }
-	  tail = prev;
+	  head = next;
 	}
     }
-  while (list-- != htab->input_list);
+  while (list++ != htab->input_list + htab->top_index);
 
   free (htab->input_list);
 #undef PREV_SEC
+#undef NEXT_SEC
+}
+
+static int
+a8_reloc_compare (const void *a, const void *b)
+{
+  const struct a8_erratum_reloc *ra = a, *rb = b;
+
+  if (ra->from < rb->from)
+    return -1;
+  else if (ra->from > rb->from)
+    return 1;
+  else
+    return 0;
 }
 
+static struct elf_link_hash_entry *find_thumb_glue (struct bfd_link_info *,
+						    const char *, char **);
+
 /* Determine and set the size of the stub section for a final link.
 
    The basic idea here is to examine all the relocations looking for
@@ -3454,9 +3819,22 @@ elf32_arm_size_stubs (bfd *output_bfd,
 		      void (*layout_sections_again) (void))
 {
   bfd_size_type stub_group_size;
-  bfd_boolean stubs_always_before_branch;
+  bfd_boolean stubs_always_after_branch;
   bfd_boolean stub_changed = 0;
   struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);
+  struct a8_erratum_fix *a8_fixes = NULL;
+  unsigned int num_a8_fixes = 0, prev_num_a8_fixes = 0, a8_fix_table_size = 10;
+  struct a8_erratum_reloc *a8_relocs = NULL;
+  unsigned int num_a8_relocs = 0, a8_reloc_table_size = 10;
+  unsigned int i;
+  
+  if (htab->fix_cortex_a8)
+    {
+      a8_fixes = bfd_zmalloc (sizeof (struct a8_erratum_fix)
+			      * a8_fix_table_size);
+      a8_relocs = bfd_zmalloc (sizeof (struct a8_erratum_reloc)
+			       * a8_reloc_table_size);
+    }
 
   /* Propagate mach to stub bfd, because it may not have been
      finalized when we created stub_bfd.  */
@@ -3467,7 +3845,14 @@ elf32_arm_size_stubs (bfd *output_bfd,
   htab->stub_bfd = stub_bfd;
   htab->add_stub_section = add_stub_section;
   htab->layout_sections_again = layout_sections_again;
-  stubs_always_before_branch = group_size < 0;
+  stubs_always_after_branch = group_size < 0;
+  
+  /* The Cortex-A8 erratum fix depends on stubs not being in the same 4K page
+     as the first half of a 32-bit branch straddling two 4K pages.  This is a
+     crude way of enforcing that.  */
+  if (htab->fix_cortex_a8)
+    stubs_always_after_branch = 1;
+  
   if (group_size < 0)
     stub_group_size = -group_size;
   else
@@ -3487,13 +3872,16 @@ elf32_arm_size_stubs (bfd *output_bfd,
       stub_group_size = 4170000;
     }
 
-  group_sections (htab, stub_group_size, stubs_always_before_branch);
+  group_sections (htab, stub_group_size, stubs_always_after_branch);
 
   while (1)
     {
       bfd *input_bfd;
       unsigned int bfd_indx;
       asection *stub_sec;
+      unsigned int i;
+
+      num_a8_fixes = 0;
 
       for (input_bfd = info->input_bfds, bfd_indx = 0;
 	   input_bfd != NULL;
@@ -3503,6 +3891,8 @@ elf32_arm_size_stubs (bfd *output_bfd,
 	  asection *section;
 	  Elf_Internal_Sym *local_syms = NULL;
 
+	  num_a8_relocs = 0;
+
 	  /* We'll need the symbol table in a second.  */
 	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
 	  if (symtab_hdr->sh_info == 0)
@@ -3551,6 +3941,7 @@ elf32_arm_size_stubs (bfd *output_bfd,
 		  char *stub_name;
 		  const asection *id_sec;
 		  unsigned char st_type;
+		  bfd_boolean created_stub = FALSE;
 
 		  r_type = ELF32_R_TYPE (irela->r_info);
 		  r_indx = ELF32_R_SYM (irela->r_info);
@@ -3564,9 +3955,14 @@ elf32_arm_size_stubs (bfd *output_bfd,
 		      goto error_ret_free_local;
 		    }
 
-		  /* Only look for stubs on call instructions.  */
-		  if ((r_type != (unsigned int) R_ARM_CALL)
-		      && (r_type != (unsigned int) R_ARM_THM_CALL))
+		  /* Only look for stubs on call or Thumb-2 call/branch
+		     instructions.  */
+		  if (r_type != (unsigned int) R_ARM_CALL
+		      && r_type != (unsigned int) R_ARM_THM_CALL
+		      && r_type != (unsigned int) R_ARM_THM_JUMP24
+		      && r_type != (unsigned int) R_ARM_THM_JUMP19
+		      && r_type != (unsigned int) R_ARM_THM_CALL
+		      && r_type != (unsigned int) R_ARM_THM_XPC22)
 		    continue;
 
 		  /* Now determine the call target, its name, value,
@@ -3648,79 +4044,393 @@ elf32_arm_size_stubs (bfd *output_bfd,
 		      sym_name = hash->root.root.root.string;
 		    }
 
-		  /* Determine what (if any) linker stub is needed.  */
-		  stub_type = arm_type_of_stub (info, section, irela, st_type,
-						hash, destination, sym_sec,
-						input_bfd, sym_name);
-		  if (stub_type == arm_stub_none)
-		    continue;
+		  /* Only look for stubs on call instructions.  */
+		  if (r_type == (unsigned int) R_ARM_CALL
+		      || r_type == (unsigned int) R_ARM_THM_CALL)
+		    do
+		      {
+			/* Determine what (if any) linker stub is needed.  */
+			stub_type = arm_type_of_stub (info, section, irela,
+						      st_type, hash,
+						      destination, sym_sec,
+						      input_bfd, sym_name);
+			if (stub_type == arm_stub_none)
+			  break;
+
+			/* Support for grouping stub sections.  */
+			id_sec = htab->stub_group[section->id].link_sec;
+
+			/* Get the name of this stub.  */
+			stub_name = elf32_arm_stub_name (id_sec, sym_sec, hash,
+							 irela);
+			if (!stub_name)
+			  goto error_ret_free_internal;
 
-		  /* Support for grouping stub sections.  */
-		  id_sec = htab->stub_group[section->id].link_sec;
+			/* We've either created a stub for this reloc already,
+			   or we are about to.  */
+			created_stub = TRUE;
+
+			stub_entry = arm_stub_hash_lookup
+				       (&htab->stub_hash_table, stub_name,
+					FALSE, FALSE);
+			if (stub_entry != NULL)
+			  {
+			    /* The proper stub has already been created.  */
+			    free (stub_name);
+			    break;
+			  }
+
+			stub_entry = elf32_arm_add_stub (stub_name, section,
+							 htab);
+			if (stub_entry == NULL)
+			  {
+			    free (stub_name);
+			    goto error_ret_free_internal;
+			  }
 
-		  /* Get the name of this stub.  */
-		  stub_name = elf32_arm_stub_name (id_sec, sym_sec, hash, irela);
-		  if (!stub_name)
-		    goto error_ret_free_internal;
-
-		  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table,
-						    stub_name,
-						    FALSE, FALSE);
-		  if (stub_entry != NULL)
-		    {
-		      /* The proper stub has already been created.  */
-		      free (stub_name);
-		      continue;
-		    }
+			stub_entry->target_value = sym_value;
+			stub_entry->target_section = sym_sec;
+			stub_entry->stub_type = stub_type;
+			stub_entry->h = hash;
+			stub_entry->st_type = st_type;
+
+			if (sym_name == NULL)
+			  sym_name = "unnamed";
+			stub_entry->output_name
+			  = bfd_alloc (htab->stub_bfd,
+				       sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
+				       + strlen (sym_name));
+			if (stub_entry->output_name == NULL)
+			  {
+			    free (stub_name);
+			    goto error_ret_free_internal;
+			  }
 
-		  stub_entry = elf32_arm_add_stub (stub_name, section, htab);
-		  if (stub_entry == NULL)
-		    {
-		      free (stub_name);
-		      goto error_ret_free_internal;
-		    }
+			/* For historical reasons, use the existing names for
+			   ARM-to-Thumb and Thumb-to-ARM stubs.  */
+			if (r_type == (unsigned int) R_ARM_THM_CALL
+			    && st_type != STT_ARM_TFUNC)
+			  sprintf (stub_entry->output_name,
+				   THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
+			else if (r_type == (unsigned int) R_ARM_CALL
+				 && st_type == STT_ARM_TFUNC)
+			  sprintf (stub_entry->output_name,
+				   ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
+			else
+			  sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
+				   sym_name);
 
-		  stub_entry->target_value = sym_value;
-		  stub_entry->target_section = sym_sec;
-		  stub_entry->stub_type = stub_type;
-		  stub_entry->h = hash;
-		  stub_entry->st_type = st_type;
-
-		  if (sym_name == NULL)
-		    sym_name = "unnamed";
-		  stub_entry->output_name
-		    = bfd_alloc (htab->stub_bfd,
-				 sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
-				 + strlen (sym_name));
-		  if (stub_entry->output_name == NULL)
+			stub_changed = TRUE;
+		      }
+		    while (0);
+
+		  /* Look for relocations which might trigger Cortex-A8
+		     erratum.  */
+		  if (htab->fix_cortex_a8
+		      && (r_type == (unsigned int) R_ARM_THM_JUMP24
+			  || r_type == (unsigned int) R_ARM_THM_JUMP19
+			  || r_type == (unsigned int) R_ARM_THM_CALL
+			  || r_type == (unsigned int) R_ARM_THM_XPC22))
 		    {
-		      free (stub_name);
-		      goto error_ret_free_internal;
+		      bfd_vma from = section->output_section->vma
+			             + section->output_offset
+				     + irela->r_offset;
+
+		      if ((from & 0xfff) == 0xffe)
+		        {
+			  /* Found a candidate.  Note we haven't checked the
+			     destination is within 4K here: if we do so (and
+			     don't create an entry in a8_relocs) we can't tell
+			     that a branch should have been relocated when
+			     scanning later.  */
+			  if (num_a8_relocs == a8_reloc_table_size)
+			    {
+			      a8_reloc_table_size *= 2;
+			      a8_relocs = bfd_realloc (a8_relocs,
+			        sizeof (struct a8_erratum_reloc)
+				* a8_reloc_table_size);
+			    }
+			  
+			  a8_relocs[num_a8_relocs].from = from;
+			  a8_relocs[num_a8_relocs].destination = destination;
+			  a8_relocs[num_a8_relocs].r_type = r_type;
+			  a8_relocs[num_a8_relocs].st_type = st_type;
+			  a8_relocs[num_a8_relocs].sym_name = sym_name;
+			  a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
+			  
+			  num_a8_relocs++;
+			}
 		    }
-
-		  /* For historical reasons, use the existing names for
-		     ARM-to-Thumb and Thumb-to-ARM stubs.  */
-		  if (r_type == (unsigned int) R_ARM_THM_CALL
-		      && st_type != STT_ARM_TFUNC)
-		    sprintf (stub_entry->output_name, THUMB2ARM_GLUE_ENTRY_NAME,
-			     sym_name);
-		  else if (r_type == (unsigned int) R_ARM_CALL
-			   && st_type == STT_ARM_TFUNC)
-		    sprintf (stub_entry->output_name, ARM2THUMB_GLUE_ENTRY_NAME,
-			     sym_name);
-		  else
-		    sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
-			     sym_name);
-
-		  stub_changed = TRUE;
 		}
 
 	      /* We're done with the internal relocs, free them.  */
 	      if (elf_section_data (section)->relocs == NULL)
 		free (internal_relocs);
 	    }
+	  
+	  if (!htab->fix_cortex_a8)
+	    continue;
+
+	  /* Sort relocs which might apply to Cortex-A8 erratum.  */
+	  qsort (a8_relocs, num_a8_relocs, sizeof (struct a8_erratum_reloc),
+		 &a8_reloc_compare);
+	  
+	  /* Scan for branches which might trigger Cortex-A8 erratum.  */
+	  for (section = input_bfd->sections;
+	       section != NULL;
+	       section = section->next)
+	    {
+	      bfd_byte *contents = NULL;
+	      struct _arm_elf_section_data *sec_data;
+	      unsigned int span;
+	      bfd_vma base_vma;
+
+	      if (elf_section_type (section) != SHT_PROGBITS
+		  || (elf_section_flags (section) & SHF_EXECINSTR) == 0
+		  || (section->flags & SEC_EXCLUDE) != 0
+		  || (section->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
+		  || (section->output_section == bfd_abs_section_ptr))
+		continue;
+
+	      base_vma = section->output_section->vma
+				 + section->output_offset;
+
+	      if (elf_section_data (section)->this_hdr.contents != NULL)
+		contents = elf_section_data (section)->this_hdr.contents;
+	      else if (! bfd_malloc_and_get_section (input_bfd, section,
+						     &contents))
+		goto error_ret_free_local;
+
+	      sec_data = elf32_arm_section_data (section);
+
+	      for (span = 0; span < sec_data->mapcount; span++)
+		{
+		  unsigned int span_start = sec_data->map[span].vma;
+		  unsigned int span_end = (span == sec_data->mapcount - 1)
+		    ? section->size : sec_data->map[span + 1].vma;
+		  unsigned int i;
+		  char span_type = sec_data->map[span].type;
+		  bfd_boolean last_was_32bit = FALSE;
+
+		  if (span_type != 't')
+		    continue;
+
+		  /* Span is entirely within a single 4KB region: skip
+		     scanning.  */
+		  if (((base_vma + span_start) & ~0xfff)
+		      == ((base_vma + span_end) & ~0xfff))
+		    continue;
+
+		  /* Scan for 32-bit Thumb-2 branches which span two 4K
+		     regions, where:
+
+		       * The opcode is BLX.W, BL.W, B.W, Bcc.W
+		       * The branch target is in the same 4KB region as the
+			 first half of the branch.
+		       * The instruction before the branch is a 32-bit
+			 length non-branch instruction.
+		  */
+
+		  for (i = span_start; i < span_end;)
+		    {
+		      unsigned int insn = bfd_getl16 (&contents[i]);
+		      bfd_boolean insn_32bit = FALSE;
+
+		      if ((insn & 0xe000) == 0xe000
+			  && (insn & 0x1800) != 0x0000)
+			insn_32bit = TRUE;
+
+		      if (((base_vma + i) & 0xfff) == 0xffe
+			  && insn_32bit && last_was_32bit)
+			{
+			  bfd_vma offset;
+			  bfd_boolean is_blx = FALSE, is_b = FALSE;
+			  bfd_boolean is_bl = FALSE, force_target_arm = FALSE;
+			  bfd_boolean force_target_thumb = FALSE;
+			  bfd_vma target;
+			  enum elf32_arm_stub_type stub_type = arm_stub_none;
+			  struct a8_erratum_reloc key, *found;
+			  
+			  key.from = base_vma + i;
+			  found = bsearch (&key, a8_relocs, num_a8_relocs,
+					   sizeof (struct a8_erratum_reloc),
+					   &a8_reloc_compare);
+
+			  if (found)
+			    {
+			      char *error_message = NULL;
+			      struct elf_link_hash_entry *entry;
+
+			      /* We don't care about the error returned from
+			         this function, only if there is glue or
+				 not.  */
+			      entry = find_thumb_glue (info, found->sym_name,
+						       &error_message);
+
+			      if (entry)
+				found->non_a8_stub = TRUE;
+			
+			      if (found->r_type == R_ARM_THM_CALL
+				  && found->st_type != STT_ARM_TFUNC)
+				force_target_arm = TRUE;
+			      else if (found->r_type == R_ARM_THM_CALL
+				       && found->st_type == STT_ARM_TFUNC)
+				force_target_thumb = TRUE;
+			    }
+
+			  /* Load the rest of the insn (in manual-friendly
+			     order).  */
+			  insn = (insn << 16)
+			         | bfd_getl16 (&contents[i + 2]);
+
+			  /* Check if we have an offending branch
+			     instruction.  */
+
+			  /* Encoding T4: B<c>.W.  */
+			  is_b = (insn & 0xf800d000) == 0xf0009000;
+			  /* Encoding T1: BL<c>.W.  */
+			  is_bl = (insn & 0xf800d000) == 0xf000d000;
+			  /* Encoding T2: BLX<c>.W.  */
+			  is_blx = (insn & 0xf800d000) == 0xf000c000;
+
+			  if (found && found->non_a8_stub)
+			    /* We've already made a stub for this instruction,
+			       e.g. it's a long branch or a Thumb->ARM stub.
+			       Assume that stub will suffice to work around the
+			       A8 erratum (see setting of always_after_branch
+			       above).  */
+			    ;
+			  else if ((insn & 0xf800d000) == 0xf0008000
+			      && (insn & 0x07f00000) != 0x03800000)
+			    {
+			      /* Encoding T3: B<c>.W (not permitted in IT
+				 block).  */
+			      offset = (insn & 0x7ff) << 1;
+			      offset |= (insn & 0x3f0000) >> 4;
+			      offset |= (insn & 0x2000) ? 0x40000 : 0;
+			      offset |= (insn & 0x800) ? 0x80000 : 0;
+			      offset |= (insn & 0x4000000) ? 0x100000 : 0;
+			      if (offset & 0x100000)
+				offset |= ~0xfffff;
+			      stub_type = arm_stub_a8_veneer_b_cond;
+			    }
+			  else if (is_b || is_bl || is_blx)
+			    {
+			      int s = (insn & 0x4000000) != 0;
+			      int j1 = (insn & 0x2000) != 0;
+			      int j2 = (insn & 0x800) != 0;
+			      int i1 = !(j1 ^ s);
+			      int i2 = !(j2 ^ s);
+
+			      offset = (insn & 0x7ff) << 1;
+			      offset |= (insn & 0x3ff0000) >> 4;
+			      offset |= i2 << 22;
+			      offset |= i1 << 23;
+			      offset |= s << 24;
+			      if (offset & 0x1000000)
+				offset |= ~0xffffff;
+
+			      if (is_blx)
+			        offset &= ~3u;
+
+			      stub_type = is_blx ? arm_stub_a8_veneer_blx :
+				is_bl ? arm_stub_a8_veneer_bl :
+				arm_stub_a8_veneer_b;
+			    }
+
+			  if (stub_type != arm_stub_none)
+			    {
+			      bfd_vma pc_for_insn = base_vma + i + 4;
+
+			      /* The original instruction is a BL, but the
+			         target is an ARM instruction.  If we were not
+				 making a stub, the BL would have been
+				 converted to a BLX.  Use the BLX stub instead
+				 in that case.  */
+			      if (htab->use_blx && force_target_arm
+				  && stub_type == arm_stub_a8_veneer_bl)
+				{
+			          stub_type = arm_stub_a8_veneer_blx;
+				  is_blx = TRUE;
+				  is_bl = FALSE;
+				}
+			      /* Conversely, if the original instruction was
+			         BLX but the target is Thumb mode, use the BL
+				 stub.  */
+			      else if (force_target_thumb
+				       && stub_type == arm_stub_a8_veneer_blx)
+				{
+				  stub_type = arm_stub_a8_veneer_bl;
+				  is_blx = FALSE;
+				  is_bl = TRUE;
+				}
+
+			      if (is_blx)
+				pc_for_insn &= ~3u;
+
+			      /* If we found a relocation, use the proper
+			         destination, not the offset in the
+				 (unrelocated) instruction.  Note this is
+				 always done if we switched the stub type
+				 above.  */
+			      if (found)
+				offset = found->destination - pc_for_insn;
+
+			      target = pc_for_insn + offset;
+			      
+			      /* The BLX stub is ARM-mode code.  Adjust the
+			         offset to take the different PC value (+8
+				 instead of +4) into account.  */
+			      if (stub_type == arm_stub_a8_veneer_blx)
+			        offset += 4;
+
+			      if (((base_vma + i) & ~0xfff)
+				  == (target & ~0xfff))
+				{
+				  char *stub_name;
+
+				  if (num_a8_fixes == a8_fix_table_size)
+		        	    {
+				      a8_fix_table_size *= 2;
+				      a8_fixes = bfd_realloc (a8_fixes,
+					sizeof (struct a8_erratum_fix)
+					* a8_fix_table_size);
+				    }
+
+				  stub_name = bfd_malloc (8 + 1 + 8 + 1);
+				  if (stub_name != NULL)
+				    sprintf (stub_name, "%x:%x",
+					     section->id, i);
+
+				  a8_fixes[num_a8_fixes].input_bfd
+				    = input_bfd;
+				  a8_fixes[num_a8_fixes].section = section;
+				  a8_fixes[num_a8_fixes].offset = i;
+				  a8_fixes[num_a8_fixes].addend = offset;
+				  a8_fixes[num_a8_fixes].orig_insn = insn;
+				  a8_fixes[num_a8_fixes].stub_name
+				    = stub_name;
+				  a8_fixes[num_a8_fixes].stub_type
+				    = stub_type;
+
+				  num_a8_fixes++;
+				}
+			    }
+			}
+
+		      i += insn_32bit ? 4 : 2;
+		      last_was_32bit = insn_32bit;
+		    }
+		}
+
+	      if (elf_section_data (section)->this_hdr.contents == NULL)
+		free (contents);
+	    }
 	}
 
+      if (htab->fix_cortex_a8 && num_a8_fixes != prev_num_a8_fixes)
+        stub_changed = TRUE;
+
       if (!stub_changed)
 	break;
 
@@ -3729,13 +4439,113 @@ elf32_arm_size_stubs (bfd *output_bfd,
       for (stub_sec = htab->stub_bfd->sections;
 	   stub_sec != NULL;
 	   stub_sec = stub_sec->next)
-	stub_sec->size = 0;
+	{
+	  /* Ignore non-stub sections.  */
+	  if (!strstr (stub_sec->name, STUB_SUFFIX))
+	    continue;
+
+	  stub_sec->size = 0;
+	}
 
       bfd_hash_traverse (&htab->stub_hash_table, arm_size_one_stub, htab);
 
+      /* Add Cortex-A8 erratum veneers to stub section sizes too.  */
+      if (htab->fix_cortex_a8)
+	for (i = 0; i < num_a8_fixes; i++)
+          {
+	    unsigned int section_id = a8_fixes[i].section->id;
+	    asection *link_sec = htab->stub_group[section_id].link_sec;
+	    asection *stub_sec = htab->stub_group[section_id].stub_sec;
+
+	    /* Copied from elf32_arm_add_stub!  Refactor.  */
+	    if (stub_sec == NULL)
+	      {
+		stub_sec = htab->stub_group[link_sec->id].stub_sec;
+		if (stub_sec == NULL)
+	          {
+		    size_t namelen;
+		    bfd_size_type len;
+		    char *s_name;
+
+		    namelen = strlen (link_sec->name);
+		    len = namelen + sizeof (STUB_SUFFIX);
+		    s_name = bfd_alloc (htab->stub_bfd, len);
+		    if (s_name == NULL)
+		      goto error_ret_free_local;
+
+		    memcpy (s_name, link_sec->name, namelen);
+		    memcpy (s_name + namelen, STUB_SUFFIX,
+			    sizeof (STUB_SUFFIX));
+		    stub_sec = (*htab->add_stub_section) (s_name, link_sec);
+		    if (stub_sec == NULL)
+		      goto error_ret_free_local;
+		    htab->stub_group[link_sec->id].stub_sec = stub_sec;
+		  }
+		htab->stub_group[section_id].stub_sec = stub_sec;
+	      }
+
+	    stub_sec->size
+	      += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
+					      NULL);
+	  }
+
       /* Ask the linker to do its stuff.  */
       (*htab->layout_sections_again) ();
       stub_changed = FALSE;
+      prev_num_a8_fixes = num_a8_fixes;
+    }
+
+  /* Add stubs for Cortex-A8 erratum fixes now.  */
+  if (htab->fix_cortex_a8)
+    {
+      for (i = 0; i < num_a8_fixes; i++)
+	{
+	  struct elf32_arm_stub_hash_entry *stub_entry;
+	  char *stub_name = a8_fixes[i].stub_name;
+	  asection *section = a8_fixes[i].section;
+	  unsigned int section_id = a8_fixes[i].section->id;
+	  asection *link_sec = htab->stub_group[section_id].link_sec;
+	  asection *stub_sec = htab->stub_group[section_id].stub_sec;
+	  const insn_sequence *template;
+	  int template_size, size = 0;
+
+	  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
+					     TRUE, FALSE);
+	  if (stub_entry == NULL)
+            {
+	      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
+				     section->owner,
+				     stub_name);
+	      return FALSE;
+	    }
+
+	  stub_entry->stub_sec = stub_sec;
+	  stub_entry->stub_offset = 0;
+	  stub_entry->id_sec = link_sec;
+	  stub_entry->stub_type = a8_fixes[i].stub_type;
+	  stub_entry->target_section = a8_fixes[i].section;
+	  stub_entry->target_value = a8_fixes[i].offset;
+	  stub_entry->target_addend = a8_fixes[i].addend;
+	  stub_entry->orig_insn = a8_fixes[i].orig_insn;
+	  stub_entry->st_type = STT_ARM_TFUNC;
+
+	  size = find_stub_size_and_template (a8_fixes[i].stub_type, &template,
+					      &template_size);
+
+	  stub_entry->stub_size = size;
+	  stub_entry->stub_template = template;
+	  stub_entry->stub_template_size = template_size;
+	}
+
+      /* Stash the Cortex-A8 erratum fix array for use later in
+	 elf32_arm_write_section().  */
+      htab->a8_erratum_fixes = a8_fixes;
+      htab->num_a8_erratum_fixes = num_a8_fixes;
+    }
+  else
+    {
+      htab->a8_erratum_fixes = NULL;
+      htab->num_a8_erratum_fixes = 0;
     }
 
   return TRUE;
@@ -3913,6 +4723,7 @@ static const insn16 t2a2_noop_insn = 0x4
 static const insn32 t2a3_b_insn = 0xea000000;
 
 #define VFP11_ERRATUM_VENEER_SIZE 8
+#define JANUS_2CC_ERRATUM_VENEER_SIZE 12
 
 #define ARM_BX_VENEER_SIZE 12
 static const insn32 armbx1_tst_insn = 0xe3100001;
@@ -3927,7 +4738,16 @@ arm_allocate_glue_section_space (bfd * a
   bfd_byte * contents;
 
   if (size == 0)
-    return;
+    {
+      /* Do not include empty glue sections in the output.  */
+      if (abfd != NULL)
+	{
+	  s = bfd_get_section_by_name (abfd, name);
+	  if (s != NULL)
+	    s->flags |= SEC_EXCLUDE;
+	}
+      return;
+    }
 
   BFD_ASSERT (abfd != NULL);
 
@@ -3964,6 +4784,10 @@ bfd_elf32_arm_allocate_interworking_sect
 				   globals->bx_glue_size,
 				   ARM_BX_GLUE_SECTION_NAME);
 
+  arm_allocate_glue_section_space (globals->bfd_of_glue_owner,
+				   globals->janus_2cc_erratum_glue_size,
+				   JANUS_2CC_ERRATUM_VENEER_SECTION_NAME);
+
   return TRUE;
 }
 
@@ -4208,16 +5032,16 @@ elf32_arm_section_map_add (asection *sec
     }
 }
 
-
-/* Record information about a VFP11 denorm-erratum veneer.  Only ARM-mode
-   veneers are handled for now.  */
+/* Record information about a CPU erratum veneer.  Only ARM-mode veneers are
+   handled for now.  */
 
 static bfd_vma
-record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
-                             elf32_vfp11_erratum_list *branch,
-                             bfd *branch_bfd,
-                             asection *branch_sec,
-                             unsigned int offset)
+record_cpu_erratum_veneer (struct bfd_link_info *link_info,
+                           elf32_cpu_erratum_list *branch,
+                           bfd *branch_bfd,
+                           asection *branch_sec,
+                           unsigned int offset,
+			   elf32_cpu_erratum_type erratum_type)
 {
   asection *s;
   struct elf32_arm_link_hash_table *hash_table;
@@ -4227,27 +5051,43 @@ record_vfp11_erratum_veneer (struct bfd_
   bfd_vma val;
   struct _arm_elf_section_data *sec_data;
   int errcount;
-  elf32_vfp11_erratum_list *newerr;
-
+  elf32_cpu_erratum_list *newerr;
+  const char *veneer_section_name;
+  const char *veneer_entry_name;
+
+  switch (erratum_type)
+    {
+    case VFP11_ERRATUM_ARM_VENEER:
+      veneer_section_name = VFP11_ERRATUM_VENEER_SECTION_NAME;
+      veneer_entry_name = VFP11_ERRATUM_VENEER_ENTRY_NAME;
+      break;
+    
+    case JANUS_2CC_ERRATUM_ARM_VENEER:
+      veneer_section_name = JANUS_2CC_ERRATUM_VENEER_SECTION_NAME;
+      veneer_entry_name = JANUS_2CC_ERRATUM_VENEER_ENTRY_NAME;
+      break;
+    
+    default:
+      abort ();
+    }
+  
   hash_table = elf32_arm_hash_table (link_info);
 
   BFD_ASSERT (hash_table != NULL);
   BFD_ASSERT (hash_table->bfd_of_glue_owner != NULL);
 
   s = bfd_get_section_by_name
-    (hash_table->bfd_of_glue_owner, VFP11_ERRATUM_VENEER_SECTION_NAME);
+    (hash_table->bfd_of_glue_owner, veneer_section_name);
 
   sec_data = elf32_arm_section_data (s);
 
   BFD_ASSERT (s != NULL);
 
-  tmp_name = bfd_malloc ((bfd_size_type) strlen
-			 (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
+  tmp_name = bfd_malloc (MAX_ERRATUM_SYMBOL_LENGTH);
 
   BFD_ASSERT (tmp_name);
 
-  sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
-	   hash_table->num_vfp11_fixes);
+  sprintf (tmp_name, veneer_entry_name, hash_table->num_errata_fixes, "");
 
   myh = elf_link_hash_lookup
     (&(hash_table)->root, tmp_name, FALSE, FALSE, FALSE);
@@ -4255,7 +5095,21 @@ record_vfp11_erratum_veneer (struct bfd_
   BFD_ASSERT (myh == NULL);
 
   bh = NULL;
-  val = hash_table->vfp11_erratum_glue_size;
+
+  switch (erratum_type)
+    {
+    case VFP11_ERRATUM_ARM_VENEER:
+      val = hash_table->vfp11_erratum_glue_size;
+      break;
+    
+    case JANUS_2CC_ERRATUM_ARM_VENEER:
+      val = hash_table->janus_2cc_erratum_glue_size;
+      break;
+    
+    default:
+      abort ();
+    }
+
   _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
                                     tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
                                     NULL, TRUE, FALSE, &bh);
@@ -4266,20 +5120,19 @@ record_vfp11_erratum_veneer (struct bfd_
 
   /* Link veneer back to calling location.  */
   errcount = ++(sec_data->erratumcount);
-  newerr = bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
+  newerr = bfd_zmalloc (sizeof (elf32_cpu_erratum_list));
 
-  newerr->type = VFP11_ERRATUM_ARM_VENEER;
+  newerr->type = erratum_type;
   newerr->vma = -1;
   newerr->u.v.branch = branch;
-  newerr->u.v.id = hash_table->num_vfp11_fixes;
+  newerr->u.v.id = hash_table->num_errata_fixes;
   branch->u.b.veneer = newerr;
 
   newerr->next = sec_data->erratumlist;
   sec_data->erratumlist = newerr;
 
   /* A symbol for the return from the veneer.  */
-  sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
-	   hash_table->num_vfp11_fixes);
+  sprintf (tmp_name, veneer_entry_name, hash_table->num_errata_fixes, "_r");
 
   myh = elf_link_hash_lookup
     (&(hash_table)->root, tmp_name, FALSE, FALSE, FALSE);
@@ -4300,7 +5153,10 @@ record_vfp11_erratum_veneer (struct bfd_
 
   /* Generate a mapping symbol for the veneer section, and explicitly add an
      entry for that symbol to the code/data map for the section.  */
-  if (hash_table->vfp11_erratum_glue_size == 0)
+  if ((erratum_type == VFP11_ERRATUM_ARM_VENEER
+       && hash_table->vfp11_erratum_glue_size == 0)
+      || (erratum_type == JANUS_2CC_ERRATUM_ARM_VENEER
+          && hash_table->janus_2cc_erratum_glue_size == 0))
     {
       bh = NULL;
       /* FIXME: Creates an ARM symbol.  Thumb mode will need attention if it
@@ -4321,19 +5177,31 @@ record_vfp11_erratum_veneer (struct bfd_
       elf32_arm_section_map_add (s, 'a', 0);
     }
 
-  s->size += VFP11_ERRATUM_VENEER_SIZE;
-  hash_table->vfp11_erratum_glue_size += VFP11_ERRATUM_VENEER_SIZE;
-  hash_table->num_vfp11_fixes++;
+  switch (erratum_type)
+    {
+    case VFP11_ERRATUM_ARM_VENEER:
+      s->size += VFP11_ERRATUM_VENEER_SIZE;
+      hash_table->vfp11_erratum_glue_size += VFP11_ERRATUM_VENEER_SIZE;
+      break;
+    
+    case JANUS_2CC_ERRATUM_ARM_VENEER:
+      s->size += JANUS_2CC_ERRATUM_VENEER_SIZE;
+      hash_table->janus_2cc_erratum_glue_size += JANUS_2CC_ERRATUM_VENEER_SIZE;
+      break;
+    
+    default:
+      abort ();
+    }
+
+  hash_table->num_errata_fixes++;
 
   /* The offset of the veneer.  */
   return val;
 }
 
-/* Note: we do not include the flag SEC_LINKER_CREATED, as that
-   would prevent elf_link_input_bfd() from processing the contents
-   of the section.  */
 #define ARM_GLUE_SECTION_FLAGS \
-  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY)
+  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE \
+   | SEC_READONLY | SEC_LINKER_CREATED)
 
 /* Create a fake section for use by the ARM backend of the linker.  */
 
@@ -4372,10 +5240,6 @@ bfd_elf32_arm_add_glue_sections_to_bfd (
   if (info->relocatable)
     return TRUE;
 
-  /* Linker stubs don't need glue.  */
-  if (!strcmp (abfd->filename, "linker stubs"))
-    return TRUE;
-
   return arm_make_glue_section (abfd, ARM2THUMB_GLUE_SECTION_NAME)
     && arm_make_glue_section (abfd, THUMB2ARM_GLUE_SECTION_NAME)
     && arm_make_glue_section (abfd, VFP11_ERRATUM_VENEER_SECTION_NAME)
@@ -4648,6 +5512,47 @@ bfd_elf32_arm_init_maps (bfd *abfd)
 }
 
 
+/* Check we're not doing applying the (invasive) Janus 2CC erratum fix
+   unnecessarily.  */
+
+void
+bfd_elf32_arm_validate_janus_2cc_fix (bfd *obfd,
+				      struct bfd_link_info *link_info)
+{
+  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
+  obj_attribute *out_attr = elf_known_obj_attributes_proc (obfd);
+  
+  /* Janus 2CC is archv4t.  We should never need the fix on higher architecture
+     versions, so emit an error in that case.  */
+  if (globals->fix_janus_2cc
+      && out_attr[Tag_CPU_arch].i >= TAG_CPU_ARCH_V5T)
+   (*_bfd_error_handler) (_("%B: error: Janus 2CC erratum workaround cannot "
+      "be used with selected target architecture"), obfd);
+}
+
+
+/* Auto-select enabling of Cortex-A8 erratum fix if the user didn't explicitly
+   say what they wanted.  */
+
+void
+bfd_elf32_arm_set_cortex_a8_fix (bfd *obfd ATTRIBUTE_UNUSED,
+				 struct bfd_link_info *link_info)
+{
+  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
+  obj_attribute *out_attr = elf_known_obj_attributes_proc (obfd);
+
+  if (globals->fix_cortex_a8 == -1)
+    {
+      /* Turn on Cortex-A8 erratum workaround for ARMv7-A.  */
+      if (out_attr[Tag_CPU_arch].i == TAG_CPU_ARCH_V7
+          && (out_attr[Tag_CPU_arch_profile].i == 'A'
+	      || out_attr[Tag_CPU_arch_profile].i == 0))
+	globals->fix_cortex_a8 = 1;
+      else
+	globals->fix_cortex_a8 = 0;
+    }
+}
+
 void
 bfd_elf32_arm_set_vfp11_fix (bfd *obfd, struct bfd_link_info *link_info)
 {
@@ -4671,10 +5576,10 @@ bfd_elf32_arm_set_vfp11_fix (bfd *obfd, 
         }
     }
   else if (globals->vfp11_fix == BFD_ARM_VFP11_FIX_DEFAULT)
-    /* For earlier architectures, we might need the workaround, but do not
-       enable it by default.  If users is running with broken hardware, they
-       must enable the erratum fix explicitly.  */
-    globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
+    /* For earlier architectures, we might need the workaround.  The compiler
+       only generates scalar code at present, so this should be sufficient in
+       most cases.  */
+    globals->vfp11_fix = BFD_ARM_VFP11_FIX_SCALAR;
 }
 
 
@@ -5112,13 +6017,13 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *a
 
               if (state == 3)
                 {
-                  elf32_vfp11_erratum_list *newerr
-                    = bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
+                  elf32_cpu_erratum_list *newerr
+                    = bfd_zmalloc (sizeof (elf32_cpu_erratum_list));
                   int errcount;
 
                   errcount = ++(elf32_arm_section_data (sec)->erratumcount);
 
-                  newerr->u.b.vfp_insn = veneer_of_insn;
+                  newerr->u.b.orig_insn = veneer_of_insn;
 
                   switch (span_type)
                     {
@@ -5130,8 +6035,9 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *a
                       abort ();
                     }
 
-                  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
-					       first_fmac);
+                  record_cpu_erratum_veneer (link_info, newerr, abfd, sec,
+					     first_fmac,
+					     VFP11_ERRATUM_ARM_VENEER);
 
                   newerr->vma = -1;
 
@@ -5165,8 +6071,8 @@ error_return:
    after sections have been laid out, using specially-named symbols.  */
 
 void
-bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
-					  struct bfd_link_info *link_info)
+bfd_elf32_arm_fix_veneer_locations (bfd *abfd,
+				    struct bfd_link_info *link_info)
 {
   asection *sec;
   struct elf32_arm_link_hash_table *globals;
@@ -5181,13 +6087,12 @@ bfd_elf32_arm_vfp11_fix_veneer_locations
 
   globals = elf32_arm_hash_table (link_info);
 
-  tmp_name = bfd_malloc ((bfd_size_type) strlen
-			   (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
+  tmp_name = bfd_malloc (MAX_ERRATUM_SYMBOL_LENGTH);
 
   for (sec = abfd->sections; sec != NULL; sec = sec->next)
     {
       struct _arm_elf_section_data *sec_data = elf32_arm_section_data (sec);
-      elf32_vfp11_erratum_list *errnode = sec_data->erratumlist;
+      elf32_cpu_erratum_list *errnode = sec_data->erratumlist;
 
       for (; errnode != NULL; errnode = errnode->next)
         {
@@ -5200,7 +6105,7 @@ bfd_elf32_arm_vfp11_fix_veneer_locations
             case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
               /* Find veneer symbol.  */
               sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
-		       errnode->u.b.veneer->u.v.id);
+		       errnode->u.b.veneer->u.v.id, "");
 
               myh = elf_link_hash_lookup
                 (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
@@ -5216,11 +6121,30 @@ bfd_elf32_arm_vfp11_fix_veneer_locations
               errnode->u.b.veneer->vma = vma;
               break;
 
+	    case JANUS_2CC_ERRATUM_BRANCH_TO_ARM_VENEER:
+	      /* Find veneer symbol.  */
+	      sprintf (tmp_name, JANUS_2CC_ERRATUM_VENEER_ENTRY_NAME,
+		       errnode->u.b.veneer->u.v.id, "");
+
+	      myh = elf_link_hash_lookup
+	        (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
+	
+	      if (myh == NULL)
+	        (*_bfd_error_handler) (_("%B: unable to find Janus 2CC veneer "
+					 "`%s'"), abfd, tmp_name);
+
+	      vma = myh->root.u.def.section->output_section->vma
+		    + myh->root.u.def.section->output_offset
+		    + myh->root.u.def.value;
+
+	      errnode->u.b.veneer->vma = vma;
+	      break;
+
 	    case VFP11_ERRATUM_ARM_VENEER:
             case VFP11_ERRATUM_THUMB_VENEER:
               /* Find return location.  */
-              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
-                       errnode->u.v.id);
+              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
+                       errnode->u.v.id, "_r");
 
               myh = elf_link_hash_lookup
                 (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
@@ -5236,6 +6160,25 @@ bfd_elf32_arm_vfp11_fix_veneer_locations
               errnode->u.v.branch->vma = vma;
               break;
 
+	    case JANUS_2CC_ERRATUM_ARM_VENEER:
+	      /* Find return location.  */
+	      sprintf (tmp_name, JANUS_2CC_ERRATUM_VENEER_ENTRY_NAME,
+		       errnode->u.v.id, "_r");
+
+	      myh = elf_link_hash_lookup
+	        (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
+
+	      if (myh == NULL)
+		(*_bfd_error_handler) (_("%B: unable to find Janus 2CC veneer "
+					 "`%s'"), abfd, tmp_name);
+
+              vma = myh->root.u.def.section->output_section->vma
+                    + myh->root.u.def.section->output_offset
+                    + myh->root.u.def.value;
+
+              errnode->u.v.branch->vma = vma;
+              break;
+	    
             default:
               abort ();
             }
@@ -5246,6 +6189,183 @@ bfd_elf32_arm_vfp11_fix_veneer_locations
 }
 
 
+/* Look for instruction sequences which can trigger the Janus 2CC shifter
+   erratum.  Any instruction which uses a register-specified shift, which is
+   not followed by a NOP instruction, is susceptible.
+   
+   NOTE: This function is only meant to work for architecture v4t, as
+   implemented by Janus 2CC (see bfd_elf32_arm_validate_janus_2cc_fix). 
+   Instruction encodings for later architectures (e.g. ARM blx, Thumb-2) will
+   not be handled correctly.  */
+
+bfd_boolean
+bfd_elf32_arm_janus_2cc_erratum_scan (bfd *abfd,
+				      struct bfd_link_info *link_info)
+{
+  asection *sec;
+  bfd_byte *contents = NULL;
+  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
+
+  /* Don't do anything if Janus 2CC fix is not enabled.  */
+  if (!globals->fix_janus_2cc)
+    return TRUE;
+
+  /* If we are only performing a partial link do not bother
+     to construct any glue.  */
+  if (link_info->relocatable)
+    return TRUE;
+  
+  /* Skip if this bfd does not correspond to an ELF image.  */
+  if (! is_arm_elf (abfd))
+    return TRUE;
+  
+  /* Skip this BFD if it corresponds to an executable or dynamic object.  */
+  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
+    return TRUE;
+  
+  for (sec = abfd->sections; sec != NULL; sec = sec->next)
+    {
+      unsigned int i, next_i, span, veneer_of_insn = 0;
+      struct _arm_elf_section_data *sec_data;
+
+      /* If we don't have executable progbits, we're not interested in this
+         section.  Also skip if section is to be excluded.  */
+      if (elf_section_type (sec) != SHT_PROGBITS
+          || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
+          || (sec->flags & SEC_EXCLUDE) != 0
+	  || sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS
+	  || sec->output_section == bfd_abs_section_ptr
+          || strcmp (sec->name, JANUS_2CC_ERRATUM_VENEER_SECTION_NAME) == 0)
+        continue;
+
+      sec_data = elf32_arm_section_data (sec);
+      
+      if (sec_data->mapcount == 0)
+        continue;
+
+      if (elf_section_data (sec)->this_hdr.contents != NULL)
+        contents = elf_section_data (sec)->this_hdr.contents;
+      else if (! bfd_malloc_and_get_section (abfd, sec, &contents))
+        goto error_return;
+	
+      qsort (sec_data->map, sec_data->mapcount, sizeof (elf32_arm_section_map),
+	     elf32_arm_compare_mapping);
+	     
+      for (span = 0; span < sec_data->mapcount; span++)
+        {
+	  unsigned int span_start = sec_data->map[span].vma;
+	  unsigned int span_end = (span == sec_data->mapcount - 1)
+				  ? sec->size : sec_data->map[span + 1].vma;
+	  char span_type = sec_data->map[span].type;
+	  int state = 0;
+	  
+	  switch (span_type)
+	    {
+	    case 'a':
+	      for (i = span_start; i < span_end;)
+		{
+		  unsigned int insn = bfd_get_32 (abfd, contents + i);
+		  
+		  next_i = i + 4;
+
+		  switch (state)
+	            {
+		    case 0:
+		      /* Data processing insn with register shift.  */
+		      if (((insn & 0x0e000090) == 0x00000010)
+			  && ((insn & 0x0ff000f0) != 0x01200010))  /* bx.  */
+		        {
+			  veneer_of_insn = insn;
+			  state = 1;
+			}
+		      break;
+
+		    case 1:
+		      /* Not a NOP (only accept mov r0, r0).  */
+		      if ((insn & 0x0fffffff) != 0x01a00000)
+		        {
+			  elf32_cpu_erratum_list *newerr;
+			  int errcount;
+			  
+			  /* Lose if Rd, Rn or Rm is PC.  Don't bother
+			     checking Rs.  */
+			  if ((veneer_of_insn & 0x000f0000) == 0x000f0000
+			      || (veneer_of_insn & 0x0000f000) == 0x0000f000
+			      || (veneer_of_insn & 0x0000000f) == 0x0000000f)
+			    (*_bfd_error_handler) (_("%B(%A+0x%lx): error: ARM "
+			      "instruction sequence using PC triggers "
+			      "Janus 2CC erratum (must be fixed manually)"),
+			      abfd, sec, i);
+			  
+			  newerr
+			    = bfd_zmalloc (sizeof (elf32_cpu_erratum_list));
+			  
+			  errcount
+			    = ++(elf32_arm_section_data (sec)->erratumcount);
+			  
+			  newerr->u.b.orig_insn = veneer_of_insn;
+			  newerr->type = JANUS_2CC_ERRATUM_BRANCH_TO_ARM_VENEER;
+			  
+			  record_cpu_erratum_veneer (link_info, newerr, abfd,
+			    sec, i - 4, JANUS_2CC_ERRATUM_ARM_VENEER);
+			  
+			  newerr->vma = -1;
+			  
+			  newerr->next = sec_data->erratumlist;
+			  sec_data->erratumlist = newerr;
+			  /* Re-scan current instruction in case of adjacent
+			     trigger insns.  */
+			  next_i = i;
+			}
+		      state = 0;
+		      break;
+		    }
+
+		  i = next_i;
+		}
+	      break;
+
+	    case 't':
+	      for (i = span_start; i < span_end; i += 2)
+	        {
+		  unsigned short insn = bfd_get_16 (abfd, contents + i);
+
+		  switch (state)
+		    {
+		    case 0:
+		      if (((insn & 0xffc0) == 0x4100)     /* ASR.  */
+		          || ((insn & 0xffc0) == 0x4080)  /* LSL.  */
+			  || ((insn & 0xffc0) == 0x40c0)  /* LSR.  */
+			  || ((insn & 0xffc0) == 0x41c0))  /* ROR.  */
+		        state = 1;
+		      break;
+
+		    case 1:
+		      /* Not a NOP (only accept cpy r8, r8).  */
+		      if (insn != 0x46c0)
+			(*_bfd_error_handler) (_("%B(%A+0x%lx): error: Thumb "
+			  "instruction sequence triggers Janus 2CC erratum "
+			  "(must be fixed manually)"),
+			  abfd, sec, i);
+		      state = 0;
+		      break;
+		    }
+		}
+	      break;
+	    
+	    default:
+	      ;
+	    }  
+	}
+    }
+
+  return TRUE;
+
+error_return:
+  return FALSE;
+}
+
+
 /* Set target relocation values needed during linking.  */
 
 void
@@ -5257,7 +6377,8 @@ bfd_elf32_arm_set_target_relocs (struct 
 				 int use_blx,
                                  bfd_arm_vfp11_fix vfp11_fix,
 				 int no_enum_warn, int no_wchar_warn,
-				 int pic_veneer)
+				 int pic_veneer, int fix_janus_2cc,
+				 int fix_cortex_a8)
 {
   struct elf32_arm_link_hash_table *globals;
 
@@ -5279,6 +6400,8 @@ bfd_elf32_arm_set_target_relocs (struct 
   globals->use_blx |= use_blx;
   globals->vfp11_fix = vfp11_fix;
   globals->pic_veneer = pic_veneer;
+  globals->fix_janus_2cc = fix_janus_2cc;
+  globals->fix_cortex_a8 = fix_cortex_a8;
 
   BFD_ASSERT (is_arm_elf (output_bfd));
   elf_arm_tdata (output_bfd)->no_enum_size_warning = no_enum_warn;
@@ -7933,72 +9056,378 @@ elf32_arm_relocate_section (bfd *       
 					  ELF_ST_TYPE (sym->st_info)), h,
 					 &unresolved_reloc, &error_message);
 
-      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
-	 because such sections are not SEC_ALLOC and thus ld.so will
-	 not process them.  */
-      if (unresolved_reloc
-          && !((input_section->flags & SEC_DEBUGGING) != 0
-               && h->def_dynamic))
+      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
+	 because such sections are not SEC_ALLOC and thus ld.so will
+	 not process them.  */
+      if (unresolved_reloc
+          && !((input_section->flags & SEC_DEBUGGING) != 0
+               && h->def_dynamic))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
+	     input_bfd,
+	     input_section,
+	     (long) rel->r_offset,
+	     howto->name,
+	     h->root.root.string);
+	  return FALSE;
+	}
+
+      if (r != bfd_reloc_ok)
+	{
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      /* If the overflowing reloc was to an undefined symbol,
+		 we have already printed one error message and there
+		 is no point complaining again.  */
+	      if ((! h ||
+		   h->root.type != bfd_link_hash_undefined)
+		  && (!((*info->callbacks->reloc_overflow)
+			(info, (h ? &h->root : NULL), name, howto->name,
+			 (bfd_vma) 0, input_bfd, input_section,
+			 rel->r_offset))))
+		  return FALSE;
+	      break;
+
+	    case bfd_reloc_undefined:
+	      if (!((*info->callbacks->undefined_symbol)
+		    (info, name, input_bfd, input_section,
+		     rel->r_offset, TRUE)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      error_message = _("out of range");
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      error_message = _("unsupported relocation");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      /* error_message should already be set.  */
+	      goto common_error;
+
+	    default:
+	      error_message = _("unknown error");
+	      /* Fall through.  */
+
+	    common_error:
+	      BFD_ASSERT (error_message != NULL);
+	      if (!((*info->callbacks->reloc_dangerous)
+		    (info, error_message, input_bfd, input_section,
+		     rel->r_offset)))
+		return FALSE;
+	      break;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Add a new unwind edit to the list described by HEAD, TAIL.  If INDEX is zero,
+   adds the edit to the start of the list.  (The list must be built in order of
+   ascending INDEX: the function's callers are primarily responsible for
+   maintaining that condition).  */
+
+static void
+add_unwind_table_edit (arm_unwind_table_edit **head,
+		       arm_unwind_table_edit **tail,
+		       arm_unwind_edit_type type,
+		       asection *linked_section,
+		       unsigned int index)
+{
+  arm_unwind_table_edit *new_edit = xmalloc (sizeof (arm_unwind_table_edit));
+  
+  new_edit->type = type;
+  new_edit->linked_section = linked_section;
+  new_edit->index = index;
+  
+  if (index > 0)
+    {
+      new_edit->next = NULL;
+
+      if (*tail)
+	(*tail)->next = new_edit;
+
+      (*tail) = new_edit;
+
+      if (!*head)
+	(*head) = new_edit;
+    }
+  else
+    {
+      new_edit->next = *head;
+
+      if (!*tail)
+	*tail = new_edit;
+
+      *head = new_edit;
+    }
+}
+
+static _arm_elf_section_data *get_arm_elf_section_data (asection *);
+
+/* Increase the size of EXIDX_SEC by ADJUST bytes.  ADJUST mau be negative.  */
+static void
+adjust_exidx_size(asection *exidx_sec, int adjust)
+{
+  asection *out_sec;
+
+  if (!exidx_sec->rawsize)
+    exidx_sec->rawsize = exidx_sec->size;
+
+  bfd_set_section_size (exidx_sec->owner, exidx_sec, exidx_sec->size + adjust);
+  out_sec = exidx_sec->output_section;
+  /* Adjust size of output section.  */
+  bfd_set_section_size (out_sec->owner, out_sec, out_sec->size +adjust);
+}
+
+/* Insert an EXIDX_CANTUNWIND marker at the end of a section.  */
+static void
+insert_cantunwind_after(asection *text_sec, asection *exidx_sec)
+{
+  struct _arm_elf_section_data *exidx_arm_data;
+
+  exidx_arm_data = get_arm_elf_section_data (exidx_sec);
+  add_unwind_table_edit (
+    &exidx_arm_data->u.exidx.unwind_edit_list,
+    &exidx_arm_data->u.exidx.unwind_edit_tail,
+    INSERT_EXIDX_CANTUNWIND_AT_END, text_sec, UINT_MAX);
+
+  adjust_exidx_size(exidx_sec, 8);
+}
+
+/* Scan .ARM.exidx tables, and create a list describing edits which should be
+   made to those tables, such that:
+   
+     1. Regions without unwind data are marked with EXIDX_CANTUNWIND entries.
+     2. Duplicate entries are merged together (EXIDX_CANTUNWIND, or unwind
+        codes which have been inlined into the index).
+
+   The edits are applied when the tables are written
+   (in elf32_arm_write_section).
+*/
+
+bfd_boolean
+elf32_arm_fix_exidx_coverage (asection **text_section_order,
+			      unsigned int num_text_sections,
+			      struct bfd_link_info *info)
+{
+  bfd *inp;
+  unsigned int last_second_word = 0, i;
+  asection *last_exidx_sec = NULL;
+  asection *last_text_sec = NULL;
+  int last_unwind_type = -1;
+
+  /* Walk over all EXIDX sections, and create backlinks from the corrsponding
+     text sections.  */
+  for (inp = info->input_bfds; inp != NULL; inp = inp->link_next)
+    {
+      asection *sec;
+      
+      for (sec = inp->sections; sec != NULL; sec = sec->next)
+        {
+	  struct bfd_elf_section_data *elf_sec = elf_section_data (sec);
+	  Elf_Internal_Shdr *hdr = &elf_sec->this_hdr;
+	  
+	  if (hdr->sh_type != SHT_ARM_EXIDX)
+	    continue;
+	  
+	  if (elf_sec->linked_to)
+	    {
+	      Elf_Internal_Shdr *linked_hdr
+	        = &elf_section_data (elf_sec->linked_to)->this_hdr;
+	      struct _arm_elf_section_data *linked_sec_arm_data
+	        = get_arm_elf_section_data (linked_hdr->bfd_section);
+
+	      if (linked_sec_arm_data == NULL)
+	        continue;
+
+	      /* Link this .ARM.exidx section back from the text section it
+	         describes.  */
+	      linked_sec_arm_data->u.text.arm_exidx_sec = sec;
+	    }
+	}
+    }
+
+  /* Walk all text sections in order of increasing VMA.  Eilminate duplicate
+     index table entries (EXIDX_CANTUNWIND and inlined unwind opcodes),
+     and add EXIDX_CANTUNWIND entries for sections with no unwind table data.
+   */
+
+  for (i = 0; i < num_text_sections; i++)
+    {
+      asection *sec = text_section_order[i];
+      asection *exidx_sec;
+      struct _arm_elf_section_data *arm_data = get_arm_elf_section_data (sec);
+      struct _arm_elf_section_data *exidx_arm_data;
+      bfd_byte *contents = NULL;
+      int deleted_exidx_bytes = 0;
+      bfd_vma j;
+      arm_unwind_table_edit *unwind_edit_head = NULL;
+      arm_unwind_table_edit *unwind_edit_tail = NULL;
+      Elf_Internal_Shdr *hdr;
+      bfd *ibfd;
+
+      if (arm_data == NULL)
+        continue;
+
+      exidx_sec = arm_data->u.text.arm_exidx_sec;
+      if (exidx_sec == NULL)
 	{
-	  (*_bfd_error_handler)
-	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
-	     input_bfd,
-	     input_section,
-	     (long) rel->r_offset,
-	     howto->name,
-	     h->root.root.string);
-	  return FALSE;
+	  /* Section has no unwind data.  */
+	  if (last_unwind_type == 0 || !last_exidx_sec)
+	    continue;
+
+	  /* Ignore zero sized sections.  */
+	  if (sec->size == 0)
+	    continue;
+
+	  insert_cantunwind_after(last_text_sec, last_exidx_sec);
+	  last_unwind_type = 0;
+	  continue;
 	}
 
-      if (r != bfd_reloc_ok)
+      if (bfd_is_abs_section (exidx_sec->output_section))
+	/* The linker script probably has /DISCARD/ for this section.  */
+	continue;
+
+      hdr = &elf_section_data (exidx_sec)->this_hdr;
+      if (hdr->sh_type != SHT_ARM_EXIDX)
+        continue;
+      
+      exidx_arm_data = get_arm_elf_section_data (exidx_sec);
+      if (exidx_arm_data == NULL)
+        continue;
+      
+      ibfd = exidx_sec->owner;
+	  
+      if (hdr->contents != NULL)
+	contents = hdr->contents;
+      else if (! bfd_malloc_and_get_section (ibfd, exidx_sec, &contents))
+	/* An error?  */
+	continue;
+
+      for (j = 0; j < hdr->sh_size; j += 8)
 	{
-	  switch (r)
+	  unsigned int second_word = bfd_get_32 (ibfd, contents + j + 4);
+	  int unwind_type;
+	  int elide = 0;
+
+	  /* An EXIDX_CANTUNWIND entry.  */
+	  if (second_word == 1)
 	    {
-	    case bfd_reloc_overflow:
-	      /* If the overflowing reloc was to an undefined symbol,
-		 we have already printed one error message and there
-		 is no point complaining again.  */
-	      if ((! h ||
-		   h->root.type != bfd_link_hash_undefined)
-		  && (!((*info->callbacks->reloc_overflow)
-			(info, (h ? &h->root : NULL), name, howto->name,
-			 (bfd_vma) 0, input_bfd, input_section,
-			 rel->r_offset))))
-		  return FALSE;
-	      break;
+	      if (last_unwind_type == 0)
+		elide = 1;
+	      unwind_type = 0;
+	    }
+	  /* Inlined unwinding data.  Merge if equal to previous.  */
+	  else if ((second_word & 0x80000000) != 0)
+	    {
+	      if (last_second_word == second_word && last_unwind_type == 1)
+		elide = 1;
+	      unwind_type = 1;
+	      last_second_word = second_word;
+	    }
+	  /* Normal table entry.  In theory we could merge these too,
+	     but duplicate entries are likely to be much less common.  */
+	  else
+	    unwind_type = 2;
 
-	    case bfd_reloc_undefined:
-	      if (!((*info->callbacks->undefined_symbol)
-		    (info, name, input_bfd, input_section,
-		     rel->r_offset, TRUE)))
-		return FALSE;
-	      break;
+	  if (elide)
+	    {
+	      add_unwind_table_edit (&unwind_edit_head, &unwind_edit_tail,
+				     DELETE_EXIDX_ENTRY, NULL, j / 8);
 
-	    case bfd_reloc_outofrange:
-	      error_message = _("out of range");
-	      goto common_error;
+	      deleted_exidx_bytes += 8;
+	    }
 
-	    case bfd_reloc_notsupported:
-	      error_message = _("unsupported relocation");
-	      goto common_error;
+	  last_unwind_type = unwind_type;
+	}
 
-	    case bfd_reloc_dangerous:
-	      /* error_message should already be set.  */
-	      goto common_error;
+      /* Free contents if we allocated it ourselves.  */
+      if (contents != hdr->contents)
+        free (contents);
 
-	    default:
-	      error_message = _("unknown error");
-	      /* Fall through.  */
+      /* Record edits to be applied later (in elf32_arm_write_section).  */
+      exidx_arm_data->u.exidx.unwind_edit_list = unwind_edit_head;
+      exidx_arm_data->u.exidx.unwind_edit_tail = unwind_edit_tail;
+	  
+      if (deleted_exidx_bytes > 0)
+	adjust_exidx_size(exidx_sec, -deleted_exidx_bytes);
+
+      last_exidx_sec = exidx_sec;
+      last_text_sec = sec;
+    }
 
-	    common_error:
-	      BFD_ASSERT (error_message != NULL);
-	      if (!((*info->callbacks->reloc_dangerous)
-		    (info, error_message, input_bfd, input_section,
-		     rel->r_offset)))
-		return FALSE;
-	      break;
-	    }
-	}
+  /* Add terminating CANTUNWIND entry.  */
+  if (last_exidx_sec && last_unwind_type != 0)
+    insert_cantunwind_after(last_text_sec, last_exidx_sec);
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf32_arm_output_glue_section (struct bfd_link_info *info, bfd *obfd,
+			       bfd *ibfd, const char *name)
+{
+  asection *sec, *osec;
+
+  sec = bfd_get_section_by_name (ibfd, name);
+  if (sec == NULL || (sec->flags & SEC_EXCLUDE) != 0)
+    return TRUE;
+
+  osec = sec->output_section;
+  if (elf32_arm_write_section (obfd, info, sec, sec->contents))
+    return TRUE;
+
+  if (! bfd_set_section_contents (obfd, osec, sec->contents,
+				  sec->output_offset, sec->size))
+    return FALSE;
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf32_arm_final_link (bfd *abfd, struct bfd_link_info *info)
+{
+  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (info);
+
+  /* Invoke the regular ELF backend linker to do all the work.  */
+  if (!bfd_elf_final_link (abfd, info))
+    return FALSE;
+
+  /* Write out any glue sections now that we have created all the
+     stubs.  */
+  if (globals->bfd_of_glue_owner != NULL)
+    {
+      if (! elf32_arm_output_glue_section (info, abfd,
+					   globals->bfd_of_glue_owner,
+					   ARM2THUMB_GLUE_SECTION_NAME))
+	return FALSE;
+
+      if (! elf32_arm_output_glue_section (info, abfd,
+					   globals->bfd_of_glue_owner,
+					   THUMB2ARM_GLUE_SECTION_NAME))
+	return FALSE;
+
+      if (! elf32_arm_output_glue_section (info, abfd,
+					   globals->bfd_of_glue_owner,
+					   VFP11_ERRATUM_VENEER_SECTION_NAME))
+	return FALSE;
+
+      if (! elf32_arm_output_glue_section (info, abfd,
+					   globals->bfd_of_glue_owner,
+					   JANUS_2CC_ERRATUM_VENEER_SECTION_NAME))
+	return FALSE;
+
+      if (! elf32_arm_output_glue_section (info, abfd,
+					   globals->bfd_of_glue_owner,
+					   ARM_BX_GLUE_SECTION_NAME))
+	return FALSE;
     }
 
   return TRUE;
@@ -8329,7 +9758,7 @@ tag_cpu_arch_combine (bfd *ibfd, int old
 
   if (oldtag >= MAX_TAG_CPU_ARCH || newtag >= MAX_TAG_CPU_ARCH)
     {
-      _bfd_error_handler (_("ERROR: %B: Unknown CPU architecture"), ibfd);
+      _bfd_error_handler (_("error: %B: Unknown CPU architecture"), ibfd);
       return -1;
     }
 
@@ -8367,7 +9796,7 @@ tag_cpu_arch_combine (bfd *ibfd, int old
 
   if (result == -1)
     {
-      _bfd_error_handler (_("ERROR: %B: Conflicting CPU architectures %d/%d"),
+      _bfd_error_handler (_("error: %B: Conflicting CPU architectures %d/%d"),
 			  ibfd, oldtag, newtag);
       return -1;
     }
@@ -8395,6 +9824,12 @@ elf32_arm_merge_eabi_attributes (bfd *ib
   int i;
   bfd_boolean result = TRUE;
 
+  /* Skip the linker stubs file.  This preserves previous behavior
+     of accepting unknown attributes in the first input file - but
+     is that a bug?  */
+  if (ibfd->flags & BFD_LINKER_CREATED)
+    return TRUE;
+
   if (!elf_known_obj_attributes_proc (obfd)[0].i)
     {
       /* This is the first object.  Copy the attributes.  */
@@ -8418,7 +9853,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
       else if (in_attr[Tag_ABI_FP_number_model].i != 0)
 	{
 	  _bfd_error_handler
-	    (_("ERROR: %B uses VFP register arguments, %B does not"),
+	    (_("error: %B uses VFP register arguments, %B does not"),
 	     ibfd, obfd);
 	  result = FALSE;
 	}
@@ -8534,7 +9969,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 		 binaries in the toolchain have had the attributes set
 		 properly.
 	      _bfd_error_handler
-		(_("ERROR: %B: 8-byte data alignment conflicts with %B"),
+		(_("error: %B: 8-byte data alignment conflicts with %B"),
 		 obfd, ibfd);
 	      result = FALSE; */
 	    }
@@ -8568,7 +10003,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 	      else
 		{
 		  _bfd_error_handler
-		    (_("ERROR: %B: Conflicting architecture profiles %c/%c"),
+		    (_("error: %B: Conflicting architecture profiles %c/%c"),
 		     ibfd,
 		     in_attr[i].i ? in_attr[i].i : '0',
 		     out_attr[i].i ? out_attr[i].i : '0');
@@ -8601,7 +10036,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 	      && in_attr[i].i != AEABI_R9_unused)
 	    {
 	      _bfd_error_handler
-		(_("ERROR: %B: Conflicting use of R9"), ibfd);
+		(_("error: %B: Conflicting use of R9"), ibfd);
 	      result = FALSE;
 	    }
 	  if (out_attr[i].i == AEABI_R9_unused)
@@ -8613,7 +10048,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 	      && out_attr[Tag_ABI_PCS_R9_use].i != AEABI_R9_unused)
 	    {
 	      _bfd_error_handler
-		(_("ERROR: %B: SB relative addressing conflicts with use of R9"),
+		(_("error: %B: SB relative addressing conflicts with use of R9"),
 		 ibfd);
 	      result = FALSE;
 	    }
@@ -8669,7 +10104,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 	  if (in_attr[i].i != out_attr[i].i)
 	    {
 	      _bfd_error_handler
-		(_("ERROR: %B uses iWMMXt register arguments, %B does not"),
+		(_("error: %B uses iWMMXt register arguments, %B does not"),
 		 ibfd, obfd);
 	      result = FALSE;
 	    }
@@ -8691,7 +10126,7 @@ elf32_arm_merge_eabi_attributes (bfd *ib
 	      if (in_attr[i].i != out_attr[i].i)
 		{
 		  _bfd_error_handler
-		    (_("ERROR: fp16 format mismatch between %B and %B"),
+		    (_("error: fp16 format mismatch between %B and %B"),
 		     ibfd, obfd);
 		  result = FALSE;
 		}
@@ -8895,7 +10330,7 @@ elf32_arm_merge_private_bfd_data (bfd * 
       && !(ibfd->flags & DYNAMIC)
       && (in_flags & EF_ARM_BE8))
     {
-      _bfd_error_handler (_("ERROR: %B is already in final BE8 format"),
+      _bfd_error_handler (_("error: %B is already in final BE8 format"),
 			  ibfd);
       return FALSE;
     }
@@ -8971,7 +10406,7 @@ elf32_arm_merge_private_bfd_data (bfd * 
 				      EF_ARM_EABI_VERSION (out_flags)))
     {
       _bfd_error_handler
-	(_("ERROR: Source object %B has EABI version %d, but target %B has EABI version %d"),
+	(_("error: Source object %B has EABI version %d, but target %B has EABI version %d"),
 	 ibfd, obfd,
 	 (in_flags & EF_ARM_EABIMASK) >> 24,
 	 (out_flags & EF_ARM_EABIMASK) >> 24);
@@ -8987,7 +10422,7 @@ elf32_arm_merge_private_bfd_data (bfd * 
       if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
 	{
 	  _bfd_error_handler
-	    (_("ERROR: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
+	    (_("error: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
 	     ibfd, obfd,
 	     in_flags & EF_ARM_APCS_26 ? 26 : 32,
 	     out_flags & EF_ARM_APCS_26 ? 26 : 32);
@@ -8998,11 +10433,11 @@ elf32_arm_merge_private_bfd_data (bfd * 
 	{
 	  if (in_flags & EF_ARM_APCS_FLOAT)
 	    _bfd_error_handler
-	      (_("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers"),
+	      (_("error: %B passes floats in float registers, whereas %B passes them in integer registers"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers"),
+	      (_("error: %B passes floats in integer registers, whereas %B passes them in float registers"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -9012,11 +10447,11 @@ elf32_arm_merge_private_bfd_data (bfd * 
 	{
 	  if (in_flags & EF_ARM_VFP_FLOAT)
 	    _bfd_error_handler
-	      (_("ERROR: %B uses VFP instructions, whereas %B does not"),
+	      (_("error: %B uses VFP instructions, whereas %B does not"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("ERROR: %B uses FPA instructions, whereas %B does not"),
+	      (_("error: %B uses FPA instructions, whereas %B does not"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -9026,11 +10461,11 @@ elf32_arm_merge_private_bfd_data (bfd * 
 	{
 	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
 	    _bfd_error_handler
-	      (_("ERROR: %B uses Maverick instructions, whereas %B does not"),
+	      (_("error: %B uses Maverick instructions, whereas %B does not"),
 	       ibfd, obfd);
 	  else
 	    _bfd_error_handler
-	      (_("ERROR: %B does not use Maverick instructions, whereas %B does"),
+	      (_("error: %B does not use Maverick instructions, whereas %B does"),
 	       ibfd, obfd);
 
 	  flags_compatible = FALSE;
@@ -9049,11 +10484,11 @@ elf32_arm_merge_private_bfd_data (bfd * 
 	    {
 	      if (in_flags & EF_ARM_SOFT_FLOAT)
 		_bfd_error_handler
-		  (_("ERROR: %B uses software FP, whereas %B uses hardware FP"),
+		  (_("error: %B uses software FP, whereas %B uses hardware FP"),
 		   ibfd, obfd);
 	      else
 		_bfd_error_handler
-		  (_("ERROR: %B uses hardware FP, whereas %B uses software FP"),
+		  (_("error: %B uses hardware FP, whereas %B uses software FP"),
 		   ibfd, obfd);
 
 	      flags_compatible = FALSE;
@@ -9644,12 +11079,12 @@ elf32_arm_check_relocs (bfd *abfd, struc
 		      return FALSE;
 
 		    /* BPABI objects never have dynamic relocations mapped.  */
-		    if (! htab->symbian_p)
+		    if (htab->symbian_p)
 		      {
 			flagword flags;
 
 			flags = bfd_get_section_flags (dynobj, sreloc);
-			flags |= (SEC_LOAD | SEC_ALLOC);
+			flags &= ~(SEC_LOAD | SEC_ALLOC);
 			bfd_set_section_flags (dynobj, sreloc, flags);
 		      }
 		  }
@@ -10541,12 +11976,16 @@ elf32_arm_size_dynamic_sections (bfd * o
       bfd_elf32_arm_init_maps (ibfd);
 
       if (!bfd_elf32_arm_process_before_allocation (ibfd, info)
-	  || !bfd_elf32_arm_vfp11_erratum_scan (ibfd, info))
+	  || !bfd_elf32_arm_vfp11_erratum_scan (ibfd, info)
+	  || !bfd_elf32_arm_janus_2cc_erratum_scan (ibfd, info))
         /* xgettext:c-format */
         _bfd_error_handler (_("Errors encountered processing file %s"),
 			    ibfd->filename);
     }
 
+  /* Allocate space for the glue sections now that we've sized them.  */
+  bfd_elf32_arm_allocate_interworking_sections (info);
+
   /* The check_relocs and adjust_dynamic_symbol entry points have
      determined the sizes of the various dynamic sections.  Allocate
      memory for them.  */
@@ -11634,6 +13073,11 @@ arm_map_one_stub (struct bfd_hash_entry 
   bfd_vma addr;
   char *stub_name;
   output_arch_syminfo *osi;
+  const insn_sequence *template;
+  enum stub_insn_type prev_type;
+  int size;
+  int i;
+  enum map_symbol_type sym_type;
 
   /* Massage our args to the form they really have.  */
   stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
@@ -11652,58 +13096,74 @@ arm_map_one_stub (struct bfd_hash_entry 
   addr = (bfd_vma) stub_entry->stub_offset;
   stub_name = stub_entry->output_name;
 
-  switch (stub_entry->stub_type)
+  template = stub_entry->stub_template;
+  switch (template[0].type)
     {
-    case arm_stub_long_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 8))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 4))
-	return FALSE;
-      break;
-    case arm_thumb_v4t_stub_long_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 12))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
-	return FALSE;
-      break;
-    case arm_thumb_thumb_stub_long_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 16))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 12))
-	return FALSE;
-      break;
-    case arm_thumb_arm_v4t_stub_long_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 20))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 8))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 16))
+    case ARM_TYPE:
+      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, stub_entry->stub_size))
 	return FALSE;
       break;
-    case arm_thumb_arm_v4t_stub_short_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 8))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 4))
-	return FALSE;
-      break;
-    case arm_stub_pic_long_branch:
-      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 12))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
-	return FALSE;
-      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
+    case THUMB16_TYPE:
+    case THUMB32_TYPE:
+      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1,
+				      stub_entry->stub_size))
 	return FALSE;
       break;
     default:
       BFD_FAIL ();
+      return FALSE;
+    }
+
+  prev_type = DATA_TYPE;
+  size = 0;
+  for (i = 0; i < stub_entry->stub_template_size; i++)
+    {
+      switch (template[i].type)
+	{
+	case ARM_TYPE:
+	  sym_type = ARM_MAP_ARM;
+	  break;
+
+	case THUMB16_TYPE:
+	case THUMB32_TYPE:
+	  sym_type = ARM_MAP_THUMB;
+	  break;
+
+	case DATA_TYPE:
+	  sym_type = ARM_MAP_DATA;
+	  break;
+
+	default:
+	  BFD_FAIL ();
+	  return FALSE;
+	}
+
+      if (template[i].type != prev_type)
+	{
+	  prev_type = template[i].type;
+	  if (!elf32_arm_output_map_sym (osi, sym_type, addr + size))
+	    return FALSE;
+	}
+
+      switch (template[i].type)
+	{
+	case ARM_TYPE:
+	case THUMB32_TYPE:
+	  size += 4;
+	  break;
+
+	case THUMB16_TYPE:
+	  size += 2;
+	  break;
+
+	case DATA_TYPE:
+	  size += 4;
+	  break;
+
+	default:
+	  BFD_FAIL ();
+	  return FALSE;
+	}
     }
 
   return TRUE;
@@ -11885,6 +13345,150 @@ elf32_arm_compare_mapping (const void * 
     return 0;
 }
 
+/* Add OFFSET to lower 31 bits of ADDR, leaving other bits unmodified.  */
+
+static unsigned long
+offset_prel31 (unsigned long addr, bfd_vma offset)
+{
+  return (addr & ~0x7ffffffful) | ((addr + offset) & 0x7ffffffful);
+}
+
+/* Copy an .ARM.exidx table entry, adding OFFSET to (applied) PREL31
+   relocations.  */
+
+static void
+copy_exidx_entry (bfd *output_bfd, bfd_byte *to, bfd_byte *from, bfd_vma offset)
+{
+  unsigned long first_word = bfd_get_32 (output_bfd, from);
+  unsigned long second_word = bfd_get_32 (output_bfd, from + 4);
+  
+  /* High bit of first word is supposed to be zero.  */
+  if ((first_word & 0x80000000ul) == 0)
+    first_word = offset_prel31 (first_word, offset);
+  
+  /* If the high bit of the first word is clear, and the bit pattern is not 0x1
+     (EXIDX_CANTUNWIND), this is an offset to an .ARM.extab entry.  */
+  if ((second_word != 0x1) && ((second_word & 0x80000000ul) == 0))
+    second_word = offset_prel31 (second_word, offset);
+  
+  bfd_put_32 (output_bfd, first_word, to);
+  bfd_put_32 (output_bfd, second_word, to + 4);
+}
+
+/* Data for make_branch_to_a8_stub().  */
+
+struct a8_branch_to_stub_data {
+  asection *writing_section;
+  bfd_byte *contents;
+};
+
+
+/* Helper to insert branches to Cortex-A8 erratum stubs in the right
+   places for a particular section.  */
+
+static bfd_boolean
+make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
+			void *in_arg)
+{
+  struct elf32_arm_stub_hash_entry *stub_entry;
+  struct a8_branch_to_stub_data *data;
+  bfd_byte *contents;
+  unsigned long branch_insn;
+  bfd_vma veneered_insn_loc, veneer_entry_loc;
+  bfd_signed_vma branch_offset;
+  bfd *abfd;
+  unsigned int index;
+  
+  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
+  data = (struct a8_branch_to_stub_data *) in_arg;
+  
+  if (stub_entry->target_section != data->writing_section
+      || stub_entry->stub_type < arm_stub_a8_veneer_b_cond)
+    return TRUE;
+  
+  contents = data->contents;
+
+  veneered_insn_loc = stub_entry->target_section->output_section->vma
+                      + stub_entry->target_section->output_offset
+		      + stub_entry->target_value;
+
+  veneer_entry_loc = stub_entry->stub_sec->output_section->vma
+		     + stub_entry->stub_sec->output_offset
+		     + stub_entry->stub_offset;
+  
+  if (stub_entry->stub_type == arm_stub_a8_veneer_blx)
+    veneered_insn_loc &= ~3u;
+  
+  branch_offset = veneer_entry_loc - veneered_insn_loc - 4;
+
+  abfd = stub_entry->target_section->owner;
+  index = stub_entry->target_value;
+
+  /* We attempt to avoid this condition by setting stubs_always_after_branch
+     in elf32_arm_size_stubs if we've enabled the Cortex-A8 erratum workaround.
+     This check is just to be on the safe side...  */
+  if ((veneered_insn_loc & ~0xfff) == (veneer_entry_loc & ~0xfff))
+    {
+      (*_bfd_error_handler) (_("%B: error: Cortex-A8 erratum stub is "
+			       "allocated in unsafe location"), abfd);
+      return FALSE;
+    }
+  
+  switch (stub_entry->stub_type)
+    {
+    case arm_stub_a8_veneer_b:
+    case arm_stub_a8_veneer_b_cond:
+      branch_insn = 0xf0009000;
+      goto jump24;
+
+    case arm_stub_a8_veneer_blx:
+      branch_insn = 0xf000e800;
+      goto jump24;
+
+    case arm_stub_a8_veneer_bl:
+      {
+	unsigned int i1, j1, i2, j2, s;
+
+        branch_insn = 0xf000d000;
+
+      jump24:
+        if (branch_offset < -16777216 || branch_offset > 16777214)
+	  {
+	    /* There's not much we can do apart from complain if this
+	       happens.  */
+	    (*_bfd_error_handler) (_("%B: error: Cortex-A8 erratum stub out "
+				     "of range (input file too large)"), abfd);
+	    return FALSE;
+	  }
+
+	/* i1 = not(j1 eor s), so:
+	   not i1 = j1 eor s
+	   j1 = (not i1) eor s.  */
+
+	branch_insn |= (branch_offset >> 1) & 0x7ff;
+	branch_insn |= ((branch_offset >> 12) & 0x3ff) << 16;
+	i2 = (branch_offset >> 22) & 1;
+	i1 = (branch_offset >> 23) & 1;
+	s = (branch_offset >> 24) & 1;
+	j1 = (!i1) ^ s;
+	j2 = (!i2) ^ s;
+	branch_insn |= j2 << 11;
+	branch_insn |= j1 << 13;
+	branch_insn |= s << 26;
+      }
+      break;
+
+    default:
+      BFD_FAIL ();
+      return FALSE;
+    }
+
+  bfd_put_16 (abfd, (branch_insn >> 16) & 0xffff, &contents[index]);
+  bfd_put_16 (abfd, branch_insn & 0xffff, &contents[index + 2]);
+  
+  return TRUE;
+}
+
 
 /* Do code byteswapping.  Return FALSE afterwards so that the section is
    written out as normal.  */
@@ -11895,16 +13499,16 @@ elf32_arm_write_section (bfd *output_bfd
 			 asection *sec,
 			 bfd_byte *contents)
 {
-  int mapcount, errcount;
+  unsigned int mapcount, errcount;
   _arm_elf_section_data *arm_data;
   struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
   elf32_arm_section_map *map;
-  elf32_vfp11_erratum_list *errnode;
+  elf32_cpu_erratum_list *errnode;
   bfd_vma ptr;
   bfd_vma end;
   bfd_vma offset = sec->output_section->vma + sec->output_offset;
   bfd_byte tmp;
-  int i;
+  unsigned int i;
 
   /* If this section has not been allocated an _arm_elf_section_data
      structure then we cannot record anything.  */
@@ -11928,11 +13532,12 @@ elf32_arm_write_section (bfd *output_bfd
           switch (errnode->type)
             {
             case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
+	    case JANUS_2CC_ERRATUM_BRANCH_TO_ARM_VENEER:
               {
                 bfd_vma branch_to_veneer;
                 /* Original condition code of instruction, plus bit mask for
                    ARM B instruction.  */
-                unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
+                unsigned int insn = (errnode->u.b.orig_insn & 0xf0000000)
                                   | 0x0a000000;
 
 		/* The instruction is before the label.  */
@@ -11970,7 +13575,7 @@ elf32_arm_write_section (bfd *output_bfd
 					   "range"), output_bfd);
 
                 /* Original instruction.  */
-                insn = errnode->u.v.branch->u.b.vfp_insn;
+                insn = errnode->u.v.branch->u.b.orig_insn;
                 contents[endianflip ^ index] = insn & 0xff;
                 contents[endianflip ^ (index + 1)] = (insn >> 8) & 0xff;
                 contents[endianflip ^ (index + 2)] = (insn >> 16) & 0xff;
@@ -11985,12 +13590,136 @@ elf32_arm_write_section (bfd *output_bfd
               }
               break;
 
+	    case JANUS_2CC_ERRATUM_ARM_VENEER:
+	      {
+		bfd_vma branch_from_veneer;
+		unsigned int insn;
+		
+		branch_from_veneer = errnode->u.v.branch->vma - errnode->vma
+				     - 16;
+
+		if ((signed) branch_from_veneer < -(1 << 25)
+		    || (signed) branch_from_veneer >= (1 << 25))
+		  (*_bfd_error_handler) (_("%B: error: Janus 2CC veneer out of "
+					   "range"), output_bfd);
+
+		bfd_put_32 (output_bfd, errnode->u.v.branch->u.b.orig_insn,
+			    contents + index);
+
+		/* nop, mov r0, r0.  */
+		bfd_put_32 (output_bfd, 0xe1a00000, contents + index + 4);
+		
+		insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
+		bfd_put_32 (output_bfd, insn, contents + index + 8);
+	      }
+	      break;
+
             default:
               abort ();
             }
         }
     }
 
+  if (arm_data->elf.this_hdr.sh_type == SHT_ARM_EXIDX)
+    {
+      arm_unwind_table_edit *edit_node
+        = arm_data->u.exidx.unwind_edit_list;
+      /* Now, sec->size is the size of the section we will write.  The original
+         size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
+	 markers) was sec->rawsize.  (This isn't the case if we perform no
+	 edits, then rawsize will be zero and we should use size).  */
+      bfd_byte *edited_contents = bfd_malloc (sec->size);
+      unsigned int input_size = sec->rawsize ? sec->rawsize : sec->size;
+      unsigned int in_index, out_index;
+      bfd_vma add_to_offsets = 0;
+
+      for (in_index = 0, out_index = 0; in_index * 8 < input_size || edit_node;)
+        {
+	  if (edit_node)
+	    {
+	      unsigned int edit_index = edit_node->index;
+	      
+	      if (in_index < edit_index && in_index * 8 < input_size)
+	        {
+		  copy_exidx_entry (output_bfd, edited_contents + out_index * 8,
+				    contents + in_index * 8, add_to_offsets);
+		  out_index++;
+		  in_index++;
+		}
+	      else if (in_index == edit_index
+		       || (in_index * 8 >= input_size
+			   && edit_index == UINT_MAX))
+	        {
+		  switch (edit_node->type)
+		    {
+		    case DELETE_EXIDX_ENTRY:
+		      in_index++;
+		      add_to_offsets += 8;
+		      break;
+		    
+		    case INSERT_EXIDX_CANTUNWIND_AT_END:
+		      {
+		        asection *text_sec = edit_node->linked_section;
+			bfd_vma text_offset = text_sec->output_section->vma
+					      + text_sec->output_offset
+					      + text_sec->size;
+			bfd_vma exidx_offset = offset + out_index * 8;
+		        unsigned long prel31_offset;
+
+			/* Note: this is meant to be equivalent to an
+			   R_ARM_PREL31 relocation.  These synthetic
+			   EXIDX_CANTUNWIND markers are not relocated by the
+			   usual BFD method.  */
+			prel31_offset = (text_offset - exidx_offset)
+					& 0x7ffffffful;
+
+			/* First address we can't unwind.  */
+			bfd_put_32 (output_bfd, prel31_offset,
+				    &edited_contents[out_index * 8]);
+
+			/* Code for EXIDX_CANTUNWIND.  */
+			bfd_put_32 (output_bfd, 0x1,
+				    &edited_contents[out_index * 8 + 4]);
+
+			out_index++;
+			add_to_offsets -= 8;
+		      }
+		      break;
+		    }
+		  
+		  edit_node = edit_node->next;
+		}
+	    }
+	  else
+	    {
+	      /* No more edits, copy remaining entries verbatim.  */
+	      copy_exidx_entry (output_bfd, edited_contents + out_index * 8,
+				contents + in_index * 8, add_to_offsets);
+	      out_index++;
+	      in_index++;
+	    }
+	}
+
+      if (!(sec->flags & SEC_EXCLUDE) && !(sec->flags & SEC_NEVER_LOAD))
+	bfd_set_section_contents (output_bfd, sec->output_section,
+				  edited_contents,
+				  (file_ptr) sec->output_offset, sec->size);
+
+      return TRUE;
+    }
+
+  /* Fix code to point to Cortex-A8 erratum stubs.  */
+  if (globals->fix_cortex_a8)
+    {
+      struct a8_branch_to_stub_data data;
+
+      data.writing_section = sec;
+      data.contents = contents;
+
+      bfd_hash_traverse (&globals->stub_hash_table, make_branch_to_a8_stub,
+			 &data);
+    }
+  
   if (mapcount == 0)
     return FALSE;
 
@@ -12267,6 +13996,7 @@ const struct elf_size_info elf32_arm_siz
 #define bfd_elf32_bfd_is_target_special_symbol	elf32_arm_is_target_special_symbol
 #define bfd_elf32_close_and_cleanup             elf32_arm_close_and_cleanup
 #define bfd_elf32_bfd_free_cached_info          elf32_arm_bfd_free_cached_info
+#define bfd_elf32_bfd_final_link		elf32_arm_final_link
 
 #define elf_backend_get_symbol_type             elf32_arm_get_symbol_type
 #define elf_backend_gc_mark_hook                elf32_arm_gc_mark_hook
--- a/bfd/elf32-mips.c
+++ b/bfd/elf32-mips.c
@@ -1662,6 +1662,15 @@ static const struct ecoff_debug_swap mip
 #define elf_backend_plt_readonly	1
 #define elf_backend_plt_sym_val		_bfd_mips_elf_plt_sym_val
 
+/* Most MIPS ELF files do not contain a traditional PLT; only VxWorks
+   and non-PIC dynamic executables do.  These settings only affect
+   _bfd_elf_create_dynamic_sections, which is only called when we
+   do want a traditional PLT.  */
+#undef elf_backend_want_plt_sym
+#define elf_backend_want_plt_sym		1
+#undef elf_backend_plt_readonly
+#define elf_backend_plt_readonly		1
+
 #define elf_backend_discard_info	_bfd_mips_elf_discard_info
 #define elf_backend_ignore_discarded_relocs \
 					_bfd_mips_elf_ignore_discarded_relocs
@@ -1686,6 +1695,8 @@ static const struct ecoff_debug_swap mip
 #define bfd_elf32_bfd_print_private_bfd_data \
 					_bfd_mips_elf_print_private_bfd_data
 
+#define elf_backend_plt_sym_val		_bfd_mips_elf_plt_sym_val
+
 /* Support for SGI-ish mips targets.  */
 #define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
 #define TARGET_LITTLE_NAME		"elf32-littlemips"
@@ -1789,6 +1800,7 @@ mips_vxworks_final_write_processing (bfd
 #undef elf_backend_additional_program_headers
 #undef elf_backend_modify_segment_map
 #undef elf_backend_symbol_processing
+#undef elf_backend_plt_sym_val
 /* NOTE: elf_backend_rela_normal is not defined for MIPS.  */
 
 #include "elf32-target.h"
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -12502,3 +12502,15 @@ _bfd_elf_make_dynamic_reloc_section (ase
 
   return reloc_sec;
 }
+
+/* Copy the ELF symbol type associated with a linker hash entry.  */
+void
+_bfd_elf_copy_link_hash_symbol_type (bfd *abfd ATTRIBUTE_UNUSED,
+    struct bfd_link_hash_entry * hdest,
+    struct bfd_link_hash_entry * hsrc)
+{
+  struct elf_link_hash_entry *ehdest = (struct elf_link_hash_entry *)hdest;
+  struct elf_link_hash_entry *ehsrc = (struct elf_link_hash_entry *)hsrc;
+
+  ehdest->type = ehsrc->type;
+}
--- a/bfd/elfxx-mips.c
+++ b/bfd/elfxx-mips.c
@@ -677,6 +677,11 @@ static bfd *reldyn_sorting_bfd;
 /* Nonzero if ABFD is using NewABI conventions.  */
 #define NEWABI_P(abfd) (ABI_N32_P (abfd) || ABI_64_P (abfd))
 
+/* Nonzero if ABFD is a non-PIC object.  */
+#define NON_PIC_P(abfd) \
+  (((elf_elfheader (abfd)->e_flags & EF_MIPS_PIC) == 0) \
+   && ((elf_elfheader (abfd)->e_flags & EF_MIPS_CPIC) == EF_MIPS_CPIC))
+
 /* The IRIX compatibility level we are striving for.  */
 #define IRIX_COMPAT(abfd) \
   (get_elf_backend_data (abfd)->elf_backend_mips_irix_compat (abfd))
@@ -689,6 +694,9 @@ static bfd *reldyn_sorting_bfd;
 #define MIPS_ELF_OPTIONS_SECTION_NAME(abfd) \
   (NEWABI_P (abfd) ? ".MIPS.options" : ".options")
 
+/* The name of the section holding non-PIC to PIC call stubs.  */
+#define NON_PIC_TO_PIC_STUB_SECTION_NAME ".MIPS.pic_stubs"
+
 /* True if NAME is the recognized name of any SHT_MIPS_OPTIONS section.
    Some IRIX system files do not use MIPS_ELF_OPTIONS_SECTION_NAME.  */
 #define MIPS_ELF_OPTIONS_SECTION_NAME_P(NAME) \
@@ -6256,11 +6264,6 @@ _bfd_mips_elf_section_processing (bfd *a
 	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
 	  hdr->sh_type = SHT_PROGBITS;
 	}
-      else if (strcmp (name, ".sbss") == 0)
-	{
-	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
-	  hdr->sh_type = SHT_NOBITS;
-	}
       else if (strcmp (name, ".srdata") == 0)
 	{
 	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
@@ -7587,7 +7590,9 @@ _bfd_mips_elf_check_relocs (bfd *abfd, s
 
 	      /* We need a stub, not a plt entry for the undefined
 		 function.  But we record it as if it needs plt.  See
-		 _bfd_elf_adjust_dynamic_symbol.  */
+		 _bfd_elf_adjust_dynamic_symbol.  Note that these relocations
+		 are always used for PIC calls, even when using the new
+		 non-PIC ABI.  */
 	      h->needs_plt = 1;
 	      h->type = STT_FUNC;
 	    }
@@ -7693,6 +7698,8 @@ _bfd_mips_elf_check_relocs (bfd *abfd, s
 	case R_MIPS_32:
 	case R_MIPS_REL32:
 	case R_MIPS_64:
+	  if (h != NULL)
+	    h->non_got_ref = TRUE;
 	  /* In VxWorks executables, references to external symbols
 	     are handled using copy relocs or PLT stubs, so there's
 	     no need to add a .rela.dyn entry for this relocation.  */
@@ -7748,11 +7755,21 @@ _bfd_mips_elf_check_relocs (bfd *abfd, s
 	case R_MIPS_GPREL16:
 	case R_MIPS_LITERAL:
 	case R_MIPS_GPREL32:
+	  if (h != NULL
+	      && (r_type == R_MIPS_GPREL16 || r_type == R_MIPS_GPREL32))
+	    h->non_got_ref = TRUE;
+
 	  if (SGI_COMPAT (abfd))
 	    mips_elf_hash_table (info)->compact_rel_size +=
 	      sizeof (Elf32_External_crinfo);
 	  break;
 
+	case R_MIPS_HI16:
+	case R_MIPS_LO16:
+	  if (h != NULL && strcmp (h->root.root.string, "_gp_disp") != 0)
+	    h->non_got_ref = TRUE;
+	  break;
+
 	  /* This relocation describes the C++ object vtable hierarchy.
 	     Reconstruct it for later use during GC.  */
 	case R_MIPS_GNU_VTINHERIT:
@@ -7775,20 +7792,20 @@ _bfd_mips_elf_check_relocs (bfd *abfd, s
 
       /* We must not create a stub for a symbol that has relocations
 	 related to taking the function's address.  This doesn't apply to
-	 VxWorks, where CALL relocs refer to a .got.plt entry instead of
-	 a normal .got entry.  */
+	 VxWorks or the non-PIC ABI, where CALL relocs refer to a
+	 .got.plt entry instead of a normal .got entry.  */
       if (!htab->is_vxworks && h != NULL)
 	switch (r_type)
 	  {
-	  default:
-	    ((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;
-	    break;
 	  case R_MIPS16_CALL16:
 	  case R_MIPS_CALL16:
 	  case R_MIPS_CALL_HI16:
 	  case R_MIPS_CALL_LO16:
 	  case R_MIPS_JALR:
 	    break;
+	  default:
+	    ((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;
+	    break;
 	  }
 
       /* See if this reloc would need to refer to a MIPS16 hard-float stub,
@@ -12471,7 +12488,9 @@ _bfd_mips_elf_merge_private_bfd_data (bf
 	  break;
 	}
     }
-  if (null_input_bfd)
+  /* Dynamic objects normally have no sections, and do not reach
+     here - but they might if used as DYNOBJ.  */
+  if (null_input_bfd || (ibfd->flags & DYNAMIC) != 0)
     return TRUE;
 
   ok = TRUE;
--- a/bfd/elfxx-mips.h
+++ b/bfd/elfxx-mips.h
@@ -63,6 +63,9 @@ extern bfd_boolean _bfd_mips_elf_finish_
 extern bfd_boolean _bfd_mips_vxworks_finish_dynamic_symbol
   (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
    Elf_Internal_Sym *);
+extern bfd_boolean _bfd_mips_nonpic_finish_dynamic_symbol
+  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+   Elf_Internal_Sym *);
 extern bfd_boolean _bfd_mips_elf_finish_dynamic_sections
   (bfd *, struct bfd_link_info *);
 extern void _bfd_mips_elf_final_write_processing
@@ -153,6 +156,15 @@ extern const struct bfd_elf_special_sect
 
 extern bfd_boolean _bfd_mips_elf_common_definition (Elf_Internal_Sym *);
 
+extern bfd_vma _bfd_mips_elf_plt_sym_val
+  (bfd_vma, const asection *, const arelent *); 
+extern void _bfd_mips_elf_begin_write_processing
+  (bfd *abfd, struct bfd_link_info *link_info);
+extern bfd_boolean bfd_mips_elf_maybe_create_non_pic_to_pic_stubs_section
+  (struct bfd_link_info *);
+extern void _bfd_mips_post_process_headers
+  (bfd *abfd, struct bfd_link_info *link_info);
+
 #define elf_backend_common_definition   _bfd_mips_elf_common_definition
 #define elf_backend_name_local_section_symbols \
   _bfd_mips_elf_name_local_section_symbols
--- a/bfd/elfxx-target.h
+++ b/bfd/elfxx-target.h
@@ -256,6 +256,11 @@
 #define bfd_elfNN_bfd_link_just_syms	_bfd_elf_link_just_syms
 #endif
 
+#ifndef bfd_elfNN_bfd_copy_link_hash_symbol_type
+#define bfd_elfNN_bfd_copy_link_hash_symbol_type \
+  _bfd_elf_copy_link_hash_symbol_type
+#endif
+
 #ifndef bfd_elfNN_bfd_link_split_section
 #define bfd_elfNN_bfd_link_split_section _bfd_generic_link_split_section
 #endif
--- a/bfd/i386msdos.c
+++ b/bfd/i386msdos.c
@@ -152,6 +152,8 @@ msdos_set_section_contents (bfd *abfd,
 #define msdos_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
 #define msdos_bfd_link_add_symbols _bfd_generic_link_add_symbols
 #define msdos_bfd_link_just_syms _bfd_generic_link_just_syms
+#define msdos_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define msdos_bfd_final_link _bfd_generic_final_link
 #define msdos_bfd_link_split_section _bfd_generic_link_split_section
 #define msdos_set_arch_mach _bfd_generic_set_arch_mach
--- a/bfd/i386os9k.c
+++ b/bfd/i386os9k.c
@@ -176,6 +176,8 @@ os9k_sizeof_headers (bfd *abfd ATTRIBUTE
 #define os9k_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
 #define os9k_bfd_link_add_symbols _bfd_generic_link_add_symbols
 #define os9k_bfd_link_just_syms _bfd_generic_link_just_syms
+#define os9k_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define os9k_bfd_final_link _bfd_generic_final_link
 #define os9k_bfd_link_split_section  _bfd_generic_link_split_section
 
--- a/bfd/ieee.c
+++ b/bfd/ieee.c
@@ -3774,6 +3774,8 @@ ieee_sizeof_headers (bfd *abfd ATTRIBUTE
 #define ieee_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
 #define ieee_bfd_link_add_symbols _bfd_generic_link_add_symbols
 #define ieee_bfd_link_just_syms _bfd_generic_link_just_syms
+#define ieee_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define ieee_bfd_final_link _bfd_generic_final_link
 #define ieee_bfd_link_split_section  _bfd_generic_link_split_section
 
--- a/bfd/ihex.c
+++ b/bfd/ihex.c
@@ -770,6 +770,14 @@ ihex_write_object_contents (bfd *abfd)
       bfd_size_type count;
 
       where = l->where;
+
+      /* If the top 32 bits of a 64-bit address are simply a sign-extension
+	 of the bottom 32 bits, then simply truncate the address to 32 bits. */
+      if (sizeof (bfd_vma) * 8 > 32
+	  && ((where & ~(bfd_vma)0x7fffffff) == 0
+	      || (where & ~(bfd_vma)0x7fffffff) == ~(bfd_vma)0x7fffffff))
+	where &= (bfd_vma)0xffffffffUL;
+
       p = l->data;
       count = l->size;
 
@@ -937,6 +945,8 @@ ihex_sizeof_headers (bfd *abfd ATTRIBUTE
 #define ihex_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
 #define ihex_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
 #define ihex_bfd_link_just_syms                   _bfd_generic_link_just_syms
+#define ihex_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define ihex_bfd_final_link                       _bfd_generic_final_link
 #define ihex_bfd_link_split_section               _bfd_generic_link_split_section
 
--- a/bfd/libbfd-in.h
+++ b/bfd/libbfd-in.h
@@ -410,6 +410,9 @@ extern bfd_boolean _bfd_generic_set_sect
   ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
 #define _bfd_nolink_bfd_link_just_syms \
   ((void (*) (asection *, struct bfd_link_info *)) bfd_void)
+#define _bfd_nolink_bfd_copy_link_hash_symbol_type \
+  ((void (*) (bfd *, struct bfd_link_hash_entry *, \
+	      struct bfd_link_hash_entry *)) bfd_void)
 #define _bfd_nolink_bfd_final_link \
   ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
 #define _bfd_nolink_bfd_link_split_section \
@@ -521,6 +524,10 @@ extern bfd_boolean _bfd_generic_link_add
 extern void _bfd_generic_link_just_syms
   (asection *, struct bfd_link_info *);
 
+/* Generic routine that does nothing.  */
+extern void _bfd_generic_copy_link_hash_symbol_type
+  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+
 /* Generic link routine.  */
 extern bfd_boolean _bfd_generic_final_link
   (bfd *, struct bfd_link_info *);
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -415,6 +415,9 @@ extern bfd_boolean _bfd_generic_set_sect
   ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
 #define _bfd_nolink_bfd_link_just_syms \
   ((void (*) (asection *, struct bfd_link_info *)) bfd_void)
+#define _bfd_nolink_bfd_copy_link_hash_symbol_type \
+  ((void (*) (bfd *, struct bfd_link_hash_entry *, \
+	      struct bfd_link_hash_entry *)) bfd_void)
 #define _bfd_nolink_bfd_final_link \
   ((bfd_boolean (*) (bfd *, struct bfd_link_info *)) bfd_false)
 #define _bfd_nolink_bfd_link_split_section \
@@ -526,6 +529,10 @@ extern bfd_boolean _bfd_generic_link_add
 extern void _bfd_generic_link_just_syms
   (asection *, struct bfd_link_info *);
 
+/* Generic routine that does nothing.  */
+extern void _bfd_generic_copy_link_hash_symbol_type
+  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+
 /* Generic link routine.  */
 extern bfd_boolean _bfd_generic_final_link
   (bfd *, struct bfd_link_info *);
--- a/bfd/libecoff.h
+++ b/bfd/libecoff.h
@@ -310,6 +310,8 @@ extern struct bfd_link_hash_table *_bfd_
 extern bfd_boolean _bfd_ecoff_bfd_link_add_symbols
   (bfd *, struct bfd_link_info *);
 #define _bfd_ecoff_bfd_link_just_syms _bfd_generic_link_just_syms
+#define _bfd_ecoff_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 extern bfd_boolean _bfd_ecoff_bfd_final_link
   (bfd *, struct bfd_link_info *);
 
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -795,6 +795,17 @@ _bfd_generic_link_just_syms (asection *s
   sec->output_offset = sec->vma;
 }
 
+/* Copy the type of a symbol assiciated with a linker hast table entry.
+   Override this so that symbols created in linker scripts get their
+   type from the RHS of the assignment.
+   The default implementation does nothing.  */
+void
+_bfd_generic_copy_link_hash_symbol_type (bfd *abfd ATTRIBUTE_UNUSED,
+    struct bfd_link_hash_entry * hdest ATTRIBUTE_UNUSED,
+    struct bfd_link_hash_entry * hsrc ATTRIBUTE_UNUSED)
+{
+}
+
 /* Add symbols from an object file to the global hash table.  */
 
 static bfd_boolean
--- a/bfd/mach-o.c
+++ b/bfd/mach-o.c
@@ -60,6 +60,8 @@
 #define bfd_mach_o_bfd_link_hash_table_free           _bfd_generic_link_hash_table_free
 #define bfd_mach_o_bfd_link_add_symbols               _bfd_generic_link_add_symbols
 #define bfd_mach_o_bfd_link_just_syms                 _bfd_generic_link_just_syms
+#define bfd_mach_o_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define bfd_mach_o_bfd_final_link                     _bfd_generic_final_link
 #define bfd_mach_o_bfd_link_split_section             _bfd_generic_link_split_section
 #define bfd_mach_o_set_arch_mach                      bfd_default_set_arch_mach
--- a/bfd/mmo.c
+++ b/bfd/mmo.c
@@ -3199,6 +3199,8 @@ mmo_write_object_contents (bfd *abfd)
 #define mmo_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
 #define mmo_bfd_link_add_symbols _bfd_generic_link_add_symbols
 #define mmo_bfd_link_just_syms _bfd_generic_link_just_syms
+#define mmo_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define mmo_bfd_final_link _bfd_generic_final_link
 #define mmo_bfd_link_split_section _bfd_generic_link_split_section
 
--- a/bfd/nlm-target.h
+++ b/bfd/nlm-target.h
@@ -53,6 +53,8 @@
 #define nlm_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
 #define nlm_bfd_link_add_symbols                _bfd_generic_link_add_symbols
 #define nlm_bfd_link_just_syms                  _bfd_generic_link_just_syms
+#define nlm_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define nlm_bfd_final_link                      _bfd_generic_final_link
 #define nlm_bfd_link_split_section              _bfd_generic_link_split_section
 
--- a/bfd/oasys.c
+++ b/bfd/oasys.c
@@ -1202,6 +1202,8 @@ oasys_sizeof_headers (bfd *abfd ATTRIBUT
 #define oasys_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
 #define oasys_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
 #define oasys_bfd_link_just_syms                   _bfd_generic_link_just_syms
+#define oasys_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define oasys_bfd_final_link                       _bfd_generic_final_link
 #define oasys_bfd_link_split_section               _bfd_generic_link_split_section
 
--- a/bfd/pef.c
+++ b/bfd/pef.c
@@ -56,6 +56,8 @@
 #define bfd_pef_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
 #define bfd_pef_bfd_link_add_symbols                _bfd_generic_link_add_symbols
 #define bfd_pef_bfd_link_just_syms                  _bfd_generic_link_just_syms
+#define bfd_pef_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define bfd_pef_bfd_final_link                      _bfd_generic_final_link
 #define bfd_pef_bfd_link_split_section              _bfd_generic_link_split_section
 #define bfd_pef_get_section_contents_in_window      _bfd_generic_get_section_contents_in_window
--- a/bfd/ppcboot.c
+++ b/bfd/ppcboot.c
@@ -479,6 +479,8 @@ ppcboot_bfd_print_private_bfd_data (abfd
 #define ppcboot_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
 #define ppcboot_bfd_link_add_symbols _bfd_generic_link_add_symbols
 #define ppcboot_bfd_link_just_syms _bfd_generic_link_just_syms
+#define ppcboot_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define ppcboot_bfd_final_link _bfd_generic_final_link
 #define ppcboot_bfd_link_split_section _bfd_generic_link_split_section
 #define ppcboot_get_section_contents_in_window \
--- a/bfd/simple.c
+++ b/bfd/simple.c
@@ -210,7 +210,8 @@ bfd_simple_get_relocated_section_content
   data = NULL;
   if (outbuf == NULL)
     {
-      data = bfd_malloc (sec->size);
+      bfd_size_type amt = sec->rawsize > sec->size ? sec->rawsize : sec->size;
+      data = bfd_malloc (amt);
       if (data == NULL)
 	return NULL;
       outbuf = data;
--- a/bfd/som.c
+++ b/bfd/som.c
@@ -6366,6 +6366,8 @@ som_bfd_link_split_section (bfd *abfd AT
 #define som_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
 #define som_bfd_link_add_symbols                _bfd_generic_link_add_symbols
 #define som_bfd_link_just_syms                  _bfd_generic_link_just_syms
+#define som_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define som_bfd_final_link                      _bfd_generic_final_link
 #define som_bfd_gc_sections		        bfd_generic_gc_sections
 #define som_bfd_merge_sections		        bfd_generic_merge_sections
--- a/bfd/srec.c
+++ b/bfd/srec.c
@@ -1259,6 +1259,8 @@ srec_print_symbol (bfd *abfd,
 #define srec_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
 #define srec_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
 #define srec_bfd_link_just_syms                   _bfd_generic_link_just_syms
+#define srec_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define srec_bfd_final_link                       _bfd_generic_final_link
 #define srec_bfd_link_split_section               _bfd_generic_link_split_section
 
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -435,6 +435,7 @@ BFD_JUMP_TABLE macros.
 .  NAME##_bfd_link_hash_table_free, \
 .  NAME##_bfd_link_add_symbols, \
 .  NAME##_bfd_link_just_syms, \
+.  NAME##_bfd_copy_link_hash_symbol_type, \
 .  NAME##_bfd_final_link, \
 .  NAME##_bfd_link_split_section, \
 .  NAME##_bfd_gc_sections, \
@@ -465,6 +466,12 @@ BFD_JUMP_TABLE macros.
 .  {* Indicate that we are only retrieving symbol values from this section.  *}
 .  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
 .
+.  {* Copy the symbol type of a linker hash table entry.  *}
+.#define bfd_copy_link_hash_symbol_type(b, t, f) \
+.  BFD_SEND (b, _bfd_copy_link_hash_symbol_type, (b, t, f))
+.  void (*_bfd_copy_link_hash_symbol_type)
+.    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+.
 .  {* Do a link based on the link_order structures attached to each
 .     section of the BFD.  *}
 .  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
--- a/bfd/tekhex.c
+++ b/bfd/tekhex.c
@@ -947,6 +947,8 @@ tekhex_print_symbol (bfd *abfd,
 #define tekhex_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
 #define tekhex_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
 #define tekhex_bfd_link_just_syms                   _bfd_generic_link_just_syms
+#define tekhex_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define tekhex_bfd_final_link                       _bfd_generic_final_link
 #define tekhex_bfd_link_split_section               _bfd_generic_link_split_section
 #define tekhex_get_section_contents_in_window       _bfd_generic_get_section_contents_in_window
--- a/bfd/versados.c
+++ b/bfd/versados.c
@@ -812,6 +812,8 @@ versados_canonicalize_reloc (bfd *abfd,
 #define versados_bfd_link_hash_table_free             _bfd_generic_link_hash_table_free
 #define versados_bfd_link_add_symbols                 _bfd_generic_link_add_symbols
 #define versados_bfd_link_just_syms                   _bfd_generic_link_just_syms
+#define versados_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define versados_bfd_final_link                       _bfd_generic_final_link
 #define versados_bfd_link_split_section               _bfd_generic_link_split_section
 
--- a/bfd/vms.c
+++ b/bfd/vms.c
@@ -30,6 +30,8 @@
 #define vms_bfd_is_target_special_symbol ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
 #define vms_make_empty_symbol             _bfd_generic_make_empty_symbol
 #define vms_bfd_link_just_syms            _bfd_generic_link_just_syms
+#define vms_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define vms_bfd_is_group_section          bfd_generic_is_group_section
 #define vms_bfd_discard_group             bfd_generic_discard_group
 #define vms_section_already_linked        _bfd_generic_section_already_linked
--- a/bfd/xsym.c
+++ b/bfd/xsym.c
@@ -49,6 +49,8 @@
 #define bfd_sym_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
 #define bfd_sym_bfd_link_add_symbols                _bfd_generic_link_add_symbols
 #define bfd_sym_bfd_link_just_syms                  _bfd_generic_link_just_syms
+#define bfd_sym_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
 #define bfd_sym_bfd_final_link                      _bfd_generic_final_link
 #define bfd_sym_bfd_link_split_section              _bfd_generic_link_split_section
 #define bfd_sym_get_section_contents_in_window      _bfd_generic_get_section_contents_in_window
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -2218,6 +2218,26 @@ setup_bfd_headers (bfd *ibfd, bfd *obfd)
   return;
 }
 
+/* Sign extend VMA if ABFD tells us that addresses are sign
+   extended.  */
+
+static bfd_vma
+maybe_sign_extend_vma (bfd *abfd, bfd_vma vma)
+{
+  if (bfd_get_sign_extend_vma (abfd) == 1
+      && bfd_arch_bits_per_address (abfd) < 8 * sizeof (bfd_vma))
+    {
+      unsigned int bits = bfd_arch_bits_per_address (abfd);
+      bfd_vma sign_bit = ((bfd_vma) 1) << (bits - 1);
+      bfd_vma upper_bits = (~(bfd_vma) 0) << bits;
+      if ((vma & sign_bit) != 0)
+	vma |= upper_bits;
+      else
+	vma &= ~upper_bits;
+    }
+  return vma;
+}
+
 /* Create a section in OBFD with the same
    name and attributes as ISECTION in IBFD.  */
 
@@ -2314,6 +2334,7 @@ setup_section (bfd *ibfd, sec_ptr isecti
   else
     vma += change_section_address;
 
+  vma = maybe_sign_extend_vma (ibfd, vma);
   if (! bfd_set_section_vma (obfd, osection, vma))
     {
       err = _("failed to set vma");
@@ -2333,6 +2354,7 @@ setup_section (bfd *ibfd, sec_ptr isecti
   else
     lma += change_section_address;
 
+  lma = maybe_sign_extend_vma (ibfd, lma);
   osection->lma = lma;
 
   /* FIXME: This is probably not enough.  If we change the LMA we
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -1895,7 +1895,7 @@ disassemble_section (bfd *abfd, asection
       bfd_boolean insns;
 
       addr = section->vma + addr_offset;
-      addr = (addr ^ sign_adjust) - sign_adjust;
+      addr = ((addr & ((sign_adjust << 1) - 1)) ^ sign_adjust) - sign_adjust;
 
       if (sym != NULL && bfd_asymbol_value (sym) <= addr)
 	{
@@ -1958,7 +1958,8 @@ disassemble_section (bfd *abfd, asection
       else
 	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
 
-      if (nextstop_offset > stop_offset)
+      if (nextstop_offset > stop_offset
+	  || nextstop_offset <= addr_offset)
 	nextstop_offset = stop_offset;
 
       /* If a symbol is explicitly marked as being an object
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -2688,6 +2688,10 @@ get_arm_section_type_name (unsigned int 
       return "ARM_PREEMPTMAP";
     case SHT_ARM_ATTRIBUTES:
       return "ARM_ATTRIBUTES";
+    case SHT_ARM_DEBUGOVERLAY:
+      return "ARM_DEBUGOVERLAY";
+    case SHT_ARM_OVERLAYSECTION:
+      return "ARM_OVERLAYSECTION";
     default:
       break;
     }
--- a/binutils/testsuite/binutils-all/arm/thumb2-cond.s
+++ b/binutils/testsuite/binutils-all/arm/thumb2-cond.s
@@ -1,6 +1,8 @@
-.thumb
+	.arch armv7
+	.syntax unified
+	.thumb
 foo:
-.short 0xf000, 0xf800
-.short 0xbf38
-.short 0xf000, 0xbf04
-bx lr
+	bl	1f
+1:	it	cc
+	bcc.w	.+0xe0c
+	bx	lr
--- a/binutils/testsuite/binutils-all/objdump.W
+++ b/binutils/testsuite/binutils-all/objdump.W
@@ -1,5 +1,5 @@
 
-tmpdir/dw2-compressed.o:     file format .*
+.*dw2-compressed.o:     file format .*
 
 Contents of the .debug_info section:
 
--- a/binutils/testsuite/binutils-all/objdump.s
+++ b/binutils/testsuite/binutils-all/objdump.s
@@ -1,5 +1,5 @@
 
-tmpdir/dw2-compressed.o:     file format .*
+.*dw2-compressed.o:     file format .*
 
 Contents of section .zdebug_abbrev:
  0000 5a4c4942 00000000 00000033 785e6314  ZLIB.......3x\^c.
--- a/config/mh-mingw
+++ b/config/mh-mingw
@@ -1,6 +1,8 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
-BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
-CFLAGS += -D__USE_MINGW_ACCESS
+# Because we wrap access in libiberty/cygpath.c, we do not want to use
+# the MinGW wrappers for access.
+BOOT_CFLAGS += -Wno-pedantic-ms-format
+# CFLAGS += -D__USE_MINGW_ACCESS
 # Increase stack limit to same as Linux default.
 LDFLAGS += -Wl,--stack,8388608
--- a/configure
+++ b/configure
@@ -2597,11 +2597,16 @@ case "${target}" in
     noconfigdirs="$noconfigdirs ld binutils gprof target-libgloss ${libgcj}"
     ;;
   mips*-sde-elf*)
-    skipdirs="$skipdirs target-libiberty"
-    noconfigdirs="$noconfigdirs ${libgcj}"
-    if test x$with_newlib = xyes; then
-      noconfigdirs="$noconfigdirs gprof"
-    fi
+    noconfigdirs="${noconfigdirs} sid ${libgcj} target-rda"
+    if ! test x"${with_newlib}" = xyes ; then
+      # remove libgloss and libiberty too, when we're not building newlib
+      skipdirs="${skipdirs} target-libgloss target-libiberty"
+      # add sde-conv host tool
+      configdirs="${configdirs} convert"
+    fi
+    # add gprof back in - we do support it!
+    skipdirs=`echo " ${skipdirs} " | sed -e 's/ gprof / /'`
+    noconfigdirs=`echo " ${noconfigdirs} " | sed -e 's/ gprof / /'`
     libgloss_dir=mips
     ;;
   mips*-*-irix5*)
--- a/configure.ac
+++ b/configure.ac
@@ -833,11 +833,16 @@ case "${target}" in
     noconfigdirs="$noconfigdirs ld binutils gprof target-libgloss ${libgcj}"
     ;;
   mips*-sde-elf*)
-    skipdirs="$skipdirs target-libiberty"
-    noconfigdirs="$noconfigdirs ${libgcj}"
-    if test x$with_newlib = xyes; then
-      noconfigdirs="$noconfigdirs gprof"
+    noconfigdirs="${noconfigdirs} sid ${libgcj} target-rda"
+    if ! test x"${with_newlib}" = xyes ; then
+      # remove libgloss and libiberty too, when we're not building newlib
+      skipdirs="${skipdirs} target-libgloss target-libiberty"
+      # add sde-conv host tool
+      configdirs="${configdirs} convert"
     fi
+    # add gprof back in - we do support it!
+    skipdirs=`echo " ${skipdirs} " | sed -e 's/ gprof / /'`
+    noconfigdirs=`echo " ${noconfigdirs} " | sed -e 's/ gprof / /'`
     libgloss_dir=mips
     ;;
   mips*-*-irix5*)
--- /dev/null
+++ b/convert/ChangeLog
@@ -0,0 +1,213 @@
+2008-03-11  Thiemo Seufer  <ths@mips.com>
+
+	* bin.c, conv.texi, convert.c, elf.h, elfio.c, elfmips.h,
+	elfout.c, idtbin.c, lsifast.c, mipsflash.c, srec.c, stagbin.c:
+	Update license to GPL v3.
+
+2007-07-02  Maciej W. Rozycki  <macro@mips.com>
+
+	* Makefile.am (AUTOMAKE_OPTIONS): Use "cygnus" rather than
+	"foreign".
+	* Makefile.in: Regenerate.
+
+2004-10-08  Nigel Stephens  <nigel@mips.com>
+
+	* elfout.c (ElfEnd): Use ehdr.e_phnum to calculate offset of
+	section header, otherwise we are out by one.
+
+2004-10-04  Nigel Stephens  <nigel@mips.com>
+
+	* Makefile.am: Use "cygnus" automake options, so that info file
+	gets created in build directory, not source directory.
+
+	* Makefile.in: Rebuilt.
+
+2004-09-09  Nigel Stephens  <nigel@mips.com>
+
+	* elfout.c (ElfEnd): Set paddr field in program header as well as vaddr.
+	Set number of program header entries to the actual number of
+	entries created (1 less than the number of sections. Use
+	ehdr.e_phnum and ehdr.e_shnum to select the number of program and
+	section headers to be written out.
+
+Tue Oct 21 12:13:43 2003  Nigel Stephens  <nigel@mips.com>
+
+	* conv.info: Gets built in source dir.
+
+Sat Oct  4 00:34:44 2003  Nigel Stephens  <nigel@mips.com>
+
+	* Makefile.am: Added conv.texi and html build rule.
+
+	* conv.texi: New Texinfo doc file for conv only.
+
+Tue Aug 19 13:07:43 2003  Nigel Stephens  <nigel@mips.com>
+
+	Changed to GPL copyright headers.
+
+Tue Aug  5 22:18:41 2003  Nigel Stephens  <nigel@mips.com>
+
+	Added BSD-style copyright headers.
+
+Wed Jul  9 03:31:06 2003  Nigel Stephens  <nigel@mips.com>
+
+	* mipsflash.c: New MIPS flash download format. Needs some more
+	work before prime-time.
+
+	* convert.c: Use const char * where necessary.
+	(formats): Add description of each format to table.
+	Add mips flash download format.
+	(usage): Output format descriptions.
+	(main): Output format descriptions if we get a bas format name.
+
+	* Makefile.am (conv_SOURCES): Added mipsflash.c
+
+Thu Apr 24 15:09:32 2003  Nigel Stephens  <nigel@mips.com>
+
+	* elfout.c (ElfStart): Set ehdr.e_version to EV_CURRENT, not EV_NONE.
+
+Wed Dec 18 16:47:42 2002  Nigel Stephens  <nigel@mips.com>
+
+	* acinclude.m4 (CONV_BINARY_FOPEN): Match cygwin* not cygwin32*.
+
+	* configure: Rebuilt.
+	* config.h.in: Rebuilt.
+	* aclocal.m4: Rebuilt.
+
+Mon Nov 18 11:04:04 2002  Nigel Stephens  <nigel@mips.com>
+
+	* configure.in (AC_REPLACE_FUNCS): Removed, used libiberty
+	versions of getopt and strtoul.
+
+	* Makefile.am (EXTRA_conv_SOURCES): Line removed, we don't have
+	our own getopt.h now.
+	(LIBIBERTY): New variable.
+	(conv_LDADD): Set to LIBIBERTY, not LDADD.
+
+	* Makefile.in, configure, config.h.in: Rebuilt.
+
+	* getopt.h: Removed.
+	* getopt.c: Removed.
+	* strtoul.c: Removed.
+
+Tue Oct 15 12:57:11 2002  Nigel Stephens  <nigel@mips.com>
+
+	* elfout.c: New "relocated" ELF output format, mainly so that we
+	can give a PROM image to MIPSsim.
+
+	* convert.c: Add endianness argument to start function entries in
+	table.
+	(formats): Add "relf" format.
+	(progname): Make it global.
+	(promflag): Similarly.
+	(prombase): Similarly.
+	(usage): Add -EB/-EL.
+	(xmalloc): New error checking interface to malloc.
+	(convertSymbols): Use xmalloc(), and free malloced data when
+	returning.
+	(main): Handle -EB/-EL argument, only relevant for raw binary
+	input files. In other cases set bigendian flag from the ELF input
+	file. Pass bigendian flag to format "start" function. Use
+	xmalloc/free.
+
+	* configure.in (AC_CHECK_HEADERS): Add stdlib.h
+
+	* config.h.in: Add HAVE_STDLIB_H
+
+	* lsifast.c (LsiStart): Use xmalloc().
+	(LsiEnd): Use free().
+	* bin.c: Similarly.
+	* stagbin.c: Similarly.
+
+	* sysdep.h: Fix up definitions of alloca(). Add definition of
+	xmalloc().
+
+	* Makefile.am (conv_SOURCES): Add elfout.c
+	(install-exec-local): Don't add .exe extension on twice.
+
+Fri Jun  7 13:58:49 2002  Nigel Stephens  <nigel@algor.co.uk>
+
+	* Makefile.am (html): Do nothing target.
+
+	* Makefile.in: Rebuilt.
+
+Mon Mar 18 19:13:08 2002  Nigel Stephens  <nigel@algor.co.uk>
+
+	* Makefile.am: Add manual install step to install program with
+	additional target alias name.
+
+	* Makefile.in: Rebuilt.
+
+Tue Nov  7 00:35:37 2000  Chris Dearman  <chris@algor.co.uk>
+
+	* convert.c (main): Convert promlimit to physical address when
+	parsing -a base:limit option. Exit with error if promlimit!=0
+	&& promlimit<=prombase.
+
+Tue Jul 18 15:19:09 2000  Nigel Stephens  <nigel@algor.co.uk>
+
+	* convert.c (main): Sort the program header into physical/load
+	address order - the linker sorts it into virtual address order.
+	(phcompar): New comparison function for qsort().
+
+Fri Nov 19 16:42:57 1999  Nigel Stephens  <nigel@algor.co.uk>
+
+	* All: Added copyright messages.
+
+Thu Nov 11 15:25:54 1999  Nigel Stephens  <nigel@algor.co.uk>
+
+	* convert.c (main): Allow byte selection when not in PROM mode.
+
+Mon Oct 25 14:21:47 1999  Nigel Stephens  <nigel@algor.co.uk>
+
+	* Makefile.am: Add no-dependencies to AUTOMAKE_OPTIONS
+
+Thu Sep  9 18:12:11 1999  Nigel Stephens  <nigel@algor.co.uk>
+
+	* convert.c (convertSegment): Change in read/write flag of segment
+	will cause it to be moved to next 16 byte boundary.
+
+Wed Jun  3 16:35:32 1998  Nigel Stephens  <nigel@algor.co.uk>
+
+	* configure.in (AC_CANONICAL_SYSTEM): No longer needed by
+	AM_CYGWIN32.  Use AM_EXEEXT instead of AM_CYGWIN32.
+
+Tue May 12 15:42:10 1998  Nigel Stephens  <nigel@algor.co.uk>
+
+	* configure.in: Bump version number to 3.0.3
+
+	* Makefile.am: Change automake options to --foreign.
+
+Fri Apr 17 14:26:29 1998  Nigel Stephens  <nigel@algor.co.uk>
+
+	* Makefile.am: Moved over to automake/autoconf.
+
+Mon Jan 26 15:40:18 1998  Nigel Stephens  <nigel@algor.co.uk>
+
+	* convert.c (convertSymbols): Flag MIPS16 symbols by making symbol
+	address odd.
+	(main): Do all PROM resident segments first, irrespective of what
+	type they are.
+
+Mon Jul  7 18:04:50 1997  Nigel Stephens  <nigel@algor.co.uk>
+
+	SDE-MIPS version 2.2.1 released.
+
+Tue May 20 18:07:32 1997  Nigel Stephens  <nigel@algor.co.uk>
+
+	SDE-MIPS version 2.2 released.
+
+Tue May 20 14:39:41 1997  Nigel Stephens  <nigel@algor.co.uk>
+
+	* convert.c: Realign segment when the PF_X flag changes.
+
+Wed Apr 30 17:59:56 1997  Nigel Stephens  <nigel@algor.co.uk>
+
+	SDE-MIPS version 2.2-beta released.
+
+Thu Apr 24 13:52:08 1997  Nigel Stephens  <nigel@algor.co.uk>
+
+	* elfio.c: Added functions to read and write .reginfo and .gptab
+	sections.
+
+	* elfmips.h: Added prototypes for above, and defined new
+	architecture flags and SDE-MIPS special flags.
--- /dev/null
+++ b/convert/Makefile.am
@@ -0,0 +1,62 @@
+## Process this file with automake to generate Makefile.in
+
+AUTOMAKE_OPTIONS = cygnus
+ACLOCAL_AMFLAGS = -I . -I .. -I ../config
+
+noinst_PROGRAMS = conv
+
+conv_SOURCES =  convert.c elfio.c elfout.c mipsflash.c \
+		srec.c lsifast.c idtbin.c stagbin.c bin.c \
+		elf.h elfmips.h sysdep.h conv-version.h \
+		conv.1
+
+#EXTRA_conv_SOURCES = getopt.h # alloca.c getopt.c strtoul.c
+
+conv-version.h:	$(srcdir)/version.h $(srcdir)/Makefile.in
+	@echo "creating $@"
+	conv_version_package="\"$(PKGVERSION)\"" ;\
+	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
+	sed -e "s,@conv_version_package@,$$conv_version_package," \
+	    -e "s,@report_bugs_to@,$$report_bugs_to," \
+	    < $(srcdir)/version.h > $@
+
+convert.o: convert.c conv-version.h
+
+LIBIBERTY = ../libiberty/libiberty.a
+
+conv_LDADD = $(LIBIBERTY)
+
+man_MANS = conv.1
+
+info_TEXINFOS = conv.texi
+
+conv_TEXI = $(srcdir)/conv.texi
+
+# FIXME!
+conv.html: $(conv_TEXI)
+#	@rm -f conv.html
+#	texi2html -monolithic -glossary -menu -I . -I $(srcdir) $(conv_TEXI)
+	touch $@
+
+conv.dvi:  $(conv_TEXI)
+
+conv.info: $(conv_TEXI)
+
+.PHONY: install-exec-local install-html
+
+install-exec-local: $(noinst_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    t="$(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo "  $(INSTALL_PROGRAM) $$p $$t"; \
+	     $(INSTALL_PROGRAM) $$p $$t; \
+	  else :; fi; \
+	done
+
+install-html:
+	echo FIXME > /dev/null
+
+install-pdf:
+	echo FIXME > /dev/null
--- /dev/null
+++ b/convert/Makefile.in
@@ -0,0 +1,638 @@
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+SOURCES = $(conv_SOURCES)
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = .
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+noinst_PROGRAMS = conv$(EXEEXT)
+DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \
+	ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(srcdir)/config.h.in $(srcdir)/../mkinstalldirs
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno configure.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+PROGRAMS = $(noinst_PROGRAMS)
+am_conv_OBJECTS = convert.$(OBJEXT) elfio.$(OBJEXT) elfout.$(OBJEXT) \
+	mipsflash.$(OBJEXT) srec.$(OBJEXT) lsifast.$(OBJEXT) \
+	idtbin.$(OBJEXT) stagbin.$(OBJEXT) bin.$(OBJEXT)
+conv_OBJECTS = $(am_conv_OBJECTS)
+am__DEPENDENCIES_1 = ../libiberty/libiberty.a
+conv_DEPENDENCIES = $(am__DEPENDENCIES_1)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(conv_SOURCES)
+INFO_DEPS = $(srcdir)/conv.info
+TEXINFO_TEX = $(top_srcdir)/../texinfo/texinfo.tex
+am__TEXINFO_TEX_DIR = $(top_srcdir)/../texinfo
+DVIS = conv.dvi
+PDFS = conv.pdf
+PSS = conv.ps
+HTMLS = conv.html
+TEXINFOS = conv.texi
+TEXI2DVI = `if test -f $(top_srcdir)/../texinfo/util/texi2dvi; then \
+             echo $(top_srcdir)/../texinfo/util/texi2dvi; \
+           else \
+             echo texi2dvi; \
+           fi`
+TEXI2PDF = $(TEXI2DVI) --pdf --batch
+MAKEINFOHTML = $(MAKEINFO) --html
+AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)
+DVIPS = dvips
+man1dir = $(mandir)/man1
+am__installdirs = "$(DESTDIR)$(man1dir)"
+NROFF = nroff
+MANS = $(man_MANS)
+ETAGS = etags
+CTAGS = ctags
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKGVERSION = @PKGVERSION@
+REPORT_BUGS_TEXI = @REPORT_BUGS_TEXI@
+REPORT_BUGS_TO = @REPORT_BUGS_TO@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+AUTOMAKE_OPTIONS = cygnus
+ACLOCAL_AMFLAGS = -I . -I .. -I ../config
+conv_SOURCES = convert.c elfio.c elfout.c mipsflash.c \
+		srec.c lsifast.c idtbin.c stagbin.c bin.c \
+		elf.h elfmips.h sysdep.h conv-version.h \
+		conv.1
+
+LIBIBERTY = ../libiberty/libiberty.a
+conv_LDADD = $(LIBIBERTY)
+man_MANS = conv.1
+info_TEXINFOS = conv.texi
+conv_TEXI = $(srcdir)/conv.texi
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .dvi .html .info .o .obj .pdf .ps .texi
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	cd $(top_srcdir) && $(AUTOHEADER)
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+
+clean-noinstPROGRAMS:
+	-test -z "$(noinst_PROGRAMS)" || rm -f $(noinst_PROGRAMS)
+conv$(EXEEXT): $(conv_OBJECTS) $(conv_DEPENDENCIES) 
+	@rm -f conv$(EXEEXT)
+	$(LINK) $(conv_LDFLAGS) $(conv_OBJECTS) $(conv_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.c.o:
+	$(COMPILE) -c $<
+
+.c.obj:
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.texi.info:
+	restore=: && backupdir="$(am__leading_dot)am$$$$" && \
+	am__cwd=`pwd` && cd $(srcdir) && \
+	rm -rf $$backupdir && mkdir $$backupdir && \
+	for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \
+	  if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \
+	done; \
+	cd "$$am__cwd"; \
+	if $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $@ $<; \
+	then \
+	  rc=0; \
+	  cd $(srcdir); \
+	else \
+	  rc=$$?; \
+	  cd $(srcdir) && \
+	  $$restore $$backupdir/* `echo "./$@" | sed 's|[^/]*$$||'`; \
+	fi; \
+	rm -rf $$backupdir; exit $$rc
+
+.texi.dvi:
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2DVI) $<
+
+.texi.pdf:
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2PDF) $<
+
+.texi.html:
+	rm -rf $(@:.html=.htp)
+	if $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $(@:.html=.htp) $<; \
+	then \
+	  rm -rf $@; \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \
+	else \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \
+	  exit 1; \
+	fi
+$(srcdir)/conv.info: conv.texi 
+conv.pdf: conv.texi 
+.dvi.ps:
+	$(DVIPS) -o $@ $<
+
+uninstall-info-am:
+	@$(PRE_UNINSTALL)
+	@if (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'"; \
+	    install-info --info-dir="$(DESTDIR)$(infodir)" --remove "$(DESTDIR)$(infodir)/$$relfile"; \
+	  done; \
+	else :; fi
+	@$(NORMAL_UNINSTALL)
+	@list='$(INFO_DEPS)'; \
+	for file in $$list; do \
+	  relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	  relfile_i=`echo "$$relfile" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  (if cd "$(DESTDIR)$(infodir)"; then \
+	     echo " cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]"; \
+	     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \
+	   else :; fi); \
+	done
+
+dist-info: $(INFO_DEPS)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; \
+	for base in $$list; do \
+	  case $$base in \
+	    $(srcdir)/*) base=`echo "$$base" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$base; then d=.; else d=$(srcdir); fi; \
+	  for file in $$d/$$base*; do \
+	    relfile=`expr "$$file" : "$$d/\(.*\)"`; \
+	    test -f $(distdir)/$$relfile || \
+	      cp -p $$file $(distdir)/$$relfile; \
+	  done; \
+	done
+
+mostlyclean-aminfo:
+	-rm -rf conv.aux conv.cp conv.cps conv.fn conv.fns conv.ky conv.log conv.pg \
+	  conv.pgs conv.tmp conv.toc conv.tp conv.tps conv.vr conv.vrs \
+	  conv.dvi conv.pdf conv.ps conv.html
+
+maintainer-clean-aminfo:
+	@list='$(INFO_DEPS)'; for i in $$list; do \
+	  i_i=`echo "$$i" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  echo " rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]"; \
+	  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \
+	done
+
+clean-info: mostlyclean-aminfo
+install-man1: $(man1_MANS) $(man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man1dir)" || $(mkdir_p) "$(DESTDIR)$(man1dir)"
+	@list='$(man1_MANS) $(dist_man1_MANS) $(nodist_man1_MANS)'; \
+	l2='$(man_MANS) $(dist_man_MANS) $(nodist_man_MANS)'; \
+	for i in $$l2; do \
+	  case "$$i" in \
+	    *.1*) list="$$list $$i" ;; \
+	  esac; \
+	done; \
+	for i in $$list; do \
+	  if test -f $(srcdir)/$$i; then file=$(srcdir)/$$i; \
+	  else file=$$i; fi; \
+	  ext=`echo $$i | sed -e 's/^.*\\.//'`; \
+	  case "$$ext" in \
+	    1*) ;; \
+	    *) ext='1' ;; \
+	  esac; \
+	  inst=`echo $$i | sed -e 's/\\.[0-9a-z]*$$//'`; \
+	  inst=`echo $$inst | sed -e 's/^.*\///'`; \
+	  inst=`echo $$inst | sed '$(transform)'`.$$ext; \
+	  echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man1dir)/$$inst'"; \
+	  $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man1dir)/$$inst"; \
+	done
+uninstall-man1:
+	@$(NORMAL_UNINSTALL)
+	@list='$(man1_MANS) $(dist_man1_MANS) $(nodist_man1_MANS)'; \
+	l2='$(man_MANS) $(dist_man_MANS) $(nodist_man_MANS)'; \
+	for i in $$l2; do \
+	  case "$$i" in \
+	    *.1*) list="$$list $$i" ;; \
+	  esac; \
+	done; \
+	for i in $$list; do \
+	  ext=`echo $$i | sed -e 's/^.*\\.//'`; \
+	  case "$$ext" in \
+	    1*) ;; \
+	    *) ext='1' ;; \
+	  esac; \
+	  inst=`echo $$i | sed -e 's/\\.[0-9a-z]*$$//'`; \
+	  inst=`echo $$inst | sed -e 's/^.*\///'`; \
+	  inst=`echo $$inst | sed '$(transform)'`.$$ext; \
+	  echo " rm -f '$(DESTDIR)$(man1dir)/$$inst'"; \
+	  rm -f "$(DESTDIR)$(man1dir)/$$inst"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am:
+check: check-am
+all-am: Makefile $(PROGRAMS) $(MANS) config.h
+installdirs:
+	for dir in "$(DESTDIR)$(man1dir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstPROGRAMS mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-tags
+
+dvi: dvi-am
+
+dvi-am: $(DVIS)
+
+html: html-am
+
+html-am: $(HTMLS)
+
+info: info-am
+
+info-am: $(INFO_DEPS)
+
+install-data-am: install-man
+
+install-exec-am: install-exec-local
+
+install-info: install-info-am
+
+install-info-am: $(INFO_DEPS)
+	@$(NORMAL_INSTALL)
+	test -z "$(infodir)" || $(mkdir_p) "$(DESTDIR)$(infodir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; \
+	for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
+	  file_i=`echo "$$file" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \
+                       $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \
+	    if test -f $$ifile; then \
+	      relfile=`echo "$$ifile" | sed 's|^.*/||'`; \
+	      echo " $(INSTALL_DATA) '$$ifile' '$(DESTDIR)$(infodir)/$$relfile'"; \
+	      $(INSTALL_DATA) "$$ifile" "$(DESTDIR)$(infodir)/$$relfile"; \
+	    else : ; fi; \
+	  done; \
+	done
+	@$(POST_INSTALL)
+	@if (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'";\
+	    install-info --info-dir="$(DESTDIR)$(infodir)" "$(DESTDIR)$(infodir)/$$relfile" || :;\
+	  done; \
+	else : ; fi
+install-man: install-man1
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-aminfo \
+	maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \
+	mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am: $(PDFS)
+
+ps: ps-am
+
+ps-am: $(PSS)
+
+uninstall-am: uninstall-man
+
+uninstall-man: uninstall-man1
+
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-generic clean-info clean-noinstPROGRAMS ctags dist-info \
+	distclean distclean-compile distclean-generic distclean-hdr \
+	distclean-tags dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-exec-local install-info \
+	install-info-am install-man install-man1 install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-aminfo maintainer-clean-generic mostlyclean \
+	mostlyclean-aminfo mostlyclean-compile mostlyclean-generic pdf \
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am \
+	uninstall-man uninstall-man1
+
+
+#EXTRA_conv_SOURCES = getopt.h # alloca.c getopt.c strtoul.c
+
+conv-version.h:	$(srcdir)/version.h $(srcdir)/Makefile.in
+	@echo "creating $@"
+	conv_version_package="\"$(PKGVERSION)\"" ;\
+	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
+	sed -e "s,@conv_version_package@,$$conv_version_package," \
+	    -e "s,@report_bugs_to@,$$report_bugs_to," \
+	    < $(srcdir)/version.h > $@
+
+convert.o: convert.c conv-version.h
+
+# FIXME!
+conv.html: $(conv_TEXI)
+#	@rm -f conv.html
+#	texi2html -monolithic -glossary -menu -I . -I $(srcdir) $(conv_TEXI)
+	touch $@
+
+conv.dvi:  $(conv_TEXI)
+
+conv.info: $(conv_TEXI)
+
+.PHONY: install-exec-local install-html
+
+install-exec-local: $(noinst_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    t="$(DESTDIR)$(bindir)/`echo $$p|sed 's/$(EXEEXT)$$//'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`"; \
+	    echo "  $(INSTALL_PROGRAM) $$p $$t"; \
+	     $(INSTALL_PROGRAM) $$p $$t; \
+	  else :; fi; \
+	done
+
+install-html:
+	echo FIXME > /dev/null
+
+install-pdf:
+	echo FIXME > /dev/null
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
--- /dev/null
+++ b/convert/acinclude.m4
@@ -0,0 +1,37 @@
+dnl See whether we need to use fopen-bin.h rather than fopen-same.h.
+AC_DEFUN([CONV_BINARY_FOPEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])
+case "${host}" in
+changequote(,)dnl
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows)
+changequote([,])dnl
+  AC_DEFINE([USE_BINARY_FOPEN], 1, [Use b modifier when opening binary files?]) ;;
+esac])dnl
+
+dnl See whether we need a declaration for a function.
+AC_DEFUN([CONV_NEED_DECLARATION],
+[AC_MSG_CHECKING([whether $1 must be declared])
+AC_CACHE_VAL(bfd_cv_decl_needed_$1,
+[AC_TRY_COMPILE([
+#include <stdio.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif],
+[char *(*pfn) = (char *(*)) $1],
+bfd_cv_decl_needed_$1=no, bfd_cv_decl_needed_$1=yes)])
+AC_MSG_RESULT($bfd_cv_decl_needed_$1)
+if test $bfd_cv_decl_needed_$1 = yes; then
+  bfd_tr_decl=NEED_DECLARATION_`echo $1 | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  AC_DEFINE_UNQUOTED($bfd_tr_decl, 1, [Define if a declaration is needed.])
+fi
+])dnl
--- /dev/null
+++ b/convert/aclocal.m4
@@ -0,0 +1,862 @@
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version="1.9"])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION so it can be traced.
+# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+	 [AM_AUTOMAKE_VERSION([1.9.5])])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 7
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])
+AC_SUBST([$1_FALSE])
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 8
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 3
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`AS_DIRNAME("$mf")`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`AS_DIRNAME(["$file"])`
+    AS_MKDIR_P([$dirpart/$fdir])
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 12
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.58])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_PROG_INSTALL_SH
+AM_PROG_INSTALL_STRIP
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+	      		     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+                  [_AM_DEPENDENCIES(CC)],
+                  [define([AC_PROG_CC],
+                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+                  [_AM_DEPENDENCIES(CXX)],
+                  [define([AC_PROG_CXX],
+                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+])
+])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $1 | $1:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
+AC_SUBST(install_sh)])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+AC_DEFUN([AM_MAINTAINER_MODE],
+[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+  dnl maintainer-mode is disabled by default
+  AC_ARG_ENABLE(maintainer-mode,
+[  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer],
+      USE_MAINTAINER_MODE=$enableval,
+      USE_MAINTAINER_MODE=no)
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL(MAINTAINER_MODE, [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST(MAINT)dnl
+]
+)
+
+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
+#
+# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
+# created by `make install' are always world readable, even if the
+# installer happens to have an overly restrictive umask (e.g. 077).
+# This was a mistake.  There are at least two reasons why we must not
+# use `-m 0755':
+#   - it causes special bits like SGID to be ignored,
+#   - it may be too restrictive (some setups expect 775 directories).
+#
+# Do not use -m 0755 and let people choose whatever they expect by
+# setting umask.
+#
+# We cannot accept any implementation of `mkdir' that recognizes `-p'.
+# Some implementations (such as Solaris 8's) are not thread-safe: if a
+# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'
+# concurrently, both version can detect that a/ is missing, but only
+# one can create it and the other will error out.  Consequently we
+# restrict ourselves to GNU make (using the --version option ensures
+# this.)
+AC_DEFUN([AM_PROG_MKDIR_P],
+[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+AC_SUBST([mkdir_p])])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
+m4_include([../config/acx.m4])
+m4_include([../config/depstand.m4])
+m4_include([../config/lead-dot.m4])
+m4_include([acinclude.m4])
--- /dev/null
+++ b/convert/alloca.c
@@ -0,0 +1,479 @@
+/* alloca.c -- allocate automatically reclaimed memory
+   (Mostly) portable public-domain implementation -- D A Gwyn
+
+   This implementation of the PWB library alloca function,
+   which is used to allocate space off the run-time stack so
+   that it is automatically reclaimed upon procedure exit,
+   was inspired by discussions with J. Q. Johnson of Cornell.
+   J.Otto Tennant <jot@cray.com> contributed the Cray support.
+
+   There are some preprocessor constants that can
+   be defined when compiling for your specific system, for
+   improved efficiency; however, the defaults should be okay.
+
+   The general concept of this implementation is to keep
+   track of all alloca-allocated blocks, and reclaim any
+   that are found to be deeper in the stack than the current
+   invocation.  This heuristic does not reclaim storage as
+   soon as it becomes invalid, but it will do so eventually.
+
+   As a special case, alloca(0) reclaims storage without
+   allocating any.  It is a good idea to use alloca(0) in
+   your main control loop, etc. to force garbage collection.  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/* If compiling with GCC, this file's not needed.  */
+#ifndef alloca
+
+#ifdef emacs
+#ifdef static
+/* actually, only want this if static is defined as ""
+   -- this is for usg, in which emacs must undefine static
+   in order to make unexec workable
+   */
+#ifndef STACK_DIRECTION
+you
+lose
+-- must know STACK_DIRECTION at compile-time
+#endif /* STACK_DIRECTION undefined */
+#endif /* static */
+#endif /* emacs */
+
+/* If your stack is a linked list of frames, you have to
+   provide an "address metric" ADDRESS_FUNCTION macro.  */
+
+#if defined (CRAY) && defined (CRAY_STACKSEG_END)
+long i00afunc ();
+#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
+#else
+#define ADDRESS_FUNCTION(arg) &(arg)
+#endif
+
+#if __STDC__
+#include <stddef.h>
+typedef void *pointer;
+#else
+typedef char *pointer;
+typedef unsigned size_t;
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+/* Different portions of Emacs need to call different versions of
+   malloc.  The Emacs executable needs alloca to call xmalloc, because
+   ordinary malloc isn't protected from input signals.  On the other
+   hand, the utilities in lib-src need alloca to call malloc; some of
+   them are very simple, and don't have an xmalloc routine.
+
+   Non-Emacs programs expect this to call use xmalloc.
+
+   Callers below should use malloc.  */
+
+#ifndef emacs
+#define malloc xmalloc
+extern pointer xmalloc ();
+#endif
+
+/* Define STACK_DIRECTION if you know the direction of stack
+   growth for your system; otherwise it will be automatically
+   deduced at run-time.
+
+   STACK_DIRECTION > 0 => grows toward higher addresses
+   STACK_DIRECTION < 0 => grows toward lower addresses
+   STACK_DIRECTION = 0 => direction of growth unknown  */
+
+#ifndef STACK_DIRECTION
+#define	STACK_DIRECTION	0	/* Direction unknown.  */
+#endif
+
+#if STACK_DIRECTION != 0
+
+#define	STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
+
+#else /* STACK_DIRECTION == 0; need run-time code.  */
+
+static int stack_dir;		/* 1 or -1 once known.  */
+#define	STACK_DIR	stack_dir
+
+static void
+find_stack_direction ()
+{
+  static char *addr = NULL;	/* Address of first `dummy', once known.  */
+  auto char dummy;		/* To get stack address.  */
+
+  if (addr == NULL)
+    {				/* Initial entry.  */
+      addr = ADDRESS_FUNCTION (dummy);
+
+      find_stack_direction ();	/* Recurse once.  */
+    }
+  else
+    {
+      /* Second entry.  */
+      if (ADDRESS_FUNCTION (dummy) > addr)
+	stack_dir = 1;		/* Stack grew upward.  */
+      else
+	stack_dir = -1;		/* Stack grew downward.  */
+    }
+}
+
+#endif /* STACK_DIRECTION == 0 */
+
+/* An "alloca header" is used to:
+   (a) chain together all alloca'ed blocks;
+   (b) keep track of stack depth.
+
+   It is very important that sizeof(header) agree with malloc
+   alignment chunk size.  The following default should work okay.  */
+
+#ifndef	ALIGN_SIZE
+#define	ALIGN_SIZE	sizeof(double)
+#endif
+
+typedef union hdr
+{
+  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
+  struct
+    {
+      union hdr *next;		/* For chaining headers.  */
+      char *deep;		/* For stack depth measure.  */
+    } h;
+} header;
+
+static header *last_alloca_header = NULL;	/* -> last alloca header.  */
+
+/* Return a pointer to at least SIZE bytes of storage,
+   which will be automatically reclaimed upon exit from
+   the procedure that called alloca.  Originally, this space
+   was supposed to be taken from the current stack frame of the
+   caller, but that method cannot be made to work for some
+   implementations of C, for example under Gould's UTX/32.  */
+
+pointer
+alloca (size)
+     size_t size;
+{
+  auto char probe;		/* Probes stack depth: */
+  register char *depth = ADDRESS_FUNCTION (probe);
+
+#if STACK_DIRECTION == 0
+  if (STACK_DIR == 0)		/* Unknown growth direction.  */
+    find_stack_direction ();
+#endif
+
+  /* Reclaim garbage, defined as all alloca'd storage that
+     was allocated from deeper in the stack than currently. */
+
+  {
+    register header *hp;	/* Traverses linked list.  */
+
+    for (hp = last_alloca_header; hp != NULL;)
+      if ((STACK_DIR > 0 && hp->h.deep > depth)
+	  || (STACK_DIR < 0 && hp->h.deep < depth))
+	{
+	  register header *np = hp->h.next;
+
+	  free ((pointer) hp);	/* Collect garbage.  */
+
+	  hp = np;		/* -> next header.  */
+	}
+      else
+	break;			/* Rest are not deeper.  */
+
+    last_alloca_header = hp;	/* -> last valid storage.  */
+  }
+
+  if (size == 0)
+    return NULL;		/* No allocation required.  */
+
+  /* Allocate combined header + user data storage.  */
+
+  {
+    register pointer new = malloc (sizeof (header) + size);
+    /* Address of header.  */
+
+    ((header *) new)->h.next = last_alloca_header;
+    ((header *) new)->h.deep = depth;
+
+    last_alloca_header = (header *) new;
+
+    /* User storage begins just after header.  */
+
+    return (pointer) ((char *) new + sizeof (header));
+  }
+}
+
+#if defined (CRAY) && defined (CRAY_STACKSEG_END)
+
+#ifdef DEBUG_I00AFUNC
+#include <stdio.h>
+#endif
+
+#ifndef CRAY_STACK
+#define CRAY_STACK
+#ifndef CRAY2
+/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
+struct stack_control_header
+  {
+    long shgrow:32;		/* Number of times stack has grown.  */
+    long shaseg:32;		/* Size of increments to stack.  */
+    long shhwm:32;		/* High water mark of stack.  */
+    long shsize:32;		/* Current size of stack (all segments).  */
+  };
+
+/* The stack segment linkage control information occurs at
+   the high-address end of a stack segment.  (The stack
+   grows from low addresses to high addresses.)  The initial
+   part of the stack segment linkage control information is
+   0200 (octal) words.  This provides for register storage
+   for the routine which overflows the stack.  */
+
+struct stack_segment_linkage
+  {
+    long ss[0200];		/* 0200 overflow words.  */
+    long sssize:32;		/* Number of words in this segment.  */
+    long ssbase:32;		/* Offset to stack base.  */
+    long:32;
+    long sspseg:32;		/* Offset to linkage control of previous
+				   segment of stack.  */
+    long:32;
+    long sstcpt:32;		/* Pointer to task common address block.  */
+    long sscsnm;		/* Private control structure number for
+				   microtasking.  */
+    long ssusr1;		/* Reserved for user.  */
+    long ssusr2;		/* Reserved for user.  */
+    long sstpid;		/* Process ID for pid based multi-tasking.  */
+    long ssgvup;		/* Pointer to multitasking thread giveup.  */
+    long sscray[7];		/* Reserved for Cray Research.  */
+    long ssa0;
+    long ssa1;
+    long ssa2;
+    long ssa3;
+    long ssa4;
+    long ssa5;
+    long ssa6;
+    long ssa7;
+    long sss0;
+    long sss1;
+    long sss2;
+    long sss3;
+    long sss4;
+    long sss5;
+    long sss6;
+    long sss7;
+  };
+
+#else /* CRAY2 */
+/* The following structure defines the vector of words
+   returned by the STKSTAT library routine.  */
+struct stk_stat
+  {
+    long now;			/* Current total stack size.  */
+    long maxc;			/* Amount of contiguous space which would
+				   be required to satisfy the maximum
+				   stack demand to date.  */
+    long high_water;		/* Stack high-water mark.  */
+    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
+    long hits;			/* Number of internal buffer hits.  */
+    long extends;		/* Number of block extensions.  */
+    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
+    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
+    long stko_free;		/* Number of deallocations by $STKRETN.  */
+    long stkm_free;		/* Number of deallocations by $STKMRET.  */
+    long segments;		/* Current number of stack segments.  */
+    long maxs;			/* Maximum number of stack segments so far.  */
+    long pad_size;		/* Stack pad size.  */
+    long current_address;	/* Current stack segment address.  */
+    long current_size;		/* Current stack segment size.  This
+				   number is actually corrupted by STKSTAT to
+				   include the fifteen word trailer area.  */
+    long initial_address;	/* Address of initial segment.  */
+    long initial_size;		/* Size of initial segment.  */
+  };
+
+/* The following structure describes the data structure which trails
+   any stack segment.  I think that the description in 'asdef' is
+   out of date.  I only describe the parts that I am sure about.  */
+
+struct stk_trailer
+  {
+    long this_address;		/* Address of this block.  */
+    long this_size;		/* Size of this block (does not include
+				   this trailer).  */
+    long unknown2;
+    long unknown3;
+    long link;			/* Address of trailer block of previous
+				   segment.  */
+    long unknown5;
+    long unknown6;
+    long unknown7;
+    long unknown8;
+    long unknown9;
+    long unknown10;
+    long unknown11;
+    long unknown12;
+    long unknown13;
+    long unknown14;
+  };
+
+#endif /* CRAY2 */
+#endif /* not CRAY_STACK */
+
+#ifdef CRAY2
+/* Determine a "stack measure" for an arbitrary ADDRESS.
+   I doubt that "lint" will like this much. */
+
+static long
+i00afunc (long *address)
+{
+  struct stk_stat status;
+  struct stk_trailer *trailer;
+  long *block, size;
+  long result = 0;
+
+  /* We want to iterate through all of the segments.  The first
+     step is to get the stack status structure.  We could do this
+     more quickly and more directly, perhaps, by referencing the
+     $LM00 common block, but I know that this works.  */
+
+  STKSTAT (&status);
+
+  /* Set up the iteration.  */
+
+  trailer = (struct stk_trailer *) (status.current_address
+				    + status.current_size
+				    - 15);
+
+  /* There must be at least one stack segment.  Therefore it is
+     a fatal error if "trailer" is null.  */
+
+  if (trailer == 0)
+    abort ();
+
+  /* Discard segments that do not contain our argument address.  */
+
+  while (trailer != 0)
+    {
+      block = (long *) trailer->this_address;
+      size = trailer->this_size;
+      if (block == 0 || size == 0)
+	abort ();
+      trailer = (struct stk_trailer *) trailer->link;
+      if ((block <= address) && (address < (block + size)))
+	break;
+    }
+
+  /* Set the result to the offset in this segment and add the sizes
+     of all predecessor segments.  */
+
+  result = address - block;
+
+  if (trailer == 0)
+    {
+      return result;
+    }
+
+  do
+    {
+      if (trailer->this_size <= 0)
+	abort ();
+      result += trailer->this_size;
+      trailer = (struct stk_trailer *) trailer->link;
+    }
+  while (trailer != 0);
+
+  /* We are done.  Note that if you present a bogus address (one
+     not in any segment), you will get a different number back, formed
+     from subtracting the address of the first block.  This is probably
+     not what you want.  */
+
+  return (result);
+}
+
+#else /* not CRAY2 */
+/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
+   Determine the number of the cell within the stack,
+   given the address of the cell.  The purpose of this
+   routine is to linearize, in some sense, stack addresses
+   for alloca.  */
+
+static long
+i00afunc (long address)
+{
+  long stkl = 0;
+
+  long size, pseg, this_segment, stack;
+  long result = 0;
+
+  struct stack_segment_linkage *ssptr;
+
+  /* Register B67 contains the address of the end of the
+     current stack segment.  If you (as a subprogram) store
+     your registers on the stack and find that you are past
+     the contents of B67, you have overflowed the segment.
+
+     B67 also points to the stack segment linkage control
+     area, which is what we are really interested in.  */
+
+  stkl = CRAY_STACKSEG_END ();
+  ssptr = (struct stack_segment_linkage *) stkl;
+
+  /* If one subtracts 'size' from the end of the segment,
+     one has the address of the first word of the segment.
+
+     If this is not the first segment, 'pseg' will be
+     nonzero.  */
+
+  pseg = ssptr->sspseg;
+  size = ssptr->sssize;
+
+  this_segment = stkl - size;
+
+  /* It is possible that calling this routine itself caused
+     a stack overflow.  Discard stack segments which do not
+     contain the target address.  */
+
+  while (!(this_segment <= address && address <= stkl))
+    {
+#ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
+#endif
+      if (pseg == 0)
+	break;
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      this_segment = stkl - size;
+    }
+
+  result = address - this_segment;
+
+  /* If you subtract pseg from the current end of the stack,
+     you get the address of the previous stack segment's end.
+     This seems a little convoluted to me, but I'll bet you save
+     a cycle somewhere.  */
+
+  while (pseg != 0)
+    {
+#ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o\n", pseg, size);
+#endif
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      result += size;
+    }
+  return (result);
+}
+
+#endif /* not CRAY2 */
+#endif /* CRAY */
+
+#endif /* no alloca */
--- /dev/null
+++ b/convert/bin.c
@@ -0,0 +1,68 @@
+/* bin.c -- Raw Binary Output
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+#define BUFSIZE		8192	/* max bytes per block */
+
+static FILE		*binfp;
+static unsigned long	binfirst = ~0;
+static unsigned long	binaddr = ~0;
+static int 		binlen;
+static unsigned char	*binbuf;
+
+static void
+binFlush ()
+{
+    if (binlen > 0) {
+	fseek (binfp, binaddr - binfirst, 0);
+	fwrite (binbuf, 1, binlen, binfp);
+	binlen = 0;
+    }
+}
+
+void
+BinStart (FILE *fp, unsigned long ep)
+{
+    binbuf = xmalloc (BUFSIZE);
+    binfp = fp;
+}
+
+
+void
+BinOutput (unsigned long addr, unsigned char byte)
+{
+    if (addr != binaddr + binlen || binlen == BUFSIZE) {
+	binFlush ();
+	binaddr = addr;
+	if (binfirst == ~0)
+	  binfirst = addr;
+    }
+    binbuf[binlen++] = byte;
+}
+
+
+void
+BinEnd (unsigned long ep)
+{
+    binFlush ();
+    free (binbuf);
+}
+
--- /dev/null
+++ b/convert/config.h.in
@@ -0,0 +1,105 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#undef HAVE_STDDEF_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strchr' function. */
+#undef HAVE_STRCHR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strtok' function. */
+#undef HAVE_STRTOK
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#undef HAVE_SYS_FILE_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Use b modifier when opening binary files? */
+#undef USE_BINARY_FOPEN
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
--- /dev/null
+++ b/convert/configure
@@ -0,0 +1,6916 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.61 for convert 3.0.4.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+if test "x$CONFIG_SHELL" = x; then
+  if (eval ":") 2>/dev/null; then
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+
+  if test $as_have_required = yes && 	 (eval ":
+(as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=\$LINENO
+  as_lineno_2=\$LINENO
+  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
+  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
+") 2> /dev/null; then
+  :
+else
+  as_candidate_shells=
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  case $as_dir in
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
+	   done;;
+       esac
+done
+IFS=$as_save_IFS
+
+
+      for as_shell in $as_candidate_shells $SHELL; do
+	 # Try only shells that exist, to save several forks.
+	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		{ ("$as_shell") 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+_ASEOF
+}; then
+  CONFIG_SHELL=$as_shell
+	       as_have_required=yes
+	       if { "$as_shell" 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+(as_func_return () {
+  (exit $1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = "$1" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test $exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
+
+_ASEOF
+}; then
+  break
+fi
+
+fi
+
+      done
+
+      if test "x$CONFIG_SHELL" != x; then
+  for as_var in BASH_ENV ENV
+        do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+        done
+        export CONFIG_SHELL
+        exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+
+    if test $as_have_required = no; then
+  echo This script requires a shell more modern than all the
+      echo shells that I found on your system.  Please install a
+      echo modern shell, or manually run the script under such a
+      echo shell if you do have one.
+      { (exit 1); exit 1; }
+fi
+
+
+fi
+
+fi
+
+
+
+(eval "as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0") || {
+  echo No shell found that supports shell functions.
+  echo Please tell autoconf@gnu.org about your system,
+  echo including any error possibly output before this
+  echo message
+}
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Identity of this package.
+PACKAGE_NAME='convert'
+PACKAGE_TARNAME='convert'
+PACKAGE_VERSION='3.0.4'
+PACKAGE_STRING='convert 3.0.4'
+PACKAGE_BUGREPORT=''
+
+ac_unique_file="convert.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL
+PATH_SEPARATOR
+PACKAGE_NAME
+PACKAGE_TARNAME
+PACKAGE_VERSION
+PACKAGE_STRING
+PACKAGE_BUGREPORT
+exec_prefix
+prefix
+program_transform_name
+bindir
+sbindir
+libexecdir
+datarootdir
+datadir
+sysconfdir
+sharedstatedir
+localstatedir
+includedir
+oldincludedir
+docdir
+infodir
+htmldir
+dvidir
+pdfdir
+psdir
+libdir
+localedir
+mandir
+DEFS
+ECHO_C
+ECHO_N
+ECHO_T
+LIBS
+build_alias
+host_alias
+target_alias
+build
+build_cpu
+build_vendor
+build_os
+host
+host_cpu
+host_vendor
+host_os
+target
+target_cpu
+target_vendor
+target_os
+INSTALL_PROGRAM
+INSTALL_SCRIPT
+INSTALL_DATA
+CYGPATH_W
+PACKAGE
+VERSION
+ACLOCAL
+AUTOCONF
+AUTOMAKE
+AUTOHEADER
+MAKEINFO
+install_sh
+STRIP
+INSTALL_STRIP_PROGRAM
+mkdir_p
+AWK
+SET_MAKE
+am__leading_dot
+AMTAR
+am__tar
+am__untar
+CC
+CFLAGS
+LDFLAGS
+CPPFLAGS
+ac_ct_CC
+EXEEXT
+OBJEXT
+DEPDIR
+am__include
+am__quote
+AMDEP_TRUE
+AMDEP_FALSE
+AMDEPBACKSLASH
+CCDEPMODE
+am__fastdepCC_TRUE
+am__fastdepCC_FALSE
+CPP
+GREP
+EGREP
+ALLOCA
+PKGVERSION
+REPORT_BUGS_TO
+REPORT_BUGS_TEXI
+MAINTAINER_MODE_TRUE
+MAINTAINER_MODE_FALSE
+MAINT
+LIBOBJS
+LTLIBOBJS'
+ac_subst_files=''
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
+    eval enable_$ac_feature=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
+    eval enable_$ac_feature=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
+    eval with_$ac_package=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
+    eval with_$ac_package=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute directory names.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; }
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  { echo "$as_me: error: Working directory cannot be determined" >&2
+   { (exit 1); exit 1; }; }
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  { echo "$as_me: error: pwd does not report name of working directory" >&2
+   { (exit 1); exit 1; }; }
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$0" ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || { echo "$as_me: error: $ac_msg" >&2
+   { (exit 1); exit 1; }; }
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures convert 3.0.4 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --datarootdir=DIR      read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR          read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR          info documentation [DATAROOTDIR/info]
+  --localedir=DIR        locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR           man documentation [DATAROOTDIR/man]
+  --docdir=DIR           documentation root [DATAROOTDIR/doc/convert]
+  --htmldir=DIR          html documentation [DOCDIR]
+  --dvidir=DIR           dvi documentation [DOCDIR]
+  --pdfdir=DIR           pdf documentation [DOCDIR]
+  --psdir=DIR            ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of convert 3.0.4:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pkgversion=PKG   Use PKG in the version string in place of "MIPS
+                          Convert"
+  --with-bugurl=URL       Direct users to URL to report a bug
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" || continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+convert configure 3.0.4
+generated by GNU Autoconf 2.61
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by convert $as_me 3.0.4, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args '$ac_arg'"
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
+echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -n "$CONFIG_SITE"; then
+  set x "$CONFIG_SITE"
+elif test "x$prefix" != xNONE; then
+  set x "$prefix/share/config.site" "$prefix/etc/config.site"
+else
+  set x "$ac_default_prefix/share/config.site" \
+	"$ac_default_prefix/etc/config.site"
+fi
+shift
+for ac_site_file
+do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
+echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+{ echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
+echo "$as_me: error: invalid value of canonical build" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
+echo "$as_me: error: invalid value of canonical host" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6; }
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
+echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) { { echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
+echo "$as_me: error: invalid value of canonical target" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+am__api_version="1.9"
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+IFS=$as_save_IFS
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { { echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&5
+echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&2;}
+   { (exit 1); exit 1; }; }
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   { { echo "$as_me:$LINENO: error: newly created file is older than distributed files!
+Check your system clock" >&5
+echo "$as_me: error: newly created file is older than distributed files!
+Check your system clock" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm -f conftest.sed
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
+echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { echo "$as_me:$LINENO: result: $AWK" >&5
+echo "${ECHO_T}$AWK" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
+set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+  SET_MAKE=
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
+echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='convert'
+ VERSION='3.0.4'
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6; }
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&5
+echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
+whose name does not start with the host triplet.  If you think this
+configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO: checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6; }
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+#
+# List of possible output files, starting from the most likely.
+# The algorithm is not robust to junk in `.', hence go to wildcards (a.*)
+# only as a last resort.  b.out is created by i960 compilers.
+ac_files='a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out'
+#
+# The IRIX 6 linker writes into existing files which may not be
+# executable, retaining their permissions.  Remove them first so a
+# subsequent execution test works.
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { (ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+
+{ echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6; }
+if test -z "$ac_file"; then
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+{ echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6; }
+{ echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6; }
+
+{ echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6; }
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+{ echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6; }
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6; }
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_c89=$ac_arg
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6; } ;;
+  xno)
+    { echo "$as_me:$LINENO: result: unsupported" >&5
+echo "${ECHO_T}unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
+echo $ECHO_N "checking for style of include used by $am_make... $ECHO_C" >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+
+
+{ echo "$as_me:$LINENO: result: $_am_result" >&5
+echo "${ECHO_T}$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+
+
+if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+
+
+if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+IFS=$as_save_IFS
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+
+{ echo "$as_me:$LINENO: checking for library containing strerror" >&5
+echo $ECHO_N "checking for library containing strerror... $ECHO_C" >&6; }
+if test "${ac_cv_search_strerror+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char strerror ();
+int
+main ()
+{
+return strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' cposix; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  ac_cv_search_strerror=$ac_res
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext
+  if test "${ac_cv_search_strerror+set}" = set; then
+  break
+fi
+done
+if test "${ac_cv_search_strerror+set}" = set; then
+  :
+else
+  ac_cv_search_strerror=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_search_strerror" >&5
+echo "${ECHO_T}$ac_cv_search_strerror" >&6; }
+ac_res=$ac_cv_search_strerror
+if test "$ac_res" != no; then
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+echo $ECHO_N "checking for grep that handles long lines and -e... $ECHO_C" >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # Extract the first word of "grep ggrep" to use in msg output
+if test -z "$GREP"; then
+set dummy grep ggrep; ac_prog_name=$2
+if test "${ac_cv_path_GREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_path_GREP_found=false
+# Loop through the user's path and test for each of PROGNAME-LIST
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in grep ggrep; do
+  for ac_exec_ext in '' $ac_executable_extensions; do
+    ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+    { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+    # Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+
+    $ac_path_GREP_found && break 3
+  done
+done
+
+done
+IFS=$as_save_IFS
+
+
+fi
+
+GREP="$ac_cv_path_GREP"
+if test -z "$GREP"; then
+  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+echo "${ECHO_T}$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     # Extract the first word of "egrep" to use in msg output
+if test -z "$EGREP"; then
+set dummy egrep; ac_prog_name=$2
+if test "${ac_cv_path_EGREP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_path_EGREP_found=false
+# Loop through the user's path and test for each of PROGNAME-LIST
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in egrep; do
+  for ac_exec_ext in '' $ac_executable_extensions; do
+    ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+    { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+    # Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+
+    $ac_path_EGREP_found && break 3
+  done
+done
+
+done
+IFS=$as_save_IFS
+
+
+fi
+
+EGREP="$ac_cv_path_EGREP"
+if test -z "$EGREP"; then
+  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+
+   fi
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+echo "${ECHO_T}$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+ac_config_headers="$ac_config_headers config.h"
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+for ac_header in stddef.h stdlib.h strings.h unistd.h limits.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in fcntl.h sys/file.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+{ echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6; }
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset cs;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_const=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_const=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6; }
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
+
+fi
+
+{ echo "$as_me:$LINENO: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6; }
+if test "${ac_cv_type_size_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+typedef size_t ac__type_new_;
+int
+main ()
+{
+if ((ac__type_new_ *) 0)
+  return 0;
+if (sizeof (ac__type_new_))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_type_size_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_size_t=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6; }
+if test $ac_cv_type_size_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
+
+fi
+
+
+
+
+
+for ac_func in strchr strtok memcpy
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+{ echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6; }
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+			  if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_working_alloca_h=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6; }
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+{ echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6; }
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  ifdef HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+				    if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func_alloca_works=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6; }
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=\${LIBOBJDIR}alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+{ echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6; }
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined CRAY && ! defined CRAY2
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6; }
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext &&
+       $as_test_x conftest$ac_exeext; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval echo '${'$as_ac_var'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+{ echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6; }
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  return find_stack_direction () < 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
+
+case "${host}" in
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows)
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_BINARY_FOPEN 1
+_ACEOF
+ ;;
+esac
+
+{ echo "$as_me:$LINENO: checking whether malloc must be declared" >&5
+echo $ECHO_N "checking whether malloc must be declared... $ECHO_C" >&6; }
+if test "${bfd_cv_decl_needed_malloc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+int
+main ()
+{
+char *(*pfn) = (char *(*)) malloc
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  bfd_cv_decl_needed_malloc=no
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	bfd_cv_decl_needed_malloc=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ echo "$as_me:$LINENO: result: $bfd_cv_decl_needed_malloc" >&5
+echo "${ECHO_T}$bfd_cv_decl_needed_malloc" >&6; }
+if test $bfd_cv_decl_needed_malloc = yes; then
+  bfd_tr_decl=NEED_DECLARATION_`echo malloc | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+
+cat >>confdefs.h <<_ACEOF
+#define $bfd_tr_decl 1
+_ACEOF
+
+fi
+
+{ echo "$as_me:$LINENO: checking whether realloc must be declared" >&5
+echo $ECHO_N "checking whether realloc must be declared... $ECHO_C" >&6; }
+if test "${bfd_cv_decl_needed_realloc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+int
+main ()
+{
+char *(*pfn) = (char *(*)) realloc
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  bfd_cv_decl_needed_realloc=no
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	bfd_cv_decl_needed_realloc=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ echo "$as_me:$LINENO: result: $bfd_cv_decl_needed_realloc" >&5
+echo "${ECHO_T}$bfd_cv_decl_needed_realloc" >&6; }
+if test $bfd_cv_decl_needed_realloc = yes; then
+  bfd_tr_decl=NEED_DECLARATION_`echo realloc | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+
+cat >>confdefs.h <<_ACEOF
+#define $bfd_tr_decl 1
+_ACEOF
+
+fi
+
+{ echo "$as_me:$LINENO: checking whether free must be declared" >&5
+echo $ECHO_N "checking whether free must be declared... $ECHO_C" >&6; }
+if test "${bfd_cv_decl_needed_free+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+int
+main ()
+{
+char *(*pfn) = (char *(*)) free
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  bfd_cv_decl_needed_free=no
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	bfd_cv_decl_needed_free=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ echo "$as_me:$LINENO: result: $bfd_cv_decl_needed_free" >&5
+echo "${ECHO_T}$bfd_cv_decl_needed_free" >&6; }
+if test $bfd_cv_decl_needed_free = yes; then
+  bfd_tr_decl=NEED_DECLARATION_`echo free | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+
+cat >>confdefs.h <<_ACEOF
+#define $bfd_tr_decl 1
+_ACEOF
+
+fi
+
+{ echo "$as_me:$LINENO: checking whether strtok must be declared" >&5
+echo $ECHO_N "checking whether strtok must be declared... $ECHO_C" >&6; }
+if test "${bfd_cv_decl_needed_strtok+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+int
+main ()
+{
+char *(*pfn) = (char *(*)) strtok
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  bfd_cv_decl_needed_strtok=no
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	bfd_cv_decl_needed_strtok=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ echo "$as_me:$LINENO: result: $bfd_cv_decl_needed_strtok" >&5
+echo "${ECHO_T}$bfd_cv_decl_needed_strtok" >&6; }
+if test $bfd_cv_decl_needed_strtok = yes; then
+  bfd_tr_decl=NEED_DECLARATION_`echo strtok | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+
+cat >>confdefs.h <<_ACEOF
+#define $bfd_tr_decl 1
+_ACEOF
+
+fi
+
+
+
+
+# Check whether --with-pkgversion was given.
+if test "${with_pkgversion+set}" = set; then
+  withval=$with_pkgversion; case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: package version not specified" >&5
+echo "$as_me: error: package version not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  PKGVERSION= ;;
+      *)   PKGVERSION="($withval) " ;;
+     esac
+else
+  PKGVERSION="(MIPS Convert) "
+
+fi
+
+
+
+
+
+# Check whether --with-bugurl was given.
+if test "${with_bugurl+set}" = set; then
+  withval=$with_bugurl; case "$withval" in
+      yes) { { echo "$as_me:$LINENO: error: bug URL not specified" >&5
+echo "$as_me: error: bug URL not specified" >&2;}
+   { (exit 1); exit 1; }; } ;;
+      no)  BUGURL=
+	   ;;
+      *)   BUGURL="$withval"
+	   ;;
+     esac
+else
+  BUGURL="http://support.codesourcery.com/"
+
+fi
+
+  case ${BUGURL} in
+  "")
+    REPORT_BUGS_TO=
+    REPORT_BUGS_TEXI=
+    ;;
+  *)
+    REPORT_BUGS_TO="<$BUGURL>"
+    REPORT_BUGS_TEXI=@uref{`echo "$BUGURL" | sed 's/@/@@/g'`}
+    ;;
+  esac;
+
+
+
+
+{ echo "$as_me:$LINENO: checking whether to enable maintainer-specific portions of Makefiles" >&5
+echo $ECHO_N "checking whether to enable maintainer-specific portions of Makefiles... $ECHO_C" >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { echo "$as_me:$LINENO: result: $USE_MAINTAINER_MODE" >&5
+echo "${ECHO_T}$USE_MAINTAINER_MODE" >&6; }
+
+
+if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+
+ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
+echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
+echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by convert $as_me 3.0.4, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+convert config.status 3.0.4
+configured by $0, generated by GNU Autoconf 2.61,
+  with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2006 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    { echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running CONFIG_SHELL=$SHELL $SHELL $0 "$ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  CONFIG_SHELL=$SHELL
+  export CONFIG_SHELL
+  exec $SHELL "$0"$ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+#
+# Set up the sed scripts for CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+
+_ACEOF
+
+
+
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  cat >conf$$subs.sed <<_ACEOF
+SHELL!$SHELL$ac_delim
+PATH_SEPARATOR!$PATH_SEPARATOR$ac_delim
+PACKAGE_NAME!$PACKAGE_NAME$ac_delim
+PACKAGE_TARNAME!$PACKAGE_TARNAME$ac_delim
+PACKAGE_VERSION!$PACKAGE_VERSION$ac_delim
+PACKAGE_STRING!$PACKAGE_STRING$ac_delim
+PACKAGE_BUGREPORT!$PACKAGE_BUGREPORT$ac_delim
+exec_prefix!$exec_prefix$ac_delim
+prefix!$prefix$ac_delim
+program_transform_name!$program_transform_name$ac_delim
+bindir!$bindir$ac_delim
+sbindir!$sbindir$ac_delim
+libexecdir!$libexecdir$ac_delim
+datarootdir!$datarootdir$ac_delim
+datadir!$datadir$ac_delim
+sysconfdir!$sysconfdir$ac_delim
+sharedstatedir!$sharedstatedir$ac_delim
+localstatedir!$localstatedir$ac_delim
+includedir!$includedir$ac_delim
+oldincludedir!$oldincludedir$ac_delim
+docdir!$docdir$ac_delim
+infodir!$infodir$ac_delim
+htmldir!$htmldir$ac_delim
+dvidir!$dvidir$ac_delim
+pdfdir!$pdfdir$ac_delim
+psdir!$psdir$ac_delim
+libdir!$libdir$ac_delim
+localedir!$localedir$ac_delim
+mandir!$mandir$ac_delim
+DEFS!$DEFS$ac_delim
+ECHO_C!$ECHO_C$ac_delim
+ECHO_N!$ECHO_N$ac_delim
+ECHO_T!$ECHO_T$ac_delim
+LIBS!$LIBS$ac_delim
+build_alias!$build_alias$ac_delim
+host_alias!$host_alias$ac_delim
+target_alias!$target_alias$ac_delim
+build!$build$ac_delim
+build_cpu!$build_cpu$ac_delim
+build_vendor!$build_vendor$ac_delim
+build_os!$build_os$ac_delim
+host!$host$ac_delim
+host_cpu!$host_cpu$ac_delim
+host_vendor!$host_vendor$ac_delim
+host_os!$host_os$ac_delim
+target!$target$ac_delim
+target_cpu!$target_cpu$ac_delim
+target_vendor!$target_vendor$ac_delim
+target_os!$target_os$ac_delim
+INSTALL_PROGRAM!$INSTALL_PROGRAM$ac_delim
+INSTALL_SCRIPT!$INSTALL_SCRIPT$ac_delim
+INSTALL_DATA!$INSTALL_DATA$ac_delim
+CYGPATH_W!$CYGPATH_W$ac_delim
+PACKAGE!$PACKAGE$ac_delim
+VERSION!$VERSION$ac_delim
+ACLOCAL!$ACLOCAL$ac_delim
+AUTOCONF!$AUTOCONF$ac_delim
+AUTOMAKE!$AUTOMAKE$ac_delim
+AUTOHEADER!$AUTOHEADER$ac_delim
+MAKEINFO!$MAKEINFO$ac_delim
+install_sh!$install_sh$ac_delim
+STRIP!$STRIP$ac_delim
+INSTALL_STRIP_PROGRAM!$INSTALL_STRIP_PROGRAM$ac_delim
+mkdir_p!$mkdir_p$ac_delim
+AWK!$AWK$ac_delim
+SET_MAKE!$SET_MAKE$ac_delim
+am__leading_dot!$am__leading_dot$ac_delim
+AMTAR!$AMTAR$ac_delim
+am__tar!$am__tar$ac_delim
+am__untar!$am__untar$ac_delim
+CC!$CC$ac_delim
+CFLAGS!$CFLAGS$ac_delim
+LDFLAGS!$LDFLAGS$ac_delim
+CPPFLAGS!$CPPFLAGS$ac_delim
+ac_ct_CC!$ac_ct_CC$ac_delim
+EXEEXT!$EXEEXT$ac_delim
+OBJEXT!$OBJEXT$ac_delim
+DEPDIR!$DEPDIR$ac_delim
+am__include!$am__include$ac_delim
+am__quote!$am__quote$ac_delim
+AMDEP_TRUE!$AMDEP_TRUE$ac_delim
+AMDEP_FALSE!$AMDEP_FALSE$ac_delim
+AMDEPBACKSLASH!$AMDEPBACKSLASH$ac_delim
+CCDEPMODE!$CCDEPMODE$ac_delim
+am__fastdepCC_TRUE!$am__fastdepCC_TRUE$ac_delim
+am__fastdepCC_FALSE!$am__fastdepCC_FALSE$ac_delim
+CPP!$CPP$ac_delim
+GREP!$GREP$ac_delim
+EGREP!$EGREP$ac_delim
+ALLOCA!$ALLOCA$ac_delim
+PKGVERSION!$PKGVERSION$ac_delim
+REPORT_BUGS_TO!$REPORT_BUGS_TO$ac_delim
+REPORT_BUGS_TEXI!$REPORT_BUGS_TEXI$ac_delim
+MAINTAINER_MODE_TRUE!$MAINTAINER_MODE_TRUE$ac_delim
+MAINTAINER_MODE_FALSE!$MAINTAINER_MODE_FALSE$ac_delim
+MAINT!$MAINT$ac_delim
+LIBOBJS!$LIBOBJS$ac_delim
+_ACEOF
+
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 97; then
+    break
+  elif $ac_last_try; then
+    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
+if test -n "$ac_eof"; then
+  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
+  ac_eof=`expr $ac_eof + 1`
+fi
+
+cat >>$CONFIG_STATUS <<_ACEOF
+cat >"\$tmp/subs-1.sed" <<\CEOF$ac_eof
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+_ACEOF
+sed '
+s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
+s/^/s,@/; s/!/@,|#_!!_#|/
+:n
+t n
+s/'"$ac_delim"'$/,g/; t
+s/$/\\/; p
+N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
+' >>$CONFIG_STATUS <conf$$subs.sed
+rm -f conf$$subs.sed
+cat >>$CONFIG_STATUS <<_ACEOF
+CEOF$ac_eof
+_ACEOF
+
+
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  cat >conf$$subs.sed <<_ACEOF
+LTLIBOBJS!$LTLIBOBJS$ac_delim
+_ACEOF
+
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 1; then
+    break
+  elif $ac_last_try; then
+    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
+if test -n "$ac_eof"; then
+  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
+  ac_eof=`expr $ac_eof + 1`
+fi
+
+cat >>$CONFIG_STATUS <<_ACEOF
+cat >"\$tmp/subs-2.sed" <<\CEOF$ac_eof
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
+_ACEOF
+sed '
+s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
+s/^/s,@/; s/!/@,|#_!!_#|/
+:n
+t n
+s/'"$ac_delim"'$/,g/; t
+s/$/\\/; p
+N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
+' >>$CONFIG_STATUS <conf$$subs.sed
+rm -f conf$$subs.sed
+cat >>$CONFIG_STATUS <<_ACEOF
+:end
+s/|#_!!_#|//g
+CEOF$ac_eof
+_ACEOF
+
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+fi # test -n "$CONFIG_FILES"
+
+
+for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
+echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      ac_file_inputs="$ac_file_inputs $ac_f"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input="Generated from "`IFS=:
+	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    fi
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin";;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+case `sed -n '/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+' $ac_file_inputs` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+    s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s&@configure_input@&$configure_input&;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+" $ac_file_inputs | sed -f "$tmp/subs-1.sed" | sed -f "$tmp/subs-2.sed" >$tmp/out
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out"; rm -f "$tmp/out";;
+  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
+  esac
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+_ACEOF
+
+# Transform confdefs.h into a sed script `conftest.defines', that
+# substitutes the proper values into config.h.in to produce config.h.
+rm -f conftest.defines conftest.tail
+# First, append a space to every undef/define line, to ease matching.
+echo 's/$/ /' >conftest.defines
+# Then, protect against being on the right side of a sed subst, or in
+# an unquoted here document, in config.status.  If some macros were
+# called several times there might be several #defines for the same
+# symbol, which is useless.  But do not sort them, since the last
+# AC_DEFINE must be honored.
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+# These sed commands are passed to sed as "A NAME B PARAMS C VALUE D", where
+# NAME is the cpp macro being defined, VALUE is the value it is being given.
+# PARAMS is the parameter list in the macro definition--in most cases, it's
+# just an empty string.
+ac_dA='s,^\\([	 #]*\\)[^	 ]*\\([	 ]*'
+ac_dB='\\)[	 (].*,\\1define\\2'
+ac_dC=' '
+ac_dD=' ,'
+
+uniq confdefs.h |
+  sed -n '
+	t rset
+	:rset
+	s/^[	 ]*#[	 ]*define[	 ][	 ]*//
+	t ok
+	d
+	:ok
+	s/[\\&,]/\\&/g
+	s/^\('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/ '"$ac_dA"'\1'"$ac_dB"'\2'"${ac_dC}"'\3'"$ac_dD"'/p
+	s/^\('"$ac_word_re"'\)[	 ]*\(.*\)/'"$ac_dA"'\1'"$ac_dB$ac_dC"'\2'"$ac_dD"'/p
+  ' >>conftest.defines
+
+# Remove the space that was appended to ease matching.
+# Then replace #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+# (The regexp can be short, since the line contains either #define or #undef.)
+echo 's/ $//
+s,^[	 #]*u.*,/* & */,' >>conftest.defines
+
+# Break up conftest.defines:
+ac_max_sed_lines=50
+
+# First sed command is:	 sed -f defines.sed $ac_file_inputs >"$tmp/out1"
+# Second one is:	 sed -f defines.sed "$tmp/out1" >"$tmp/out2"
+# Third one will be:	 sed -f defines.sed "$tmp/out2" >"$tmp/out1"
+# et cetera.
+ac_in='$ac_file_inputs'
+ac_out='"$tmp/out1"'
+ac_nxt='"$tmp/out2"'
+
+while :
+do
+  # Write a here document:
+    cat >>$CONFIG_STATUS <<_ACEOF
+    # First, check the format of the line:
+    cat >"\$tmp/defines.sed" <<\\CEOF
+/^[	 ]*#[	 ]*undef[	 ][	 ]*$ac_word_re[	 ]*\$/b def
+/^[	 ]*#[	 ]*define[	 ][	 ]*$ac_word_re[(	 ]/b def
+b
+:def
+_ACEOF
+  sed ${ac_max_sed_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+    sed -f "$tmp/defines.sed"' "$ac_in >$ac_out" >>$CONFIG_STATUS
+  ac_in=$ac_out; ac_out=$ac_nxt; ac_nxt=$ac_in
+  sed 1,${ac_max_sed_lines}d conftest.defines >conftest.tail
+  grep . conftest.tail >/dev/null || break
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines conftest.tail
+
+echo "ac_result=$ac_in" >>$CONFIG_STATUS
+cat >>$CONFIG_STATUS <<\_ACEOF
+  if test x"$ac_file" != x-; then
+    echo "/* $configure_input  */" >"$tmp/config.h"
+    cat "$ac_result" >>"$tmp/config.h"
+    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f $ac_file
+      mv "$tmp/config.h" $ac_file
+    fi
+  else
+    echo "/* $configure_input  */"
+    cat "$ac_result"
+  fi
+  rm -f "$tmp/out12"
+# Compute $ac_file's index in $config_headers.
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $ac_file | $ac_file:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $ac_file" >`$as_dirname -- $ac_file ||
+$as_expr X$ac_file : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X$ac_file : 'X\(//\)[^/]' \| \
+	 X$ac_file : 'X\(//\)$' \| \
+	 X$ac_file : 'X\(/\)' \| . 2>/dev/null ||
+echo X$ac_file |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
+
+  :C)  { echo "$as_me:$LINENO: executing $ac_file commands" >&5
+echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    { as_dir=$dirpart/$fdir
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+ ;;
+
+  esac
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
--- /dev/null
+++ b/convert/configure.ac
@@ -0,0 +1,38 @@
+dnl Process this file with autoconf to produce a configure script.
+
+AC_INIT(convert, 3.0.4)
+AC_CANONICAL_TARGET
+AM_INIT_AUTOMAKE
+AC_PREREQ(2.59)
+AC_CONFIG_SRCDIR(convert.c)
+
+AC_PROG_CC
+AC_PROG_INSTALL
+
+AC_ISC_POSIX
+
+AC_HEADER_STDC
+AC_CONFIG_HEADERS([config.h])
+AC_CHECK_HEADERS(stddef.h stdlib.h strings.h unistd.h limits.h)
+AC_CHECK_HEADERS(fcntl.h sys/file.h)
+
+AC_C_CONST
+AC_TYPE_SIZE_T
+
+AC_CHECK_FUNCS(strchr strtok memcpy)
+AC_FUNC_ALLOCA
+
+CONV_BINARY_FOPEN
+
+CONV_NEED_DECLARATION(malloc)
+CONV_NEED_DECLARATION(realloc)
+CONV_NEED_DECLARATION(free)
+CONV_NEED_DECLARATION(strtok)
+
+ACX_PKGVERSION([MIPS Convert])
+ACX_BUGURL([http://support.codesourcery.com/])
+
+AM_MAINTAINER_MODE
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
--- /dev/null
+++ b/convert/conv.1
@@ -0,0 +1,178 @@
+.TH conv 1 "29 Jul 2003" "MIPS SDE" "Programmer's Manual"
+.de BP
+.sp
+.ti -.2i
+\(**
+..
+.SH NAME
+conv \- ELF object file converter
+.SH SYNOPSIS
+.B conv
+.RB [ \-lvypr ]
+.RB [ "\-a \fIaddr" [ /\fIsize ]]
+.RB [ "\-a \fIaddr" [ :\fIlimit ]]
+.RB [ "\-R \fIoffs" ]
+.RB [ "\-f \fIfmt" ]
+.RB [ "\-i \fIoffs" ]
+.RB [ "\-w \fIwidth" ]
+.RB [ "\-b \fIbyte,..." ]
+.br
+.RB [ "\-s \fIsize" ]
+.RB [ "\-x \fIseg,..." ]
+.RB [ "\-o \fIofile" ]
+.RI [ ifile ]
+.SH DESCRIPTION
+The
+.I conv
+command takes ELF executable
+.I ifile
+and converts it into an ASCII or encoded binary format, suitable for
+downloading onto a PROM programmer or evaluation board.  It can take
+horizontal and/or vertical slices through the file, to cater for PROM
+programmers that do not have this facility or memory capacity.
+.SH OPTIONS
+.TP 10
+.B \-l
+Lists the segments in the ELF file's program header, for possible use
+in the
+.B \-x
+option below; does not produce any other output.
+.TP 10
+.B \-v
+Selects verbose mode, which makes the program report its actions as it
+converts the file.
+.TP 10
+.B \-p
+Selects PROM mode: output addresses start at zero; the read-only
+segments are converted first and the other segments are concatenated
+to them (aligned to 16 byte boundaries).  If this option is not given,
+then the segments are converted in program header order, and the
+output addresses are the data's actual virtual addresses.
+.TP 10
+.B \-y
+Requests symbol output: for formats which support this the file's
+symbol table is also converted and sent to the output file.
+.TP 10
+.B \-a \fIaddr\fR[/\fIsize\fR]
+.TP 10
+.B \-a \fIaddr\fR[:\fIlimit\fR]
+Specifies the physical address range of the PROM, for use with the
+.B \-p
+option.  All input data located between \fIaddr\fP and \fIlimit\fP
+(i.e.  between \fIaddr\fP and \fIaddr\fP+\fIsize\fP) are deemed to be
+intended for PROM execution, and are placed at the relevant offset
+from \fIaddr\fP.  Segments outside of this address range are assumed
+to be intended for relocation to RAM, and are concatenated to the end
+of the last read-only segment.  The default value for \fIaddr\fP is
+0x1fc00000, and the default \fIsize\fP is 0x400000 (i.e. 4Mb).
+.TP 10
+.B \-r
+Selects raw binary input mode, which ignores any ELF headers and
+converts the whole input file into the output format, starting at the
+selected PROM base address.
+.TP 10
+.B \-R \fIoffs\fR
+Selects raw binary input mode as above, but places the input
+at offset \fIoffs\fP from the PROM base address.
+.TP 10
+.B \-f \fIfmt\fP
+Selects the output format, from the list below.  If not specified then
+the environment variable
+.B DLTYPE
+is used.  The default if neither of these are specified is
+.BR srec .
+.RS
+.TP 10
+.B srec, s3
+Motorola S-records, using S3 and S7 (32-bit address) records; symbol
+output can be provided via S4 records, as supported by LSI PMON.
+.TP 10
+.B s2
+Same as above, except using S2 and S8 (24-bit address) records, to
+suit some PROM programmers.
+.TP 10
+.B s1
+Same as above, except using S1 and S9 (16-bit address) records.
+.TP 10
+.B lsi
+High density (radix 64) ASCII encoding for downloading by the
+.I LSI PMON
+monitor; symbol output is supported.
+.TP 10
+.B idt
+Binary S-record format for downloading by the
+.I IDT/sim
+monitor.
+.TP 10
+.B stagbin
+Proprietary binary format for
+.I Stag
+PROM programmers.
+.TP 10
+.B bin
+Raw binary output, suitable for further conversion by another user
+program.
+.RE
+.TP 10
+.BI \-w " width"
+Specifies the width of CPU data bus in bits (default: 32).
+.TP 10
+.BI \-b " byte,..."
+The input file is read in multiples of
+.I width
+bits, and then these bytes are selected from it.  The
+default is
+.RB `` 0,1,2,3 '',
+which sends all bytes in their file order.  To
+perform a byte swap specify
+.RB `` 3,2,1,0 ''.
+To program four PROMs with
+consecutive bytes, run
+.I convert
+four times with
+.RB `` \-b0 '',
+.RB `` \-b1 '',
+.RB `` \-b2 ''
+and
+.RB `` \-b3 ''.
+.IP
+To handle interleaved PROMs, multiply the PROM width by the interleave,
+(e.g.
+.RB `` \-w64 ''
+for two-way interleave on a 32-bit bus), and then run
+.I conv
+interleave \(mu byte-width times
+(e.g.
+.RB `` \-b0 ''
+to
+.RB `` \-b7 '').
+.br
+.ne 4
+.TP 10
+.BI \-i " offs"
+.TP 10
+.BI \-s " size"
+Specified together to split a large program into multiple PROMs.  The
+.B \-i
+flag specifies the initial offset, and
+.B \-s
+the size of the PROM.  For example for two 128K proms:
+.nf
+.in +5
+conv -f s3 -i 0x00000 -s 0x20000 -o prom.s31 prom
+conv -f s3 -i 0x20000 -s 0x20000 -o prom.s32 prom
+.in 0
+.fi
+.TP 10
+.BI \-x " seg,..."
+Exclude the following segments from the output; the segment numbers
+can be determined using the
+.B \-l
+option above.
+.TP 10
+.BI "\-o " oname
+Selects
+.I oname
+as the output file, default is standard output.
+.SH SEE ALSO
+edown(1)
--- /dev/null
+++ b/convert/conv.texi
@@ -0,0 +1,232 @@
+\input texinfo       @c                    -*- Texinfo -*-
+@c  Copyright 1993-2003,2008
+@c  Free Software Foundation, Inc.
+@c  Contributed by MIPS Technologies, Inc.
+@setfilename conv.info
+
+@ifinfo
+@format
+START-INFO-DIR-ENTRY
+* Convert: (conv). 	The MIPS SDE tool "sde-conv"
+END-INFO-DIR-ENTRY
+@end format
+@end ifinfo
+
+@ifinfo
+Copyright @copyright{} 1998-2003 MIPS Technologies, Inc. All Rights Reserved.
+@end ifinfo
+
+@synindex ky cp
+@c
+@c This file documents the MIPS ELF converter
+@c
+@c Copyright (C) 1998-2003 MIPS Technologies, Inc.  All Rights Reserved.
+@c
+@c
+
+@setchapternewpage odd
+@settitle MIPS SDE ELF Conversion Tool
+@titlepage
+@finalout
+@title MIPS SDE ELF Conversion Tool
+@subtitle @code{sde-conv}
+@subtitle Version 5.0
+@sp 1
+@subtitle October 2003
+@author MIPS Technologies Inc
+@page
+
+@tex
+\def\$#1${{#1}} % Kluge: collect RCS revision info without $...$
+\xdef\manvers{\$Revision$} % For use in headers, footers too
+{\parskip=0pt \hfill MIPS Technologies Inc\par \hfill \manvers\par \hfill
+\TeX{}info \texinfoversion\par }
+@end tex
+
+@vskip 0pt plus 1filll
+Copyright @copyright{} 1998-2003 MIPS Technologies, Inc.  All Rights Reserved.
+
+@end titlepage
+
+@node Top, (dir), (dir), (dir)
+@chapter conv
+
+@kindex conv
+@kindex sde-conv
+@cindex convert ELF files
+
+@smallexample
+sde-conv [ -l ] [ -v ] [ -y ] [ -p ] [ -r ]
+         [ -a @var{addr}[/@var{size}] ]
+         [ -a @var{addr}[:@var{limit}] ]
+         [ -f @var{fmt} ] [ -R @var{offs} ]
+         [ -w @var{width} ] [ -b @var{byte},... ]
+         [ -i @var{offs} ] [ -s @var{size} ]
+         [ -x @var{seg},... ] [ -o @var{ofile} ] @var{ifile}
+@end smallexample
+
+The @code{sde-conv} utility takes ELF executable @var{ifile}
+and converts it into an ASCII or encoded binary format, suitable for
+downloading onto a PROM programmer or evaluation board.  It can take
+horizontal and/or vertical slices through the file, to cater for PROM
+programmers that do not have this facility or memory capacity.
+
+@table @code
+
+@item -o @var{ofile}
+Selects @var{ofile}
+as the output file, the default is the standard output.  Note: you must
+use this for the binary output format.
+
+@cindex list program segments
+@item -l
+Lists the segments in the ELF file's program header, for possible use
+in the @code{-x} option below; does not produce any other output.
+
+@item -v
+Selects verbose mode, which makes the program report its actions as it
+converts the file.
+
+@cindex output symbol data
+@item -y
+Requests symbol output: for formats which support this the file's
+symbol table is also converted and sent to the output file.
+
+@cindex specify PROM address
+@item -a @var{addr}
+@itemx -a @var{addr}:@var{limit}
+@itemx -a @var{addr}/@var{size}
+Selects PROM output mode and specifies the physical address range of the
+PROM.  All input data located between @var{addr} and @var{limit} (or
+between @var{addr} and @var{addr}+@var{size}) are deemed to be
+PROM-resident, and are mapped to their relative offset from @var{addr}.
+Segments outside of this address range are assumed to be intended for
+relocation to RAM, and they are concatenated to the end of the last
+PROM-resident segment (rounded to the next 16 byte boundary).  The
+default value for @var{addr} is @code{1fc00000}, and the default
+@var{size} is @code{400000} (i.e. 4Mb).
+
+Note that if the code segment has a load address that doesn't fall
+inside the ROM then it will get treated like an initialised data
+segment.  It will get mapped to the start of the ROM (the reset
+exception address) if it was linked with the lowest address, and then
+your reset code can be carefully written to copy the code segment
+from ROM to RAM.
+
+@cindex create PROM image
+@item -p
+Selects PROM output mode, equivalent to @samp{-a@ 1fc00000/400000}.
+
+@cindex raw binary input
+@item -r
+Selects raw binary input mode, which ignores any ELF headers and
+converts the whole input file into the output format, starting at the
+selected PROM base address.
+
+@item -R @var{offs}
+Selects raw binary input mode as above, but places the input
+at offset @var{offs} from the PROM base address.
+
+@cindex output file format
+@item -f @var{fmt}
+Selects the output format, from the list below.  If not specified then
+the environment variable @code{DLTYPE}
+is used.  The default if neither of these are specified is
+@code{srec}.
+
+@table @code
+@cindex Motorola
+@cindex S-records
+@item srec
+@itemx s3
+Motorola S-records, using S3 and S7 (32-bit address) records. Symbol
+output is provided via S4 records, as supported by LSI PMON, if the
+@code{-y} option is also used.
+
+@item s2
+Same as above, except using S2 and S8 (24-bit address) records, to
+suit some PROM programmers.
+
+@item s1
+Same as above, except using S1 and S9 (16-bit address) records.
+
+@cindex LSI PMON format
+@item lsi
+High density (radix 64) ASCII encoding for downloading by the
+@samp{LSI PMON}
+monitor; symbol output is supported with the @code{-y} option.
+
+@cindex IDT/sim binary format
+@item idt
+Binary S-record format for downloading by the @samp{IDT/sim} monitor.
+
+@cindex Stag binary format
+@item stagbin
+@itemx sbin
+Proprietary binary format for @samp{Stag} PROM programmers.
+
+@cindex MIPS flash format
+@cindex fl
+@item fl
+MIPS flash file format, suitable for downloading to a Malta
+or SEAD-2 board.
+
+@cindex raw binary output
+@item bin
+Raw binary output, suitable for further conversion by another user
+program.
+
+@cindex relocated ELF
+@cindex relf
+@item relf
+Relocated ELF executable object file output, with the code and data
+relocated to their new addresses in ROM, as selected by the @samp{-p} or
+@samp{-a} options. This can be used to generate a ROM image which can be
+loaded by gdb's MDI interface. Note that symbols and other debug
+information are not copied to the new file, and the file's entrypoint
+address is set to the base ROM address.
+@end table
+
+@cindex PROM width
+@item -w @var{width}
+Specifies the width of CPU data bus in bits (default: 32).
+
+@cindex byte select
+@cindex interleaved PROMS
+@item -b @var{byte},...
+The input file is read in multiples of @var{width} bits, and then these
+bytes are selected from it.  The default is @samp{0,1,2,3}, which sends
+all bytes in their file order.  To perform a byte swap specify
+@samp{3,2,1,0}.  To program four PROMs with consecutive bytes, run
+@code{conv} four times with @samp{-b0}, @samp{-b1}, @samp{-b2} and
+@samp{-b3}.
+
+To handle interleaved PROMs, multiply the PROM width by the interleave,
+(e.g. @samp{-w64} for two-way interleave on a 32-bit bus), and then run
+@code{conv} interleave times byte-width times
+(e.g. @samp{-b0} to @samp{-b7}).
+
+@cindex split into multiple PROMS
+@item -i @var{offs}
+@itemx -s @var{size}
+Specified together to split a large program into multiple PROMs.  The
+@code{-i}
+flag specifies the initial offset, and
+@code{-s}
+the size of the PROM.  For example for two 128K proms:
+
+@quotation
+@smallexample
+conv -f s3 -i 0x00000 -s 0x20000 -o prom.s3.1 prom
+conv -f s3 -i 0x20000 -s 0x20000 -o prom.s3.2 prom
+@end smallexample
+@end quotation
+
+@cindex select program segments
+@item -x @var{seg},...
+Exclude the following segments from the output; the segment numbers
+can be determined using the @code{-l} option described above.
+
+@end table
+
+@bye
--- /dev/null
+++ b/convert/convert.c
@@ -0,0 +1,717 @@
+/* convert.c -- ELF to hex (etc) file converter
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "elfmips.h"
+#include "conv-version.h"
+
+#include <sys/stat.h>
+
+#include <getopt.h>
+
+struct format {
+    const char	*name;
+    int		binary;
+    void	(*start) (FILE *, unsigned long, int);
+    void	(*output) (unsigned long, unsigned char);
+    void	(*sym) (char *, unsigned long);
+    void	(*end) (unsigned long);
+    const char	*desc;
+};
+
+extern void Srec3Start (FILE *, unsigned long, int);
+extern void Srec2Start (FILE *, unsigned long, int);
+extern void Srec1Start (FILE *, unsigned long, int);
+extern void SrecOutput (unsigned long, unsigned char);
+extern void SrecSym (char *, unsigned long);
+extern void SrecEnd (unsigned long);
+
+extern void LsiStart (FILE *, unsigned long, int);
+extern void LsiOutput (unsigned long, unsigned char);
+extern void LsiSym (char *, unsigned long);
+extern void LsiEnd (unsigned long);
+
+extern void StagStart (FILE *, unsigned long, int);
+extern void StagOutput (unsigned long, unsigned char);
+extern void StagEnd (unsigned long);
+
+extern void BinStart (FILE *, unsigned long, int);
+extern void BinOutput (unsigned long, unsigned char);
+extern void BinEnd (unsigned long);
+
+extern void IdtStart (FILE *, unsigned long, int);
+extern void IdtOutput (unsigned long, unsigned char);
+extern void IdtEnd (unsigned long);
+
+extern void ElfStart (FILE *, unsigned long, int);
+extern void ElfOutput (unsigned long, unsigned char);
+extern void ElfEnd (unsigned long);
+
+extern void MipsStart (FILE *, unsigned long, int);
+extern void MipsOutput (unsigned long, unsigned char);
+extern void MipsEnd (unsigned long);
+
+static const struct format formats[] = {
+    {"srec",	0,	Srec3Start, SrecOutput, SrecSym, SrecEnd,
+     "Motorola S-record (32-bit address)"},
+    {"s3",	0,	Srec3Start, SrecOutput, SrecSym, SrecEnd,
+     "Motorola S-record (32-bit address)"},
+    {"s2",	0,	Srec2Start, SrecOutput, SrecSym, SrecEnd,
+     "Motorola S-record (24-bit address)"},
+    {"s1",	0,	Srec1Start, SrecOutput, SrecSym, SrecEnd,
+     "Motorola S-record (16-bit address)"},
+    {"lsi",	0,	LsiStart, LsiOutput, LsiSym, LsiEnd,
+     "LSI fast download (PMON)"},
+    {"fl",	0,	MipsStart, MipsOutput, 0, MipsEnd,
+     "MIPS flash download"},
+    {"idt",	1,	IdtStart, IdtOutput, 0, IdtEnd,
+     "IDT/sim binary S-record"},
+    {"sbin",	1,	StagStart, StagOutput, 0, StagEnd,
+     "Stag PROM programmer"},
+    {"bin",	1,	BinStart, BinOutput, 0, BinEnd,
+     "Raw binary"},
+    {"relf",	1,	ElfStart, ElfOutput, 0, ElfEnd,
+     "Relocated ELF"},
+    {0}
+};
+
+
+char *		progname;
+int		promflag = 0;
+static int 	symflag = 0;
+static int 	listflag = 0;
+static int	verbose = 0;
+
+#define MAXALIGN	16	/* align segments to 16 byte boundaries */
+
+#define MAXSEGS		20
+static unsigned	segomit[MAXSEGS];
+static unsigned	omitseg[MAXSEGS];
+static unsigned	nomit;
+
+#define MAXWIDTH	8
+static unsigned	bytelist[MAXWIDTH];
+static unsigned	nbytes;
+static unsigned	width = 4;		/* in bytes */
+
+typedef unsigned long msize_t;
+       msize_t	prombase  = 0x1fc00000;
+static msize_t	promlimit = 0;
+static msize_t	promstart;
+static msize_t	promend;
+
+static void
+usage (int error)
+{
+    const struct format *fmt;
+    FILE* to = error ? stderr : stdout;
+
+    fprintf(to,
+"usage: %s [-lvypr] [-f fmt] [-w width] [-b byte,...] [-i offs] [-s size]\n"
+"                [-R offs] [-x seg,...] [-a addr] [-o file] [file]\n"
+"	-l		list segments only, no conversion\n"
+"	-v		verbose conversion option\n"
+"	-y		include symbols\n"
+"	-p		prom mode (start addresses at zero)\n"
+"	-a addr[:lim]	address of prom (default: 1fc00000:20000000)\n"
+"	-a addr[/size]	address of prom (default: 1fc00000/400000)\n"
+"	-r		raw binary input (not ELF)\n"
+"	-R offs		raw binary, start addresses at offs (default: 0)\n"
+"	-EB | -EL	set big or little endianness\n"
+"	-f fmt		output format (default: srec)\n"
+"	-w width	data width in bits (default: 32)\n"
+"	-b byte,...	select bytes (default: 0,1,2,3)\n"
+"	-i offs		initial input offset (default: 0)\n"
+"	-s size		prom size (default: infinite)\n"
+"	-x seg,...	exclude segments (default: none)\n"
+	    , progname);
+
+    fprintf (to, "\nOutput formats (-f):\n");
+    for (fmt = formats; fmt->name; fmt++)
+      fprintf (to, "  %s\t%s\n", fmt->name, fmt->desc ? fmt->desc : "");
+
+    fprintf (to, "\nReport bugs to " CONVERT_REPORT_BUGS_TO ".\n");
+
+    exit(error);
+}
+
+
+static int
+parselist (char *arg, unsigned *list, int lsize)
+{
+    char *s, *ep;
+    int n = 0;
+
+    for (s = strtok (arg, ","); s; s = strtok (0, ",")) {
+	if (n >= lsize) {
+	    fprintf (stderr, "%s: too many items in list\n", progname);
+	    usage (1);
+	}
+	list[n++] = strtol (s, &ep, 0);
+	if (*ep) {
+	    fprintf (stderr, "%s: bad number in list: %s\n", progname, s);
+	    usage (1);
+	}
+    }
+    return n;
+}
+
+static char *
+phtype (Elf32_Phdr *ph)
+{
+    static char buf[11];
+
+    switch (ph->p_type) {
+    case PT_NULL:
+ 	return "NULL    ";
+    case PT_LOAD:
+ 	return "LOAD    ";
+    case PT_DYNAMIC:
+	return "DYNAMIC ";
+    case PT_INTERP:
+ 	return "INTERP  ";
+    case PT_NOTE:
+	return "NOTE    ";
+    case PT_SHLIB:
+	return "SHLIB   ";
+    case PT_PHDR:
+	return "PHDR    ";
+    case PT_MIPS_REGINFO:
+	return "REGINFO ";
+    default:
+	sprintf (buf, "%08x", ph->p_type);
+	return buf;
+   }
+}
+
+
+static char *
+phflags (Elf32_Phdr *ph)
+{
+    static char buf[4];
+    buf[0] = (ph->p_flags & PF_R) ? 'r' : '-';
+    buf[1] = (ph->p_flags & PF_W) ? 'w' : '-';
+    buf[2] = (ph->p_flags & PF_X) ? 'x' : '-';
+    buf[3] = '\0';
+    return buf;
+}
+
+
+static void
+convertSegment (FILE *ifp, const struct format *fmt, Elf32_Phdr *ph)
+{
+    unsigned char buf[MAXWIDTH];
+    static msize_t req_top = 0, offs_top = 0;
+    static unsigned int last_flags = 0;
+    msize_t req, offset;
+    unsigned long skip = 0;
+    long n;
+
+    /* get requested physical address */
+    req = (ph->p_paddr ? ph->p_paddr : ph->p_vaddr);
+    if (promflag) {
+	offset = req & 0x1fffffff;
+	if (offset < prombase || offset >= promlimit) {
+	    /* not a valid prom address: force to rom */
+	    if (offs_top == 0) {
+		/* force to start, whatever it says in the file */
+		offset = prombase;
+	    }
+	    else {
+		unsigned long align = ph->p_align ? ph->p_align - 1 : 0;
+		if (req == ((req_top + align) & ~align)
+		    && ((ph->p_flags ^ last_flags) & PF_W) == 0) {
+		  /* segment is contiguous and of same read/write type,
+		     then keep its relative offset the same */
+		  offset = offs_top + (req - req_top);
+		}
+		else {
+		  /* segment is not contiguous, or a different type,
+		     put at next MAXALIGN boundary. */
+		  align = MAXALIGN - 1;
+		  offset = (offs_top + align) & ~align;
+		}
+	    }
+	}
+    }
+    else {
+	/* not a prom: preserve load address */
+	offset = req;
+    }
+
+    req_top = req + ph->p_memsz;
+    offs_top = offset + ph->p_memsz;
+    last_flags = ph->p_flags;
+
+    if (promflag) {
+	/* convert to offset from start of PROM */
+	offset -= prombase;
+	/* skip as many bytes as necessary to reach requested start */
+	if (offset < promstart) {
+	    skip = (promstart - offset) * (width / nbytes);
+	    if (skip >= ph->p_filesz)
+		skip = ph->p_filesz;
+	    offset += ((skip + width - 1) / width) * nbytes;
+	}
+    }
+
+    if (skip < ph->p_filesz) {
+	fseek (ifp, ph->p_offset + skip, SEEK_SET);
+	n = ph->p_filesz - skip;
+
+	/* convert to offset and size in prom */
+	offset /= (width / nbytes);
+	n = (n + (width / nbytes) - 1) / (width / nbytes);
+
+	if (verbose) {
+	  int i, j;
+	  fprintf (stderr, "%s segment %08x:%08x -> %s %05x:%05x [",
+		  phflags (ph), req, req + n,
+		  fmt->name, offset, offset + n);
+	  for (i = 0; i < width; i++) {
+	    for (j = 0; j < nbytes; j++)
+	      if (bytelist[j] == i)
+		break;
+	    if (j < nbytes)
+	      fprintf (stderr, "%x", j);
+	    else
+	      fprintf (stderr, "-");
+	  }
+	  fprintf (stderr, "]\n");
+	}
+
+	while (n > 0 && offset < promend) {
+	    int nr, i;
+	    if ((nr = fread (buf, 1, width, ifp)) <= 0) {
+		fprintf (stderr, "%s: bad file read\n", progname);
+		exit (1);
+	    }
+	    for (i = 0; i < nbytes; i++) {
+		int bn = bytelist[i];
+		if (bn < nr)
+		  (*fmt->output) (offset++, buf[bn]);
+	    }
+	    n -= nbytes;
+	}
+    }
+}
+
+static void
+convertSymbols (FILE *ifp, Elf32_Ehdr *eh, const struct format *fmt)
+{
+    Elf32_Shdr *shtab, *sh;
+    char *strtab;
+    int i;
+
+    shtab = (Elf32_Shdr *) xmalloc (eh->e_shnum * sizeof(Elf32_Shdr));
+
+    fseek (ifp, eh->e_shoff, SEEK_SET);
+    if (elfShdrRead (ifp, eh, shtab, eh->e_shnum) != eh->e_shnum) {
+	fprintf (stderr,"%s: failed to read section headers\n", progname);
+	exit (1);
+    }
+
+    for (i = 0; i < eh->e_shnum; i++)
+      if (shtab[i].sh_type == SHT_SYMTAB)
+	break;
+    if (i >= eh->e_shnum) {
+	free (shtab);
+	return;
+    }
+
+    /* get string table */
+    sh = &shtab[shtab[i].sh_link];
+    strtab = (char *) xmalloc (sh->sh_size);
+    fseek (ifp, sh->sh_offset, SEEK_SET);
+    if (fread (strtab, 1, sh->sh_size, ifp) != sh->sh_size) {
+	fprintf (stderr, "%s: cannot read string table\n", progname);
+	exit (1);
+    }
+
+    /* scan symbol table */
+    sh = &shtab[i];
+    fseek (ifp, sh->sh_offset, SEEK_SET);
+    for (i = sh->sh_size / sh->sh_entsize; i != 0; i--) {
+	Elf32_Sym sym;
+	int type;
+
+	if (elfSymRead (ifp, eh, sh, &sym, 1) != 1) {
+	    fprintf (stderr, "%s: cannot read symbol table\n", progname);
+	    exit (1);
+	}
+	switch (sym.st_shndx) {
+	case SHN_UNDEF:
+	case SHN_COMMON:
+	    continue;
+	}
+
+	type = ELF32_ST_TYPE (sym.st_info);
+	switch (type) {
+	case STT_SECTION:
+	case STT_FILE:
+	    continue;
+	}
+
+	/* only emit globals and functions */
+	if (ELF32_ST_BIND (sym.st_info) != STB_GLOBAL && type != STT_FUNC)
+	  continue;
+
+	if (sym.st_other == 0xf0)
+	    sym.st_value |= 1;
+
+	(*fmt->sym) (strtab + sym.st_name, sym.st_value);
+    }
+
+    free (strtab);
+    free (shtab);
+}
+
+
+/* comparison function for qsort() */
+int
+phcompar (const void *a, const void *b)
+{
+  const Elf32_Phdr *pha = a;
+  const Elf32_Phdr *phb = b;
+  unsigned long addra = pha->p_paddr ? pha->p_paddr : pha->p_vaddr;
+  unsigned long addrb = phb->p_paddr ? phb->p_paddr : phb->p_vaddr;
+  return (addra == addrb) ? 0
+    : (addra < addrb) ? -1
+    : 1;
+}
+
+
+
+#ifndef HAVE_STRTOUL
+extern unsigned long int strtoul (const char *, char **, int);
+#endif
+
+static const struct option long_opts[] =
+{
+    { "version", no_argument, NULL, 'V' },
+    { "help", no_argument, NULL, 'h' },
+    { 0, 0, NULL, 0 }
+};
+
+int
+main(int argc, char **argv)
+{
+    extern char *getenv ();
+    FILE *ifp, *ofp, *cfp;
+    Elf32_Ehdr ehdr;
+    Elf32_Phdr *phtab, *ph;
+    const struct format *fmt = 0;
+    char *infile = "a.out";
+    char *outfile = 0;
+    char *fmtname;
+    char *s;
+    extern char *optarg;
+    extern int optind;
+    msize_t size = 0;
+    int rawflag = 0;
+    msize_t rawoffs = 0;
+    int i, c;
+    int bigendian = 0;
+
+    progname = argv[0];
+    if ((s = strrchr(progname, '/')) || (s = strrchr(progname, '\\')) ||
+	(s = strrchr(progname, ':')))
+      progname = s + 1;
+
+    fmtname = getenv ("DLTYPE");
+    while ((c = getopt_long(argc,argv,"prR:vylf:x:b:s:i:w:o:t:a:E:",
+			    &long_opts[0], NULL)) != EOF)
+      switch(c) {
+      case 'p':
+	  promflag = 1;
+	  break;
+      case 'r':
+	  rawflag = 1;
+	  break;
+      case 'R':
+	  rawflag = 1;
+	  rawoffs = strtoul (optarg, &s, 16);
+	  if (*s)
+	    usage (1);
+	  break;
+      case 'v':
+	  verbose = 1;
+	  break;
+      case 'y':
+	  symflag = 1;
+	  break;
+      case 'l':
+	  listflag = 1;
+	  break;
+      case 'f':
+	  fmtname = optarg;
+	  break;
+      case 'b':
+	  nbytes = parselist (optarg, bytelist, MAXWIDTH);
+	  break;
+      case 'x':
+	  nomit = parselist (optarg, segomit, MAXSEGS);
+	  break;
+      case 'i':
+	  promstart = strtoul (optarg, &s, 0);
+	  if (*s)
+	    usage (1);
+	  break;
+      case 's':
+	  size = strtoul (optarg, &s, 0);
+	  if (*s)
+	    usage (1);
+	  break;
+      case 'a':
+	  promflag = 1;
+	  prombase = strtoul (optarg, &s, 16) & 0x1fffffff;
+	  if (*s == '/' || *s == '#') {
+	    promlimit = strtoul (++s, &s, 16) + prombase;
+	  }
+	  else if (*s == ':' || *s == '-') {
+	    promlimit = strtoul (++s, &s, 16) & 0x1fffffff;
+	    if (promlimit && (promlimit <= prombase)) {
+		fprintf (stderr, "%s: ROM limit below ROM base\n", progname);
+		usage (1);
+	    }
+	  }
+	  if (*s)
+	    usage (1);
+	  break;
+      case 'w':
+	  width = strtoul (optarg, &s, 0);
+	  if (*s || width % 8 != 0)
+	    usage (1);
+	  width /= 8;
+	  break;
+      case 'o':
+	  outfile = optarg;
+	  break;
+      case 't':
+	  fprintf (stderr, "%s: -t flag deprecated and ignored\n", progname);
+	  break;
+      case 'E':
+	  if (optarg[0] == 'B' && optarg[1] == '\0')
+	      bigendian = 1;
+	  else if (optarg[0] == 'L' && optarg[1] == '\0')
+	      bigendian = 0;
+	  else {
+	      fprintf (stderr, "%s: -E%s flag not recognised\n", progname,
+		       optarg);
+	      usage (1);
+	  }
+	  break;
+      case 'h':
+	  usage (0);
+	  break;
+      case 'V':
+          printf ("MIPS convert " CONVERT_PKGVERSION "\n");
+	  return 0;
+      default:
+	  usage (1);
+      }
+
+    if(optind < argc) {
+	infile = argv[optind++];
+	if (optind < argc)
+	  usage (1);
+    }
+
+    if ((size || promstart) && !promflag) {
+	fprintf (stderr, "%s: -s or -i specified without -p\n", progname);
+	usage (1);
+    }
+
+    if (width == 0 || width > MAXWIDTH) {
+	fprintf (stderr, "%s: bad width\n", progname);
+	usage (1);
+    }
+
+    if (nbytes == 0) {
+	for (i = 0; i < width; i++)
+	  bytelist[i] = i;
+	nbytes = width;
+    } else {
+	if (nbytes != (nbytes & -nbytes)) {
+	    fprintf (stderr, "%s: number of selected bytes not power of two\n",
+		     progname);
+	    usage (1);
+	}
+	if (nbytes > width) {
+	    fprintf (stderr, "%s: number of selected bytes > data width\n",
+		     progname);
+	    usage (1);
+	}
+	for (i = 0; i < nbytes; i++)
+	  if (bytelist[i] >= width) {
+	      fprintf (stderr, "%s: bad byte select %d (should be 0-%d)\n",
+		       progname, bytelist[i], width-1);
+	      usage (1);
+	  }
+    }
+
+    /* invert seg omit list */
+    for (i = 0; i < nomit; i++) {
+	int o = segomit[i];
+	if (o >= MAXSEGS) {
+	    fprintf (stderr, "%s: bad segment number: %d\n",
+		     progname, o);
+	    usage (1);
+	}
+	omitseg[o] = 1;
+    }
+
+    if (fmtname) {
+	for (fmt = formats; fmt->name; fmt++)
+	  if (strcmp (fmtname, fmt->name) == 0)
+	    break;
+	if (!fmt->name) {
+	    fprintf (stderr, "%s: unknown output format '%s'\n", fmtname,
+		     progname);
+	    usage (1);
+	}
+    } else {
+	fmt = formats;
+    }
+
+    if (size == 0)
+      promend = ULONG_MAX;
+    else
+      promend = promstart + size;
+
+    if (promlimit == 0) {
+      if (size == 0)
+	promlimit = prombase + 0x400000;
+      else
+	promlimit = prombase + size / nbytes * width;
+    }
+
+    if (!(ifp = fopen (infile, FOPEN_RB))) {
+	perror(infile);
+	return 1;
+    }
+
+    if (outfile && strcmp(outfile, "-")) {
+	if (!(ofp = fopen (outfile, fmt->binary ? FOPEN_WB : FOPEN_WT))) {
+	    perror(outfile);
+	    return 1;
+	}
+    }
+    else {
+      ofp = stdout;
+#ifdef MSDOS
+      if (fmt->binary)
+	setmode (fileno (ofp), O_BINARY);
+#endif
+    }
+
+    if (!rawflag) {
+      if (elfEhdrRead (ifp, &ehdr) != 1) {
+	fprintf (stderr,"%s: not an ELF object file: %s\n", progname, infile);
+	return 1;
+      }
+
+      if (ehdr.e_type != ET_EXEC) {
+	fprintf(stderr,"%s: warning: not an executable ELF file: %s\n",
+		progname, infile);
+      }
+
+      bigendian = ehdr.e_ident[5] == ELFDATA2MSB;
+
+      if (ehdr.e_phoff == 0 || ehdr.e_phnum == 0) {
+	fprintf(stderr, "%s: missing ELF program header: %s\n",
+		progname, infile);
+	return 1;
+      }
+
+      if (ehdr.e_phnum > MAXSEGS) {
+	fprintf(stderr, "%s: too many segments in ELF program header: %s\n",
+		progname, infile);
+	return 1;
+      }
+
+      phtab = (Elf32_Phdr *) xmalloc (ehdr.e_phnum * sizeof(Elf32_Phdr));
+
+      fseek (ifp, ehdr.e_phoff, SEEK_SET);
+      if (elfPhdrRead (ifp, &ehdr, phtab, ehdr.e_phnum) != ehdr.e_phnum) {
+	fprintf (stderr,"%s: failed to read program header\n", progname);
+	return 1;
+      }
+    }
+    else {
+      /* fake up the header etc */
+      struct stat stb;
+
+      ehdr.e_phnum = 1;
+      ehdr.e_entry = prombase + rawoffs;
+      ph = phtab = (Elf32_Phdr *) xmalloc (sizeof(Elf32_Phdr));
+      ph->p_type = PT_LOAD;
+      ph->p_flags = PF_R | PF_X;
+      ph->p_vaddr = ph->p_paddr = prombase + rawoffs;
+      fstat (fileno (ifp), &stb);
+      ph->p_filesz = ph->p_memsz = stb.st_size;
+    }
+
+    if (listflag) {
+	printf ("Segment List\n");
+	printf ("Num Type       Vaddr    Paddr  MemSz FSize FOffs Align Flgs\n");
+	for (ph = phtab; ph < &phtab[ehdr.e_phnum]; ph++) {
+	    printf (" %1d  %8s %08x %08x %05x %05x %05x %05x %s%s\n",
+		    ph-phtab, phtype(ph), ph->p_vaddr, ph->p_paddr,
+		    ph->p_memsz, ph->p_filesz, ph->p_offset, ph->p_align,
+		    phflags(ph), omitseg[ph-phtab]?" (omitted)":"");
+	}
+	exit (0);
+    }
+
+    (*fmt->start) (ofp, ehdr.e_entry, bigendian);
+
+    /* sort program header table into physical address order */
+    qsort (phtab, ehdr.e_phnum, sizeof (phtab[0]), phcompar);
+
+    if (promflag) {
+	/* do prom-resident segments first */
+	for (ph = phtab; ph < &phtab[ehdr.e_phnum]; ph++)
+	    if (ph->p_type == PT_LOAD) {
+		unsigned int offset;
+		offset = (ph->p_paddr ? ph->p_paddr : ph->p_vaddr)
+		    & 0x1fffffff;
+		if (offset >= prombase && offset < promlimit
+		    && !omitseg[ph - phtab]) {
+		    convertSegment (ifp, fmt, ph);
+		    ph->p_type = PT_NULL;
+		}
+	    }
+    }
+
+    /* then do all other segments in order */
+    for (ph = phtab; ph < &phtab[ehdr.e_phnum]; ph++)
+      if (ph->p_type == PT_LOAD && ph->p_filesz && !omitseg[ph - phtab])
+	convertSegment (ifp, fmt, ph);
+
+    if (symflag && !rawflag && fmt->sym)
+      convertSymbols (ifp, &ehdr, fmt);
+
+    (*fmt->end) (ehdr.e_entry);
+
+    free (phtab);
+
+    return 0;
+}
--- /dev/null
+++ b/convert/elf.h
@@ -0,0 +1,248 @@
+/* elf.h: ELF data structures and values
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+typedef unsigned char	Elf_Char;
+typedef unsigned short	Elf32_Half;
+typedef unsigned long	Elf32_Word;
+typedef long		Elf32_Sword;
+typedef unsigned long	Elf32_Off;
+typedef unsigned long	Elf32_Addr;
+
+#define EI_NIDENT	16
+
+typedef struct {
+    Elf_Char	e_ident[EI_NIDENT];
+    Elf32_Half	e_type;
+    Elf32_Half	e_machine;
+    Elf32_Word	e_version;
+    Elf32_Addr	e_entry;
+    Elf32_Off	e_phoff;
+    Elf32_Off	e_shoff;
+    Elf32_Word	e_flags;
+    Elf32_Half	e_ehsize;
+    Elf32_Half	e_phentsize;
+    Elf32_Half	e_phnum;
+    Elf32_Half	e_shentsize;
+    Elf32_Half	e_shnum;
+    Elf32_Half	e_shstrndx;
+} Elf32_Ehdr;
+
+typedef struct {
+  Elf32_Word	p_type;			/* Identifies program segment type */
+  Elf32_Off	p_offset;		/* Segment file offset */
+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
+  Elf32_Addr	p_paddr;		/* Segment physical address */
+  Elf32_Word	p_filesz;		/* Segment size in file */
+  Elf32_Word	p_memsz;		/* Segment size in memory */
+  Elf32_Word	p_flags;		/* Segment flags */
+  Elf32_Word	p_align;		/* Segment alignment, file & memory */
+} Elf32_Phdr;
+
+typedef struct {
+    Elf32_Word	sh_name;
+    Elf32_Word	sh_type;
+    Elf32_Word	sh_flags;
+    Elf32_Addr	sh_addr;
+    Elf32_Off	sh_offset;
+    Elf32_Word	sh_size;
+    Elf32_Word	sh_link;
+    Elf32_Word	sh_info;
+    Elf32_Word	sh_addralign;
+    Elf32_Word	sh_entsize;
+} Elf32_Shdr;
+
+typedef struct {
+    Elf32_Word	st_name;
+    Elf32_Addr	st_value;
+    Elf32_Word	st_size;
+    Elf_Char	st_info;
+    Elf_Char	st_other;
+    Elf32_Half	st_shndx;
+} Elf32_Sym;
+
+typedef struct {
+    Elf32_Addr		r_offset;
+    Elf32_Word		r_info;
+    Elf32_Sword		r_addend;
+} Elf32_Rela;
+
+typedef struct {
+    Elf32_Addr		r_offset;
+    Elf32_Word		r_info;
+} Elf32_Rel;
+
+/* these are the external file sizes (should be absolute values) */
+#define ELFEHDRSZ	sizeof(Elf32_Ehdr)
+#define ELFPHDRSZ	sizeof(Elf32_Phdr)
+#define ELFSHDRSZ	sizeof(Elf32_Shdr)
+#define ELFSYMSZ	sizeof(Elf32_Sym)
+#define ELFRELASZ	sizeof(Elf32_Rela)
+#define ELFRELSZ	sizeof(Elf32_Rel)
+
+size_t elfEhdrRead(FILE *,Elf32_Ehdr *);
+size_t elfEhdrWrite(FILE *,const Elf32_Ehdr *);
+
+size_t elfPhdrRead(FILE *, const Elf32_Ehdr *, Elf32_Phdr *, size_t);
+size_t elfPhdrWrite(FILE *, const Elf32_Ehdr *, const Elf32_Phdr *, size_t);
+
+size_t elfShdrRead(FILE *,const Elf32_Ehdr *, Elf32_Shdr *,size_t);
+size_t elfShdrWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,size_t);
+
+size_t elfSymRead(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		  Elf32_Sym *,size_t);
+size_t elfSymWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		   const Elf32_Sym *,size_t);
+
+size_t elfRelaWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		   const Elf32_Rela *,size_t);
+size_t elfRelWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		   const Elf32_Rel *,size_t);
+
+
+/* ELF header */
+
+/* e_ident[] fields */
+#define EI_MAG0		0		/* id byte 0 index */
+#define ELFMAG0		0x7F		/* id byte 0 value */
+
+#define EI_MAG1		1		/* id byte 1 index */
+#define ELFMAG1		'E'		/* id byte 1 value */
+
+#define EI_MAG2		2		/* id byte 2 index */
+#define ELFMAG2		'L'		/* id byte 3 value */
+
+#define EI_MAG3		3		/* id byte 3 index */
+#define ELFMAG3		'F'		/* id byte 3 value */
+
+#define EI_CLASS	4		/* file class */
+#define ELFCLASSNONE	0		/* invalid */
+#define ELFCLASS32	1		/* 32-bit */
+#define ELFCLASS64	2		/* 64-bit */
+
+#define EI_DATA		5		/* data encoding */
+#define ELFDATANONE	0		/* invalid */
+#define ELFDATA2LSB	1		/* little endian */
+#define ELFDATA2MSB	2		/* big endian */
+
+#define EI_VERSION	6		/* file format version */
+
+#define EI_PAD		7		/* start of padding */
+
+
+/* e_type values */
+#define ET_NONE		0		/* no file type */
+#define ET_REL		1		/* relocatable  */
+#define ET_EXEC		2		/* executable */
+#define ET_DYN		3		/* shared object */
+#define ET_CORE		4		/* core file */
+#define ET_LOPROC	0xFF00		/* processor-specific (lo) */
+#define ET_HIPROC	0xFFFF		/* processor-specific (hi) */
+
+/* e_machine values */
+#define EM_NONE		0		/* undefined machine */
+#define EM_M32		1		/* AT&T WE 32100 */
+#define EM_SPARC	2		/* SUN SPARC */
+#define EM_386		3		/* Intel 80386 */
+#define EM_68K		4		/* Motorola M68K family */
+#define EM_88K		5		/* Motorola M88K family */
+#define EM_860		7		/* Intel 80860 */
+#define EM_MIPS		8		/* MIPS Rx000 */
+
+/* e_version values */
+#define EV_NONE		0		/* invalid */
+#define EV_CURRENT	1		/* current version */
+
+/* Program header */
+
+/* p_type field */
+#define	PT_NULL		0		/* unused */
+#define PT_LOAD		1		/* loadable segment */
+#define PT_DYNAMIC	2		/* dynamic link information */
+#define PT_INTERP	3		/* interpreter */
+#define PT_NOTE		4		/* auxiliary information */
+#define PT_SHLIB	5		/* shared library */
+#define PT_PHDR		6		/* self */
+#define PT_LOPROC	0x70000000	/* processor-specific (lo) */
+#define PT_HIPROC	0x7FFFFFFF	/* processor-specific (ho) */
+
+/* p_flags bit fields */
+#define PF_X		(1 << 0)	/* executable */
+#define PF_W		(1 << 1)	/* writable */
+#define PF_R		(1 << 2)	/* readable */
+#define PF_MASKPROC	0xF0000000	/* processor-specific bits */
+
+/* Section header */
+
+/* sh_type values */
+#define SHT_NULL	0		/* unused */
+#define SHT_PROGBITS	1		/* program code or data */
+#define SHT_SYMTAB	2		/* symbol table */
+#define SHT_STRTAB	3		/* string table */
+#define SHT_RELA	4		/* relocation records (with addends) */
+#define SHT_HASH	5		/* symbol hash table */
+#define SHT_DYNAMIC	6		/* dynamic linking table */
+#define SHT_NOTE	7		/* comments */
+#define SHT_NOBITS	8		/* zero program data (i.e. bss)*/
+#define SHT_REL		9		/* relocation records (w/o addends) */
+#define SHT_SHLIB	10		/* shared library */
+#define SHT_DYNSYM	11		/* dynamic linking symbol table */
+#define SHT_LOPROC	0x70000000	/* processor specific (lo) */
+#define SHT_HIPROC	0x7FFFFFFF	/* processor specific (hi) */
+#define SHT_LOUSER	0x80000000	/* user specific (lo) */
+#define SHT_HIUSER	0x8FFFFFFF	/* user specific (hi) */
+
+/* sh_flags bit fields */
+#define SHF_WRITE	(1 << 0)	/* writable section */
+#define SHF_ALLOC	(1 << 1)	/* allocated in program space */
+#define SHF_EXECINSTR	(1 << 2)	/* executable instructions */
+#define SHF_MASKPROC	0xF0000000	/* processor-specific bits */
+
+/* symbol binding */
+#define STB_LOCAL	0		/* local to this file */
+#define STB_GLOBAL	1		/* globally visible */
+#define STB_WEAK	2		/* weakly global */
+#define STB_LOPROC	13		/* processor-specific (lo) */
+#define STB_HIPROC	15		/* processor-specific (hi) */
+
+/* symbol type */
+#define STT_NOTYPE	0		/* unspecified */
+#define STT_OBJECT	1		/* data object */
+#define STT_FUNC	2		/* code object */
+#define STT_SECTION	3		/* section symbol */
+#define STT_FILE	4		/* file name symbol */
+#define STT_LOPROC	13		/* processor-specific (lo) */
+#define STT_HIPROC	15		/* processor-specific (hi) */
+
+/* special reserved values for st_shndx */
+#define SHN_UNDEF	0		/* undefined (external) symbol */
+#define SHN_LORESERV	0xFF00		/* reserved values (lo) */
+#define SHN_LOPROC	0xFF00		/* processor-specific (lo) */
+#define SHN_HIPROC	0xFF1F		/* processor-specific (hi) */
+#define SHN_ABS		0xFFF1		/* absolute symbol */
+#define SHN_COMMON	0xFFF2		/* common symbol */
+#define SHN_HIRESERVE	0xFFFF		/* reserved values (hi)*/
+
+#define ELF32_R_SYM(i)		((i) >> 8)
+#define ELF32_R_TYPE(i)		((i) & 0xff)
+#define ELF32_R_INFO(sym,type)	(((sym) << 8) | ((type) & 0xff))
+
+#define ELF32_ST_BIND(i)	((i) >> 4)
+#define ELF32_ST_TYPE(i)	((i) & 0xf)
+#define ELF32_ST_INFO(bind,type) (((bind) << 4) | ((type) & 0xf))
--- /dev/null
+++ b/convert/elfio.c
@@ -0,0 +1,553 @@
+/* elfio.c: ELF file i/o primitives
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "elfmips.h"
+
+#define ELFINU8(b,w) \
+  (w = bp[0])
+
+#define ELFINMSBU16(b,w) \
+  (w = ((b)[0] << 8) | (b)[1])
+
+#define ELFINLSBU16(b,w) \
+  (w = ((b)[1] << 8) | (b)[0])
+
+#define ELFINMSBU32(b,w) \
+  (w = ((unsigned long)(b)[0] << 24) | \
+       ((unsigned long)(b)[1] << 16) | \
+       ((b)[2] << 8) | \
+       (b)[3])
+
+#define ELFINLSBU32(b,w) \
+  (w = ((unsigned long)(b)[3] << 24) | \
+       ((unsigned long)(b)[2] << 16) | \
+       ((b)[1] << 8) | \
+       (b)[0])
+
+#define ELFOUTU8(b,w) \
+  (bp[0] = w)
+
+#define ELFOUTMSBU16(b,w) \
+  ((b)[0] = (w >> 8), \
+   (b)[1]  = w)
+
+#define ELFOUTLSBU16(b,w) \
+  ((b)[1] = (w >> 8), \
+   (b)[0]  = w)
+
+#define ELFOUTMSBU32(b,w) \
+  ((b)[0] = (w >> 24), \
+   (b)[1] = (w >> 16), \
+   (b)[2] = (w >> 8), \
+   (b)[3]  = w)
+
+#define ELFOUTLSBU32(b,w) \
+  ((b)[3] = (w >> 24), \
+   (b)[2] = (w >> 16), \
+   (b)[1] = (w >> 8), \
+   (b)[0]  = w)
+
+static unsigned long elfinlsbu32(unsigned char *bp)
+{
+    unsigned long v;
+    ELFINLSBU32(bp,v);
+    return v;
+}
+
+static unsigned int elfinlsbu16(unsigned char *bp)
+{
+    unsigned int v;
+    ELFINLSBU16(bp,v);
+    return v;
+}
+
+static unsigned long elfinmsbu32(unsigned char *bp)
+{
+    unsigned long v;
+    ELFINMSBU32(bp,v);
+    return v;
+}
+static unsigned int elfinmsbu16(unsigned char *bp)
+{
+    unsigned int v;
+    ELFINMSBU16(bp,v);
+    return v;
+}
+
+static void elfoutmsbu32(unsigned char *bp,unsigned long v)
+{
+    ELFOUTMSBU32(bp,v);
+}
+
+static void elfoutmsbu16(unsigned char *bp,unsigned int v)
+{
+    ELFOUTMSBU16(bp,v);
+}
+
+static void elfoutlsbu32(unsigned char *bp,unsigned long v)
+{
+    ELFOUTLSBU32(bp,v);
+}
+
+static void elfoutlsbu16(unsigned char *bp,unsigned int v)
+{
+    ELFOUTLSBU16(bp,v);
+}
+
+
+#define X3
+
+#if defined(X1)
+/* this is applaing because there is no optimisation of the test
+ * of format between succesive macro calls
+*/
+#define ELFINU16(b,w) (format?ELFINLSBU16(b,w):ELFINMSBU16(b,w))
+#define ELFINU32(b,w) (format?ELFINLSBU32(b,w):ELFINMSBU32(b,w))
+#define ELFOUTU16(b,w) (format?ELFOUTLSBU16(b,w):ELFOUTMSBU16(b,w))
+#define ELFOUTU32(b,w) (format?ELFOUTLSBU32(b,w):ELFOUTMSBU32(b,w))
+#elif defined(X2)
+/* this is also appaling because there is no optimisation of the test
+ * of format between succesive macro calls
+*/
+#define ELFINU16(b,w) w = (format?elfinlsbu16(b):elfinmsbu16(b))
+#define ELFINU32(b,w) w = (format?elfinlsbu32(b):elfinmsbu32(b))
+#define ELFOUTU16(b,w) (format?elfoutlsbu16(b,w):elfoutmsbu16(b,w))
+#define ELFOUTU32(b,w) (format?elfoutlsbu32(b,w):elfoutmsbu32(b,w))
+#elif defined(X3)
+/* this works better but still is poor as the function address
+ * is loaded from table before each call
+*/
+static const struct {
+    void (*out16)(unsigned char *bp,unsigned int v);
+    void (*out32)(unsigned char *bp,unsigned long v);
+    unsigned int (*in16)(unsigned char *bp);
+    unsigned long (*in32)(unsigned char *bp);
+} fvec[] = {
+    {elfoutmsbu16,elfoutmsbu32,elfinmsbu16,elfinmsbu32},
+    {elfoutlsbu16,elfoutlsbu32,elfinlsbu16,elfinlsbu32}
+};
+
+#define ELFINU16(b,w) w = fvec[format].in16(b)
+#define ELFINU32(b,w) w = fvec[format].in32(b)
+#define ELFOUTU16(b,w) fvec[format].out16(b,w)
+#define ELFOUTU32(b,w) fvec[format].out32(b,w)
+#endif
+
+
+#define ELFINCHAR(b,w) 	(ELFINU8(b,w),(b)+=1)
+#define ELFINHALF(b,w) 	(ELFINU16(b,w),(b)+=2)
+#define ELFINWORD(b,w) 	(ELFINU32(b,w),(b)+=4)
+#define ELFINADDR(b,w) 	(ELFINU32(b,w),(b)+=4)
+#define ELFINOFF(b,w) 	(ELFINU32(b,w),(b)+=4)
+
+#define ELFOUTCHAR(b,w) (ELFOUTU8(b,w),(b)+=1)
+#define ELFOUTHALF(b,w) (ELFOUTU16(b,w),(b)+=2)
+#define ELFOUTWORD(b,w) (ELFOUTU32(b,w),(b)+=4)
+#define ELFOUTADDR(b,w) (ELFOUTU32(b,w),(b)+=4)
+#define ELFOUTOFF(b,w) 	(ELFOUTU32(b,w),(b)+=4)
+
+/* Maximum sizes of things we will consider reading
+ * these are a bit more than that cos of poosible compiler struct padding
+ */
+#define MAXEHDRSIZE	sizeof(Elf32_Ehdr)
+#define MAXPHDRSIZE	sizeof(Elf32_Phdr)
+#define MAXSHDRSIZE	sizeof(Elf32_Shdr)
+#define MAXRELASIZE	sizeof(Elf32_Rela)
+#define MAXSYMSIZE	sizeof(Elf32_Sym)
+#define MAXGPTABSIZE	sizeof(Elf32_Gptab)
+#define MAXREGINFOSIZE	sizeof(Elf32_Reginfo)
+
+#define FORMATSELECT(eh) ((eh->e_ident[5] == ELFDATA2MSB)?0:1)
+
+size_t elfShdrRead(FILE *fp,
+		   const Elf32_Ehdr *eh, Elf32_Shdr *sh,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; sh++,n++) {
+  	unsigned char 	buf[MAXSHDRSIZE];
+	unsigned char 	*bp = buf;
+
+	if(fread(buf,eh->e_shentsize,1,fp) != 1)
+	  break;
+
+	/* convert from bytes to numbers
+	 */
+	ELFINWORD(bp,sh->sh_name);
+	ELFINWORD(bp,sh->sh_type);
+	ELFINWORD(bp,sh->sh_flags);
+	ELFINADDR(bp,sh->sh_addr);
+	ELFINOFF(bp,sh->sh_offset);
+	ELFINWORD(bp,sh->sh_size);
+	ELFINWORD(bp,sh->sh_link);
+	ELFINWORD(bp,sh->sh_info);
+	ELFINWORD(bp,sh->sh_addralign);
+	ELFINWORD(bp,sh->sh_entsize);
+    }
+    return n;
+}
+
+size_t elfShdrWrite(FILE *fp,
+		  const Elf32_Ehdr *eh,
+		  const Elf32_Shdr *sh,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; sh++,n++) {
+  	unsigned char 	buf[MAXSHDRSIZE];
+	unsigned char 	*bp = buf;
+
+	/* convert from numbers to bytes
+	 */
+	ELFOUTWORD(bp,sh->sh_name);
+	ELFOUTWORD(bp,sh->sh_type);
+	ELFOUTWORD(bp,sh->sh_flags);
+	ELFOUTADDR(bp,sh->sh_addr);
+	ELFOUTOFF(bp,sh->sh_offset);
+	ELFOUTWORD(bp,sh->sh_size);
+	ELFOUTWORD(bp,sh->sh_link);
+	ELFOUTWORD(bp,sh->sh_info);
+	ELFOUTWORD(bp,sh->sh_addralign);
+	ELFOUTWORD(bp,sh->sh_entsize);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+size_t elfPhdrRead(FILE *fp,
+		   const Elf32_Ehdr *eh, Elf32_Phdr *ph,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; ph++,n++) {
+  	unsigned char 	buf[MAXPHDRSIZE];
+	unsigned char 	*bp = buf;
+
+	if(fread(buf,eh->e_phentsize,1,fp) != 1)
+	  break;
+
+	/* convert from bytes to numbers */
+	ELFINWORD(bp,ph->p_type);
+	ELFINOFF(bp,ph->p_offset);
+	ELFINADDR(bp,ph->p_vaddr);
+	ELFINADDR(bp,ph->p_paddr);
+	ELFINWORD(bp,ph->p_filesz);
+	ELFINWORD(bp,ph->p_memsz);
+	ELFINWORD(bp,ph->p_flags);
+	ELFINWORD(bp,ph->p_align);
+    }
+    return n;
+}
+
+size_t elfPhdrWrite(FILE *fp,
+		  const Elf32_Ehdr *eh,
+		  const Elf32_Phdr *ph,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; ph++,n++) {
+  	unsigned char 	buf[MAXPHDRSIZE];
+	unsigned char 	*bp = buf;
+
+	/* convert from numbers to bytes */
+	ELFOUTWORD(bp,ph->p_type);
+	ELFOUTOFF(bp,ph->p_offset);
+	ELFOUTADDR(bp,ph->p_vaddr);
+	ELFOUTADDR(bp,ph->p_paddr);
+	ELFOUTWORD(bp,ph->p_filesz);
+	ELFOUTWORD(bp,ph->p_memsz);
+	ELFOUTWORD(bp,ph->p_flags);
+	ELFOUTWORD(bp,ph->p_align);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+size_t elfSymRead(FILE *fp,
+		   const Elf32_Ehdr *eh,
+		   const Elf32_Shdr *sh,
+		   Elf32_Sym *sym,size_t nsym)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nsym; sym++,n++) {
+  	unsigned char 	buf[MAXSYMSIZE];
+	unsigned char 	*bp = buf;
+
+	if(fread(buf,sh->sh_entsize,1,fp) != 1)
+	  break;
+
+	/* convert from bytes to numbers
+	 */
+	ELFINWORD(bp,sym->st_name);
+	ELFINADDR(bp,sym->st_value);
+	ELFINWORD(bp,sym->st_size);
+	ELFINCHAR(bp,sym->st_info);
+	ELFINCHAR(bp,sym->st_other);
+	ELFINHALF(bp,sym->st_shndx);
+    }
+    return n;
+}
+
+size_t elfSymWrite(FILE *fp,
+		   const Elf32_Ehdr *eh,
+		   const Elf32_Shdr *sh,
+		   const Elf32_Sym *sym,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; sym++,n++) {
+  	unsigned char 	buf[MAXSYMSIZE];
+	unsigned char 	*bp = buf;
+
+	/* convert from numbers to bytes
+	 */
+	ELFOUTWORD(bp,sym->st_name);
+	ELFOUTADDR(bp,sym->st_value);
+	ELFOUTWORD(bp,sym->st_size);
+	ELFOUTCHAR(bp,sym->st_info);
+	ELFOUTCHAR(bp,sym->st_other);
+	ELFOUTHALF(bp,sym->st_shndx);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+size_t elfRelaWrite(FILE *fp,
+		   const Elf32_Ehdr *eh,
+		   const Elf32_Shdr *sh,
+		   const Elf32_Rela *rela,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; rela++,n++) {
+  	unsigned char 	buf[MAXRELASIZE];
+	unsigned char 	*bp = buf;
+
+	/* convert from numbers to bytes
+	 */
+	ELFOUTWORD(bp,rela->r_offset);
+	ELFOUTWORD(bp,rela->r_info);
+	ELFOUTWORD(bp,rela->r_addend);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+size_t elfEhdrWrite(FILE *fp,const Elf32_Ehdr *eh)
+{
+    int format = FORMATSELECT(eh);
+    unsigned char buf[MAXEHDRSIZE];
+    unsigned char *bp = buf;
+
+    memcpy(bp,eh->e_ident,EI_NIDENT);
+    bp += EI_NIDENT;
+
+    ELFOUTHALF(bp,eh->e_type);
+    ELFOUTHALF(bp,eh->e_machine);
+    ELFOUTWORD(bp,eh->e_version);
+    ELFOUTADDR(bp,eh->e_entry);
+    ELFOUTOFF(bp,eh->e_phoff);
+    ELFOUTOFF(bp,eh->e_shoff);
+    ELFOUTWORD(bp,eh->e_flags);
+    ELFOUTHALF(bp,eh->e_ehsize);
+    ELFOUTHALF(bp,eh->e_phentsize);
+    ELFOUTHALF(bp,eh->e_phnum);
+    ELFOUTHALF(bp,eh->e_shentsize);
+    ELFOUTHALF(bp,eh->e_shnum);
+    ELFOUTHALF(bp,eh->e_shstrndx);
+
+    return fwrite(&buf,bp-buf,1,fp);
+}
+
+size_t elfEhdrRead(FILE *fp,Elf32_Ehdr *eh)
+{
+    unsigned char buf[MAXEHDRSIZE];
+    unsigned char *bp = buf;
+
+    if(fread(buf,ELFEHDRSZ,1,fp) != 1)
+      return 0;
+
+    memcpy(eh->e_ident,bp,EI_NIDENT);
+    bp += EI_NIDENT;
+
+    if(eh->e_ident[0] != ELFMAG0 ||
+       eh->e_ident[1] != ELFMAG1 ||
+       eh->e_ident[2] != ELFMAG2 ||
+       eh->e_ident[3] != ELFMAG3)
+      return 0;
+
+    if(eh->e_ident[4] != ELFCLASS32)
+      return 0;
+
+    if(eh->e_ident[5] != ELFDATA2MSB && eh->e_ident[5] != ELFDATA2LSB)
+      return 0;
+
+#ifdef notdef
+    /* what should the version in the ident be ?? */
+    if(eh->e_ident[6] != 1)
+      return 0;
+#endif
+
+    {
+	int i;
+
+	for(i=7;i<EI_NIDENT;i++)
+	  if(eh->e_ident[i] != 0)
+	    return 0;
+    }
+    {
+	int format = FORMATSELECT(eh);
+
+	ELFINHALF(bp,eh->e_type);
+	ELFINHALF(bp,eh->e_machine);
+	ELFINWORD(bp,eh->e_version);
+	ELFINADDR(bp,eh->e_entry);
+	ELFINOFF(bp,eh->e_phoff);
+	ELFINOFF(bp,eh->e_shoff);
+	ELFINWORD(bp,eh->e_flags);
+	ELFINHALF(bp,eh->e_ehsize);
+	ELFINHALF(bp,eh->e_phentsize);
+	ELFINHALF(bp,eh->e_phnum);
+	ELFINHALF(bp,eh->e_shentsize);
+	ELFINHALF(bp,eh->e_shnum);
+	ELFINHALF(bp,eh->e_shstrndx);
+    }
+    return 1;
+}
+
+
+size_t elfReginfoWrite(FILE *fp,
+		       const Elf32_Ehdr *eh,
+		       const Elf32_Shdr *sh,
+		       const Elf32_Reginfo *ri,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; ri++,n++) {
+  	unsigned char 	buf[MAXREGINFOSIZE];
+	unsigned char 	*bp = buf;
+	int i;
+
+	/* convert from numbers to bytes
+	 */
+	ELFOUTWORD(bp,ri->ri_gprmask);
+	for (i = 0; i < 4; i++) {
+	    ELFOUTWORD(bp,ri->ri_cprmask[i]);
+	}
+	ELFOUTWORD(bp,ri->ri_gp_value);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+
+size_t elfReginfoRead (FILE *fp,
+		       const Elf32_Ehdr *eh,
+		       const Elf32_Shdr *sh,
+		       Elf32_Reginfo *ri,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; ri++,n++) {
+  	unsigned char 	buf[MAXREGINFOSIZE];
+	unsigned char 	*bp = buf;
+	int i;
+
+	if(fread(buf,sh->sh_entsize,1,fp) != 1)
+	  break;
+
+	/* convert from numbers to bytes
+	 */
+	ELFINWORD(bp,ri->ri_gprmask);
+	for (i = 0; i < 4; i++) {
+	    ELFINWORD(bp,ri->ri_cprmask[i]);
+	}
+	ELFINWORD(bp,ri->ri_gp_value);
+    }
+    return n;
+}
+
+size_t elfGptabWrite(FILE *fp,
+		       const Elf32_Ehdr *eh,
+		       const Elf32_Shdr *sh,
+		       const Elf32_Gptab *gt,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; gt++,n++) {
+  	unsigned char 	buf[MAXGPTABSIZE];
+	unsigned char 	*bp = buf;
+
+	/* convert from numbers to bytes
+	 */
+	ELFOUTWORD(bp,gt->gt_entry.gt_g_value);
+	ELFOUTWORD(bp,gt->gt_entry.gt_bytes);
+
+	if(fwrite(buf,bp-buf,1,fp) != 1)
+	  break;
+    }
+    return n;
+}
+
+
+size_t elfGptabRead(FILE *fp,
+		    const Elf32_Ehdr *eh,
+		    const Elf32_Shdr *sh,
+		    Elf32_Gptab *gt,size_t nhdr)
+{
+    int format = FORMATSELECT(eh);
+    size_t n;
+
+    for(n=0; n<nhdr; gt++,n++) {
+  	unsigned char 	buf[MAXGPTABSIZE];
+	unsigned char 	*bp = buf;
+
+	if(fread(buf,sh->sh_entsize,1,fp) != 1)
+	  break;
+
+	/* convert from numbers to bytes
+	 */
+	ELFINWORD(bp,gt->gt_entry.gt_g_value);
+	ELFINWORD(bp,gt->gt_entry.gt_bytes);
+    }
+    return n;
+}
--- /dev/null
+++ b/convert/elfmips.h
@@ -0,0 +1,122 @@
+/* elfmips.h: MIPS ABI specific ELF definitions
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "elf.h"
+
+/* MIPSABI program header special */
+#define PT_MIPS_REGINFO		(PT_LOPROC + 0)
+
+/* SDEMIPS relocation (rela type) */
+#define R_SDE_8			0
+#define R_SDE_16		1
+#define R_SDE_32		2
+#define R_SDE_ILA		35
+#define R_SDE_IGPREL		36
+#define R_SDE_ILAHI		37
+#define R_SDE_ILALO		38
+#define R_SDE_IBRA		39
+#define R_SDE_IJMP		40
+#define R_SDE_ILITERAL		41
+
+/* MIPSABI relocation (rel type) */
+#define R_MIPS_NONE		0
+#define R_MIPS_16		1
+#define R_MIPS_32		2
+#define R_MIPS_REL32		3
+#define R_MIPS_26		4
+#define R_MIPS_HI16		5
+#define R_MIPS_LO16		6
+#define R_MIPS_GPREL16		7
+#define R_MIPS_LITERAL		8
+#define R_MIPS_GOT16		9
+#define R_MIPS_PC16		10
+#define R_MIPS_CALL16		11
+#define R_MIPS_GPREL32		12
+
+/* MIPSABI special section numbers */
+#define SHN_MIPS_ACOMMON	(SHN_LOPROC + 0)
+#define SHN_MIPS_SCOMMON	(SHN_LOPROC + 3)
+#define SHN_MIPS_SUNDEFINED	(SHN_LOPROC + 4)
+
+/* MIPSABI special section types */
+#define SHT_MIPS_LIBLIST	(SHT_LOPROC + 0)
+#define SHT_MIPS_CONFLICT	(SHT_LOPROC + 2)
+#define SHT_MIPS_GPTAB		(SHT_LOPROC + 3)
+#define SHT_MIPS_UCODE		(SHT_LOPROC + 4)
+#define SHT_MIPS_DEBUG		(SHT_LOPROC + 5)
+#define SHT_MIPS_REGINFO	(SHT_LOPROC + 6)
+
+/* MIPSABI special section flags */
+#define SHF_MIPS_GPREL		0x10000000
+
+/* MIPSABI processor specific flags */
+#define EF_MIPS_NOREORDER	0x00000001
+#define EF_MIPS_PIC		0x00000002
+#define EF_MIPS_CPIC		0x00000004
+#define EF_MIPS_ARCH		0xf0000000
+#define  E_MIPS_ARCH_1		0x00000000 /* -mips1 */
+#define  E_MIPS_ARCH_2		0x10000000 /* -mips2 */
+#define  E_MIPS_ARCH_3		0x20000000 /* -mips3 */
+#define  E_MIPS_ARCH_4		0x30000000 /* -mips4 */
+/* The following are not MIPSABI, but SDE-MIPS only */
+#define EF_MIPS_CPU		0x000f0000
+#define  E_MIPS_CPU_STD		0x00000000
+#define  E_MIPS_CPU_CW4		0x00010000
+#define  E_MIPS_CPU_R4100	0x00020000
+#define  E_MIPS_CPU_R4650	0x00030000
+#define  E_MIPS_CPU_R3900	0x00040000
+#define  E_MIPS_CPU_RM52XX	0x00050000
+#define EF_MIPS_NOGPCOUNT	0x00001000
+
+/* MIPSABI special sections */
+
+/* .reginfo */
+typedef struct {
+    Elf32_Word		ri_gprmask;
+    Elf32_Word		ri_cprmask[4];
+    Elf32_Sword		ri_gp_value;
+} Elf32_Reginfo;
+
+#define ELFREGINFOSZ	sizeof(Elf32_Reginfo)
+
+size_t elfReginfoWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		       const Elf32_Reginfo *,size_t);
+size_t elfReginfoRead(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		      Elf32_Reginfo *,size_t);
+
+/* .gptab.xxx */
+typedef union {
+    struct {
+	Elf32_Word		gt_current_g_value;
+	Elf32_Word		gt_unused;
+    } gt_header;
+    struct {
+	Elf32_Word		gt_g_value;
+	Elf32_Word		gt_bytes;
+    } gt_entry;
+} Elf32_Gptab;
+
+#define ELFGPTABSZ	sizeof(Elf32_Gptab)
+
+size_t elfGptabRead(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		    Elf32_Gptab *,size_t);
+size_t elfGptabWrite(FILE *,const Elf32_Ehdr *,const Elf32_Shdr *,
+		   const Elf32_Gptab *,size_t);
+
--- /dev/null
+++ b/convert/elfout.c
@@ -0,0 +1,188 @@
+/* elfout.c -- ELF Output
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "elfmips.h"
+
+#define BUFSIZE		8192	/* max bytes per block */
+
+static FILE		*elffp;
+static unsigned long	elffirst = ~0;
+static unsigned long	elfaddr = ~0;
+static long		elfoffs;
+static int 		elflen;
+static unsigned char	*elfbuf;
+
+static Elf32_Ehdr	ehdr;
+#define NSECTIONS	9
+static Elf32_Phdr	phdr[NSECTIONS];
+static Elf32_Shdr	shdr[NSECTIONS + 1];	/* plus 1 for shsectname */
+static int		nsect;
+
+extern char *		progname;
+extern int		promflag;
+extern unsigned long	prombase;
+
+static void
+elfFlush (int endsect)
+{
+    if (elflen > 0) {
+	fwrite (elfbuf, 1, elflen, elffp);
+	elfoffs += elflen;
+	elfaddr += elflen;
+	elflen = 0;
+    }
+
+    if (endsect && nsect > 1) {
+	Elf32_Shdr *sh = &shdr[nsect - 1];
+	sh->sh_size = elfoffs - sh->sh_offset;
+    }
+}
+
+void
+ElfStart (FILE *fp, unsigned long ep, int bigendian)
+{
+    elfbuf = xmalloc (BUFSIZE);
+    elffp = fp;
+
+    memset (&ehdr, 0, sizeof (ehdr));
+    ehdr.e_ident[EI_MAG0] = ELFMAG0;
+    ehdr.e_ident[EI_MAG1] = ELFMAG1;
+    ehdr.e_ident[EI_MAG2] = ELFMAG2;
+    ehdr.e_ident[EI_MAG3] = ELFMAG3;
+    ehdr.e_ident[EI_CLASS] = ELFCLASS32;
+    ehdr.e_ident[EI_DATA] = bigendian ? ELFDATA2MSB : ELFDATA2LSB;
+    ehdr.e_ident[EI_VERSION] = EV_CURRENT;
+    ehdr.e_type = ET_EXEC;
+    ehdr.e_machine = EM_MIPS;
+    ehdr.e_version = EV_CURRENT;
+    ehdr.e_ehsize = sizeof (Elf32_Ehdr);
+    ehdr.e_phentsize = sizeof (Elf32_Phdr);
+    ehdr.e_shentsize = sizeof (Elf32_Shdr);
+    elfoffs = ehdr.e_shoff + sizeof (shdr);
+
+    nsect = 1;
+    fseek (elffp, elfoffs, SEEK_SET);
+}
+
+
+void
+ElfOutput (unsigned long addr, unsigned char byte)
+{
+    if (promflag)
+	/* convert back to PROM virtual address in KSEG1 */
+	addr = (addr + prombase) | 0xa0000000;
+
+    if (addr != elfaddr + elflen) {
+	Elf32_Shdr *sh = &shdr[nsect];
+
+	elfFlush (1);
+
+	if (nsect == NSECTIONS) {
+	    fprintf (stderr, "%s: too many ELF output sections\n",
+		     progname);
+	    exit (1);
+	}
+
+	sh->sh_type = SHT_PROGBITS;
+	sh->sh_flags = SHF_ALLOC | SHF_EXECINSTR;
+	sh->sh_addr = addr;
+	sh->sh_offset = elfoffs;
+	sh->sh_size = 0;
+	sh->sh_addralign = 1;
+	nsect++;
+
+	elfaddr = addr;
+    }
+
+    if (elflen == BUFSIZE)
+	elfFlush (0);
+    elfbuf[elflen++] = byte;
+}
+
+
+void
+ElfEnd (unsigned long ep)
+{
+    Elf32_Shdr *sh;
+    Elf32_Phdr *ph;
+    char * strtab;
+    int stroffs, i;
+
+    if (nsect <= 1)
+	return;
+
+    elfFlush (1);
+
+    strtab = xmalloc (nsect * sizeof ".psect##"
+		     + sizeof ".shstrtab" + 1);
+
+    /* Prepare the Section Header string table */
+    stroffs = 0;
+    strtab[stroffs++] = '\0';	/* initial null byte */
+    for (sh = &shdr[1], i = 1; i < nsect; sh++, i++) {
+	sh->sh_name = stroffs;
+	sprintf (&strtab[stroffs], ".psect%d", i);
+	stroffs += strlen (&strtab[stroffs]) + 1;
+    }
+
+    /* Prepare the section header for the string table */
+    sh = &shdr[nsect];
+    sh->sh_name = stroffs;
+    strcpy (&strtab[stroffs], ".shstrtab");
+    stroffs += sizeof ".shstrtab";
+    sh->sh_type = SHT_STRTAB;
+    sh->sh_offset = elfoffs;
+    sh->sh_size = stroffs;
+
+    /* Write the Section Header string table */
+    fwrite (strtab, 1, stroffs, elffp);
+    free (strtab);
+
+    /* Prepare Program Header */
+    for (ph = phdr, sh = &shdr[1], i = 1; i < nsect; ph++, sh++, i++) {
+	ph->p_type = PT_LOAD;
+	ph->p_offset = sh->sh_offset;
+	ph->p_vaddr = sh->sh_addr;
+	ph->p_paddr = sh->sh_addr;
+	ph->p_filesz = ph->p_memsz = sh->sh_size;
+	ph->p_flags = PF_R | PF_X;
+	ph->p_align = sh->sh_addralign;
+    }
+
+    /* Prepare ELF header */
+    ehdr.e_phnum = ph - phdr;
+    ehdr.e_shstrndx = nsect;
+    ehdr.e_shnum = nsect + 1;	/* + 1 for string table */
+    ehdr.e_phoff = sizeof (Elf32_Ehdr);
+    ehdr.e_shoff = ehdr.e_phoff + sizeof (Elf32_Phdr) * ehdr.e_phnum;
+    if (promflag)
+	ehdr.e_entry = 0xbfc00000;	/* should this be progreammable */
+    else
+	ehdr.e_entry = ep;
+
+    /* Write the headers */
+    fseek (elffp, 0L, SEEK_SET);
+    elfEhdrWrite (elffp, &ehdr);
+    elfPhdrWrite (elffp, &ehdr, phdr, ehdr.e_phnum);
+    elfShdrWrite (elffp, &ehdr, shdr, ehdr.e_shnum);
+
+    free (elfbuf);
+}
--- /dev/null
+++ b/convert/idtbin.c
@@ -0,0 +1,93 @@
+/* idtbin.c -- Compressed Motorola S-Record Output for IDT/sim
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+#define BUFSIZE		250
+#define ADDRSIZE	4
+
+static FILE		*idtfp;
+static unsigned long	idtaddr = ~0;
+static int 		idtlen;
+static unsigned char	idtbuf[BUFSIZE];
+
+static void
+idtFlush ()
+{
+    unsigned char cksum = 0;
+    int n;
+
+    if (idtlen == 0)
+      return;
+
+    fprintf (idtfp, "S3%c", idtlen + ADDRSIZE + 1);
+    cksum += idtlen + ADDRSIZE + 1;
+
+    for (n = (ADDRSIZE - 1) * 8; n >= 0; n -= 8) {
+	unsigned char ab = idtaddr >> n;
+	fputc (ab, idtfp);
+	cksum += ab;
+    }
+
+    for (n = 0; n < idtlen; n++) {
+	putc (idtbuf[n], idtfp);
+	cksum += idtbuf[n];
+    }
+
+    fputc (~cksum & 0xff, idtfp);
+    idtlen = 0;
+}
+
+
+void
+IdtStart (FILE *fp, unsigned long ep)
+{
+    idtfp = fp;
+}
+
+void
+IdtOutput (unsigned long addr, unsigned char byte)
+{
+    if (addr != idtaddr + idtlen || idtlen == BUFSIZE) {
+	idtFlush ();
+	idtaddr = addr;
+    }
+    idtbuf[idtlen++] = byte;
+}
+
+void
+IdtEnd (unsigned long ep)
+{
+    unsigned char cksum = 0;
+    int n;
+
+    idtFlush ();
+
+    fprintf (idtfp, "S7%c", ADDRSIZE + 1);
+    cksum += ADDRSIZE + 1;
+
+    for (n = (ADDRSIZE - 1) * 8; n >= 0; n -= 8) {
+	unsigned char ab = ep >> n;
+	fputc (ab, idtfp);
+	cksum += ab;
+    }
+
+    fputc (~cksum & 0xff, idtfp);
+}
--- /dev/null
+++ b/convert/lsifast.c
@@ -0,0 +1,219 @@
+/* lsifast.c -- LSI PMON Fast ASCII Output
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+/*#define MAXREC			550*/
+#define MAXREC			255
+#define BUFSIZE			((MAXREC-12)/4*3)
+
+#define ZEROS "/Z"		/* record contains a count of zeros,
+				   actually it's the number of 24-bit
+				   records that are all zero */
+#define BYTE "/B"		/* record contains a single byte */
+#define CHKSUM "/C"		/* checksum to date */
+#define CLRSUM "/K"		/* klear (sic) the checksum */
+#define ADDR "/A"		/* double length record containing a 32 bit
+				   address */
+#define END "/E"		/* end of download */
+
+static FILE		*lsifp;
+static unsigned long	lsiaddr = ~0;
+static int 		lsilen;
+static unsigned char	*lsibuf;
+static int		chksum;
+
+
+static int
+b2a(int c)
+{
+/* translate binary to base64 (tx form)
+0..25		A-Z
+26..51		a-z
+52..61		0-9
+62		,
+63		.
+*/
+
+    c &= 0x3f;
+    if (c <= 25)  return('A'+c);
+    if (c <= 51) return('a'+c-26);
+    if (c <= 61) return('0'+c-52);
+    if (c == 62) return(',');
+    if (c == 63) return('.');
+    abort();
+}
+
+static void
+send12 (char *type, unsigned val)
+{
+    val &= 0xfff;
+    chksum += val;
+    fputc (type[0], lsifp);
+    fputc (type[1], lsifp);
+    fputc (b2a(val>>6), lsifp);
+    fputc (b2a(val), lsifp);
+}
+
+
+static void
+send24(unsigned long val)
+{
+    int i;
+    val &= 0xffffff;
+    chksum += val>>12;
+    chksum += val&0xfff;
+    for (i = 18; i >= 0; i -= 6) {
+	char c = b2a(val >> i);
+	putc (c, lsifp);
+    }
+}
+
+
+static void
+txaddr (unsigned long addr)
+{
+    send12(ADDR, addr >> 24);
+    send24(addr);
+}
+
+static void
+lsiChecksum ()
+{
+    fputc ('\n', lsifp);
+    send12(CHKSUM, chksum);
+    fputc ('\n', lsifp);
+    chksum = 0;
+}
+
+static void
+lsiFlush ()
+{
+    unsigned char *buf = lsibuf;
+    int zcnt = 0;
+
+    if (lsilen == 0)
+      return;
+
+    while (lsilen >= 3) {
+	unsigned long bdat;
+
+	bdat = (buf[0]<<16)+(buf[1]<<8)+buf[2]; /* convert to single word */
+	buf += 3; lsilen -= 3;
+
+	if (bdat == 0) {
+	    if (++zcnt < 4096)
+	      continue;
+	    zcnt--;
+	}
+
+	if (zcnt) {
+	    send12 (ZEROS, zcnt);
+	    zcnt = 0;
+	}
+	send24(bdat); /* send the data */
+    }
+
+    if (zcnt)
+      send12 (ZEROS, zcnt);
+
+    while (lsilen != 0) {
+	send12 (BYTE, *buf++);
+	lsilen--;
+    }
+
+    fputc ('\n', lsifp);
+}
+
+void
+LsiStart (FILE *fp, unsigned long ep)
+{
+    lsibuf = (char *) xmalloc (BUFSIZE);
+    lsifp = fp;
+    send12(CLRSUM, 0);
+    chksum = 0;
+}
+
+
+void
+LsiOutput (unsigned long addr, unsigned char byte)
+{
+    int newaddr = (addr != lsiaddr + lsilen);
+    if (newaddr || lsilen >= BUFSIZE) {
+	lsiFlush ();
+	if (newaddr)
+	  txaddr (addr);
+	lsiaddr = addr;
+    }
+    lsibuf[lsilen++] = byte;
+}
+
+
+void
+LsiSym (char *name, unsigned long value)
+{
+    int len = strlen(name);
+    char *buf = alloca (len + 10);
+    static int reclen = 0;
+    static int first = 1;
+
+    if (first) {
+	lsiFlush ();
+	lsiChecksum ();
+	first = 0;
+    }
+
+    if (reclen + 8 >= MAXREC) {
+	fputc ('\n', lsifp);
+	reclen = 0;
+    }
+    txaddr (value);
+    reclen += 8;
+
+    len += 2;			/* /S */
+    strcpy(buf, name);
+    strcat(buf, ","); len++;
+
+    /* pad total string length to multiple of 4 */
+    while (len & 3) {
+	strcat (buf, "X");
+	len++;
+    }
+
+    if (reclen + len >= MAXREC) {
+	fputc ('\n', lsifp);
+	reclen = 0;
+    }
+    fprintf(lsifp, "/S%s", buf);
+    reclen += len;
+}
+
+
+void
+LsiEnd (unsigned long ep)
+{
+    lsiFlush ();
+    lsiChecksum ();
+    txaddr(ep);
+    send12(END, 0);
+    fputc ('\n', lsifp);
+    free (lsibuf);
+}
+
--- /dev/null
+++ b/convert/mipsflash.c
@@ -0,0 +1,161 @@
+/* mipsflash.c -- MIPS eval board USB/parallel flash download format
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+static FILE		*mipsfp;
+static unsigned long	mipsaddr = ~0;
+static unsigned long	mipsbase = ~0;
+static int 		mipslen;
+static unsigned char	*mipsbuf;
+static int		mipsbigendian;
+
+extern int		promflag;
+extern unsigned long	prombase;
+
+/* data chunk size - 16 words */
+#define BUFSIZE			(16*4)
+
+/* flash sector size */
+#define FLASH_BLOCK_SIZE	0x20000
+
+static void
+mipsFlush ()
+{
+    unsigned char *buf;
+    int done;
+
+    if (mipslen == 0)
+      return;
+
+    for (buf = mipsbuf, done = 0; done < BUFSIZE; buf += 4, done += 4) {
+	unsigned long val = 0;
+	int i;
+
+	/* new line every 32 bytes (8 words) */
+	if (done != 0 && done % 32 == 0)
+	    fputc ('\n', mipsfp);
+
+	/* collect one word from input buffer using appropriate endianness. */
+	for (i = 0; i < 4; i++) {
+	    unsigned int addr01 = (mipsaddr + done + i) & 0x3;
+	    if (mipsbigendian)
+		val |= buf[i] << (8 * (3 - addr01));
+	    else
+		val |= buf[i] << (8 * addr01);
+	}
+
+	/* output one word of data */
+	fprintf (mipsfp, " %08lx", val);
+    }
+
+    fputc ('\n', mipsfp);
+
+    /* reset output buffer to blank */
+    memset (mipsbuf, 0xff, BUFSIZE);
+    mipslen = 0;
+}
+
+
+void
+MipsStart (FILE *fp, unsigned long ep, int bigendian)
+{
+    mipsbuf = (char *) xmalloc (BUFSIZE);
+    mipsfp = fp;
+    mipsbigendian = bigendian;
+
+    /* Reset the loader state machine */
+    fprintf (fp, "!R\n");
+}
+
+
+void
+MipsOutput (unsigned long addr, unsigned char byte)
+{
+  /* XXX Rework this whole thing to gather up aligned chunks into each
+     buffer, don't require strictly contiguous addresses.  */
+
+    unsigned long lastaddr = mipsaddr + mipslen;
+    int newsector, newaddr;
+
+    if (promflag)
+	/* convert back to PROM physical address */
+	addr += prombase;
+
+    newsector = ((addr ^ lastaddr) & ~(FLASH_BLOCK_SIZE - 1)) != 0;
+    newaddr = newsector || (addr != lastaddr);
+
+    if (newaddr || newsector || mipslen >= BUFSIZE) {
+	mipsFlush ();
+	mipsaddr = addr;
+    }
+
+    if (mipsbase == ~0) {
+      /* first byte - remember base address */
+      mipsbase = addr;
+      if (mipsbase == 0x1fc00000)
+	/* unlock the flash */
+	fprintf (mipsfp, ">1fc00xxx @1fc00000 !C\n");
+    }
+
+    if (newsector)
+      {
+	/* started new flash sector - erase it */
+	unsigned long base = addr & ~(FLASH_BLOCK_SIZE - 1);
+	fprintf (mipsfp, ">%.5xxxx ", base / 0x1000);
+	fprintf (mipsfp, "@%.8x !E\n", base);
+	if (base != addr)
+	  newaddr = 1;
+      }
+
+    if (newaddr)
+      /* set new write addr */
+      fprintf (mipsfp, "@%.8lx\n", addr);
+
+    if (newaddr || newsector || ((addr & 0xfff == 0) && mipslen == 0))
+      /* update display */
+      fprintf (mipsfp, ">%.8lx\n", addr);
+
+    mipsbuf[mipslen++] = byte;
+}
+
+void
+MipsEnd (unsigned long ep)
+{
+    mipsFlush ();
+
+    if (mipsbase == 0x1fc00000) {
+	/* Lock the flash */
+	fprintf (mipsfp, ">LOCKFLSH\n");
+	fprintf (mipsfp, "@1fc00000 !S\n");
+	fprintf (mipsfp, "@1fc20000 !S\n");
+	fprintf (mipsfp, "@1fc40000 !S\n");
+	fprintf (mipsfp, "@1fc60000 !S\n");
+	fprintf (mipsfp, "@1fc80000 !S\n");
+	fprintf (mipsfp, "@1fca0000 !S\n");
+	fprintf (mipsfp, "@1fcc0000 !S\n");
+	fprintf (mipsfp, "@1fce0000 !S\n");
+    }
+
+    fprintf (mipsfp, ">#DL_DONE\n");
+    fprintf (mipsfp, ">FINISHED\n");
+    free (mipsbuf);
+}
+
--- /dev/null
+++ b/convert/srec.c
@@ -0,0 +1,119 @@
+/* srec.c -- Motorola S-Record Output
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+#define BUFSIZE		32
+
+static FILE		*srecfp;
+static unsigned long	srecaddr = ~0;
+static int 		sreclen;
+static unsigned char	srecbuf[BUFSIZE];
+static int		addrsize;
+
+
+static void
+srecFlush ()
+{
+    unsigned char cksum = 0;
+    int n;
+
+    if (sreclen == 0)
+      return;
+
+    fprintf (srecfp, "S%1d%02X", addrsize-1, sreclen + addrsize + 1);
+    cksum += sreclen + addrsize + 1;
+
+    for (n = (addrsize - 1) * 8; n >= 0; n -= 8) {
+	unsigned char ab = srecaddr >> n;
+	fprintf (srecfp, "%02X", ab);
+	cksum += ab;
+    }
+
+    for (n = 0; n < sreclen; n++) {
+	fprintf (srecfp, "%02X", srecbuf[n]);
+	cksum += srecbuf[n];
+    }
+
+    fprintf (srecfp, "%02X\n", ~cksum & 0xff);
+    sreclen = 0;
+}
+
+
+void
+Srec3Start (FILE *fp, unsigned long ep)
+{
+    srecfp = fp;
+    addrsize = 4;
+}
+
+void
+Srec2Start (FILE *fp, unsigned long ep)
+{
+    srecfp = fp;
+    addrsize = 3;
+}
+
+void
+Srec1Start (FILE *fp, unsigned long ep)
+{
+    srecfp = fp;
+    addrsize = 2;
+}
+
+
+void
+SrecOutput (unsigned long addr, unsigned char byte)
+{
+    if (addr != srecaddr + sreclen || sreclen == BUFSIZE) {
+	srecFlush ();
+	srecaddr = addr;
+    }
+    srecbuf[sreclen++] = byte;
+}
+
+
+void
+SrecSym (char *name, unsigned long value)
+{
+    int len = strlen(name) + 8 + 2;
+    fprintf (srecfp, "S4%02X%08X%s,00\n", len, value, name);
+}
+
+
+void
+SrecEnd (unsigned long ep)
+{
+    unsigned char cksum = 0;
+    int n;
+
+    srecFlush ();
+
+    fprintf (srecfp, "S%1d%02X", 11 - addrsize, addrsize + 1);
+    cksum += addrsize + 1;
+
+    for (n = (addrsize - 1) * 8; n >= 0; n -= 8) {
+	unsigned char ab = ep >> n;
+	fprintf (srecfp, "%02X", ab);
+	cksum += ab;
+    }
+
+    fprintf (srecfp, "%02X\n", ~cksum & 0xff);
+}
--- /dev/null
+++ b/convert/stagbin.c
@@ -0,0 +1,105 @@
+/* stag.c -- Stag Programmer Binary Output
+
+   Copyright (c) 1993-2003, 2008 Free Software Foundation, Inc.
+   Contributed by MIPS Technologies, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; If not, write to the Free Software
+   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "sysdep.h"
+
+#define SOH 		1
+#define CHECKLENGTH	1024	/* # bytes between intermediate checksums */
+#define BUFSIZE		8192	/* max bytes per block */
+
+static FILE		*stagfp;
+static unsigned long	stagaddr = ~0;
+static int 		staglen;
+static unsigned char	*stagbuf;
+static int		chksum;
+
+static void
+sbinputc (unsigned char c)
+{
+    chksum += c;
+    putc (c, stagfp);
+}
+
+static void
+sbinlong (unsigned i)
+{
+    sbinputc (i >> 24);
+    sbinputc (i >> 16);
+    sbinputc (i >> 8);
+    sbinputc (i);
+}
+
+static void
+sbinheader (unsigned len, unsigned offs)
+{
+    sbinputc (SOH);
+    chksum = 0;
+    sbinlong (len);
+    sbinlong (offs);
+}
+
+static void
+stagFlush ()
+{
+    int i;
+
+    if (staglen > 0) {
+	sbinheader (staglen, stagaddr);
+	for (i = 0; i < staglen; i++) {
+	    if (i > 0 && i % CHECKLENGTH == 0)
+	      fputc (-chksum, stagfp);	/* intermediate checksum */
+	    putc (stagbuf[i], stagfp);
+	    chksum += stagbuf[i];
+	}
+	fputc (-chksum, stagfp);	/* final checksum */
+	staglen = 0;
+    }
+}
+
+void
+StagStart (FILE *fp, unsigned long ep)
+{
+    stagbuf = (char *) xmalloc (BUFSIZE);
+    stagfp = fp;
+}
+
+
+void
+StagOutput (unsigned long addr, unsigned char byte)
+{
+    if (addr != stagaddr + staglen || staglen == BUFSIZE) {
+	stagFlush ();
+	stagaddr = addr;
+    }
+    stagbuf[staglen++] = byte;
+}
+
+
+void
+StagEnd (unsigned long ep)
+{
+    stagFlush ();
+
+    /* terminating null block */
+    sbinheader (0, 0);		/* header */
+    fputc (0, stagfp);		/* checksum */
+    free (stagbuf);
+}
+
--- /dev/null
+++ b/convert/sysdep.h
@@ -0,0 +1,114 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+
+#ifndef HAVE_STRCHR
+# define strchr index
+# define strrchr rindex
+#endif
+
+#if HAVE_STRING_H
+# include <string.h>
+#else
+char *strchr(), *strrchr();
+#endif
+
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+
+#ifndef HAVE_MEMCPY
+#  define memcpy(d, s, n) bcopy ((s), (d), (n))
+#  define memmove(d, s, n) bcopy ((s), (d), (n))
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <sys/types.h>
+#include <unistd.h>
+#endif
+
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#else
+#ifdef HAVE_SYS_FILE_H
+#include <sys/file.h>
+#endif
+#endif
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif
+
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+
+#if defined(__GNUC__) && !defined(C_ALLOCA)
+# undef alloca
+# define alloca __builtin_alloca
+#else
+# if defined(HAVE_ALLOCA_H) && !defined(C_ALLOCA)
+#  include <alloca.h>
+# else
+#  ifndef alloca /* predefined by HP cc +Olibcalls */
+#   if !defined (__STDC__) && !defined (__hpux)
+char *alloca ();
+#   else
+void *alloca ();
+#   endif /* __STDC__, __hpux */
+#  endif /* alloca */
+# endif /* HAVE_ALLOCA_H */
+#endif
+
+#ifdef NEED_DECLARATION_MALLOC
+extern void *malloc (size_t);
+#endif
+#ifdef NEED_DECLARATION_REALLOC
+extern void *realloc (void *, size_t);
+#endif
+#ifdef NEED_DECLARATION_FREE
+extern void free (void *);
+#endif
+#ifdef NEED_DECLARATION_STRTOK
+extern char *strtok (char *, const char *);
+#endif
+
+#ifdef USE_BINARY_FOPEN
+#define FOPEN_RB	"rb"
+#define FOPEN_WB 	"wb"
+#define FOPEN_AB 	"ab"
+#define FOPEN_RUB 	"r+b"
+#define FOPEN_WUB 	"w+b"
+#define FOPEN_AUB 	"a+b"
+#else
+#define FOPEN_RB	"r"
+#define FOPEN_WB 	"w"
+#define FOPEN_AB 	"a"
+#define FOPEN_RUB 	"r+"
+#define FOPEN_WUB 	"w+"
+#define FOPEN_AUB 	"a+"
+#endif
+
+#define FOPEN_RT	"r"
+#define FOPEN_WT 	"w"
+#define FOPEN_AT 	"a"
+#define FOPEN_RUT 	"r+"
+#define FOPEN_WUT 	"w+"
+#define FOPEN_AUT 	"a+"
+
+/* local utility functions */
+extern void * xmalloc (size_t);
--- /dev/null
+++ b/convert/version.h
@@ -0,0 +1,7 @@
+#ifndef CONVERT_VERSION_H
+#define CONVERT_VERSION_H 1
+
+#define CONVERT_PKGVERSION @conv_version_package@
+#define CONVERT_REPORT_BUGS_TO @report_bugs_to@
+
+#endif
--- a/gas/config/m68k-parse.h
+++ b/gas/config/m68k-parse.h
@@ -101,6 +101,7 @@ enum m68k_register
   CACR,
   VBR,
   CAAR,
+  CPUCR,
   MSP,
   ITT0,
   ITT1,
--- a/gas/config/tc-arm.c
+++ b/gas/config/tc-arm.c
@@ -25,10 +25,10 @@
    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
+#include "as.h"
 #include <limits.h>
 #include <stdarg.h>
 #define	 NO_RELOC 0
-#include "as.h"
 #include "safe-ctype.h"
 #include "subsegs.h"
 #include "obstack.h"
@@ -199,6 +199,8 @@ static const arm_feature_set arm_ext_div
 static const arm_feature_set arm_ext_v7 = ARM_FEATURE (ARM_EXT_V7, 0);
 static const arm_feature_set arm_ext_v7a = ARM_FEATURE (ARM_EXT_V7A, 0);
 static const arm_feature_set arm_ext_v7r = ARM_FEATURE (ARM_EXT_V7R, 0);
+static const arm_feature_set arm_ext_marvell_f =
+  ARM_FEATURE (0, ARM_CEXT_MARVELL_F);
 static const arm_feature_set arm_ext_m =
   ARM_FEATURE (ARM_EXT_V6M | ARM_EXT_V7M, 0);
 
@@ -261,6 +263,9 @@ symbolS * GOT_symbol;
       instructions.  */
 static int thumb_mode = 0;
 
+/* Enables/disables automatic IT insn insertion mode. */
+static int do_automatic_it = 0;
+
 /* If unified_syntax is true, we are processing the new unified
    ARM/Thumb syntax.  Important differences from the old ARM mode:
 
@@ -311,6 +316,18 @@ struct neon_type
   unsigned elems;
 };
 
+enum it_instruction_type
+{
+   OUTSIDE_IT_INSN,
+   INSIDE_IT_INSN,
+   INSIDE_IT_LAST_INSN,
+   IF_INSIDE_IT_LAST_INSN, /* Either outside or inside;
+                              if inside, should be the last one.  */
+   NEUTRAL_IT_INSN,        /* This could be either inside or outside,
+                              i.e. BKPT and NOP.  */
+   IT_INSN                 /* The IT insn has been parsed.  */
+};
+
 struct arm_it
 {
   const char *	error;
@@ -333,6 +350,8 @@ struct arm_it
     int			     pc_rel;
   } reloc;
 
+  enum it_instruction_type it_insn_type;
+
   struct
   {
     unsigned reg;
@@ -670,6 +689,9 @@ struct asm_opcode
 #define BAD_BRANCH	_("branch must be last instruction in IT block")
 #define BAD_NOT_IT	_("instruction not allowed in IT block")
 #define BAD_FPU		_("selected FPU does not support instruction")
+#define BAD_OUT_IT  _("thumb conditional instruction should be in IT block")
+#define BAD_IT_COND _("incorrect condition in IT block")
+#define BAD_IT_IT   _("IT falling in the range of a previous IT block")
 
 static struct hash_control *arm_ops_hsh;
 static struct hash_control *arm_cond_hsh;
@@ -691,7 +713,7 @@ static struct hash_control *arm_barrier_
 
 symbolS *  last_label_seen;
 static int label_is_thumb_function_name = FALSE;
-
+
 /* Literal pool structure.  Held on a per-section
    and per-sub-section basis.  */
 
@@ -711,9 +733,58 @@ typedef struct literal_pool
 literal_pool * list_of_pools = NULL;
 
 /* State variables for IT block handling.  */
-static bfd_boolean current_it_mask = 0;
-static int current_cc;
-
+enum it_state
+{
+  OUTSIDE_IT_BLOCK, MANUAL_IT_BLOCK, AUTOMATIC_IT_BLOCK
+};
+struct current_it
+{
+  int mask;
+  enum it_state state;
+  int cc;
+  int block_length;
+  char *insn;
+  int state_handled;
+};
+
+static struct current_it current_it;
+
+static inline int
+current_it_compatible (int cond)
+{
+  return (cond & ~1) == (current_it.cc & ~1);
+}
+
+static inline int
+conditional_insn(void)
+{
+  return inst.cond != COND_ALWAYS;
+}
+
+static int
+in_it_block (void);
+
+static int
+handle_it_state (void);
+
+static void
+force_automatic_it_block_close (void);
+
+#define set_it_insn_type(type)      \
+  do{                               \
+    inst.it_insn_type = type;       \
+    if (handle_it_state () == FAIL) \
+      return;                       \
+  }while(0)
+
+#define set_it_insn_type_last()                     \
+  do{                                               \
+    if (inst.cond == COND_ALWAYS)                   \
+      set_it_insn_type (IF_INSIDE_IT_LAST_INSN);    \
+    else                                            \
+      set_it_insn_type (INSIDE_IT_LAST_INSN);       \
+  }while(0)
+
 /* Pure syntax.	 */
 
 /* This array holds the chars that always start a comment.  If the
@@ -2210,7 +2281,13 @@ create_neon_reg_alias (char *newname, ch
         }
     }
 
+#ifdef TC_CASE_SENSITIVE
   namelen = nameend - newname;
+#else
+  newname = original_case_string;
+  namelen = strlen (newname);
+#endif
+
   namebuf = alloca (namelen + 1);
   strncpy (namebuf, newname, namelen);
   namebuf[namelen] = '\0';
@@ -2348,20 +2425,15 @@ s_unreq (int a ATTRIBUTE_UNUSED)
 
 static enum mstate mapstate = MAP_UNDEFINED;
 
-void
-mapping_state (enum mstate state)
+/* Create a new mapping symbol for the transition to STATE.  */
+
+static void
+make_mapping_symbol (enum mstate state, valueT value, fragS *frag)
 {
   symbolS * symbolP;
   const char * symname;
   int type;
 
-  if (mapstate == state)
-    /* The mapping symbol has already been emitted.
-       There is nothing else to do.  */
-    return;
-
-  mapstate = state;
-
   switch (state)
     {
     case MAP_DATA:
@@ -2376,16 +2448,11 @@ mapping_state (enum mstate state)
       symname = "$t";
       type = BSF_NO_FLAGS;
       break;
-    case MAP_UNDEFINED:
-      return;
     default:
       abort ();
     }
 
-  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
-
-  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
-  symbol_table_insert (symbolP);
+  symbolP = symbol_new (symname, now_seg, value, frag);
   symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
 
   switch (state)
@@ -2404,11 +2471,84 @@ mapping_state (enum mstate state)
 
     case MAP_DATA:
     default:
-      return;
+      break;
     }
+
+  /* Save the mapping symbols for future reference.  Also check that
+     we do not place two mapping symbols at the same offset within a
+     frag.  We'll handle overlap between frags in
+     check_mapping_symbols.  */
+  if (value == 0)
+    {
+      know (frag->tc_frag_data.first_map == NULL);
+      frag->tc_frag_data.first_map = symbolP;
+    }
+  if (frag->tc_frag_data.last_map != NULL)
+    know (S_GET_VALUE (frag->tc_frag_data.last_map) < S_GET_VALUE (symbolP));
+  frag->tc_frag_data.last_map = symbolP;
+}
+
+/* We must sometimes convert a region marked as code to data during
+   code alignment, if an odd number of bytes have to be padded.  The
+   code mapping symbol is pushed to an aligned address.  */
+
+static void
+insert_data_mapping_symbol (enum mstate state,
+			    valueT value, fragS *frag, offsetT bytes)
+{
+  /* If there was already a mapping symbol, remove it.  */
+  if (frag->tc_frag_data.last_map != NULL
+      && S_GET_VALUE (frag->tc_frag_data.last_map) == frag->fr_address + value)
+    {
+      symbolS *symp = frag->tc_frag_data.last_map;
+
+      if (value == 0)
+	{
+	  know (frag->tc_frag_data.first_map == symp);
+	  frag->tc_frag_data.first_map = NULL;
+	}
+      frag->tc_frag_data.last_map = NULL;
+      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
+    }
+
+  make_mapping_symbol (MAP_DATA, value, frag);
+  make_mapping_symbol (state, value + bytes, frag);
+}
+
+/* Set the mapping state to STATE.  Only call this when about to
+   emit some STATE bytes to the file.  */
+
+void
+mapping_state (enum mstate state)
+{
+  if (mapstate == state)
+    /* The mapping symbol has already been emitted.
+       There is nothing else to do.  */
+    return;
+
+  mapstate = state;
+  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
+  make_mapping_symbol (state, (valueT) frag_now_fix (), frag_now);
+}
+
+/* Same as mapping_state, but MAX_CHARS bytes have already been
+   allocated.  Put the mapping symbol that far back.  */
+
+static void
+mapping_state_2 (enum mstate state, int max_chars)
+{
+  if (mapstate == state)
+    /* The mapping symbol has already been emitted.
+       There is nothing else to do.  */
+    return;
+
+  mapstate = state;
+  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
+  make_mapping_symbol (state, (valueT) frag_now_fix () - max_chars, frag_now);
 }
 #else
 #define mapping_state(x) /* nothing */
+#define mapping_state_2(x, y) /* nothing */
 #endif
 
 /* Find the real, Thumb encoded start of a Thumb function.  */
@@ -2462,7 +2602,6 @@ opcode_select (int width)
 	     coming from ARM mode, which is word-aligned.  */
 	  record_alignment (now_seg, 1);
 	}
-      mapping_state (MAP_THUMB);
       break;
 
     case 32:
@@ -2478,7 +2617,6 @@ opcode_select (int width)
 
 	  record_alignment (now_seg, 1);
 	}
-      mapping_state (MAP_ARM);
       break;
 
     default:
@@ -2717,7 +2855,10 @@ s_bss (int ignore ATTRIBUTE_UNUSED)
      marking in_bss, then looking at s_skip for clues.	*/
   subseg_set (bss_section, 0);
   demand_empty_rest_of_line ();
-  mapping_state (MAP_DATA);
+
+#ifdef md_elf_section_change_hook
+  md_elf_section_change_hook ();
+#endif
 }
 
 static void
@@ -6114,7 +6255,7 @@ parse_operands (char *str, const unsigne
 #undef po_reg_or_goto
 #undef po_imm_or_fail
 #undef po_scalar_or_fail
-
+
 /* Shorthand macro for instruction encoding functions issuing errors.  */
 #define constraint(expr, err) do {		\
   if (expr)					\
@@ -6136,6 +6277,14 @@ parse_operands (char *str, const unsigne
      }							\
   while (0)
 
+/* If REG is R13 (the stack pointer), warn that its use is
+   deprecated.  */
+#define warn_deprecated_sp(reg)			\
+  do						\
+    if (warn_on_deprecated && reg == REG_SP)	\
+       as_warn (_("use of r13 is deprecated"));	\
+  while (0)
+
 /* Functions for operand encoding.  ARM, then Thumb.  */
 
 #define rotate_left(v, n) (v << n | v >> (32 - n))
@@ -7304,11 +7453,14 @@ do_mull (void)
 static void
 do_nop (void)
 {
-  if (inst.operands[0].present)
+  if (inst.operands[0].present
+      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6k))
     {
       /* Architectural NOP hints are CPSR sets with no bits selected.  */
       inst.instruction &= 0xf0000000;
-      inst.instruction |= 0x0320f000 + inst.operands[0].imm;
+      inst.instruction |= 0x0320f000;
+      if (inst.operands[0].present)
+	inst.instruction |= inst.operands[0].imm;
     }
 }
 
@@ -8468,6 +8620,9 @@ do_t_add_sub (void)
 	? inst.operands[1].reg    /* Rd, Rs, foo */
 	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
 
+  if (Rd == REG_PC)
+    set_it_insn_type_last ();
+
   if (unified_syntax)
     {
       bfd_boolean flags;
@@ -8477,9 +8632,9 @@ do_t_add_sub (void)
       flags = (inst.instruction == T_MNEM_adds
 	       || inst.instruction == T_MNEM_subs);
       if (flags)
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
       if (!inst.operands[2].isreg)
 	{
 	  int add;
@@ -8731,9 +8886,9 @@ do_t_arit3 (void)
 
 	  /* See if we can do this with a 16-bit instruction.  */
 	  if (THUMB_SETS_FLAGS (inst.instruction))
-	    narrow = current_it_mask == 0;
+	    narrow = !in_it_block ();
 	  else
-	    narrow = current_it_mask != 0;
+	    narrow = in_it_block ();
 
 	  if (Rd > 7 || Rn > 7 || Rs > 7)
 	    narrow = FALSE;
@@ -8819,9 +8974,9 @@ do_t_arit3c (void)
 
 	  /* See if we can do this with a 16-bit instruction.  */
 	  if (THUMB_SETS_FLAGS (inst.instruction))
-	    narrow = current_it_mask == 0;
+	    narrow = !in_it_block ();
 	  else
-	    narrow = current_it_mask != 0;
+	    narrow = in_it_block ();
 
 	  if (Rd > 7 || Rn > 7 || Rs > 7)
 	    narrow = FALSE;
@@ -8974,7 +9129,8 @@ do_t_bfx (void)
 static void
 do_t_blx (void)
 {
-  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
+  set_it_insn_type_last ();
+
   if (inst.operands[0].isreg)
     {
       constraint (inst.operands[0].reg == REG_PC, BAD_PC);
@@ -8985,12 +9141,7 @@ do_t_blx (void)
     {
       /* No register.  This must be BLX(1).  */
       inst.instruction = 0xf000e800;
-#ifdef OBJ_ELF
-      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
-	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH23;
-      else
-#endif
-	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BLX;
+      inst.reloc.type = BFD_RELOC_THUMB_PCREL_BLX;
       inst.reloc.pc_rel = 1;
     }
 }
@@ -9001,13 +9152,14 @@ do_t_branch (void)
   int opcode;
   int cond;
 
-  if (current_it_mask)
+  cond = inst.cond;
+  set_it_insn_type (IF_INSIDE_IT_LAST_INSN);
+
+  if (in_it_block ())
     {
       /* Conditional branches inside IT blocks are encoded as unconditional
          branches.  */
       cond = COND_ALWAYS;
-      /* A branch must be the last instruction in an IT block.  */
-      constraint (current_it_mask != 0x10, BAD_BRANCH);
     }
   else
     cond = inst.cond;
@@ -9057,13 +9209,14 @@ do_t_bkpt (void)
       constraint (inst.operands[0].imm > 255,
 		  _("immediate value out of range"));
       inst.instruction |= inst.operands[0].imm;
+      set_it_insn_type (NEUTRAL_IT_INSN);
     }
 }
 
 static void
 do_t_branch23 (void)
 {
-  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
+  set_it_insn_type_last ();
   inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
   inst.reloc.pc_rel = 1;
 
@@ -9082,7 +9235,7 @@ do_t_branch23 (void)
 static void
 do_t_bx (void)
 {
-  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
+  set_it_insn_type_last ();
   inst.instruction |= inst.operands[0].reg << 3;
   /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
      should cause the alignment to be checked once it is known.	 This is
@@ -9094,7 +9247,7 @@ do_t_bxj (void)
 {
   int Rm;
 
-  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
+  set_it_insn_type_last ();
   Rm = inst.operands[0].reg;
   reject_bad_reg (Rm);
   inst.instruction |= Rm << 16;
@@ -9120,14 +9273,14 @@ do_t_clz (void)
 static void
 do_t_cps (void)
 {
-  constraint (current_it_mask, BAD_NOT_IT);
+  set_it_insn_type (OUTSIDE_IT_INSN);
   inst.instruction |= inst.operands[0].imm;
 }
 
 static void
 do_t_cpsi (void)
 {
-  constraint (current_it_mask, BAD_NOT_IT);
+  set_it_insn_type (OUTSIDE_IT_INSN);
   if (unified_syntax
       && (inst.operands[1].present || inst.size_req == 4)
       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6_notm))
@@ -9174,7 +9327,7 @@ do_t_cpy (void)
 static void
 do_t_cbz (void)
 {
-  constraint (current_it_mask, BAD_NOT_IT);
+  set_it_insn_type (OUTSIDE_IT_INSN);
   constraint (inst.operands[0].reg > 7, BAD_HIREG);
   inst.instruction |= inst.operands[0].reg;
   inst.reloc.pc_rel = 1;
@@ -9188,6 +9341,17 @@ do_t_dbg (void)
 }
 
 static void
+do_marvell_div (void)
+{
+  /* Encode SDIV or UDIV instructions using the special Marvell
+     encoding utilizing MRC.  */
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+}
+
+static void
 do_t_div (void)
 {
   unsigned Rd, Rn, Rm;
@@ -9220,9 +9384,9 @@ do_t_it (void)
 {
   unsigned int cond = inst.operands[0].imm;
 
-  constraint (current_it_mask, BAD_NOT_IT);
-  current_it_mask = (inst.instruction & 0xf) | 0x10;
-  current_cc = cond;
+  set_it_insn_type (IT_INSN);
+  current_it.mask = (inst.instruction & 0xf) | 0x10;
+  current_it.cc = cond;
 
   /* If the condition is a negative condition, invert the mask.  */
   if ((cond & 0x1) == 0x0)
@@ -9257,9 +9421,13 @@ encode_thumb2_ldmstm (int base, unsigned
     inst.error =  _("SP not allowed in register list");
   if (load)
     {
-      if (mask & (1 << 14)
-	  && mask & (1 << 15))
-	inst.error = _("LR and PC should not both be in register list");
+      if (mask & (1 << 15))
+        {
+          if (mask & (1 << 14))
+            inst.error = _("LR and PC should not both be in register list");
+          else
+            set_it_insn_type_last ();
+        }
 
       if ((mask & (1 << base)) != 0
 	  && writeback)
@@ -9435,6 +9603,13 @@ do_t_ldst (void)
   unsigned long opcode;
   int Rn;
 
+  if (inst.operands[0].isreg
+      && !inst.operands[0].preind
+      && inst.operands[0].reg == REG_PC)
+    {
+      set_it_insn_type_last ();
+    }
+
   opcode = inst.instruction;
   if (unified_syntax)
     {
@@ -9655,6 +9830,9 @@ do_t_mov_cmp (void)
   Rn = inst.operands[0].reg;
   Rm = inst.operands[1].reg;
 
+  if (Rn == REG_PC)
+    set_it_insn_type_last ();
+
   if (unified_syntax)
     {
       int r0off = (inst.instruction == T_MNEM_mov
@@ -9665,7 +9843,7 @@ do_t_mov_cmp (void)
 
       low_regs = (Rn <= 7 && Rm <= 7);
       opcode = inst.instruction;
-      if (current_it_mask)
+      if (in_it_block ())
 	narrow = opcode != T_MNEM_movs;
       else
 	narrow = opcode != T_MNEM_movs || low_regs;
@@ -9686,7 +9864,18 @@ do_t_mov_cmp (void)
       if (opcode == T_MNEM_cmp)
 	{
 	  constraint (Rn == REG_PC, BAD_PC);
-	  reject_bad_reg (Rm);
+	  if (narrow)
+	    {
+	      /* In the Thumb-2 ISA, use of R13 as Rm is deprecated,
+		 but valid.  */
+	      warn_deprecated_sp (Rm);
+	      /* R15 was documented as a valid choice for Rm in ARMv6,
+		 but as UNPREDICTABLE in ARMv7.  ARM's proprietary
+		 tools reject R15, so we do too.  */
+	      constraint (Rm == REG_PC, BAD_PC);
+	    }
+	  else
+	    reject_bad_reg (Rm);
 	}
       else if (opcode == T_MNEM_mov
 	       || opcode == T_MNEM_movs)
@@ -9709,7 +9898,7 @@ do_t_mov_cmp (void)
       if (!inst.operands[1].isreg)
 	{
 	  /* Immediate operand.  */
-	  if (current_it_mask == 0 && opcode == T_MNEM_mov)
+	  if (!in_it_block () && opcode == T_MNEM_mov)
 	    narrow = 0;
 	  if (low_regs && narrow)
 	    {
@@ -9735,7 +9924,7 @@ do_t_mov_cmp (void)
 	  /* Register shifts are encoded as separate shift instructions.  */
 	  bfd_boolean flags = (inst.instruction == T_MNEM_movs);
 
-	  if (current_it_mask)
+	  if (in_it_block ())
 	    narrow = !flags;
 	  else
 	    narrow = flags;
@@ -9791,7 +9980,7 @@ do_t_mov_cmp (void)
 	      && (inst.instruction == T_MNEM_mov
 		  || inst.instruction == T_MNEM_movs))
 	    {
-	      if (current_it_mask)
+	      if (in_it_block ())
 		narrow = (inst.instruction == T_MNEM_mov);
 	      else
 		narrow = (inst.instruction == T_MNEM_movs);
@@ -9953,9 +10142,9 @@ do_t_mvn_tst (void)
       else if (inst.instruction == T_MNEM_cmn)
 	narrow = TRUE;
       else if (THUMB_SETS_FLAGS (inst.instruction))
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
 
       if (!inst.operands[1].isreg)
 	{
@@ -10094,9 +10283,9 @@ do_t_mul (void)
 	  || Rm > 7)
 	narrow = FALSE;
       else if (inst.instruction == T_MNEM_muls)
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
     }
   else
     {
@@ -10162,6 +10351,8 @@ do_t_mull (void)
 static void
 do_t_nop (void)
 {
+  set_it_insn_type(NEUTRAL_IT_INSN);
+
   if (unified_syntax)
     {
       if (inst.size_req == 4 || inst.operands[0].imm > 15)
@@ -10198,9 +10389,9 @@ do_t_neg (void)
       bfd_boolean narrow;
 
       if (THUMB_SETS_FLAGS (inst.instruction))
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
       if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
 	narrow = FALSE;
       if (inst.size_req == 4)
@@ -10424,9 +10615,9 @@ do_t_rsb (void)
       bfd_boolean narrow;
 
       if ((inst.instruction & 0x00100000) != 0)
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
 
       if (Rd > 7 || Rs > 7)
 	narrow = FALSE;
@@ -10460,7 +10651,7 @@ do_t_rsb (void)
 static void
 do_t_setend (void)
 {
-  constraint (current_it_mask, BAD_NOT_IT);
+  set_it_insn_type (OUTSIDE_IT_INSN);
   if (inst.operands[0].imm)
     inst.instruction |= 0x8;
 }
@@ -10490,9 +10681,9 @@ do_t_shift (void)
 	}
 
       if (THUMB_SETS_FLAGS (inst.instruction))
-	narrow = (current_it_mask == 0);
+	narrow = !in_it_block ();
       else
-	narrow = (current_it_mask != 0);
+	narrow = in_it_block ();
       if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
 	narrow = FALSE;
       if (!inst.operands[2].isreg && shift_kind == SHIFT_ROR)
@@ -10778,7 +10969,7 @@ do_t_tb (void)
   int half;
 
   half = (inst.instruction & 0x10) != 0;
-  constraint (current_it_mask && current_it_mask != 0x10, BAD_BRANCH);
+  set_it_insn_type_last ();
   constraint (inst.operands[0].immisreg,
 	      _("instruction requires register index"));
 
@@ -14410,6 +14601,28 @@ output_inst (const char * str)
   dwarf2_emit_insn (inst.size);
 }
 
+static char*
+output_it_inst (int cond, int mask, char* to)
+{
+  unsigned long instruction = 0xbf00;
+
+  mask &= 0xf;
+  instruction |= mask;
+  instruction |= cond << 4;
+
+  if (to == NULL)
+    {
+      to = frag_more (2);
+#ifdef OBJ_ELF
+      dwarf2_emit_insn (2);
+#endif
+    }
+
+  md_number_to_chars (to, instruction, 2);
+
+  return to;
+}
+
 /* Tag values used in struct asm_opcode's tag field.  */
 enum opcode_tag
 {
@@ -14655,6 +14868,301 @@ opcode_lookup (char **str)
   return 0;
 }
 
+/* Output an automatically inserted IT instruction. Initially this only covers 
+   a single instruction, but may be extended later. To simply cleanup at the end 
+   of a block we update the instruction as we go along.  */
+static void
+new_automatic_it_block (int cond)
+{
+  current_it.state = AUTOMATIC_IT_BLOCK;
+  current_it.mask = 0x18;
+  current_it.cc = cond;
+  current_it.block_length = 1;
+  current_it.insn = output_it_inst(cond, current_it.mask, NULL);
+}
+
+/* Close an automatic IT block.
+   See comments in new_automatic_it_block ().  */
+static void
+close_automatic_it_block (void)
+{
+  current_it.mask = 0x10;
+  current_it.block_length = 0;
+}
+
+/* Update the mask of the current automatically-generated IT
+   instruction. See comments in new_automatic_it_block ().  */
+static void
+current_it_add_mask (int cond)
+{
+#define CLEAR_BIT(value, nbit)  ((value) & ~(1 << (nbit)))
+#define SET_BIT_VALUE(value, bitvalue, nbit)  (CLEAR_BIT(value, nbit) \
+                                              | ((bitvalue) << (nbit)))
+
+  const int resulting_bit = (cond & 1);
+  current_it.mask &= 0xf;
+  current_it.mask = SET_BIT_VALUE (current_it.mask,
+                                   resulting_bit,
+                                  (5 - current_it.block_length));
+  current_it.mask = SET_BIT_VALUE (current_it.mask,
+                                   1,
+                                   ((5 - current_it.block_length) - 1) );
+  output_it_inst (current_it.cc, current_it.mask, current_it.insn);
+
+#undef CLEAR_BIT
+#undef SET_BIT_VALUE
+
+}
+
+/* The IT blocks handling machinery is accessed through the these functions:
+     it_fsm_pre_encode ()               from md_assemble ()
+     set_it_insn_type ()                optional, from the tencode functions
+     set_it_insn_type_last ()           ditto
+     in_it_block ()                     ditto
+     it_fsm_post_encode ()              from md_assemble ()
+     force_automatic_it_block_close ()  from label habdling functions
+
+   Rationale:
+     1) md_assemble () calls it_fsm_pre_encode () before calling tencode (),
+        initializing the IT insn type with a generic initial value depending
+        on the inst.condition.
+     2) During the tencode function, two things may happen:
+        a) The tencode function overrides the IT insn type by
+           calling either set_it_insn_type (type) or set_it_insn_type_last ().
+        b) The tencode function queries the IT block state by
+           calling in_it_block () (i.e. to determine narrow/wide mode).
+
+        Both set_it_insn_type and in_it_block run the internal FSM state
+        handling function (handle_it_state), because: a) setting the IT insn
+        type may incur in an invalid state (exiting the function),
+        and b) querying the state requires the FSM to be updated.
+        Specifically we want to avoid creating an IT block for conditional
+        branches, so it_fsm_pre_encode is actually a guess and we can't
+        determine whether an IT block is required until the tencode () routine
+        has decided what type of instruction this actually it.
+        Because of this, if set_it_insn_type and in_it_block have to be used,
+        set_it_insn_type has to be called first.
+
+        set_it_insn_type_last () is a wrapper of set_it_insn_type (type), that
+        determines the insn IT type depending on the inst.cond code.
+        When a tencode () routine encodes an instruction that can be
+        either outside an IT block, or, in the case of being inside, has to be
+        the last one, set_it_insn_type_last () will determine the proper
+        IT instruction type based on the inst.cond code. Otherwise,
+        set_it_insn_type can be called for overriding that logic or
+        for covering other cases.
+
+        Calling handle_it_state () may not transition the IT block state to
+        OUTSIDE_IT_BLOCK immediatelly, since the (current) state could be
+        still queried. Instead, if the FSM determines that the state should
+        be transitioned to OUTSIDE_IT_BLOCK, a flag is marked to be closed
+        after the tencode () function: that's what it_fsm_post_encode () does.
+
+        Since in_it_block () calls the state handling function to get an
+        updated state, an error may occur (due to invalid insns combination).
+        In that case, inst.error is set.
+        Therefore, inst.error has to be checked after the execution of
+        the tencode () routine.
+
+     3) Back in md_assemble(), it_fsm_post_encode () is called to commit
+        any pending state change (if any) that didn't take place in
+        handle_it_state () as explained above.  */
+
+static void
+it_fsm_pre_encode (void)
+{
+  if (inst.cond != COND_ALWAYS)
+    inst.it_insn_type = INSIDE_IT_INSN;
+  else
+    inst.it_insn_type = OUTSIDE_IT_INSN;
+
+  current_it.state_handled = 0;
+}
+
+/* IT state FSM handling function.  */
+static int
+handle_it_state (void)
+{
+  current_it.state_handled = 1;
+
+  switch(current_it.state)
+    {
+      case OUTSIDE_IT_BLOCK:
+        switch (inst.it_insn_type)
+          {
+            case OUTSIDE_IT_INSN:
+              break;
+
+            case INSIDE_IT_INSN:
+            case INSIDE_IT_LAST_INSN:
+              if (do_automatic_it)
+                {
+                  /* Automatically generate the IT instruction.  */
+                  new_automatic_it_block (inst.cond);
+                  if (inst.it_insn_type == INSIDE_IT_LAST_INSN)
+                    close_automatic_it_block ();
+                }
+              else
+                {
+                  inst.error = BAD_OUT_IT;
+                  return FAIL;
+                }
+              break;
+
+            case IF_INSIDE_IT_LAST_INSN:
+            case NEUTRAL_IT_INSN:
+              break;
+
+            case IT_INSN:
+              current_it.state = MANUAL_IT_BLOCK;
+              current_it.block_length = 0;
+              break;
+          }
+      break;
+
+      case AUTOMATIC_IT_BLOCK:
+          /* Three things may happen now:
+              a) We should increment current it block size;
+              b) We should close current it block (closing insn or 4 insns);
+              c) We should close current it block and start a new one (due
+                 to incompatible conditions or
+                 4 insns-length block reached).  */
+
+        switch (inst.it_insn_type)
+          {
+            case OUTSIDE_IT_INSN:
+              /* The closure of the block shall happen immediatelly,
+                 so any in_it_block () call reports the block as closed.  */
+              force_automatic_it_block_close ();
+              break;
+
+            case INSIDE_IT_INSN:
+            case INSIDE_IT_LAST_INSN:
+            case IF_INSIDE_IT_LAST_INSN:
+              current_it.block_length++;
+
+              if (current_it.block_length > 4
+                  || !current_it_compatible (inst.cond))
+                {
+                  force_automatic_it_block_close ();
+                  if (inst.it_insn_type != IF_INSIDE_IT_LAST_INSN)
+                    new_automatic_it_block (inst.cond);
+                }
+              else
+                {
+                  current_it_add_mask (inst.cond);
+                }
+
+              if (current_it.state == AUTOMATIC_IT_BLOCK
+		  && (inst.it_insn_type == INSIDE_IT_LAST_INSN
+		      || inst.it_insn_type == IF_INSIDE_IT_LAST_INSN))
+                close_automatic_it_block ();
+              break;
+
+            case NEUTRAL_IT_INSN:
+              current_it.block_length++;
+
+              if (current_it.block_length > 4)
+                  force_automatic_it_block_close ();
+              else
+                  current_it_add_mask (current_it.cc & 1);
+              break;
+
+            case IT_INSN:
+              close_automatic_it_block ();
+              current_it.state = MANUAL_IT_BLOCK;
+              break;
+          }
+        break;
+
+      case MANUAL_IT_BLOCK:
+        {
+          /* Check conditional suffixes.  */
+          const int cond = current_it.cc ^ ((current_it.mask >> 4) & 1) ^ 1;
+          int is_last;
+          current_it.mask <<= 1;
+          current_it.mask &= 0x1f;
+          is_last = (current_it.mask == 0x10);
+
+          switch (inst.it_insn_type)
+            {
+              case OUTSIDE_IT_INSN:
+                inst.error = BAD_NOT_IT;
+                return FAIL;
+
+              case INSIDE_IT_INSN:
+                if (cond != inst.cond)
+                  {
+                    inst.error = BAD_IT_COND;
+                    return FAIL;
+                  }
+                break;
+
+              case INSIDE_IT_LAST_INSN:
+              case IF_INSIDE_IT_LAST_INSN:
+                if (cond != inst.cond)
+                  {
+                    inst.error = BAD_IT_COND;
+                    return FAIL;
+                  }
+                if (!is_last)
+                  {
+                    inst.error = BAD_BRANCH;
+                    return FAIL;
+                  }
+                break;
+
+              case NEUTRAL_IT_INSN:
+                /* The BKPT instruction is unconditional even in an IT block.  */
+                break;
+
+              case IT_INSN:
+                inst.error = BAD_IT_IT;
+                return FAIL;
+            }
+        }
+      break;
+    }
+
+  return SUCCESS;
+}
+
+static void
+it_fsm_post_encode (void)
+{
+  int is_last;
+
+  if (!current_it.state_handled)
+    handle_it_state ();
+
+  is_last = (current_it.mask == 0x10);
+  if (is_last)
+    {
+      current_it.state = OUTSIDE_IT_BLOCK;
+      current_it.mask = 0;
+    }
+}
+
+static void
+force_automatic_it_block_close (void)
+{
+  if (current_it.state == AUTOMATIC_IT_BLOCK)
+    {
+      close_automatic_it_block ();
+      current_it.state = OUTSIDE_IT_BLOCK;
+      current_it.mask = 0;
+    }
+}
+
+static int
+in_it_block (void)
+{
+  if (!current_it.state_handled)
+    handle_it_state ();
+
+  return current_it.state != OUTSIDE_IT_BLOCK;
+}
+
 void
 md_assemble (char *str)
 {
@@ -14719,40 +15227,24 @@ md_assemble (char *str)
 	  /* Implicit require narrow instructions on Thumb-1.  This avoids
 	     relaxation accidentally introducing Thumb-2 instructions.  */
 	  if (opcode->tencode != do_t_blx && opcode->tencode != do_t_branch23
-	      && !ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr))
+	      && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
+		   || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
 	    inst.size_req = 2;
 	}
 
-      /* Check conditional suffixes.  */
-      if (current_it_mask)
-	{
-	  int cond;
-	  cond = current_cc ^ ((current_it_mask >> 4) & 1) ^ 1;
-	  current_it_mask <<= 1;
-	  current_it_mask &= 0x1f;
-	  /* The BKPT instruction is unconditional even in an IT block.  */
-	  if (!inst.error
-	      && cond != inst.cond && opcode->tencode != do_t_bkpt)
-	    {
-	      as_bad (_("incorrect condition in IT block"));
-	      return;
-	    }
-	}
-      else if (inst.cond != COND_ALWAYS && opcode->tencode != do_t_branch)
-	{
-	  as_bad (_("thumb conditional instruction not in IT block"));
-	  return;
-	}
-
       mapping_state (MAP_THUMB);
       inst.instruction = opcode->tvalue;
 
       if (!parse_operands (p, opcode->operands))
-	opcode->tencode ();
+        {
+          /* Prepare the it_insn_type for those encodings that don't set
+             it.  */
+          it_fsm_pre_encode ();
 
-      /* Clear current_it_mask at the end of an IT block.  */
-      if (current_it_mask == 0x10)
-	current_it_mask = 0;
+          opcode->tencode ();
+
+          it_fsm_post_encode ();
+        }
 
       if (!(inst.error || inst.relax))
 	{
@@ -14777,7 +15269,8 @@ md_assemble (char *str)
 	 This is overly pessimistic for relaxable instructions.  */
       if (((inst.size == 4 && (inst.instruction & 0xf800e800) != 0xf000e800)
 	   || inst.relax)
-	  && !ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr))
+	  && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
+	       || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
 	ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
 				arm_ext_v6t2);
     }
@@ -14847,6 +15340,8 @@ arm_frob_label (symbolS * sym)
   ARM_SET_INTERWORK (sym, support_interwork);
 #endif
 
+  force_automatic_it_block_close ();
+
   /* Note - do not allow local symbols (.Lxxx) to be labelled
      as Thumb functions.  This is because these labels, whilst
      they exist inside Thumb code, are not the entry points for
@@ -15834,11 +16329,14 @@ static const struct asm_opcode insns[] =
  TCE(tbb,       0, e8d0f000, 1, (TB), 0, t_tb),
  TCE(tbh,       0, e8d0f010, 1, (TB), 0, t_tb),
 
- /* Thumb-2 hardware division instructions (R and M profiles only).  */
+ /* Thumb-2 hardware division instructions (R and M profiles only) and
+    Marvell-specific encoding of sdiv and udiv as mrc.  */
 #undef THUMB_VARIANT
 #define THUMB_VARIANT &arm_ext_div
- TCE(sdiv,	0, fb90f0f0, 3, (RR, oRR, RR), 0, t_div),
- TCE(udiv,	0, fbb0f0f0, 3, (RR, oRR, RR), 0, t_div),
+#undef ARM_VARIANT
+#define ARM_VARIANT &arm_ext_marvell_f
+ TCE(sdiv,	e300690, fb90f0f0, 3, (RR, oRR, RR), marvell_div, t_div),
+ TCE(udiv,	e300610, fbb0f0f0, 3, (RR, oRR, RR), marvell_div, t_div),
 
  /* ARM V6M/V7 instructions.  */
 #undef ARM_VARIANT
@@ -17550,14 +18048,39 @@ md_section_align (segT	 segment ATTRIBUT
 void
 arm_handle_align (fragS * fragP)
 {
-  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
-  static char const thumb_noop[2] = { 0xc0, 0x46 };
-  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
-  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };
-
-  int bytes, fix, noop_size;
+  static char const arm_noop[2][2][4] =
+    {
+      {  /* ARMv1 */
+	{0x00, 0x00, 0xa0, 0xe1},  /* LE */
+	{0xe1, 0xa0, 0x00, 0x00},  /* BE */
+      },
+      {  /* ARMv6k */
+	{0x00, 0xf0, 0x20, 0xe3},  /* LE */
+	{0xe3, 0x20, 0xf0, 0x00},  /* BE */
+      },
+    };
+  static char const thumb_noop[2][2][2] =
+    {
+      {  /* Thumb-1 */
+	{0xc0, 0x46},  /* LE */
+	{0x46, 0xc0},  /* BE */
+      },
+      {  /* Thumb-2 */
+	{0x00, 0xbf},  /* LE */
+	{0xbf, 0x00}   /* BE */
+      }
+    };
+  static char const wide_thumb_noop[2][4] =
+    {  /* Wide Thumb-2 */
+      {0xaf, 0xf3, 0x00, 0x80},  /* LE */
+      {0xf3, 0xaf, 0x80, 0x00},  /* BE */
+    };
+  
+  unsigned bytes, fix, noop_size;
   char * p;
   const char * noop;
+  const char *narrow_noop = NULL;
+  enum mstate state;
 
   if (fragP->fr_type != rs_align_code)
     return;
@@ -17569,31 +18092,52 @@ arm_handle_align (fragS * fragP)
   if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
     bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
 
-  if (fragP->tc_frag_data)
+  if (fragP->tc_frag_data.thumb_mode)
     {
-      if (target_big_endian)
-	noop = thumb_bigend_noop;
+      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2))
+	{
+	  narrow_noop = thumb_noop[1][target_big_endian];
+	  noop = wide_thumb_noop[target_big_endian];
+	}
       else
-	noop = thumb_noop;
-      noop_size = sizeof (thumb_noop);
+	noop = thumb_noop[0][target_big_endian];
+      noop_size = 2;
+      state = MAP_THUMB;
     }
   else
     {
-      if (target_big_endian)
-	noop = arm_bigend_noop;
-      else
-	noop = arm_noop;
-      noop_size = sizeof (arm_noop);
+      noop = arm_noop[ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6k) != 0]
+		     [target_big_endian];
+      noop_size = 4;
+      state = MAP_ARM;
     }
-
+  
+  fragP->fr_var = noop_size;
+  
   if (bytes & (noop_size - 1))
     {
       fix = bytes & (noop_size - 1);
+      insert_data_mapping_symbol (state, fragP->fr_fix, fragP, fix);
       memset (p, 0, fix);
       p += fix;
       bytes -= fix;
     }
 
+  if (narrow_noop)
+    {
+      if (bytes & noop_size)
+	{
+	  /* Insert a narrow noop.  */
+	  memcpy (p, narrow_noop, noop_size);
+	  p += noop_size;
+	  bytes -= noop_size;
+	  fix += noop_size;
+	}
+
+      /* Use wide noops for the remainder */
+      noop_size = 4;
+    }
+
   while (bytes >= noop_size)
     {
       memcpy (p, noop, noop_size);
@@ -17603,7 +18147,6 @@ arm_handle_align (fragS * fragP)
     }
 
   fragP->fr_fix += fix;
-  fragP->fr_var = noop_size;
 }
 
 /* Called from md_do_align.  Used to create an alignment
@@ -17615,9 +18158,15 @@ arm_frag_align_code (int n, int max)
   char * p;
 
   /* We assume that there will never be a requirement
-     to support alignments greater than 32 bytes.  */
+     to support alignments greater than [MAX_MEM_FOR_RS_ALIGN_CODE] bytes.  */
   if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
-    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
+    {
+      char err_msg[128];
+      sprintf (err_msg, 
+        _("alignments greater than %d bytes not supported in .text sections."),
+        MAX_MEM_FOR_RS_ALIGN_CODE + 1);
+      as_fatal (err_msg);
+    }
 
   p = frag_var (rs_align_code,
 		MAX_MEM_FOR_RS_ALIGN_CODE,
@@ -17632,10 +18181,26 @@ arm_frag_align_code (int n, int max)
 /* Perform target specific initialisation of a frag.  */
 
 void
-arm_init_frag (fragS * fragP)
+arm_init_frag (fragS * fragP, int max_chars)
 {
   /* Record whether this frag is in an ARM or a THUMB area.  */
-  fragP->tc_frag_data = thumb_mode;
+  fragP->tc_frag_data.thumb_mode = thumb_mode;
+
+  /* Record a mapping symbol for alignment frags.  We will delete this
+     later if the alignment ends up empty.  */
+  switch (fragP->fr_type)
+    {
+    case rs_align:
+    case rs_align_test:
+    case rs_fill:
+      mapping_state_2 (MAP_DATA, max_chars);
+      break;
+    case rs_align_code:
+      mapping_state_2 (thumb_mode ? MAP_THUMB : MAP_ARM, max_chars);
+      break;
+    default:
+      break;
+    }
 }
 
 #ifdef OBJ_ELF
@@ -18127,9 +18692,13 @@ md_pcrel_from_section (fixS * fixP, segT
     case BFD_RELOC_THUMB_PCREL_BRANCH20:
     case BFD_RELOC_THUMB_PCREL_BRANCH23:
     case BFD_RELOC_THUMB_PCREL_BRANCH25:
-    case BFD_RELOC_THUMB_PCREL_BLX:
       return base + 4;
 
+      /* BLX is like branches above, but forces the low two bits of PC to
+	 zero.  */
+    case BFD_RELOC_THUMB_PCREL_BLX:
+      return (base + 4) & ~3;
+
       /* ARM mode branches are offset by +8.  However, the Windows CE
 	 loader expects the relocation not to take this into account.  */
     case BFD_RELOC_ARM_PCREL_BRANCH:
@@ -18499,6 +19068,15 @@ md_apply_fix (fixS *	fixP,
 	  break;
 	}
 
+      if (fixP->fx_addsy
+	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("symbol %s is in a different section"),
+			S_GET_NAME (fixP->fx_addsy));
+	  break;
+	}
+
       newimm = encode_arm_immediate (value);
       temp = md_chars_to_number (buf, INSN_SIZE);
 
@@ -18522,6 +19100,24 @@ md_apply_fix (fixS *	fixP,
 	unsigned int highpart = 0;
 	unsigned int newinsn  = 0xe1a00000; /* nop.  */
 
+	if (fixP->fx_addsy
+	    && ! S_IS_DEFINED (fixP->fx_addsy))
+	  {
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("undefined symbol %s used as an immediate value"),
+			  S_GET_NAME (fixP->fx_addsy));
+	    break;
+	  }
+
+	if (fixP->fx_addsy
+	    && S_GET_SEGMENT (fixP->fx_addsy) != seg)
+	  {
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("symbol %s is in a different section"),
+			  S_GET_NAME (fixP->fx_addsy));
+	    break;
+	  }
+
 	newimm = encode_arm_immediate (value);
 	temp = md_chars_to_number (buf, INSN_SIZE);
 
@@ -19624,7 +20220,6 @@ tc_gen_reloc (asection *section, fixS *f
     case BFD_RELOC_THUMB_PCREL_BRANCH20:
     case BFD_RELOC_THUMB_PCREL_BRANCH23:
     case BFD_RELOC_THUMB_PCREL_BRANCH25:
-    case BFD_RELOC_THUMB_PCREL_BLX:
     case BFD_RELOC_VTABLE_ENTRY:
     case BFD_RELOC_VTABLE_INHERIT:
 #ifdef TE_PE
@@ -19633,6 +20228,15 @@ tc_gen_reloc (asection *section, fixS *f
       code = fixp->fx_r_type;
       break;
 
+    case BFD_RELOC_THUMB_PCREL_BLX:
+#ifdef OBJ_ELF
+      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
+	code = BFD_RELOC_THUMB_PCREL_BRANCH23;
+      else
+#endif
+	code = BFD_RELOC_THUMB_PCREL_BLX;
+      break;
+
     case BFD_RELOC_ARM_LITERAL:
     case BFD_RELOC_ARM_HWLITERAL:
       /* If this is called then the a literal has
@@ -19992,6 +20596,73 @@ arm_cleanup (void)
     }
 }
 
+#ifdef OBJ_ELF
+/* Remove any excess mapping symbols generated for alignment frags in
+   SEC.  We may have created a mapping symbol before a zero byte
+   alignment; remove it if there's a mapping symbol after the
+   alignment.  */
+static void
+check_mapping_symbols (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
+		       void *dummy ATTRIBUTE_UNUSED)
+{
+  segment_info_type *seginfo = seg_info (sec);
+  fragS *fragp;
+
+  if (seginfo == NULL || seginfo->frchainP == NULL)
+    return;
+
+  for (fragp = seginfo->frchainP->frch_root;
+       fragp != NULL;
+       fragp = fragp->fr_next)
+    {
+      symbolS *sym = fragp->tc_frag_data.last_map;
+      fragS *next = fragp->fr_next;
+
+      /* Variable-sized frags have been converted to fixed size by
+	 this point.  But if this was variable-sized to start with,
+	 there will be a fixed-size frag after it.  So don't handle
+	 next == NULL.  */
+      if (sym == NULL || next == NULL)
+	continue;
+
+      if (S_GET_VALUE (sym) < next->fr_address)
+	/* Not at the end of this frag.  */
+	continue;
+      know (S_GET_VALUE (sym) == next->fr_address);
+
+      do
+	{
+	  if (next->tc_frag_data.first_map != NULL)
+	    {
+	      /* Next frag starts with a mapping symbol.  Discard this
+		 one.  */
+	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
+	      break;
+	    }
+
+	  if (next->fr_next == NULL)
+	    {
+	      /* This mapping symbol is at the end of the section.  Discard
+		 it.  */
+	      know (next->fr_fix == 0 && next->fr_var == 0);
+	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
+	      break;
+	    }
+
+	  /* As long as we have empty frags without any mapping symbols,
+	     keep looking.  */
+	  /* If the next frag is non-empty and does not start with a
+	     mapping symbol, then this mapping symbol is required.  */
+	  if (next->fr_address != next->fr_next->fr_address)
+	    break;
+
+	  next = next->fr_next;
+	}
+      while (next != NULL);
+    }
+}
+#endif
+
 /* Adjust the symbol table.  This marks Thumb symbols as distinct from
    ARM ones.  */
 
@@ -20066,6 +20737,9 @@ arm_adjust_symtab (void)
 	    }
 	}
     }
+
+  /* Remove any overlapping mapping symbols generated by alignment frags.  */
+  bfd_map_over_sections (stdoutput, check_mapping_symbols, (char *) 0);
 #endif
 }
 
@@ -20154,7 +20828,7 @@ md_begin (void)
     }
   else if (!mfpu_opt)
     {
-#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS))
+#if !(defined (EABI_DEFAULT) || defined (TE_NetBSD) || defined (TE_VXWORKS))
       /* Some environments specify a default FPU.  If they don't, infer it
 	 from the processor.  */
       if (mcpu_fpu_opt)
@@ -20414,6 +21088,8 @@ struct arm_option_table arm_opts[] =
   {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
   {"mthumb-interwork", N_("support ARM/Thumb interworking"),
    &support_interwork, 1, NULL},
+  {"mauto-it", N_("Enables/disables automatic IT insn insertion mode"),
+   &do_automatic_it, 1, NULL},
   {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
   {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
   {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
@@ -20660,6 +21336,7 @@ static const struct arm_cpu_option_table
                                                           NULL},
   {"cortex-r4",		ARM_ARCH_V7R,	 FPU_NONE,	  NULL},
   {"cortex-m3",		ARM_ARCH_V7M,	 FPU_NONE,	  NULL},
+  {"cortex-m0",		ARM_ARCH_V6M,	 FPU_NONE,	  NULL},
   {"cortex-m1",		ARM_ARCH_V6M,	 FPU_NONE,	  NULL},
   /* ??? XSCALE is really an architecture.  */
   {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL},
@@ -20669,6 +21346,8 @@ static const struct arm_cpu_option_table
   {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL},
   /* Maverick */
   {"ep9312",	ARM_FEATURE(ARM_AEXT_V4T, ARM_CEXT_MAVERICK), FPU_ARCH_MAVERICK, "ARM920T"},
+  /* Marvell */
+  {"marvell-f",         ARM_ARCH_MARVELL_F, FPU_ARCH_VFP_V2, NULL},
   {NULL,		ARM_ARCH_NONE,	 ARM_ARCH_NONE, NULL}
 };
 
@@ -20722,6 +21401,7 @@ static const struct arm_arch_option_tabl
   {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
   {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
   {"iwmmxt2",		ARM_ARCH_IWMMXT2,FPU_ARCH_VFP},
+  {"marvell-f",		ARM_ARCH_MARVELL_F,FPU_ARCH_VFP},
   {NULL,		ARM_ARCH_NONE,	 ARM_ARCH_NONE}
 };
 
--- a/gas/config/tc-arm.h
+++ b/gas/config/tc-arm.h
@@ -179,13 +179,27 @@ void arm_copy_symbol_attributes (symbolS
 
 #define TC_CONS_FIX_NEW cons_fix_new_arm
 
-#define MAX_MEM_FOR_RS_ALIGN_CODE 31
+#define MAX_MEM_ALIGNMENT_BYTES   6
+#define MAX_MEM_FOR_RS_ALIGN_CODE ((1 << MAX_MEM_ALIGNMENT_BYTES) - 1)
 
 /* For frags in code sections we need to record whether they contain
    ARM code or THUMB code.  This is that if they have to be aligned,
    they can contain the correct type of no-op instruction.  */
-#define TC_FRAG_TYPE		int
-#define TC_FRAG_INIT(fragp)	arm_init_frag (fragp)
+struct arm_frag_type
+{
+  int thumb_mode;
+#ifdef OBJ_ELF
+  /* If there is a mapping symbol at offset 0 in this frag,
+     it will be saved in FIRST_MAP.  If there are any mapping
+     symbols in this frag, the last one will be saved in
+     LAST_MAP.  */
+  symbolS *first_map, *last_map;
+#endif
+};
+
+#define TC_FRAG_TYPE		struct arm_frag_type
+/* NOTE: max_chars is a local variable from frag_var / frag_variant.  */
+#define TC_FRAG_INIT(fragp)	arm_init_frag (fragp, max_chars)
 #define HANDLE_ALIGN(fragp)	arm_handle_align (fragp)
 
 #define md_do_align(N, FILL, LEN, MAX, LABEL)					\
@@ -269,7 +283,7 @@ extern char * arm_canonicalize_symbol_na
 extern void arm_adjust_symtab (void);
 extern void armelf_frob_symbol (symbolS *, int *);
 extern void cons_fix_new_arm (fragS *, int, int, expressionS *);
-extern void arm_init_frag (struct frag *);
+extern void arm_init_frag (struct frag *, int);
 extern void arm_handle_align (struct frag *);
 extern bfd_boolean arm_fix_adjustable (struct fix *);
 extern int arm_elf_section_type (const char *, size_t);
--- a/gas/config/tc-m68k.c
+++ b/gas/config/tc-m68k.c
@@ -181,8 +181,8 @@ static const enum m68k_register mcf_ctrl
   RAMBAR0, RAMBAR1, RAMBAR, MBAR,
   0
 };
-static const enum m68k_register mcf51qe_ctrl[] = {
-  VBR,
+static const enum m68k_register mcf51_ctrl[] = {
+  VBR, CPUCR,
   0
 };
 static const enum m68k_register mcf5206_ctrl[] = {
@@ -210,13 +210,21 @@ static const enum m68k_register mcf52223
   0
 };
 static const enum m68k_register mcf52235_ctrl[] = {
-  VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
+  VBR, FLASHBAR, RAMBAR, RAMBAR1,
   0
 };
 static const enum m68k_register mcf5225_ctrl[] = {
   VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, MBAR, RAMBAR1,
   0
 };
+static const enum m68k_register mcf52259_ctrl[] = {
+  VBR, FLASHBAR, RAMBAR, RAMBAR1,
+  0
+};
+static const enum m68k_register mcf52277_ctrl[] = {
+  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
+  0
+};
 static const enum m68k_register mcf5235_ctrl[] = {
   VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
   0
@@ -249,8 +257,12 @@ static const enum m68k_register mcf5282_
   VBR, CACR, ACR0, ACR1, FLASHBAR, RAMBAR, RAMBAR1,
   0
 };
+static const enum m68k_register mcf53017_ctrl[] = {
+  VBR, CACR, ACR0, ACR1, RAMBAR, RAMBAR1,
+  0
+};
 static const enum m68k_register mcf5307_ctrl[] = {
-  CACR, ACR0, ACR1,  VBR, RAMBAR0, RAMBAR_ALT, MBAR,
+  VBR, CACR, ACR0, ACR1, RAMBAR0, RAMBAR_ALT, MBAR,
   0
 };
 static const enum m68k_register mcf5329_ctrl[] = {
@@ -525,6 +537,9 @@ static const struct m68k_cpu m68k_archs[
   {0,0,NULL, 0}
 };
 
+/* For -mno-mac we want to turn off all types of mac.  */
+static const unsigned no_mac = mcfmac | mcfemac;
+
 /* Architecture extensions, here 'alias' -1 for m68k, +1 for cf and 0
    for either.  */
 static const struct m68k_cpu m68k_extensions[] =
@@ -537,7 +552,7 @@ static const struct m68k_cpu m68k_extens
 
   {mcfhwdiv,					NULL, "div", 1},
   {mcfusp,					NULL, "usp", 1},
-  {mcfmac,					NULL, "mac", 1},
+  {mcfmac,					(void *)&no_mac, "mac", 1},
   {mcfemac,					NULL, "emac", 1},
 
   {0,NULL,NULL, 0}
@@ -579,7 +594,12 @@ static const struct m68k_cpu m68k_cpus[]
   {cpu32|m68881,				cpu32_ctrl, "68349", 1},
   {cpu32|m68881,				cpu32_ctrl, "68360", 1},
 
-  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51qe_ctrl, "51qe", 0},
+  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51", 0},
+  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51ac", 1},
+  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51cn", 1},
+  {mcfisa_a|mcfisa_c|mcfusp|mcfmac,  		mcf51_ctrl, "51em", 1},
+  {mcfisa_a|mcfisa_c|mcfusp,  			mcf51_ctrl, "51jm", 1},
+  {mcfisa_a|mcfisa_c|mcfusp,                    mcf51_ctrl, "51qe", 1},
 
   {mcfisa_a,					mcf_ctrl, "5200", 0},
   {mcfisa_a,					mcf_ctrl, "5202", 1},
@@ -613,6 +633,9 @@ static const struct m68k_cpu m68k_cpus[]
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5224", -1},
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfmac|mcfusp,   mcf5225_ctrl, "5225", 0},
 
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52277_ctrl, "52274", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,  mcf52277_ctrl, "52277", 0},
+  
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5232", -1},
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5233", -1},
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5235_ctrl, "5234", -1},
@@ -622,7 +645,14 @@ static const struct m68k_cpu m68k_cpus[]
   {mcfisa_a|mcfhwdiv|mcfemac,			mcf5249_ctrl, "5249", 0},
   {mcfisa_a|mcfhwdiv|mcfemac,			mcf5250_ctrl, "5250", 0},
   {mcfisa_a|mcfhwdiv|mcfemac, 			mcf5253_ctrl, "5253", 0},
-  
+
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52252", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52254", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52255", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52256", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52258", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf52259_ctrl, "52259", 0},
+   
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5270", -1},
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5271_ctrl, "5271", 0},
   
@@ -636,6 +666,14 @@ static const struct m68k_cpu m68k_cpus[]
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "5282", -1},
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5282_ctrl, "528x", 0},
   
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53011", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53012", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53013", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53014", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53015", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53016", -1},
+  {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf53017_ctrl, "53017", 0},
+  
   {mcfisa_a|mcfhwdiv|mcfmac,			mcf5307_ctrl, "5307", 0},
   
   {mcfisa_a|mcfisa_aa|mcfhwdiv|mcfemac|mcfusp,	mcf5329_ctrl, "5327", -1},
@@ -3275,6 +3313,7 @@ m68k_ip (char *instring)
 	      tmpreg = 0x801;
 	      break;
 	    case CAAR:
+	    case CPUCR:
 	      tmpreg = 0x802;
 	      break;
 	    case MSP:
@@ -4036,6 +4075,7 @@ static const struct init_entry init_tabl
   { "dfcr", DFC },
   { "cacr", CACR },		/* Cache Control Register.  */
   { "caar", CAAR },		/* Cache Address Register.  */
+  { "cpucr", CPUCR },		/* CPU Control Register.  */
 
   { "usp", USP },		/* User Stack Pointer.  */
   { "vbr", VBR },		/* Vector Base Register.  */
@@ -7407,7 +7447,8 @@ m68k_set_extension (char const *name, in
     }
 
   if (negated)
-    not_current_architecture |= ext->arch;
+    not_current_architecture |= (ext->control_regs
+				 ? *(unsigned *)ext->control_regs: ext->arch);
   else
     current_architecture |= ext->arch;
   return 1;
--- a/gas/config/tc-mips.c
+++ b/gas/config/tc-mips.c
@@ -73,6 +73,8 @@ static int mips_output_flavor (void) { r
 
 int mips_flag_mdebug = -1;
 
+static int octeon_use_unalign = 0;
+
 /* Control generation of .pdr sections.  Off by default on IRIX: the native
    linker doesn't know about and discards them, but relocations against them
    remain, leading to rld crashes.  */
@@ -391,6 +393,12 @@ static int mips_32bitmode = 0;
   ((ISA) == ISA_MIPS32R2		\
    || (ISA) == ISA_MIPS64R2)
 
+/* Return true if ISA supports ins instructions. */
+#define ISA_HAS_INS(ISA) ( \
+  (ISA) == ISA_MIPS32R2    \
+  || (ISA) == ISA_MIPS64R2 \
+  )
+
 #define HAVE_32BIT_GPRS		                   \
     (mips_opts.gp32 || !ISA_HAS_64BIT_REGS (mips_opts.isa))
 
@@ -653,18 +661,21 @@ static int mips_debug = 0;
 /* The maximum number of NOPs needed to avoid the VR4130 mflo/mfhi errata.  */
 #define MAX_VR4130_NOPS 4
 
+/* The number of MOVN.Ds needed to avoid the ICE9A errata.  */
+#define ICE9A_MOVNDS 5
+
 /* The maximum number of NOPs needed to fill delay slots.  */
 #define MAX_DELAY_NOPS 2
 
-/* The maximum number of NOPs needed for any purpose.  */
-#define MAX_NOPS 4
+/* The maximum number of insns needed for any purpose.  */
+#define MAX_HIST_INSNS 5
 
 /* A list of previous instructions, with index 0 being the most recent.
-   We need to look back MAX_NOPS instructions when filling delay slots
-   or working around processor errata.  We need to look back one
+   We need to look back MAX_HIST_INSNS instructions when filling delay
+   slots or working around processor errata.  We need to look back one
    instruction further if we're thinking about using history[0] to
    fill a branch delay slot.  */
-static struct mips_cl_insn history[1 + MAX_NOPS];
+static struct mips_cl_insn history[1 + MAX_HIST_INSNS];
 
 /* Nop instructions used by emit_nop.  */
 static struct mips_cl_insn nop_insn, mips16_nop_insn;
@@ -760,6 +771,12 @@ static int mips_fix_vr4120;
 /* ...likewise -mfix-vr4130.  */
 static int mips_fix_vr4130;
 
+/* ...likewise -mfix-ice9a.  */
+static int mips_fix_ice9a;
+
+/* ...likewise -mfix-24k.  */
+static int mips_fix_24k;
+
 /* We don't relax branches by default, since this causes us to expand
    `la .l2 - .l1' if there's a branch between .l1 and .l2, because we
    fail to compute the offset before expanding the macro to the most
@@ -1789,6 +1806,84 @@ reg_lookup (char **s, unsigned int types
   return reg >= 0;
 }
 
+#define INSN_ERET  0x42000018
+#define INSN_DERET 0x4200001f
+
+/*  Implement the ERET/DERET Errata for MIPS 24k.
+ 
+    If an ERET/DERET is encountered in a noreorder block,
+    warn if the ERET/DERET is followed by a branch instruction.
+    Also warn if the ERET/DERET is the last instruction in the 
+    noreorder block.
+
+    IF an ERET/DERET is in a reorder block and is followed by a
+    branch instruction, insert a nop.  */
+
+static void
+check_for_24k_errata (struct mips_cl_insn *insn, int eret_ndx)
+{
+  bfd_boolean next_insn_is_branch = FALSE;
+
+  /* eret_ndx will be -1 for the last instruction in a section.  */
+  if (insn
+      && eret_ndx == -1
+      && (insn->insn_opcode == INSN_ERET
+	  || insn->insn_opcode == INSN_DERET)
+      && insn->noreorder_p)
+    {
+      as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
+      return;
+    }
+   
+  if (history[eret_ndx].insn_opcode != INSN_ERET
+      && history[eret_ndx].insn_opcode != INSN_DERET)
+    return;
+
+  if (!insn)
+    {
+      if (history[eret_ndx].noreorder_p)
+	as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
+      return;
+    }
+
+  next_insn_is_branch = ((insn->insn_opcode == INSN_ERET)
+			 || (insn->insn_opcode == INSN_DERET)
+			 || (insn->insn_mo->pinfo
+			     & (INSN_UNCOND_BRANCH_DELAY
+				| INSN_COND_BRANCH_DELAY
+				| INSN_COND_BRANCH_LIKELY)));
+
+  if (next_insn_is_branch && history[eret_ndx].noreorder_p)
+    {
+      as_warn (_("ERET and DERET must be followed by a NOP on the 24K."));
+      return;
+    }
+
+  /* Emit nop if the next instruction is a branch.  */ 
+  if (next_insn_is_branch)
+    {
+      long nop_where, br_where;
+      struct frag *nop_frag, *br_frag;
+      struct mips_cl_insn br_insn, nop_insn;
+
+      emit_nop ();
+
+      nop_insn = history[eret_ndx - 1]; 
+      nop_frag = history[eret_ndx - 1].frag;
+      nop_where = history[eret_ndx - 1].where;
+
+      br_insn = history[eret_ndx];
+      br_frag = history[eret_ndx].frag;
+      br_where = history[eret_ndx].where;
+
+      move_insn (&nop_insn, br_frag, br_where);
+      move_insn (&br_insn, nop_frag, nop_where);
+
+      history[eret_ndx-1] = br_insn;
+      history[eret_ndx] = nop_insn;
+    }
+}
+
 /* Return TRUE if opcode MO is valid on the currently selected ISA and
    architecture.  If EXPANSIONP is TRUE then this check is done while
    expanding a macro.  Use is_opcode_valid_16 for MIPS16 opcodes.  */
@@ -1876,6 +1971,12 @@ md_begin (void)
 	as_bad (_("-G may not be used in position-independent code"));
       g_switch_value = 0;
     }
+  else if (mips_abicalls)
+    {
+      if (g_switch_seen && g_switch_value != 0)
+	as_bad (_("-G may not be used with abicalls"));
+      g_switch_value = 0;
+    }
 
   if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, file_mips_arch))
     as_warn (_("Could not set architecture and machine"));
@@ -2074,6 +2175,9 @@ md_begin (void)
 void
 md_mips_end (void)
 {
+  if (mips_fix_24k)
+    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);
+
   if (! ECOFF_DEBUGGING)
     md_obj_end ();
 }
@@ -2616,8 +2720,111 @@ nops_for_vr4130 (const struct mips_cl_in
   return 0;
 }
 
+/* Return true if the instruction called NAME is a double-precision
+   multiplication instruction placing an FP stall hazard needed
+   to be tackled with -mfix-ice9a.  */
+
+static bfd_boolean
+ice9a_fp_stall_hazard_p (const char *name)
+{
+  return (strcmp (name, "madd.d") == 0
+	  || strcmp (name, "msub.d") == 0
+	  || strcmp (name, "mul.d") == 0
+	  || strcmp (name, "nmadd.d") == 0
+	  || strcmp (name, "nmsub.d") == 0
+	  || strcmp (name, "recip.d") == 0
+	  || strcmp (name, "rsqrt.d") == 0);
+}
+
+/* Return true if the instruction called NAME is a double-precision
+   multiplication instruction placing an FP round hazard needed
+   to be tackled with -mfix-ice9a.  This happens to be a superset
+   of the above.  */
+
+static bfd_boolean
+ice9a_fp_round_hazard_p (const char *name)
+{
+  return (ice9a_fp_stall_hazard_p (name) || strcmp (name, "sqrt.d") == 0);
+}
+
+/* Return true if the instruction INSN is the "movn.d $f30, <reg>, $zero"
+   designated as the workaround for the purpose of -mfix-ice9a.  */
+
+static bfd_boolean
+ice9a_movnd_workaround_p (const struct mips_cl_insn *insn, unsigned int reg)
+{
+  return (strcmp (insn->insn_mo->name, "movn.d") == 0
+	  && EXTRACT_OPERAND (RT, *insn) == ZERO
+	  && EXTRACT_OPERAND (FS, *insn) == reg
+	  && EXTRACT_OPERAND (FD, *insn) == 30);
+}
+
+/* Return true if the instruction INSN accesses $f30 in any way.  */
+
+static bfd_boolean
+ice9a_insn_accesses_f30_p (const struct mips_cl_insn *insn)
+{
+  unsigned long pinfo;
+
+  pinfo = insn->insn_mo->pinfo;
+  return (((pinfo & (INSN_WRITE_FPR_S | INSN_READ_FPR_S)) != 0
+	   && (EXTRACT_OPERAND (FS, *insn) == 30))
+	  || ((pinfo & (INSN_WRITE_FPR_T | INSN_READ_FPR_T)) != 0
+	      && (EXTRACT_OPERAND (FT, *insn) == 30))
+	  || ((pinfo & INSN_WRITE_FPR_D) != 0
+	      && (EXTRACT_OPERAND (FD, *insn) == 30))
+	  || ((pinfo & INSN_READ_FPR_R) != 0
+	      && (EXTRACT_OPERAND (FR, *insn) == 30)));
+}
+
+/* Check for the ICE9A_MOVNDS MOVN.D instructions needed before and after
+   some FP instructions to work around the ICE9A errata.  Also check for
+   $f30 references other than the workaround.  */
+
+static void
+check_for_ice9a (const struct mips_cl_insn *history,
+		 const struct mips_cl_insn *insn)
+{
+  bfd_boolean f30_access_ok = FALSE;
+  int i;
+
+  if (ice9a_fp_round_hazard_p (history->insn_mo->name))
+    {
+      if (insn == NULL
+	  || (history->insn_mo->pinfo & INSN_WRITE_FPR_D) == 0
+	  || ! ice9a_movnd_workaround_p (insn, EXTRACT_OPERAND (FD, *history)))
+	as_bad (_("Hazardous instruction missing the ICE9A workaround"));
+      else
+	f30_access_ok = TRUE;
+    }
+
+  if (insn == NULL)
+    return;
+
+  if (ice9a_fp_stall_hazard_p (insn->insn_mo->name))
+    for (i = 0; i < ICE9A_MOVNDS; i++)
+      if (! ice9a_movnd_workaround_p (history + i, 28))
+	{
+	  as_bad (_("Hazardous instruction missing the ICE9A workaround"));
+	  break;
+	}
+
+  if (! f30_access_ok
+      && ! ice9a_movnd_workaround_p (insn, 28)
+      && ice9a_insn_accesses_f30_p (insn))
+    as_bad (_("Instruction used $f30, reserved for the ICE9A workaround"));
+}
+
+/* Check the last instruction assembled for the ICE9A errata workaround.  */
+
+void mips_cleanup (void)
+{
+  if (mips_fix_ice9a)
+    check_for_ice9a (history, NULL);
+}
+
 /* Return the number of nops that would be needed if instruction INSN
-   immediately followed the MAX_NOPS instructions given by HISTORY,
+   immediately followed the MAX_HIST_INSNS instructions given by HISTORY,
    where HISTORY[0] is the most recent instruction.  If INSN is null,
    return the worse-case number of nops for any instruction.  */
 
@@ -2643,6 +2850,9 @@ nops_for_insn (const struct mips_cl_insn
 	nops = tmp_nops;
     }
 
+  if (mips_fix_ice9a)
+    check_for_ice9a (history, insn);
+
   return nops;
 }
 
@@ -2654,13 +2864,13 @@ static int
 nops_for_sequence (int num_insns, const struct mips_cl_insn *history, ...)
 {
   va_list args;
-  struct mips_cl_insn buffer[MAX_NOPS];
+  struct mips_cl_insn buffer[MAX_HIST_INSNS];
   struct mips_cl_insn *cursor;
   int nops;
 
   va_start (args, history);
   cursor = buffer + num_insns;
-  memcpy (cursor, history, (MAX_NOPS - num_insns) * sizeof (*cursor));
+  memcpy (cursor, history, (MAX_HIST_INSNS - num_insns) * sizeof (*cursor));
   while (cursor > buffer)
     *--cursor = *va_arg (args, const struct mips_cl_insn *);
 
@@ -2705,6 +2915,7 @@ append_insn (struct mips_cl_insn *ip, ex
 	     bfd_reloc_code_real_type *reloc_type)
 {
   unsigned long prev_pinfo, pinfo;
+  int hndx_24k = 0;
   relax_stateT prev_insn_frag_type = 0;
   bfd_boolean relaxed_branch = FALSE;
   segment_info_type *si = seg_info (now_seg);
@@ -3238,7 +3449,15 @@ append_insn (struct mips_cl_insn *ip, ex
 	      || (mips_opts.mips16 && history[0].fixp[0])
 	      /* If the previous instruction is a sync, sync.l, or
 		 sync.p, we can not swap.  */
-	      || (prev_pinfo & INSN_SYNC))
+	      || (prev_pinfo & INSN_SYNC)
+	      /* If we're assembling for the 24k errata and the previous
+ 		 instruction is an ERET or DERET, avoid the swap.  */
+	      || (history[0].insn_opcode == INSN_ERET)
+	      || (history[0].insn_opcode == INSN_DERET)
+	      /* FIXME: Disable MIPS16 branch swapping for now as it
+		 breaks DWARF-2 line information irrecoverably.
+		 --macro  */
+	      || mips_opts.mips16)
 	    {
 	      if (mips_opts.mips16
 		  && (pinfo & INSN_UNCOND_BRANCH_DELAY)
@@ -3258,6 +3477,8 @@ append_insn (struct mips_cl_insn *ip, ex
 		     slot, and bump the destination address.  */
 		  insert_into_history (0, 1, ip);
 		  emit_nop ();
+		  if (mips_fix_24k)
+		    hndx_24k++;
 		}
 		
 	      if (mips_relax.sequence)
@@ -3297,7 +3518,14 @@ append_insn (struct mips_cl_insn *ip, ex
 	  /* If that was an unconditional branch, forget the previous
 	     insn information.  */
 	  if (pinfo & INSN_UNCOND_BRANCH_DELAY)
-	    mips_no_prev_insn ();
+	    {
+	      /* Check for eret/deret before clearing history.  */
+	      if (mips_fix_24k)
+		check_for_24k_errata (
+			(struct mips_cl_insn *) &history[hndx_24k],
+			hndx_24k+1);
+	      mips_no_prev_insn ();
+	    }
 	}
       else if (pinfo & INSN_COND_BRANCH_LIKELY)
 	{
@@ -3307,6 +3535,8 @@ append_insn (struct mips_cl_insn *ip, ex
 	     the next instruction.  */
 	  insert_into_history (0, 1, ip);
 	  emit_nop ();
+	  if (mips_fix_24k)
+	    hndx_24k++;
 	}
       else
 	insert_into_history (0, 1, ip);
@@ -3314,6 +3544,10 @@ append_insn (struct mips_cl_insn *ip, ex
   else
     insert_into_history (0, 1, ip);
 
+  if (mips_fix_24k)
+    check_for_24k_errata ((struct mips_cl_insn *) &history[hndx_24k],
+			  hndx_24k+1);
+
   /* We just output an insn, so the next one doesn't have a label.  */
   mips_clear_insn_labels ();
 }
@@ -3400,6 +3634,9 @@ start_noreorder (void)
 static void
 end_noreorder (void)
 {
+  if (mips_fix_24k)
+    check_for_24k_errata (NULL, 0);
+
   mips_opts.noreorder--;
   if (mips_opts.noreorder == 0 && prev_nop_frag != NULL)
     {
@@ -7273,6 +7510,47 @@ macro (struct mips_cl_insn *ip)
       macro_build (&offset_expr, s, "t,o(b)", treg + 1, BFD_RELOC_LO16, breg);
       break;
 
+    case M_SAA_AB:
+      s = "saa";
+      goto saa_saad;
+
+    case M_SAAD_AB:
+      s = "saad";
+
+      saa_saad:
+      /* The "saa/saad" instructions are new in CN58XX. These instructions
+	 do not specify offset. When invoked with address or symbol, then
+	 load the address or value of symbol in a register using the dla macro
+	 into AT, and pass the register for emitting "saa/saad" instruction. 
+	 This will get expanded to
+
+	    dla AT, constant/label
+	    saa/saad $treg,(AT)  */
+      {
+	char *name = "dla";
+	char *fmt = "t,A(b)";
+	const struct mips_opcode *mo;
+  	struct mips_cl_insn insn;
+
+	mo = hash_find (op_hash, name);
+	assert (strcmp (name, mo->name) == 0);
+	assert (strcmp (fmt, mo->args) == 0);
+	create_insn (&insn, mo);
+  
+	insn.insn_opcode = insn.insn_mo->match;
+
+	used_at = 1;
+	INSERT_OPERAND (RT, insn, AT);
+	if (breg)
+	  INSERT_OPERAND (RS, insn, breg);
+
+	/* The address part is forwarded through the global offset_expr. */
+	macro (&insn);
+
+	macro_build (NULL, s, "t,(b)", treg, AT);
+	break;
+     }
+ 
    /* New code added to support COPZ instructions.
       This code builds table entries out of the macros in mip_opcodes.
       R4000 uses interlocks to handle coproc delays.
@@ -7980,8 +8258,13 @@ macro2 (struct mips_cl_insn *ip)
       else
 	++offset_expr.X_add_number;
       macro_build (&offset_expr, "lbu", "t,o(b)", treg, BFD_RELOC_LO16, breg);
-      macro_build (NULL, "sll", "d,w,<", AT, AT, 8);
-      macro_build (NULL, "or", "d,v,t", treg, treg, AT);
+      if (ISA_HAS_INS (mips_opts.isa))
+	macro_build (NULL, "ins", "t,r,+A,+B", treg, AT, 8, 31); 
+      else
+	{
+	  macro_build (NULL, "sll", "d,w,<", AT, AT, 8);
+	  macro_build (NULL, "or", "d,v,t", treg, treg, AT);
+	}
       break;
 
     case M_ULD:
@@ -8021,11 +8304,21 @@ macro2 (struct mips_cl_insn *ip)
       break;
 
     case M_ULD_A:
+      if (mips_opts.arch == CPU_OCTEON && octeon_use_unalign)
+	{
+	  s = "uld";
+	  goto ld;
+	}
       s = "ldl";
       s2 = "ldr";
       off = 7;
       goto ulwa;
     case M_ULW_A:
+      if (mips_opts.arch == CPU_OCTEON && octeon_use_unalign)
+	{
+	  s = "ulw";
+	  goto ld;
+	}
       s = "lwl";
       s2 = "lwr";
       off = 3;
@@ -8052,17 +8345,25 @@ macro2 (struct mips_cl_insn *ip)
       load_address (AT, &offset_expr, &used_at);
       if (breg != 0)
 	macro_build (NULL, ADDRESS_ADD_INSN, "d,v,t", AT, AT, breg);
-      if (target_big_endian)
-	expr1.X_add_number = 0;
-      macro_build (&expr1, mask == M_ULH_A ? "lb" : "lbu", "t,o(b)",
-		   treg, BFD_RELOC_LO16, AT);
-      if (target_big_endian)
-	expr1.X_add_number = 1;
+      if (ISA_HAS_INS (mips_opts.isa))
+	{
+	  expr1.X_add_number = target_big_endian ? 1 : 0;
+	  macro_build (&expr1, "lbu", "t,o(b)", treg, BFD_RELOC_LO16, AT);
+	  expr1.X_add_number = target_big_endian ? 0 : 1;
+	  macro_build (&expr1, mask == M_ULH_A ? "lb" : "lbu", "t,o(b)",
+		       AT, BFD_RELOC_LO16, AT);
+	  macro_build (NULL, "ins", "t,r,+A,+B", treg, AT, 8, 31);
+	}
       else
-	expr1.X_add_number = 0;
-      macro_build (&expr1, "lbu", "t,o(b)", AT, BFD_RELOC_LO16, AT);
-      macro_build (NULL, "sll", "d,w,<", treg, treg, 8);
-      macro_build (NULL, "or", "d,v,t", treg, treg, AT);
+	{
+	  expr1.X_add_number = target_big_endian ? 0 : 1;
+	  macro_build (&expr1, mask == M_ULH_A ? "lb" : "lbu", "t,o(b)",
+		       treg, BFD_RELOC_LO16, AT);
+	  expr1.X_add_number = target_big_endian ? 1 : 0;
+	  macro_build (&expr1, "lbu", "t,o(b)", AT, BFD_RELOC_LO16, AT);
+	  macro_build (NULL, "sll", "d,w,<", treg, treg, 8);
+	  macro_build (NULL, "or", "d,v,t", treg, treg, AT);
+	}
       break;
 
     case M_USH:
@@ -8103,11 +8404,21 @@ macro2 (struct mips_cl_insn *ip)
       break;
 
     case M_USD_A:
+      if (mips_opts.arch == CPU_OCTEON && octeon_use_unalign)
+	{
+	  s = "usd";
+	  goto st;
+	}
       s = "sdl";
       s2 = "sdr";
       off = 7;
       goto uswa;
     case M_USW_A:
+      if (mips_opts.arch == CPU_OCTEON && octeon_use_unalign)
+	{
+	  s = "usw";
+	  goto st;
+	}
       s = "swl";
       s2 = "swr";
       off = 3;
@@ -8674,6 +8985,36 @@ mips_ip (char *str, struct mips_cl_insn 
       assert (strcmp (insn->name, str) == 0);
 
       ok = is_opcode_valid (insn, FALSE);
+
+      if (insn->pinfo != INSN_MACRO)
+	{
+	  if (mips_opts.arch == CPU_OCTEON
+	      && !octeon_use_unalign
+	      && (strcmp (insn->name, "ulw") == 0
+		  || strcmp (insn->name, "uld") == 0
+		  || strcmp (insn->name, "usw") == 0
+		  || strcmp (insn->name, "usd") == 0))
+	    ok = FALSE;
+
+	  if (mips_opts.arch == CPU_OCTEON
+	      && octeon_use_unalign
+	      && (strcmp (insn->name, "lwl") == 0
+		  || strcmp (insn->name, "lwr") == 0
+		  || strcmp (insn->name, "ldl") == 0
+		  || strcmp (insn->name, "ldr") == 0
+		  || strcmp (insn->name, "sdl") == 0
+		  || strcmp (insn->name, "sdr") == 0
+		  || strcmp (insn->name, "swr") == 0
+		  || strcmp (insn->name, "swl") == 0))
+	    {
+	      static char buf[100];
+	      sprintf (buf, _("Unaligned load/store instructions are not "
+			      "allowed with -mocteon-useun"));
+	      insn_error = buf;
+	      return;
+	    }
+	}
+
       if (! ok)
 	{
 	  if (insn + 1 < &mips_opcodes[NUMOPCODES]
@@ -11165,6 +11506,8 @@ enum options
     OPTION_NO_SMARTMIPS,
     OPTION_DSPR2,
     OPTION_NO_DSPR2,
+    OPTION_MIPS16E,
+    OPTION_NO_MIPS16E,
     OPTION_COMPAT_ARCH_BASE,
     OPTION_M4650,
     OPTION_NO_M4650,
@@ -11175,11 +11518,15 @@ enum options
     OPTION_M3900,
     OPTION_NO_M3900,
     OPTION_M7000_HILO_FIX,
-    OPTION_MNO_7000_HILO_FIX,
+    OPTION_MNO_7000_HILO_FIX, 
+    OPTION_FIX_24K,
+    OPTION_NO_FIX_24K,
     OPTION_FIX_VR4120,
     OPTION_NO_FIX_VR4120,
     OPTION_FIX_VR4130,
     OPTION_NO_FIX_VR4130,
+    OPTION_FIX_ICE9A,
+    OPTION_NO_FIX_ICE9A,
     OPTION_TRAP,
     OPTION_BREAK,
     OPTION_EB,
@@ -11200,6 +11547,8 @@ enum options
     OPTION_HARD_FLOAT,
     OPTION_SINGLE_FLOAT,
     OPTION_DOUBLE_FLOAT,
+    OPTION_OCTEON_UNALIGNED,
+    OPTION_NO_OCTEON_UNALIGNED,
     OPTION_32,
 #ifdef OBJ_ELF
     OPTION_CALL_SHARED,
@@ -11214,6 +11563,7 @@ enum options
     OPTION_PDR,
     OPTION_NO_PDR,
     OPTION_MVXWORKS_PIC,
+    OPTION_NON_PIC_ABICALLS,
 #endif /* OBJ_ELF */
     OPTION_END_OF_ENUM    
   };
@@ -11249,6 +11599,9 @@ struct option md_longopts[] =
   {"mno-smartmips", no_argument, NULL, OPTION_NO_SMARTMIPS},
   {"mdspr2", no_argument, NULL, OPTION_DSPR2},
   {"mno-dspr2", no_argument, NULL, OPTION_NO_DSPR2},
+  /* SDE backward compatibility alias.  */
+  {"mips16e", no_argument, NULL, OPTION_MIPS16},
+  {"no-mips16e", no_argument, NULL, OPTION_NO_MIPS16},
 
   /* Old-style architecture options.  Don't add more of these.  */
   {"m4650", no_argument, NULL, OPTION_M4650},
@@ -11268,6 +11621,10 @@ struct option md_longopts[] =
   {"mno-fix-vr4120", no_argument, NULL, OPTION_NO_FIX_VR4120},
   {"mfix-vr4130",    no_argument, NULL, OPTION_FIX_VR4130},
   {"mno-fix-vr4130", no_argument, NULL, OPTION_NO_FIX_VR4130},
+  {"mfix-ice9a",    no_argument, NULL, OPTION_FIX_ICE9A},
+  {"mno-fix-ice9a", no_argument, NULL, OPTION_NO_FIX_ICE9A},
+  {"mfix-24k",    no_argument, NULL, OPTION_FIX_24K},
+  {"mno-fix-24k", no_argument, NULL, OPTION_NO_FIX_24K},
 
   /* Miscellaneous options.  */
   {"trap", no_argument, NULL, OPTION_TRAP},
@@ -11292,6 +11649,8 @@ struct option md_longopts[] =
   {"mhard-float", no_argument, NULL, OPTION_HARD_FLOAT},
   {"msingle-float", no_argument, NULL, OPTION_SINGLE_FLOAT},
   {"mdouble-float", no_argument, NULL, OPTION_DOUBLE_FLOAT},
+  {"mocteon-useun", no_argument, NULL, OPTION_OCTEON_UNALIGNED},
+  {"mno-octeon-useun", no_argument, NULL, OPTION_NO_OCTEON_UNALIGNED},
 
   /* Strictly speaking this next option is ELF specific,
      but we allow it for other ports as well in order to
@@ -11313,6 +11672,7 @@ struct option md_longopts[] =
   {"mpdr", no_argument, NULL, OPTION_PDR},
   {"mno-pdr", no_argument, NULL, OPTION_NO_PDR},
   {"mvxworks-pic", no_argument, NULL, OPTION_MVXWORKS_PIC},
+  {"mnon-pic-abicalls", no_argument, NULL, OPTION_NON_PIC_ABICALLS},
 #endif /* OBJ_ELF */
 
   {NULL, no_argument, NULL, 0}
@@ -11521,6 +11881,14 @@ md_parse_option (int c, char *arg)
       mips_opts.ase_smartmips = 0;
       break;
 
+    case OPTION_FIX_24K:
+      mips_fix_24k = 1;
+      break;
+
+    case OPTION_NO_FIX_24K:
+      mips_fix_24k = 0;
+      break;
+
     case OPTION_FIX_VR4120:
       mips_fix_vr4120 = 1;
       break;
@@ -11537,6 +11905,14 @@ md_parse_option (int c, char *arg)
       mips_fix_vr4130 = 0;
       break;
 
+    case OPTION_FIX_ICE9A:
+      mips_fix_ice9a = 1;
+      break;
+
+    case OPTION_NO_FIX_ICE9A:
+      mips_fix_ice9a = 0;
+      break;
+
     case OPTION_RELAX_BRANCH:
       mips_relax_branch = 1;
       break;
@@ -11561,6 +11937,14 @@ md_parse_option (int c, char *arg)
       mips_opts.sym32 = FALSE;
       break;
 
+    case OPTION_OCTEON_UNALIGNED:
+      octeon_use_unalign = 1;
+      break;
+
+    case OPTION_NO_OCTEON_UNALIGNED:
+      octeon_use_unalign = 0;
+      break;
+
 #ifdef OBJ_ELF
       /* When generating ELF code, we permit -KPIC and -call_shared to
 	 select SVR4_PIC, and -non_shared to select no PIC.  This is
@@ -11729,6 +12113,11 @@ md_parse_option (int c, char *arg)
     case OPTION_MVXWORKS_PIC:
       mips_pic = VXWORKS_PIC;
       break;
+
+    case OPTION_NON_PIC_ABICALLS:
+      mips_pic = NO_PIC;
+      mips_abicalls = TRUE;
+      break;
 #endif /* OBJ_ELF */
 
     default:
@@ -12468,6 +12857,10 @@ s_change_sec (int sec)
 #endif
 
   mips_emit_delays ();
+
+  if (mips_fix_24k)
+    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);
+
   switch (sec)
     {
     case 't':
@@ -12526,6 +12919,9 @@ s_change_section (int ignore ATTRIBUTE_U
   if (!IS_ELF)
     return;
 
+  if (mips_fix_24k)
+    check_for_24k_errata ((struct mips_cl_insn *) &history[0], -1);
+
   section_name = input_line_pointer;
   c = get_symbol_end ();
   if (c)
@@ -15234,7 +15630,10 @@ static const struct mips_cpu_info mips_c
   { "octeon",	      0,      ISA_MIPS64R2,   CPU_OCTEON },
 
   /* RMI Xlr */
-  { "xlr",	      0,      ISA_MIPS64,     CPU_XLR },
+  { "xlr",            0,      ISA_MIPS64,     CPU_XLR },
+
+  /* SiCortex ice9 */
+  { "ice9",           0,      ISA_MIPS64,     CPU_MIPS64 },
 
   /* End marker */
   { NULL, 0, 0, 0 }
@@ -15457,13 +15856,17 @@ MIPS options:\n\
   fprintf (stream, _("\
 -mfix-vr4120		work around certain VR4120 errata\n\
 -mfix-vr4130		work around VR4130 mflo/mfhi errata\n\
+-mfix-ice9a		detect the lack of the ICE9A double float multiplication errata workaround\n\
+-mfix-24k		insert a nop after ERET and DERET instructions\n\
 -mgp32			use 32-bit GPRs, regardless of the chosen ISA\n\
 -mfp32			use 32-bit FPRs, regardless of the chosen ISA\n\
 -msym32			assume all symbols have 32-bit values\n\
 -O0			remove unneeded NOPs, do not swap branches\n\
 -O			remove unneeded NOPs and swap branches\n\
 --trap, --no-break	trap exception on div by 0 and mult overflow\n\
---break, --no-trap	break exception on div by 0 and mult overflow\n"));
+--break, --no-trap	break exception on div by 0 and mult overflow\n\
+-mocteon-useun		use Octeon-specific unaligned loads/stores for 32/64-bit data (default)\n\
+-mno-octeon-useun	do not use Octeon-specific unaligned loads/stores for 32/64-bit data\n"));
   fprintf (stream, _("\
 -mhard-float		allow floating-point instructions\n\
 -msoft-float		do not allow floating-point instructions\n\
--- a/gas/config/tc-mips.h
+++ b/gas/config/tc-mips.h
@@ -53,6 +53,9 @@ extern int mips_relax_frag (asection *, 
 #define md_undefined_symbol(name)	(0)
 #define md_operand(x)
 
+extern void mips_cleanup (void);
+#define md_cleanup() mips_cleanup ()
+
 extern char mips_nop_opcode (void);
 #define NOP_OPCODE (mips_nop_opcode ())
 
--- a/gas/config/tc-ppc.c
+++ b/gas/config/tc-ppc.c
@@ -905,6 +905,10 @@ parse_cpu (const char *arg)
     }
   /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
      620.  */
+  else if (strcmp (arg, "pmr") == 0)
+    {
+      ppc_cpu |= PPC_OPCODE_PMR;
+    }
   else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
     {
       ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
--- a/gas/config/te-armeabi.h
+++ b/gas/config/te-armeabi.h
@@ -18,7 +18,7 @@
    02110-1301, USA.  */
 
 /* The EABI requires the use of VFP.  */
-#define FPU_DEFAULT FPU_ARCH_VFP_V2
+#define FPU_DEFAULT FPU_ARCH_VFP
 #define EABI_DEFAULT EF_ARM_EABI_VER5
 
 #define LOCAL_LABELS_DOLLAR 1
--- a/gas/config/te-armlinuxeabi.h
+++ b/gas/config/te-armlinuxeabi.h
@@ -20,5 +20,5 @@
 #include "te-linux.h"
 
 /* The EABI requires the use of VFP.  */
-#define FPU_DEFAULT FPU_ARCH_VFP_V2
+#define FPU_DEFAULT FPU_ARCH_VFP
 #define EABI_DEFAULT EF_ARM_EABI_VER5
--- a/gas/configure
+++ b/gas/configure
@@ -12167,6 +12167,9 @@ echo "$as_me: error: $target_cpu isn't a
 	esac
 	# Decide which ABI to target by default.
 	case ${target} in
+	  mips64el-sicortex-linux-gnu)
+	    mips_default_abi=N64_ABI
+	    ;;
 	  mips64*-linux* | mips-sgi-irix6*)
 	    mips_default_abi=N32_ABI
 	    ;;
--- a/gas/configure.in
+++ b/gas/configure.in
@@ -245,6 +245,9 @@ changequote([,])dnl
 	esac
 	# Decide which ABI to target by default.
 	case ${target} in
+	  mips64el-sicortex-linux-gnu)
+	    mips_default_abi=N64_ABI
+	    ;;
 	  mips64*-linux* | mips-sgi-irix6*)
 	    mips_default_abi=N32_ABI
 	    ;;
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -287,6 +287,8 @@ case ${generic_target} in
   mips-*-riscos*)			fmt=ecoff ;;
   mips*-*-linux*)			fmt=elf em=tmips ;;
   mips-*-sysv4*MP* | mips-*-gnu*)	fmt=elf em=tmips ;;
+  mips-wrs-elf*)			fmt=elf em=tmips ;;
+  mips-montavista-elf*)                 fmt=elf em=tmips ;;
   mips*-sde-elf*)			fmt=elf em=tmips ;;
   mips-*-sysv*)				fmt=ecoff ;;
   mips-*-elf* | mips-*-rtems*)		fmt=elf ;;
--- a/gas/doc/as.texinfo
+++ b/gas/doc/as.texinfo
@@ -375,6 +375,7 @@ gcc(1), ld(1), and the Info entries for 
    [@b{-construct-floats}] [@b{-no-construct-floats}]
    [@b{-trap}] [@b{-no-break}] [@b{-break}] [@b{-no-trap}]
    [@b{-mfix7000}] [@b{-mno-fix7000}]
+   [@b{-mfix-ice9a}] [@b{-mno-fix-ice9a}]
    [@b{-mips16}] [@b{-no-mips16}]
    [@b{-msmartmips}] [@b{-mno-smartmips}]
    [@b{-mips3d}] [@b{-no-mips3d}]
--- a/gas/doc/c-arm.texi
+++ b/gas/doc/c-arm.texi
@@ -116,6 +116,8 @@ recognized: 
 @code{cortex-a9},
 @code{cortex-r4},
 @code{cortex-m3},
+@code{cortex-m1},
+@code{cortex-m0},
 @code{ep9312} (ARM920 with Cirrus Maverick coprocessor),
 @code{i80200} (Intel XScale processor)
 @code{iwmmxt} (Intel(r) XScale processor with Wireless MMX(tm) technology coprocessor)
@@ -194,6 +196,7 @@ The following format options are recogni
 @code{vfp},
 @code{vfp10},
 @code{vfp10-r0},
+@code{vfp3}
 @code{vfp9},
 @code{vfpxd},
 @code{vfpv2}
@@ -225,6 +228,12 @@ instructions; that is, it should behave 
 This option specifies that the output generated by the assembler should
 be marked as supporting interworking.
 
+@cindex @code{-mauto-it} command line option, ARM
+@item -mauto-it
+This option enables the automatic generation of IT instructions for Thumb-2 
+conditional instructions.  Explicit IT instructons are still accepted and 
+checked. This option has no effect on ARM mode code.
+
 @cindex @code{-mapcs} command line option, ARM
 @item -mapcs @code{[26|32]}
 This option specifies that the output generated by the assembler should
--- a/gas/doc/c-mips.texi
+++ b/gas/doc/c-mips.texi
@@ -182,6 +182,16 @@ all problems in hand-written assembler c
 @itemx -no-mfix-vr4130
 Insert nops to work around the VR4130 @samp{mflo}/@samp{mfhi} errata.
 
+@item -mfix-ice9a
+@itemx -mno-fix-ice9a
+Detect missing @code{movn.d $f30, <reg>, $zero} instructions required for
+the ICE9A double floating-point multiplication errata and invalid @code{$f30}
+references conflicting with same.  Raise an error if so.
+
+@item -mfix-24k
+@itemx -no-mfix-24k
+Insert nops to work around the 24K @samp{eret}/@samp{deret} errata.
+
 @item -m4010
 @itemx -no-m4010
 Generate code for the LSI @sc{r4010} chip.  This tells the assembler to
--- a/gas/read.c
+++ b/gas/read.c
@@ -1920,6 +1920,10 @@ s_fill (int ignore ATTRIBUTE_UNUSED)
   md_flush_pending_output ();
 #endif
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   get_known_segmented_expression (&rep_exp);
   if (*input_line_pointer == ',')
     {
@@ -3119,6 +3123,10 @@ s_space (int mult)
   md_flush_pending_output ();
 #endif
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   if (flag_mri)
     stop = mri_comment_field (&stopc);
 
@@ -3290,6 +3298,10 @@ s_float_space (int float_type)
   char *stop = NULL;
   char stopc = 0;
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   if (flag_mri)
     stop = mri_comment_field (&stopc);
 
@@ -3792,7 +3804,15 @@ cons_worker (register int nbytes,	/* 1=.
 	parse_mri_cons (&exp, (unsigned int) nbytes);
       else
 #endif
-	TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
+        {
+	  if (*input_line_pointer == '"')
+	    {
+	      as_bad (_("unexpected \" in expression"));
+	      ignore_rest_of_line ();
+	      return;
+	    }
+	  TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
+	}
 
       if (rva)
 	{
@@ -4631,6 +4651,10 @@ float_cons (/* Clobbers input_line-point
   md_flush_pending_output ();
 #endif
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   do
     {
       /* input_line_pointer->1st char of a flonum (we hope!).  */
@@ -5075,6 +5099,10 @@ stringer (int bits_appendzero)
   md_flush_pending_output ();
 #endif
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   /* The following awkward logic is to parse ZERO or more strings,
      comma separated. Recall a string expression includes spaces
      before the opening '\"' and spaces after the closing '\"'.
@@ -5453,6 +5481,10 @@ s_incbin (int x ATTRIBUTE_UNUSED)
   md_flush_pending_output ();
 #endif
 
+#ifdef md_cons_align
+  md_cons_align (1);
+#endif
+
   SKIP_WHITESPACE ();
   filename = demand_copy_string (& len);
   if (filename == NULL)
--- a/gprof/cg_print.c
+++ b/gprof/cg_print.c
@@ -58,6 +58,10 @@ extern void fsf_callg_blurb (FILE * fp);
 
 double print_time = 0.0;
 
+static double child_max;
+static int self_wid;
+static int child_wid;
+static int prec;
 
 static void
 print_header ()
@@ -79,8 +83,8 @@ print_header ()
 	  (long) hist_scale * (long) sizeof (UNIT));
 
   if (print_time > 0.0)
-    printf (_(" for %.2f%% of %.2f seconds\n\n"),
-	    100.0 / print_time, print_time / hz);
+    printf (_(" for %.2f%% of %.2f %s\n\n"),
+	    100.0 / print_time, print_time / hz, hist_dimension);
   else
     {
       printf (_(" no time propagated\n\n"));
@@ -100,10 +104,10 @@ print_header ()
 	      "", "", "", "", _("called"), _("total"), _("children"));
       printf ("\n");
     }
+  else if (child_max / hz >= 100000.0)
+    printf (_("index %% time       self     children    called     name\n"));
   else
-    {
-      printf (_("index %% time    self  children    called     name\n"));
-    }
+    printf (_("index %% time    self  children    called     name\n"));
 }
 
 /* Print a cycle header.  */
@@ -114,12 +118,11 @@ print_cycle (Sym *cyc)
   char buf[BUFSIZ];
 
   sprintf (buf, "[%d]", cyc->cg.index);
-  printf (bsd_style_output
-	  ? "%-6.6s %5.1f %7.2f %11.2f %7lu"
-	  : "%-6.6s %5.1f %7.2f %7.2f %7lu", buf,
+  printf ("%-6.6s %5.1f %*.*f %*.*f %7lu", buf,
 	  100 * (cyc->cg.prop.self + cyc->cg.prop.child) / print_time,
-	  cyc->cg.prop.self / hz, cyc->cg.prop.child / hz, cyc->ncalls);
-
+	  self_wid, prec, cyc->cg.prop.self / hz,
+	  child_wid, prec, cyc->cg.prop.child / hz,
+	  cyc->ncalls);
   if (cyc->cg.self_calls != 0)
     printf ("+%-7lu", cyc->cg.self_calls);
   else
@@ -192,10 +195,10 @@ print_members (Sym *cyc)
 
   for (member = cyc->cg.cyc.next; member; member = member->cg.cyc.next)
     {
-      printf (bsd_style_output
-	      ? "%6.6s %5.5s %7.2f %11.2f %7lu"
-	      : "%6.6s %5.5s %7.2f %7.2f %7lu",
-	      "", "", member->cg.prop.self / hz, member->cg.prop.child / hz,
+      printf ("%6.6s %5.5s %*.*f %*.*f %7lu",
+	      "", "",
+	      self_wid, prec, member->cg.prop.self / hz,
+	      child_wid, prec, member->cg.prop.child / hz,
 	      member->ncalls);
 
       if (member->cg.self_calls != 0)
@@ -350,10 +353,11 @@ print_parents (Sym *child)
 
   if (!child->cg.parents)
     {
-      printf (bsd_style_output
-	      ? _("%6.6s %5.5s %7.7s %11.11s %7.7s %7.7s     <spontaneous>\n")
-	      : _("%6.6s %5.5s %7.7s %7.7s %7.7s %7.7s     <spontaneous>\n"),
-	      "", "", "", "", "", "");
+      printf (_("%6.6s %5.5s %*.*s %*.*s %7.7s %7.7s     <spontaneous>\n"),
+	      "", "",
+	      self_wid, self_wid, "",
+	      child_wid, child_wid, "",
+	      "", "");
       return;
     }
 
@@ -365,23 +369,22 @@ print_parents (Sym *child)
       if (child == parent || (child->cg.cyc.num != 0
 			      && parent->cg.cyc.num == child->cg.cyc.num))
 	{
-	  /* Selfcall or call among siblings.  */
-	  printf (bsd_style_output
-		  ? "%6.6s %5.5s %7.7s %11.11s %7lu %7.7s     "
-		  : "%6.6s %5.5s %7.7s %7.7s %7lu %7.7s     ",
-		  "", "", "", "",
+	  /* Selfcall or call among siblings. */
+	  printf ("%6.6s %5.5s %*.*s %*.*s %7lu %7.7s     ",
+		  "", "",
+		  self_wid, self_wid, "",
+		  child_wid, child_wid, "",
 		  arc->count, "");
 	  print_name (parent);
 	  printf ("\n");
 	}
       else
 	{
-	  /* Regular parent of child.  */
-	  printf (bsd_style_output
-		  ? "%6.6s %5.5s %7.2f %11.2f %7lu/%-7lu     "
-		  : "%6.6s %5.5s %7.2f %7.2f %7lu/%-7lu     ",
+	  /* Regular parent of child. */
+	  printf ("%6.6s %5.5s %*.*f %*.*f %7lu/%-7lu     ",
 		  "", "",
-		  arc->time / hz, arc->child_time / hz,
+		  self_wid, prec, arc->time / hz,
+		  child_wid, prec, arc->child_time / hz,
 		  arc->count, cycle_head->ncalls);
 	  print_name (parent);
 	  printf ("\n");
@@ -438,22 +441,22 @@ print_children (Sym *parent)
       if (child == parent || (child->cg.cyc.num != 0
 			      && child->cg.cyc.num == parent->cg.cyc.num))
 	{
-	  /* Self call or call to sibling.  */
-	  printf (bsd_style_output
-		  ? "%6.6s %5.5s %7.7s %11.11s %7lu %7.7s     "
-		  : "%6.6s %5.5s %7.7s %7.7s %7lu %7.7s     ",
-		  "", "", "", "", arc->count, "");
+	  /* Self call or call to sibling. */
+	  printf ("%6.6s %5.5s %*.*s %*.*s %7lu %7.7s     ",
+		  "", "",
+		  self_wid, self_wid, "",
+		  child_wid, child_wid, "",
+		  arc->count, "");
 	  print_name (child);
 	  printf ("\n");
 	}
       else
 	{
-	  /* Regular child of parent.  */
-	  printf (bsd_style_output
-		  ? "%6.6s %5.5s %7.2f %11.2f %7lu/%-7lu     "
-		  : "%6.6s %5.5s %7.2f %7.2f %7lu/%-7lu     ",
+	  /* Regular child of parent. */
+	  printf ("%6.6s %5.5s %*.*f %*.*f %7lu/%-7lu     ",
 		  "", "",
-		  arc->time / hz, arc->child_time / hz,
+		  self_wid, prec, arc->time / hz,
+		  child_wid, prec, arc->child_time / hz,
 		  arc->count, child->cg.cyc.head->ncalls);
 	  print_name (child);
 	  printf ("\n");
@@ -468,25 +471,21 @@ print_line (Sym *np)
   char buf[BUFSIZ];
 
   sprintf (buf, "[%d]", np->cg.index);
-  printf (bsd_style_output
-	  ? "%-6.6s %5.1f %7.2f %11.2f"
-	  : "%-6.6s %5.1f %7.2f %7.2f", buf,
+  printf ("%-6.6s %5.1f %*.*f %*.*f", buf,
 	  100 * (np->cg.prop.self + np->cg.prop.child) / print_time,
-	  np->cg.prop.self / hz, np->cg.prop.child / hz);
-
+	  self_wid, prec, np->cg.prop.self / hz,
+	  child_wid, prec, np->cg.prop.child / hz);
   if ((np->ncalls + np->cg.self_calls) != 0)
     {
       printf (" %7lu", np->ncalls);
 
       if (np->cg.self_calls != 0)
-	  printf ("+%-7lu ", np->cg.self_calls);
+	printf ("+%-7lu ", np->cg.self_calls);
       else
-	  printf (" %7.7s ", "");
+	printf (" %7.7s ", "");
     }
   else
-    {
-      printf (" %7.7s %7.7s ", "", "");
-    }
+    printf (" %7.7s %7.7s ", "", "");
 
   print_name (np);
   printf ("\n");
@@ -504,6 +503,20 @@ cg_print (Sym ** timesortsym)
   if (print_descriptions && bsd_style_output)
     bsd_callg_blurb (stdout);
 
+  child_max = 0.0;
+  for (index = 0; index < symtab.len; index++)
+    {
+      Sym *sym = &symtab.base[index];
+      if (sym->cg.prop.child > child_max)
+	child_max = sym->cg.prop.child;
+    }
+  if (bsd_style_output)
+    self_wid = 7, child_wid = 11, prec = 2;
+  else if (child_max / hz >= 100000.0)
+    self_wid = 10, child_wid = 10, prec = 0;
+  else
+    self_wid = 7, child_wid = 7, prec = 2;
+
   print_header ();
 
   for (index = 0; index < symtab.len + num_cycles; ++index)
--- a/gprof/corefile.c
+++ b/gprof/corefile.c
@@ -29,6 +29,11 @@
 #include "corefile.h"
 #include "safe-ctype.h"
 
+/* FIXME: These are needed to figure out if this is a mips16 symbol or
+   not.  It would be better to think of a cleaner way to do this.  */
+#include "elf-bfd.h"
+#include "elf/mips.h"
+
 bfd *core_bfd;
 static int core_num_syms;
 static asymbol **core_syms;
@@ -233,6 +238,10 @@ core_init (const char *aout_name)
       min_insn_size = 4;
       break;
 
+    case bfd_arch_mips:
+      min_insn_size = 2;
+      break;
+
     default:
       break;
     }
@@ -528,6 +537,17 @@ core_create_function_syms ()
       if (sym_sec)
 	symtab.limit->addr += bfd_get_section_vma (sym_sec->owner, sym_sec);
 
+      /* Flag mips16 symbols by making them odd (we don't have a
+	 handle on the original bfd symbol after this point). */
+      if (bfd_get_arch (core_bfd) == bfd_arch_mips
+	  && bfd_get_flavour (core_bfd) == bfd_target_elf_flavour)
+	{
+	  elf_symbol_type *es = elf_symbol_from (core_bfd, core_syms[i]);
+
+	  if (es && es->internal_elf_sym.st_other == STO_MIPS16)
+	    symtab.limit->addr |= 1;
+	}
+
       if (symbol_map_count
 	  && !strcmp (core_syms[i]->name, symbol_map[found].function_name))
 	{
--- a/gprof/gmon_io.c
+++ b/gprof/gmon_io.c
@@ -430,8 +430,8 @@ gmon_out_read (const char *filename)
 	    goto bad_gmon_file;
 
 	  if (!histograms)
-	    hz = profrate;
-	  else if (hz != (int) profrate)
+	    hz_int = profrate;
+	  else if (hz_int != (int) profrate)
 	    {
 	      fprintf (stderr,
 		       _("%s: profiling rate incompatible with first gmon file\n"),
@@ -553,15 +553,15 @@ gmon_out_read (const char *filename)
 
       fclose (ifp);
 
-      if (hz == HZ_WRONG)
+      if (hz_int == HZ_WRONG)
 	{
-	  /* How many ticks per second?  If we can't tell, report
-	     time in ticks.  */
-	  hz = hertz ();
-
-	  if (hz == HZ_WRONG)
+	  /*
+	     How many ticks per second?  If we can't tell, report
+	     time in ticks. */
+	  hz_int = hertz ();
+	  if (hz_int == HZ_WRONG)
 	    {
-	      hz = 1;
+	      hz_int = 1;
 	      fprintf (stderr, _("time is in ticks, not seconds\n"));
 	    }
 	}
@@ -573,6 +573,15 @@ gmon_out_read (const char *filename)
       done (1);
     }
 
+#ifdef HERTZ_FLOAT
+  if (hz_int < 0)
+    hz = 1.0 / -hz_int;
+  else
+    hz = hz_int;
+#else
+  hz = hz_int;
+#endif
+
   if (output_style & STYLE_GMON_INFO)
     {
       printf (_("File `%s' (version %d) contains:\n"),
@@ -645,7 +654,7 @@ gmon_out_write (const char *filename)
          header if explicitly specified, or if the profiling rate is
          non-standard.  Otherwise, use the old BSD format.  */
       if (file_format == FF_BSD44
-	  || hz != hertz())
+	  || hz_int != hertz ())
 	{
 	  padsize = 3*4;
 	  switch (gmon_get_ptr_size ())
@@ -692,10 +701,10 @@ gmon_out_write (const char *filename)
 
       /* Write out the 4.4BSD header bits, if that's what we're using.  */
       if (file_format == FF_BSD44
-	  || hz != hertz())
+	  || hz_int != hertz())
 	{
           if (gmon_io_write_32 (ofp, GMONVERSION)
-	      || gmon_io_write_32 (ofp, (unsigned int) hz))
+	      || gmon_io_write_32 (ofp, (unsigned int) hz_int))
 	    {
 	      perror (filename);
 	      done (1);
--- a/gprof/gprof.c
+++ b/gprof/gprof.c
@@ -50,7 +50,12 @@ static void usage (FILE *, int) ATTRIBUT
 const char *whoami;
 const char *function_mapping_file;
 const char *a_out_name = A_OUTNAME;
-long hz = HZ_WRONG;
+#ifdef HERTZ_FLOAT
+double hz;
+#else
+long hz;
+#endif
+long hz_int = HZ_WRONG;
 
 /*
  * Default options values:
--- a/gprof/gprof.h
+++ b/gprof/gprof.h
@@ -29,6 +29,10 @@
 #ifndef gprof_h
 #define gprof_h
 
+#include "gconfig.h"
+
+#undef PACKAGE
+
 /* Include the BFD sysdep.h file.  */
 #include "sysdep.h"
 #include "bfd.h"
@@ -109,7 +113,15 @@ typedef unsigned char UNIT[2];	/* unit o
 extern const char *whoami;	/* command-name, for error messages */
 extern const char *function_mapping_file; /* file mapping functions to files */
 extern const char *a_out_name;	/* core filename */
+extern char hist_dimension[];   /* histogram label */
+
+#define HERTZ_FLOAT
+#ifdef HERTZ_FLOAT
+extern double hz;		/* ticks per second */
+#else
 extern long hz;			/* ticks per second */
+#endif
+extern long hz_int;
 
 /*
  * Command-line options:
--- a/gprof/hist.c
+++ b/gprof/hist.c
@@ -49,7 +49,7 @@ static histogram *find_histogram (bfd_vm
 static histogram *find_histogram_for_pc (bfd_vma pc);
 
 double hist_scale;
-static char hist_dimension[16] = "seconds";
+char hist_dimension[16] = "seconds";
 static char hist_dimension_abbrev = 's';
 
 static double accum_time;	/* Accumulated time so far for print_line(). */
@@ -86,7 +86,7 @@ SItab[] =
    that the new histogram is compatible with already-set values
    of those variables and emits an error if that's not so.  */
 static void
-read_histogram_header (histogram *record, 
+read_histogram_header (histogram *record,
 		       FILE *ifp, const char *filename,
 		       int first)
 {
@@ -108,28 +108,28 @@ read_histogram_header (histogram *record
       done (1);
     }
 
-  n_hist_scale = (double)((record->highpc - record->lowpc) / sizeof (UNIT)) 
+  n_hist_scale = (double)((record->highpc - record->lowpc) / sizeof (UNIT))
     / record->num_bins;
 
   if (first)
     {
-      /* We don't try to veryfy profrate is the same for all histogram
+      /* We don't try to verify profrate is the same for all histogram
 	 records.  If we have two histogram records for the same
 	 address range and profiling samples is done as often
 	 as possible as opposed on timer, then the actual profrate will
 	 be slightly different.  Most of the time the difference does not
 	 matter and insisting that profiling rate is exactly the same
 	 will only create inconvenient.  */
-      hz = profrate;
+      hz_int = profrate;
       memcpy (hist_dimension, n_hist_dimension, 15);
       hist_dimension_abbrev = n_hist_dimension_abbrev;
-      hist_scale = n_hist_scale;      
+      hist_scale = n_hist_scale;
     }
   else
     {
       if (strncmp (n_hist_dimension, hist_dimension, 15) != 0)
 	{
-	  fprintf (stderr, 
+	  fprintf (stderr,
 		   _("%s: dimension unit changed between histogram records\n"
 		     "%s: from '%s'\n"
 		     "%s: to '%s'\n"),
@@ -139,12 +139,12 @@ read_histogram_header (histogram *record
 
       if (n_hist_dimension_abbrev != hist_dimension_abbrev)
 	{
-	  fprintf (stderr, 
+	  fprintf (stderr,
 		   _("%s: dimension abbreviation changed between histogram records\n"
 		     "%s: from '%c'\n"
 		     "%s: to '%c'\n"),
 		   whoami, whoami, hist_dimension_abbrev, whoami, n_hist_dimension_abbrev);
-	  done (1);	  
+	  done (1);
 	}
 
       /* The only reason we require the same scale for histograms is that
@@ -153,10 +153,10 @@ read_histogram_header (histogram *record
 	 things for different functions.  */
       if (fabs (hist_scale - n_hist_scale) > 0.000001)
 	{
-	  fprintf (stderr, 
+	  fprintf (stderr,
 		   _("%s: different scales in histogram records"),
 		   whoami);
-	  done (1);      
+	  done (1);
 	}
     }
 }
@@ -190,10 +190,10 @@ hist_read_rec (FILE * ifp, const char *f
       hist_clip_symbol_address (&lowpc, &highpc);
       if (lowpc != highpc)
 	{
-	  fprintf (stderr, 
+	  fprintf (stderr,
 		   _("%s: overlapping histogram records\n"),
 		   whoami);
-	  done (1);      
+	  done (1);
 	}
 
       /* This is new record.  Add it to global array and allocate space for
@@ -202,10 +202,10 @@ hist_read_rec (FILE * ifp, const char *f
 			     sizeof (histogram) * (num_histograms + 1));
       memcpy (histograms + num_histograms,
 	      &n_record, sizeof (histogram));
-      record = &histograms[num_histograms];      
+      record = &histograms[num_histograms];
       ++num_histograms;
 
-      record->sample = (int *) xmalloc (record->num_bins 
+      record->sample = (int *) xmalloc (record->num_bins
 					* sizeof (record->sample[0]));
       memset (record->sample, 0, record->num_bins * sizeof (record->sample[0]));
     }
@@ -216,9 +216,9 @@ hist_read_rec (FILE * ifp, const char *f
 
   DBG (SAMPLEDEBUG,
        printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n",
-	       (unsigned long) record->lowpc, (unsigned long) record->highpc, 
+	       (unsigned long) record->lowpc, (unsigned long) record->highpc,
                record->num_bins));
-           
+
   for (i = 0; i < record->num_bins; ++i)
     {
       UNIT count;
@@ -232,8 +232,8 @@ hist_read_rec (FILE * ifp, const char *f
       record->sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) & count[0]);
       DBG (SAMPLEDEBUG,
 	   printf ("[hist_read_rec] 0x%lx: %u\n",
-		   (unsigned long) (record->lowpc 
-                                    + i * (record->highpc - record->lowpc) 
+		   (unsigned long) (record->lowpc
+                                    + i * (record->highpc - record->lowpc)
                                     / record->num_bins),
 		   record->sample[i]));
     }
@@ -259,7 +259,7 @@ hist_write_hist (FILE * ofp, const char 
 	  || gmon_io_write_vma (ofp, record->lowpc)
 	  || gmon_io_write_vma (ofp, record->highpc)
 	  || gmon_io_write_32 (ofp, record->num_bins)
-	  || gmon_io_write_32 (ofp, hz)
+	  || gmon_io_write_32 (ofp, hz_int)
 	  || gmon_io_write (ofp, hist_dimension, 15)
 	  || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
 	{
@@ -484,12 +484,24 @@ print_header (int prefix)
       total_time = 1.0;
     }
 
-  printf ("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
-	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "),
-	  "");
-  printf ("%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
-	  _("time"), hist_dimension, hist_dimension, _("calls"), unit, unit,
-	  _("name"));
+  if (total_time / hz_int >= 100000.0 && ! bsd_style_output)
+    {
+      printf ("%5.5s %13.13s %11.11s %8.8s %8.8s %8.8s  %-8.8s\n",
+	      "%  ", _("cumulative"), _("self  "), "", _("self  "),
+	      _("total "), "");
+      printf ("%5.5s %12.12s  %11.11s %8.8s %8.8s %8.8s  %-8.8s\n",
+	      _("time"), hist_dimension, hist_dimension, _("calls"), unit,
+	      unit, _("name"));
+    }
+  else
+    {
+      printf ("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
+	      "%  ", _("cumulative"), _("self  "), "", _("self  "),
+	      _("total "), "");
+      printf ("%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
+	      _("time"), hist_dimension, hist_dimension, _("calls"), unit,
+	      unit, _("name"));
+    }
 }
 
 
@@ -505,6 +517,10 @@ print_line (Sym *sym, double scale)
     printf ("%5.1f %10.2f %8.2f",
 	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
 	    accum_time / hz, sym->hist.time / hz);
+  else if (total_time / hz >= 100000.0)
+    printf ("%6.2f %12.0f %11.0f",
+	    100 * sym->hist.time / total_time,
+	    accum_time / hz, sym->hist.time / hz);
   else
     printf ("%6.2f %9.2f %8.2f",
 	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
@@ -610,7 +626,12 @@ hist_print ()
       for (index = 0; index < symtab.len; ++index)
 	{
 	  sym = time_sorted_syms[index];
-
+	  /* Don't let this symbol affect the scaling if it's not going
+	     to be included in the histogram. */
+	  if ((syms[INCL_FLAT].len != 0
+	       && ! sym_lookup (&syms[INCL_FLAT], sym->addr))
+	      || sym_lookup (&syms[EXCL_FLAT], sym->addr))
+	    continue;
 	  if (sym->ncalls != 0)
 	    {
 	      time = (sym->hist.time + sym->cg.child_time) / sym->ncalls;
@@ -631,7 +652,7 @@ hist_print ()
 	    {
 	      double scaled_value = SItab[log_scale].scale * top_time;
 
-	      if (scaled_value >= 1.0 && scaled_value < 1000.0) 
+	      if (scaled_value >= 1.0 && scaled_value < 1000.0)
 		break;
 	    }
 	}
@@ -669,7 +690,7 @@ hist_check_address (unsigned address)
     if (histograms[i].lowpc <= address && address < histograms[i].highpc)
       return 1;
 
-  return 0;        
+  return 0;
 }
 
 #if ! defined(min)
@@ -744,5 +765,5 @@ find_histogram_for_pc (bfd_vma pc)
       if (histograms[i].lowpc <= pc && pc < histograms[i].highpc)
 	return &histograms[i];
     }
-  return 0;  
+  return 0;
 }
--- a/gprof/mips.c
+++ b/gprof/mips.c
@@ -46,6 +46,7 @@ mips_find_call (Sym *parent, bfd_vma p_l
   int offset;
   Sym *child;
   static bfd_boolean inited = FALSE;
+  int mips16;
 
   if (!inited)
     {
@@ -55,46 +56,123 @@ mips_find_call (Sym *parent, bfd_vma p_l
       indirect_child.cg.prop.fract = 1.0;
       indirect_child.cg.cyc.head = &indirect_child;
     }
+  mips16 = (p_lowpc & 1) != 0;
+  p_lowpc &= ~1;
+  p_highpc &= ~1;
 
-  DBG (CALLDEBUG, printf (_("[find_call] %s: 0x%lx to 0x%lx\n"),
+  DBG (CALLDEBUG, printf (_("[find_call] %s: 0x%lx to 0x%lx%s\n"),
 			  parent->name, (unsigned long) p_lowpc,
-			  (unsigned long) p_highpc));
-  for (pc = p_lowpc; pc < p_highpc; pc += 4)
+			  (unsigned long) p_highpc,
+			  mips16 ? " (mips16)" : ""));
+  for (pc = p_lowpc; pc < p_highpc;)
     {
-      op = bfd_get_32 (core_bfd, ((unsigned char *)core_text_space
-                                 + pc - core_text_sect->vma));
-      if ((op & 0xfc000000) == 0x0c000000)
+      if (!mips16)
 	{
-	  /* This is a "jal" instruction.  Check that the destination
-	     is the address of a function.  */
-	  DBG (CALLDEBUG,
-	       printf (_("[find_call] 0x%lx: jal"), (unsigned long) pc));
-          offset = (op & 0x03ffffff) << 2;
-	  dest_pc = (pc & ~(bfd_vma) 0xfffffff) | offset;
-	  if (hist_check_address (dest_pc))
+	  op = bfd_get_32 (core_bfd, &((char *)core_text_space)[pc - p_lowpc]);
+	  pc += 4;
+	  if ((op & 0xfc000000) == 0x0c000000)		/* jal */
+	    {
+	      DBG (CALLDEBUG,
+		   printf (_("[find_call] 0x%lx: jal"), (unsigned long) pc-4));
+	      offset = (op & 0x03ffffff) << 2;
+	      dest_pc = (pc & ~(bfd_vma) 0xfffffff) | offset;
+	      pc += 4; /* skip delay slot */
+	    }
+	  else if ((op & 0xfc000000) == 0x74000000) 	/* jalx */
 	    {
-	      child = sym_lookup (&symtab, dest_pc);
 	      DBG (CALLDEBUG,
-		   printf (" 0x%lx\t; name=%s, addr=0x%lx",
-			   (unsigned long) dest_pc, child->name,
-			   (unsigned long) child->addr));
-	      if (child->addr == dest_pc)
-		{
-		  DBG (CALLDEBUG, printf ("\n"));
-		  /* a hit:  */
-		  arc_add (parent, child, (unsigned long) 0);
-		  continue;
-		}
+		   printf (_("[find_call] 0x%lx: jalx"), (unsigned long) pc-4));
+	      offset = (op & 0x03ffffff) << 2;
+	      dest_pc = (pc & ~(bfd_vma) 0xfffffff) | offset | 1;
+	      pc += 4; /* skip delay slot */
+	    }
+	  else if ((op & 0xfc1f07ff) == 0x00000009)	/* jalr */
+	    {
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:jalr\n" ,
+				      (unsigned long)pc-4));
+	      arc_add (parent, &indirect_child, (long)0);
+	      pc += 4; /* skip delay slot */
+	      continue;
 	    }
-	  /* Something funny going on.  */
-	  DBG (CALLDEBUG, printf ("\tbut it's a botch\n"));
+	  else if ((op & 0xfc1c0000) == 0x04100000)	/* bxxzal */
+	    {
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:bal" ,
+				      (unsigned long)pc-4));
+	      dest_pc = pc + ((short)op << 2) + 4;
+	      pc += 4; /* skip delay slot */
+	    }
+	  else
+	    continue;
 	}
-      else if ((op & 0xfc00f83f) == 0x0000f809)
+      else
 	{
-	  /* This is a "jalr" instruction (indirect call).  */
+	  /* MIPS16 function */
+	  op = bfd_get_16 (core_bfd, &((char *)core_text_space)[pc - p_lowpc]);
+	  pc += 2;
+	  if ((op & 0xfc00) == 0x1800			/* jal */
+	      || (op & 0xfc00) == 0x1c00)		/* jalx */
+	    {
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:jal%s",
+				      (unsigned long)pc-2,
+				      (op & 0xfc00) == 0x1c00 ? "x" : ""));
+	      offset = bfd_get_16 (core_bfd,
+				   &((char *)core_text_space)[pc - p_lowpc]);
+	      pc += 2;
+	      offset |= (op & 0x1f) << 21;
+	      offset |= (op & 0x3e0) << (16 - 5);
+	      dest_pc = (pc & ~(bfd_vma)0x0fffffff)
+		+ ((offset & 0x3ffffff) << 2);
+	      if ((op & 0xfc00) == 0x1800)		/* jal */
+		dest_pc |= 1;
+	      pc += 2;		/* skip delay slot */
+	    }
+	  else if ((op & 0xf8ff) == 0xe840)		/* jalr */
+	    {
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:jalr\n" ,
+				      (unsigned long)pc-2));
+	      arc_add (parent, &indirect_child, (long)0);
+	      pc += 2;		/* skip delay slot */
+	      continue;
+	    }
+	  else if ((op & 0xf8ff) == 0xe8c0)		/* jalrc */
+	    {
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:jalrc\n" ,
+				      (unsigned long)pc-2));
+	      arc_add (parent, &indirect_child, (long)0);
+	      continue;
+	    }
+	  else if ((op & 0xff7f) == 0xe820		/* jr/jrc $31 */
+		   || (op & 0xff7f) == 0xef00		/* jr/jrc $7 */
+		   || (op & 0xff80) == 0x6400		/* restore */
+		   || (op & 0xff1f) == 0xed09		/* exit */
+		   || (op & 0xff1f) == 0xee09		/* exit */
+		   || (op & 0xff1f) == 0xef09)		/* exit */
+	    {
+	      /* Skip constants after the end of the function. */
+	      DBG (CALLDEBUG, printf ("[find_call]\t0x%lx:end\n" ,
+				      (unsigned long)pc-2));
+	      return;
+	    }
+	  else
+	    continue;
+	}
+
+      if (dest_pc >= p_lowpc && dest_pc <= p_highpc)
+	{
+	  child = sym_lookup (&symtab, dest_pc);
 	  DBG (CALLDEBUG,
-	       printf (_("[find_call] 0x%lx: jalr\n"), (unsigned long) pc));
-	  arc_add (parent, &indirect_child, (unsigned long) 0);
+	       printf (" 0x%lx\t; name=%s, addr=0x%lx",
+		       (unsigned long) dest_pc, child->name,
+		       (unsigned long) child->addr));
+	  if (child->addr == dest_pc)
+	    {
+	      DBG (CALLDEBUG, printf ("\n"));
+	      /* a hit:  */
+	      arc_add (parent, child, (unsigned long) 0);
+	      continue;
+	    }
 	}
+      /* Something funny going on.  */
+      DBG (CALLDEBUG, printf ("\tbut it's a botch\n"));
     }
 }
--- a/include/elf/arm.h
+++ b/include/elf/arm.h
@@ -71,9 +71,11 @@
 #define STT_ARM_16BIT      STT_HIPROC   /* A Thumb label.  */
 
 /* Additional section types.  */
-#define SHT_ARM_EXIDX	   0x70000001	/* Section holds ARM unwind info.  */
-#define SHT_ARM_PREEMPTMAP 0x70000002	/* Section pre-emption details.  */
-#define SHT_ARM_ATTRIBUTES 0x70000003	/* Section holds attributes.  */
+#define SHT_ARM_EXIDX          0x70000001	/* Section holds ARM unwind info.  */
+#define SHT_ARM_PREEMPTMAP     0x70000002	/* Section pre-emption details.  */
+#define SHT_ARM_ATTRIBUTES     0x70000003	/* Section holds attributes.  */
+#define SHT_ARM_DEBUGOVERLAY   0x70000004	/* Section holds overlay debug info.  */
+#define SHT_ARM_OVERLAYSECTION 0x70000005	/* Section holds GDB and overlay integration info.  */
 
 /* ARM-specific values for sh_flags.  */
 #define SHF_ENTRYSECT      0x10000000   /* Section contains an entry point.  */
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -591,6 +591,10 @@ extern int pexecute (const char *, char 
 
 extern int pwait (int, int *, int);
 
+/* Convert a Cygwin path to a Windows path.  */
+
+extern int cygpath (const char *, char []);
+
 #if !HAVE_DECL_ASPRINTF
 /* Like sprintf but provides a pointer to malloc'd storage, which must
    be freed by the caller.  */
--- a/include/opcode/arm.h
+++ b/include/opcode/arm.h
@@ -53,6 +53,7 @@
 #define ARM_CEXT_MAVERICK 0x00000002	/* Use Cirrus/DSP coprocessor.  */
 #define ARM_CEXT_IWMMXT   0x00000004    /* Intel Wireless MMX technology coprocessor.   */
 #define ARM_CEXT_IWMMXT2  0x00000008    /* Intel Wireless MMX technology coprocessor version 2.   */
+#define ARM_CEXT_MARVELL_F 0x00000010	/* Marvell division extension. */
 
 #define FPU_ENDIAN_PURE	 0x80000000	/* Pure-endian doubles.	      */
 #define FPU_ENDIAN_BIG	 0		/* Double words-big-endian.   */
@@ -116,6 +117,8 @@
  ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_XSCALE | ARM_CEXT_IWMMXT)
 #define ARM_ARCH_IWMMXT2	\
  ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_XSCALE | ARM_CEXT_IWMMXT | ARM_CEXT_IWMMXT2)
+#define ARM_ARCH_MARVELL_F	\
+ ARM_FEATURE (ARM_AEXT_V5TE, ARM_CEXT_MARVELL_F)
 
 #define FPU_VFP_V1xD	(FPU_VFP_EXT_V1xD | FPU_ENDIAN_PURE)
 #define FPU_VFP_V1	(FPU_VFP_V1xD | FPU_VFP_EXT_V1)
--- a/include/opcode/mips.h
+++ b/include/opcode/mips.h
@@ -843,6 +843,8 @@ enum
   M_S_DOB,
   M_S_DAB,
   M_S_S,
+  M_SAA_AB,
+  M_SAAD_AB,
   M_SC_AB,
   M_SCD_AB,
   M_SD_A,
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -163,6 +163,12 @@ ALL_EMULATIONS = \
 	eelf32bfinfd.o \
 	eelf32cr16.o \
 	eelf32cr16c.o \
+	eelf32ebocteon.o \
+	eelf32elocteon.o \
+	eelf32ebocteonn32.o \
+	eelf32elocteonn32.o \
+	eelf64ebocteon.o \
+	eelf64elocteon.o \
 	eelf32bmip.o \
 	eelf32bmipn32.o \
 	eelf32btsmip.o \
@@ -789,6 +795,35 @@ eelf32cr16c.c: $(srcdir)/emulparams/elf3
   $(ELF_DEPS) \
   $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32cr16c "$(tdir_elf32cr16c)"
+eelf32ebocteon.c: $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emulparams/elf32bmip.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebocteon "$(tdir_elf32ebocteon)"
+eelf32elocteon.c: $(srcdir)/emulparams/elf32elocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elocteon "$(tdir_elf32elocteon)"
+eelf32ebocteonn32.c: $(srcdir)/emulparams/elf32ebocteonn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebocteonn32 "$(tdir_elf32ebocteonn32)"
+eelf32elocteonn32.c: $(srcdir)/emulparams/elf32elocteonn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elocteonn32 "$(tdir_elf32elocteonn32)"
+eelf64ebocteon.c: $(srcdir)/emulparams/elf64ebocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ebocteon "$(tdir_elf64ebocteon)"
+eelf64elocteon.c: $(srcdir)/emulparams/elf64elocteon.sh \
+  $(srcdir)/emulparams/elf64ebocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64elocteon "$(tdir_elf64elocteon)"
 eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
   $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32bmip "$(tdir_elf32bmip)"
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -427,6 +427,12 @@ ALL_EMULATIONS = \
 	eelf32bfinfd.o \
 	eelf32cr16.o \
 	eelf32cr16c.o \
+	eelf32ebocteon.o \
+	eelf32elocteon.o \
+	eelf32ebocteonn32.o \
+	eelf32elocteonn32.o \
+	eelf64ebocteon.o \
+	eelf64elocteon.o \
 	eelf32bmip.o \
 	eelf32bmipn32.o \
 	eelf32btsmip.o \
@@ -1635,6 +1641,35 @@ eelf32cr16c.c: $(srcdir)/emulparams/elf3
   $(ELF_DEPS) \
   $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32cr16c "$(tdir_elf32cr16c)"
+eelf32ebocteon.c: $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emulparams/elf32bmip.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebocteon "$(tdir_elf32ebocteon)"
+eelf32elocteon.c: $(srcdir)/emulparams/elf32elocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elocteon "$(tdir_elf32elocteon)"
+eelf32ebocteonn32.c: $(srcdir)/emulparams/elf32ebocteonn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebocteonn32 "$(tdir_elf32ebocteonn32)"
+eelf32elocteonn32.c: $(srcdir)/emulparams/elf32elocteonn32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elocteonn32 "$(tdir_elf32elocteonn32)"
+eelf64ebocteon.c: $(srcdir)/emulparams/elf64ebocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ebocteon "$(tdir_elf64ebocteon)"
+eelf64elocteon.c: $(srcdir)/emulparams/elf64elocteon.sh \
+  $(srcdir)/emulparams/elf64ebocteon.sh \
+  $(srcdir)/emulparams/elf32ebocteon.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/octeonelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64elocteon "$(tdir_elf64elocteon)"
 eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
   $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32bmip "$(tdir_elf32bmip)"
--- a/ld/config.in
+++ b/ld/config.in
@@ -4,6 +4,9 @@
    language is requested. */
 #undef ENABLE_NLS
 
+/* Define to warn for use of native system library directories */
+#undef ENABLE_POISON_SYSTEM_DIRECTORIES
+
 /* Additional extension a shared object might have. */
 #undef EXTRA_SHLIB_EXTENSION
 
--- a/ld/configure
+++ b/ld/configure
@@ -1004,6 +1004,8 @@ Optional Features:
   --enable-dependency-tracking   do not reject slow dependency extractors
   --enable-targets        alternative target configurations
   --enable-64-bit-bfd     64-bit support (on hosts with narrower word sizes)
+  --enable-poison-system-directories
+                          warn for use of native system library directories
   --enable-got=<type>     GOT handling scheme (target, single, negative,
                           multigot)
   --enable-werror         treat compile warnings as errors
@@ -3341,6 +3343,21 @@ fi;
 
 
 
+# Check whether --enable-poison-system-directories or --disable-poison-system-directories was given.
+if test "${enable_poison_system_directories+set}" = set; then
+  enableval="$enable_poison_system_directories"
+
+else
+  enable_poison_system_directories=no
+fi;
+if test "x${enable_poison_system_directories}" = "xyes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_POISON_SYSTEM_DIRECTORIES 1
+_ACEOF
+
+fi
+
 # Check whether --enable-got or --disable-got was given.
 if test "${enable_got+set}" = set; then
   enableval="$enable_got"
@@ -5795,13 +5812,13 @@ if test "${lt_cv_nm_interface+set}" = se
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:5798: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:5815: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5801: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:5818: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5804: output\"" >&5)
+  (eval echo "\"\$as_me:5821: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -6958,7 +6975,7 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 6961 "configure"' > conftest.$ac_ext
+  echo '#line 6978 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -8264,11 +8281,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8267: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8284: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8271: \$? = $ac_status" >&5
+   echo "$as_me:8288: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8603,11 +8620,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8606: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8623: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8610: \$? = $ac_status" >&5
+   echo "$as_me:8627: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8708,11 +8725,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8711: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8728: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8715: \$? = $ac_status" >&5
+   echo "$as_me:8732: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8763,11 +8780,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8766: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8783: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8770: \$? = $ac_status" >&5
+   echo "$as_me:8787: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11575,7 +11592,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11578 "configure"
+#line 11595 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11671,7 +11688,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11674 "configure"
+#line 11691 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
--- a/ld/configure.in
+++ b/ld/configure.in
@@ -68,6 +68,16 @@ AC_SUBST(use_sysroot)
 AC_SUBST(TARGET_SYSTEM_ROOT)
 AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
 
+AC_ARG_ENABLE([poison-system-directories],
+	      AS_HELP_STRING([--enable-poison-system-directories],
+			     [warn for use of native system library directories]),,
+	      [enable_poison_system_directories=no])
+if test "x${enable_poison_system_directories}" = "xyes"; then
+  AC_DEFINE([ENABLE_POISON_SYSTEM_DIRECTORIES],
+	    [1],
+	    [Define to warn for use of native system library directories])
+fi
+
 AC_ARG_ENABLE([got],
 AS_HELP_STRING([--enable-got=<type>],
                [GOT handling scheme (target, single, negative, multigot)]),
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -380,6 +380,9 @@ mips*vr4100el-*-elf*)	targ_emul=elf32l43
 mips*vr4100-*-elf*)	targ_emul=elf32b4300 ;;
 mips*vr5000el-*-elf*)	targ_emul=elf32l4300 ;;
 mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
+mips64octeon*-*-elf*) targ_emul=elf32ebocteon
+			targ_extra_emuls="elf32elocteon elf32ebocteonn32 elf32elocteonn32 elf64ebocteon elf64elocteon"
+			;;
 mips*el-sde-elf*)	targ_emul=elf32ltsmip
 			targ_extra_emuls="elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip" ;;
 mips*-sde-elf*)		targ_emul=elf32btsmip
@@ -392,6 +395,10 @@ mips*el-*-vxworks*)	targ_emul=elf32elmip
 mips*-*-vxworks*)	targ_emul=elf32ebmipvxworks
 		        targ_extra_emuls="elf32elmipvxworks" ;;
 mips*-*-windiss)	targ_emul=elf32mipswindiss ;;
+mips64el-sicortex-linux-gnu)
+			targ_emul=elf64ltsmip
+			targ_extra_emuls="elf32ltsmipn32 elf32btsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
 mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
 			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
 			targ_extra_libpath=$targ_extra_emuls ;;
--- a/ld/emulparams/armelf.sh
+++ b/ld/emulparams/armelf.sh
@@ -6,7 +6,7 @@ LITTLE_OUTPUT_FORMAT="elf32-littlearm"
 TEXT_START_ADDR=0x8000
 TEMPLATE_NAME=elf32
 EXTRA_EM_FILE=armelf
-OTHER_TEXT_SECTIONS='*(.glue_7t) *(.glue_7) *(.vfp11_veneer) *(.v4_bx)'
+OTHER_TEXT_SECTIONS='*(.glue_7t) *(.glue_7) *(.vfp11_veneer) *(.janus_2cc_veneer) *(.v4_bx)'
 OTHER_BSS_SYMBOLS='__bss_start__ = .;'
 OTHER_BSS_END_SYMBOLS='_bss_end__ = . ; __bss_end__ = . ;'
 OTHER_END_SYMBOLS='__end__ = . ;'
--- a/ld/emulparams/elf32ebmipvxworks.sh
+++ b/ld/emulparams/elf32ebmipvxworks.sh
@@ -13,6 +13,9 @@ OTHER_READWRITE_SECTIONS="
   .rdata ${RELOCATING-0} : ONLY_IF_RW { *(.rdata) }
 "
 unset OTHER_GOT_SYMBOLS
+unset GOT
+unset GOTPLT
+unset DATA_GOTPLT
 SHLIB_TEXT_START_ADDR=0
 unset TEXT_DYNAMIC
 unset DATA_ADDR
--- /dev/null
+++ b/ld/emulparams/elf32ebocteon.sh
@@ -0,0 +1,45 @@
+# If you change this file, please also look at files which source this one:
+# elf32locteon.sh
+
+EMBEDDED=yes
+. ${srcdir}/emulparams/elf32btsmip.sh
+
+# Entry point symbol.
+ENTRY=__start
+
+# Start of the .text section
+TEXT_START_ADDR=0x10000000
+
+# Data and .cmvx_shared are 32M pages. Unlike what the documentation says we 
+# always use (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - COMMONPAGESIZE))) to 
+# align data. On-disk image will have at most 4K (ELF_MAXPAGESIZE) padding 
+# before data.
+MAXPAGESIZE=32M
+COMMONPAGESIZE=32M
+# Needed to disable demand paging.
+EXTRA_EM_FILE=octeonelf
+
+# If defined, the genscripts.sh script sets TEXT_START_ADDR to its value
+# for the -n/-N options.
+# Define this as the TEXT_START_ADDR is different to overright the one 
+# defined in elf32bmip.sh
+NONPAGED_TEXT_START_ADDR=0x10000000
+
+# Create new macro to place .cvmx_shared at the end of _end.
+OCTEON_SPECIAL_SECTIONS='
+   . = ALIGN(32M);   /* RBF added alignment of data */
+   __cvmx_shared_start = .;
+   .cvmx_shared : { *(.cvmx_shared .cvmx_shared.linkonce.*) }
+   .cvmx_shared_bss : { *(.cvmx_shared_bss .cvmx_shared_bss.linkonce.*) }
+   __cvmx_shared_end = .;'
+
+OTHER_END_SYMBOLS='
+   /* All symbols above this (32 bit compat space) the simulator will attribute
+      to the bootloader. */
+    __bootloader = 0xFFFFFFF8;'
+
+EXECUTABLE_SYMBOLS='
+   PROVIDE(__cvmx_app_init = 0);
+   PROVIDE(__cvmx_app_exit = 0);
+   PROVIDE(__cvmx_pci_console_write = 0);
+   PROVIDE(__cvmx_pci_console_read = 0);'
--- /dev/null
+++ b/ld/emulparams/elf32ebocteonn32.sh
@@ -0,0 +1,6 @@
+EMBEDDED=yes
+. ${srcdir}/emulparams/elf32ebocteon.sh
+
+OUTPUT_FORMAT="elf32-ntradbigmips"
+BIG_OUTPUT_FORMAT="elf32-ntradbigmips"
+LITTLE_OUTPUT_FORMAT="elf32-ntradlittlemips"
--- a/ld/emulparams/elf32elmipvxworks.sh
+++ b/ld/emulparams/elf32elmipvxworks.sh
@@ -4,6 +4,9 @@ OUTPUT_FORMAT="elf32-littlemips-vxworks"
 BIG_OUTPUT_FORMAT="elf32-bigmips-vxworks"
 LITTLE_OUTPUT_FORMAT="elf32-littlemips-vxworks"
 unset OTHER_GOT_SYMBOLS
+unset GOT
+unset GOTPLT
+unset DATA_GOTPLT
 SHLIB_TEXT_START_ADDR=0
 unset TEXT_DYNAMIC
 unset DATA_ADDR
--- /dev/null
+++ b/ld/emulparams/elf32elocteon.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf32ebocteon.sh
+OUTPUT_FORMAT=$LITTLE_OUTPUT_FORMAT
--- /dev/null
+++ b/ld/emulparams/elf32elocteonn32.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf32ebocteonn32.sh
+OUTPUT_FORMAT="elf32-ntradlittlemips"
--- /dev/null
+++ b/ld/emulparams/elf64ebocteon.sh
@@ -0,0 +1,6 @@
+EMBEDDED=yes
+. ${srcdir}/emulparams/elf32ebocteon.sh
+
+OUTPUT_FORMAT="elf64-tradbigmips"
+BIG_OUTPUT_FORMAT="elf64-tradbigmips"
+LITTLE_OUTPUT_FORMAT="elf64-tradlittlemips"
--- /dev/null
+++ b/ld/emulparams/elf64elocteon.sh
@@ -0,0 +1,2 @@
+. ${srcdir}/emulparams/elf64ebocteon.sh
+OUTPUT_FORMAT=$LITTLE_OUTPUT_FORMAT
--- a/ld/emultempl/armelf.em
+++ b/ld/emultempl/armelf.em
@@ -31,13 +31,14 @@ fragment <<EOF
 #include "elf/arm.h"
 
 static char *thumb_entry_symbol = NULL;
-static bfd *bfd_for_interwork;
 static int byteswap_code = 0;
 static int target1_is_rel = 0${TARGET1_IS_REL};
 static char *target2_type = "${TARGET2_TYPE}";
 static int fix_v4bx = 0;
 static int use_blx = 0;
 static bfd_arm_vfp11_fix vfp11_denorm_fix = BFD_ARM_VFP11_FIX_DEFAULT;
+static int fix_janus_2cc = 0;
+static int fix_cortex_a8 = -1;
 static int no_enum_size_warning = 0;
 static int no_wchar_size_warning = 0;
 static int pic_veneer = 0;
@@ -53,67 +54,21 @@ gld${EMULATION_NAME}_before_parse (void)
 }
 
 static void
-arm_elf_after_open (void)
-{
-  {
-    LANG_FOR_EACH_INPUT_STATEMENT (is)
-      {
-	bfd_elf32_arm_add_glue_sections_to_bfd (is->the_bfd, & link_info);
-      }
-  }
-
-  /* Call the standard elf routine.  */
-  gld${EMULATION_NAME}_after_open ();
-}
-
-static void
-arm_elf_set_bfd_for_interworking (lang_statement_union_type *statement)
-{
-  if (statement->header.type == lang_input_section_enum)
-    {
-      asection *i = statement->input_section.section;
-
-      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
-	  && (i->flags & SEC_EXCLUDE) == 0)
-	{
-	  asection *output_section = i->output_section;
-
-	  ASSERT (output_section->owner == link_info.output_bfd);
-
-	  /* Don't attach the interworking stubs to a dynamic object, to
-	     an empty section, etc.  */
-	  if ((output_section->flags & SEC_HAS_CONTENTS) != 0
-	      && (i->flags & SEC_NEVER_LOAD) == 0
-	      && ! (i->owner->flags & DYNAMIC))
-	    bfd_for_interwork = i->owner;
-	}
-    }
-}
-
-static void
 arm_elf_before_allocation (void)
 {
-  if (link_info.input_bfds != NULL)
-    {
-      /* The interworking bfd must be the last one in the link.  */
-      bfd_for_interwork = NULL;
-
-      lang_for_each_statement (arm_elf_set_bfd_for_interworking);
-
-      /* If bfd_for_interwork is NULL, then there are no loadable sections
-	 with real contents to be linked, so we are not going to have to
-	 create any interworking stubs, so it is OK not to call
-	 bfd_elf32_arm_get_bfd_for_interworking.  */
-      if (bfd_for_interwork != NULL)
-	bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
-    }
-
   bfd_elf32_arm_set_byteswap_code (&link_info, byteswap_code);
 
   /* Choose type of VFP11 erratum fix, or warn if specified fix is unnecessary
      due to architecture version.  */
   bfd_elf32_arm_set_vfp11_fix (link_info.output_bfd, &link_info);
 
+  /* Make sure we haven't selected the Janus 2CC fix on an architecture for
+     which it is unnecessary.  */
+  bfd_elf32_arm_validate_janus_2cc_fix (link_info.output_bfd, &link_info);
+
+  /* Auto-select Cortex-A8 erratum fix if it wasn't explicitly specified.  */
+  bfd_elf32_arm_set_cortex_a8_fix (link_info.output_bfd, &link_info);
+
   /* We should be able to set the size of the interworking stub section.  We
      can't do it until later if we have dynamic sections, though.  */
   if (! elf_hash_table (&link_info)->dynamic_sections_created)
@@ -126,17 +81,19 @@ arm_elf_before_allocation (void)
 
 	  if (!bfd_elf32_arm_process_before_allocation (is->the_bfd,
 							&link_info)
-	      || !bfd_elf32_arm_vfp11_erratum_scan (is->the_bfd, &link_info))
+	      || !bfd_elf32_arm_vfp11_erratum_scan (is->the_bfd, &link_info)
+	      || !bfd_elf32_arm_janus_2cc_erratum_scan (is->the_bfd,
+							&link_info))
 	    /* xgettext:c-format */
 	    einfo (_("Errors encountered processing file %s"), is->filename);
 	}
+
+      /* We have seen it all.  Allocate it, and carry on.  */
+      bfd_elf32_arm_allocate_interworking_sections (& link_info);
     }
 
   /* Call the standard elf routine.  */
   gld${EMULATION_NAME}_before_allocation ();
-
-  /* We have seen it all. Allocate it, and carry on.  */
-  bfd_elf32_arm_allocate_interworking_sections (& link_info);
 }
 
 static void
@@ -150,7 +107,7 @@ arm_elf_after_allocation (void)
       {
         /* Figure out where VFP11 erratum veneers (and the labels returning
            from same) have been placed.  */
-        bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
+        bfd_elf32_arm_fix_veneer_locations (is->the_bfd, &link_info);
       }
   }
 }
@@ -213,9 +170,9 @@ hook_in_stub (struct hook_stub_info *inf
 	  if (l->input_section.section == info->input_section)
 	    {
 	      /* We've found our section.  Insert the stub immediately
-		 before its associated input section.  */
-	      *lp = info->add.head;
-	      *(info->add.tail) = l;
+		 after its associated input section.  */
+	      *(info->add.tail) = l->header.next;
+	      l->header.next = info->add.head;
 	      return TRUE;
 	    }
 	  break;
@@ -244,7 +201,7 @@ hook_in_stub (struct hook_stub_info *inf
 /* Call-back for elf32_arm_size_stubs.  */
 
 /* Create a new stub section, and arrange for it to be linked
-   immediately before INPUT_SECTION.  */
+   immediately after INPUT_SECTION.  */
 
 static asection *
 elf32_arm_add_stub_section (const char *stub_sec_name,
@@ -312,10 +269,78 @@ build_section_lists (lang_statement_unio
     }
 }
 
+static int
+compare_output_sec_vma (const void *a, const void *b)
+{
+  asection *asec = *(asection **) a, *bsec = *(asection **) b;
+  asection *aout = asec->output_section, *bout = bsec->output_section;
+  bfd_vma avma, bvma;
+  
+  /* If there's no output section for some reason, compare equal.  */
+  if (!aout || !bout)
+    return 0;
+  
+  avma = aout->vma + asec->output_offset;
+  bvma = bout->vma + bsec->output_offset;
+  
+  if (avma > bvma)
+    return 1;
+  else if (avma < bvma)
+    return -1;
+  
+  return 0;
+}
+
 static void
 gld${EMULATION_NAME}_finish (void)
 {
   struct bfd_link_hash_entry * h;
+  unsigned int list_size = 10;
+  asection **sec_list = xmalloc (list_size * sizeof (asection *));
+  unsigned int sec_count = 0;
+
+  if (!link_info.relocatable)
+    {
+      /* Build a sorted list of input text sections, then use that to process
+	 the unwind table index.  */
+      LANG_FOR_EACH_INPUT_STATEMENT (is)
+	{
+	  bfd *abfd = is->the_bfd;
+	  asection *sec;
+	  
+	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
+	    continue;
+	  
+	  for (sec = abfd->sections; sec != NULL; sec = sec->next)
+	    {
+	      asection *out_sec = sec->output_section;
+
+	      if (out_sec
+		  && elf_section_type (sec) == SHT_PROGBITS
+		  && (elf_section_flags (sec) & SHF_EXECINSTR) != 0
+		  && (sec->flags & SEC_EXCLUDE) == 0
+		  && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS
+		  && out_sec != bfd_abs_section_ptr)
+		{
+		  if (sec_count == list_size)
+		    {
+		      list_size *= 2;
+		      sec_list = xrealloc (sec_list,
+					   list_size * sizeof (asection *));
+		    }
+
+		  sec_list[sec_count++] = sec;
+		}
+	    }
+	}
+	
+      qsort (sec_list, sec_count, sizeof (asection *), &compare_output_sec_vma);
+      
+      if (elf32_arm_fix_exidx_coverage (sec_list, sec_count, &link_info))
+	need_laying_out = 1;
+      
+      free (sec_list);
+    }
 
   /* bfd_elf32_discard_info just plays with debugging sections,
      ie. doesn't affect any code, so we can delay resizing the
@@ -444,7 +469,7 @@ arm_elf_create_output_section_statements
 				   target2_type, fix_v4bx, use_blx,
 				   vfp11_denorm_fix, no_enum_size_warning,
 				   no_wchar_size_warning,
-				   pic_veneer);
+				   pic_veneer, fix_janus_2cc, fix_cortex_a8);
 
   stub_file = lang_add_input_file ("linker stubs",
  				   lang_input_file_is_fake_enum,
@@ -461,6 +486,10 @@ arm_elf_create_output_section_statements
  
   stub_file->the_bfd->flags |= BFD_LINKER_CREATED;
   ldlang_add_file (stub_file);
+
+  /* Also use the stub file for stubs placed in a single output section.  */
+  bfd_elf32_arm_add_glue_sections_to_bfd (stub_file->the_bfd, &link_info);
+  bfd_elf32_arm_get_bfd_for_interworking (stub_file->the_bfd, &link_info);
 }
 
 /* Avoid processing the fake stub_file in vercheck, stat_needed and
@@ -500,8 +529,11 @@ PARSE_AND_LIST_PROLOGUE='
 #define OPTION_NO_ENUM_SIZE_WARNING	309
 #define OPTION_PIC_VENEER		310
 #define OPTION_FIX_V4BX_INTERWORKING	311
-#define OPTION_STUBGROUP_SIZE           312
+#define OPTION_STUBGROUP_SIZE		312
 #define OPTION_NO_WCHAR_SIZE_WARNING	313
+#define OPTION_FIX_JANUS_2CC		314
+#define OPTION_FIX_CORTEX_A8		315
+#define OPTION_NO_FIX_CORTEX_A8		316
 '
 
 PARSE_AND_LIST_SHORTOPTS=p
@@ -521,6 +553,9 @@ PARSE_AND_LIST_LONGOPTS='
   { "pic-veneer", no_argument, NULL, OPTION_PIC_VENEER},
   { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
   { "no-wchar-size-warning", no_argument, NULL, OPTION_NO_WCHAR_SIZE_WARNING},
+  { "fix-janus-2cc", no_argument, NULL, OPTION_FIX_JANUS_2CC},
+  { "fix-cortex-a8", no_argument, NULL, OPTION_FIX_CORTEX_A8},
+  { "no-fix-cortex-a8", no_argument, NULL, OPTION_NO_FIX_CORTEX_A8},
 '
 
 PARSE_AND_LIST_OPTIONS='
@@ -541,12 +576,14 @@ PARSE_AND_LIST_OPTIONS='
   fprintf (file, _("\
    --stub-group-size=N   Maximum size of a group of input sections that can be\n\
                            handled by one stub section.  A negative value\n\
-                           locates all stubs before their branches (with a\n\
+                           locates all stubs after their branches (with a\n\
                            group size of -N), while a positive value allows\n\
                            two groups of input sections, one before, and one\n\
                            after each stub section.  Values of +/-1 indicate\n\
                            the linker should choose suitable defaults.\n"
  		   ));
+  fprintf (file, _("  --fix-janus-2cc             Enable Janus 2CC erratum fix\n"));
+  fprintf (file, _("  --[no-]fix-cortex-a8        Disable/enable Cortex-A8 Thumb-2 branch erratum fix\n"));
 '
 
 PARSE_AND_LIST_ARGS_CASES='
@@ -618,11 +655,22 @@ PARSE_AND_LIST_ARGS_CASES='
 	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
       }
       break;
+
+    case OPTION_FIX_JANUS_2CC:
+      fix_janus_2cc = 1;
+      break;
+    
+    case OPTION_FIX_CORTEX_A8:
+      fix_cortex_a8 = 1;
+      break;
+
+    case OPTION_NO_FIX_CORTEX_A8:
+      fix_cortex_a8 = 0;
+      break;
 '
 
-# We have our own after_open and before_allocation functions, but they call
+# We have our own before_allocation etc. functions, but they call
 # the standard routines, so give them a different name.
-LDEMUL_AFTER_OPEN=arm_elf_after_open
 LDEMUL_BEFORE_ALLOCATION=arm_elf_before_allocation
 LDEMUL_AFTER_ALLOCATION=arm_elf_after_allocation
 LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=arm_elf_create_output_section_statements
--- a/ld/emultempl/m68kelf.em
+++ b/ld/emultempl/m68kelf.em
@@ -33,10 +33,7 @@ esac
 
 case ${target} in
   *-linux*)
-# Don't use multi-GOT by default due to glibc linker's assumption
-# that GOT pointer points to GOT[0].
-#   got_handling_target_default=GOT_HANDLING_MULTIGOT
-    got_handling_target_default=GOT_HANDLING_SINGLE
+    got_handling_target_default=GOT_HANDLING_MULTIGOT
     ;;
   *)
     got_handling_target_default=GOT_HANDLING_SINGLE
--- /dev/null
+++ b/ld/emultempl/octeonelf.em
@@ -0,0 +1,42 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2007 Cavium Networks.
+#
+# This file is part of GLD, the Gnu Linker.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+#
+
+# This file is sourced from elf32.em and used to define OCTEON and ELF
+# specific things.
+
+source_em ${srcdir}/emultempl/mipself.em
+
+fragment <<EOF
+
+static void
+elfocteon_before_parse (void)
+{
+  gld${EMULATION_NAME}_before_parse ();
+
+  /* To be able to directly map file blocks to memory blocks, demand paging
+     requires addresses and file offsets to be equal modulo the page size 
+     (64K). We also want segment virtual addresses to be 32M aligned which 
+     would require extensive padding in the file up to pagesize.  Instead 
+     disable demand paging which is not used on our embedded target.  */
+  config.magic_demand_paged = FALSE;
+}
+EOF
+
+LDEMUL_BEFORE_PARSE=elfocteon_before_parse
--- a/ld/ld.h
+++ b/ld/ld.h
@@ -177,6 +177,14 @@ typedef struct {
      input files.  */
   bfd_boolean accept_unknown_input_arch;
 
+  /* If TRUE (the default) warn for uses of system directories when
+     cross linking.  */
+  bfd_boolean poison_system_directories;
+
+  /* If TRUE (default FALSE) give an error for uses of system
+     directories when cross linking instead of a warning.  */
+  bfd_boolean error_poison_system_directories;
+
   /* Big or little endian as set on command line.  */
   enum { ENDIAN_UNSET = 0, ENDIAN_BIG, ENDIAN_LITTLE } endian;
 
--- a/ld/ld.texinfo
+++ b/ld/ld.texinfo
@@ -335,11 +335,20 @@ prefixed by @samp{-Wl,} (or whatever is 
 compiler driver) like this:
 
 @smallexample
-  gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup
+  gcc -Wl,--start-group foo.o bar.o -Wl,--end-group
 @end smallexample
 
 This is important, because otherwise the compiler driver program may
-silently drop the linker options, resulting in a bad link.
+silently drop the linker options, resulting in a bad link.  Confusion
+may also arise when passing options that require values through a
+driver, as the use of a space between option and argument acts as
+a separator, and causes the driver to pass only the option to the linker
+and the argument to the compiler.  In this case, it is simplest to use
+the joined forms of both single- and multiple-letter options, such as:
+
+@smallexample
+  gcc foo.o bar.o -Wl,-eENTRY -Wl,-Map=a.map
+@end smallexample
 
 Here is a table of the generic command line switches accepted by the GNU
 linker:
@@ -347,8 +356,8 @@ linker:
 @table @gcctabopt
 @include at-file.texi
 
-@kindex -a@var{keyword}
-@item -a@var{keyword}
+@kindex -a @var{keyword}
+@item -a @var{keyword}
 This option is supported for HP/UX compatibility.  The @var{keyword}
 argument must be one of the strings @samp{archive}, @samp{shared}, or
 @samp{default}.  @samp{-aarchive} is functionally equivalent to
@@ -357,8 +366,8 @@ to @samp{-Bdynamic}.  This option may be
 
 @ifset I960
 @cindex architectures
-@kindex -A@var{arch}
-@item -A@var{architecture}
+@kindex -A @var{arch}
+@item -A @var{architecture}
 @kindex --architecture=@var{arch}
 @itemx --architecture=@var{architecture}
 In the current release of @command{ld}, this option is useful only for the
@@ -514,10 +523,10 @@ Link big-endian objects.  This affects t
 Link little-endian objects.  This affects the default output format.
 @end ifclear
 
-@kindex -f
-@kindex --auxiliary
-@item -f
-@itemx --auxiliary @var{name}
+@kindex -f @var{name}
+@kindex --auxiliary=@var{name}
+@item -f @var{name}
+@itemx --auxiliary=@var{name}
 When creating an ELF shared object, set the internal DT_AUXILIARY field
 to the specified name.  This tells the dynamic linker that the symbol
 table of the shared object should be used as an auxiliary filter on the
@@ -536,10 +545,10 @@ machine specific performance.
 This option may be specified more than once.  The DT_AUXILIARY entries
 will be created in the order in which they appear on the command line.
 
-@kindex -F
-@kindex --filter
+@kindex -F @var{name}
+@kindex --filter=@var{name}
 @item -F @var{name}
-@itemx --filter @var{name}
+@itemx --filter=@var{name}
 When creating an ELF shared object, set the internal DT_FILTER field to
 the specified name.  This tells the dynamic linker that the symbol table
 of the shared object which is being created should be used as a filter
@@ -566,8 +575,8 @@ The @sc{gnu} linker will ignore the @opt
 creating an ELF shared object.
 
 @cindex finalization function
-@kindex -fini
-@item -fini @var{name}
+@kindex -fini=@var{name}
+@item -fini=@var{name}
 When creating an ELF executable or shared object, call NAME when the
 executable or shared object is unloaded, by setting DT_FINI to the
 address of the function.  By default, the linker uses @code{_fini} as
@@ -577,10 +586,10 @@ the function to call.
 @item -g
 Ignored.  Provided for compatibility with other tools.
 
-@kindex -G
-@kindex --gpsize
+@kindex -G @var{value}
+@kindex --gpsize=@var{value}
 @cindex object size
-@item -G@var{value}
+@item -G @var{value}
 @itemx --gpsize=@var{value}
 Set the maximum size of objects to be optimized using the GP register to
 @var{size}.  This is only meaningful for object file formats such as
@@ -588,9 +597,9 @@ MIPS ECOFF which supports putting large 
 sections.  This is ignored for other object file formats.
 
 @cindex runtime library name
-@kindex -h@var{name}
+@kindex -h @var{name}
 @kindex -soname=@var{name}
-@item -h@var{name}
+@item -h @var{name}
 @itemx -soname=@var{name}
 When creating an ELF shared object, set the internal DT_SONAME field to
 the specified name.  When an executable is linked with a shared object
@@ -604,17 +613,17 @@ field rather than the using the file nam
 Perform an incremental link (same as option @samp{-r}).
 
 @cindex initialization function
-@kindex -init
-@item -init @var{name}
+@kindex -init=@var{name}
+@item -init=@var{name}
 When creating an ELF executable or shared object, call NAME when the
 executable or shared object is loaded, by setting DT_INIT to the address
 of the function.  By default, the linker uses @code{_init} as the
 function to call.
 
 @cindex archive files, from cmd line
-@kindex -l@var{namespec}
+@kindex -l @var{namespec}
 @kindex --library=@var{namespec}
-@item -l@var{namespec}
+@item -l @var{namespec}
 @itemx --library=@var{namespec}
 Add the archive or object file specified by @var{namespec} to the
 list of files to link.  This option may be used any number of times.
@@ -650,9 +659,9 @@ behaviour of the AIX linker.
 @end ifset
 
 @cindex search directory, from cmd line
-@kindex -L@var{dir}
+@kindex -L @var{dir}
 @kindex --library-path=@var{dir}
-@item -L@var{searchdir}
+@item -L @var{searchdir}
 @itemx --library-path=@var{searchdir}
 Add path @var{searchdir} to the list of paths that @command{ld} will search
 for archive libraries and @command{ld} control scripts.  You may use this
@@ -660,7 +669,9 @@ option any number of times.  The directo
 in which they are specified on the command line.  Directories specified
 on the command line are searched before the default directories.  All
 @option{-L} options apply to all @option{-l} options, regardless of the
-order in which the options appear.
+order in which the options appear.  @option{-L} options do not affect
+how @command{ld} searches for a linker script unless @option{-T}
+option is specified.
 
 If @var{searchdir} begins with @code{=}, then the @code{=} will be replaced
 by the @dfn{sysroot prefix}, a path specified when the linker is configured.
@@ -677,7 +688,7 @@ at the point in which the linker script 
 
 @cindex emulation
 @kindex -m @var{emulation}
-@item -m@var{emulation}
+@item -m @var{emulation}
 Emulate the @var{emulation} linker.  You can list the available
 emulations with the @samp{--verbose} or @samp{-V} options.
 
@@ -1244,8 +1255,8 @@ duplicate when there are many dynamic mo
 paths for runtime symbol resolution.
 
 @cindex symbols, from command line
-@kindex --defsym @var{symbol}=@var{exp}
-@item --defsym @var{symbol}=@var{expression}
+@kindex --defsym=@var{symbol}=@var{exp}
+@item --defsym=@var{symbol}=@var{expression}
 Create a global symbol in the output file, containing the absolute
 address given by @var{expression}.  You may use this option as many
 times as necessary to define multiple symbols in the command line.  A
@@ -1275,8 +1286,9 @@ is set.  These options may be used to ov
 
 @cindex dynamic linker, from command line
 @kindex -I@var{file}
-@kindex --dynamic-linker @var{file}
-@item --dynamic-linker @var{file}
+@kindex --dynamic-linker=@var{file}
+@item -I@var{file}
+@itemx --dynamic-linker=@var{file}
 Set the name of the dynamic linker.  This is only meaningful when
 generating dynamically linked ELF executables.  The default dynamic
 linker is normally correct; don't use this unless you know what you are
@@ -1347,8 +1359,8 @@ Print a summary of the command-line opti
 @item --target-help
 Print a summary of all target specific options on the standard output and exit.
 
-@kindex -Map
-@item -Map @var{mapfile}
+@kindex -Map=@var{mapfile}
+@item -Map=@var{mapfile}
 Print a link map to the file @var{mapfile}.  See the description of the
 @option{-M} option, above.
 
@@ -1463,8 +1475,8 @@ command line.  Library directories speci
 (including linker scripts specified on the command line) are ignored.
 
 @ifclear SingleFormat
-@kindex --oformat
-@item --oformat @var{output-format}
+@kindex --oformat=@var{output-format}
+@item --oformat=@var{output-format}
 @command{ld} may be configured to support more than one kind of object
 file.  If your @command{ld} is configured this way, you can use the
 @samp{--oformat} option to specify the binary format for the output
@@ -1542,7 +1554,8 @@ but ignored.
 @cindex retaining specified symbols
 @cindex stripping all but some symbols
 @cindex symbols, retaining selectively
-@item --retain-symbols-file @var{filename}
+@kindex --retain-symbols-file=@var{filename}
+@item --retain-symbols-file=@var{filename}
 Retain @emph{only} the symbols listed in the file @var{filename},
 discarding all others.  @var{filename} is simply a flat file, with one
 symbol name per line.  This option is especially useful in environments
@@ -1559,9 +1572,9 @@ You may only specify @samp{--retain-symb
 line.  It overrides @samp{-s} and @samp{-S}.
 
 @ifset GENERIC
-@item -rpath @var{dir}
+@item -rpath=@var{dir}
 @cindex runtime library search path
-@kindex -rpath
+@kindex -rpath=@var{dir}
 Add a directory to the runtime library search path.  This is used when
 linking an ELF executable with shared objects.  All @option{-rpath}
 arguments are concatenated and passed to the runtime linker, which uses
@@ -1587,8 +1600,8 @@ the @option{-rpath} option.
 
 @ifset GENERIC
 @cindex link-time runtime library search path
-@kindex -rpath-link
-@item -rpath-link @var{DIR}
+@kindex -rpath-link=@var{dir}
+@item -rpath-link=@var{dir}
 When using ELF or SunOS, one shared library may require another.  This
 happens when an @code{ld -shared} link includes a shared library as one
 of the input files.
@@ -1656,8 +1669,10 @@ and SunOS platforms.  On SunOS, the link
 shared library if the @option{-e} option is not used and there are
 undefined symbols in the link.
 
-@item --sort-common [= ascending | descending]
 @kindex --sort-common
+@item --sort-common
+@itemx --sort-common=ascending
+@itemx --sort-common=descending
 This option tells @command{ld} to sort the common symbols by alignment in
 ascending or descending order when it places them in the appropriate output
 sections.  The symbol alignments considered are sixteen-byte or larger,
@@ -1665,24 +1680,24 @@ eight-byte, four-byte, two-byte, and one
 between symbols due to alignment constraints.  If no sorting order is
 specified, then descending order is assumed.
 
-@kindex --sort-section name
-@item --sort-section name
+@kindex --sort-section=name
+@item --sort-section=name
 This option will apply @code{SORT_BY_NAME} to all wildcard section
 patterns in the linker script.
 
-@kindex --sort-section alignment
-@item --sort-section alignment
+@kindex --sort-section=alignment
+@item --sort-section=alignment
 This option will apply @code{SORT_BY_ALIGNMENT} to all wildcard section
 patterns in the linker script.
 
 @kindex --split-by-file
-@item --split-by-file [@var{size}]
+@item --split-by-file[=@var{size}]
 Similar to @option{--split-by-reloc} but creates a new output section for
 each input file when @var{size} is reached.  @var{size} defaults to a
 size of 1 if not given.
 
 @kindex --split-by-reloc
-@item --split-by-reloc [@var{count}]
+@item --split-by-reloc[=@var{count}]
 Tries to creates extra sections in the output file so that no single
 output section in the file contains more than @var{count} relocations.
 This is useful when generating huge relocatable files for downloading into
@@ -1699,7 +1714,7 @@ many relocations.  @var{count} defaults 
 Compute and display statistics about the operation of the linker, such
 as execution time and memory usage.
 
-@kindex --sysroot
+@kindex --sysroot=@var{directory}
 @item --sysroot=@var{directory}
 Use @var{directory} as the location of the sysroot, overriding the
 configure-time default.  This option is only supported by linkers
@@ -1720,8 +1735,8 @@ full debugging information by over 30 pe
 trouble).  The @samp{--traditional-format} switch tells @command{ld} to not
 combine duplicate entries.
 
-@kindex --section-start @var{sectionname}=@var{org}
-@item --section-start @var{sectionname}=@var{org}
+@kindex --section-start=@var{sectionname}=@var{org}
+@item --section-start=@var{sectionname}=@var{org}
 Locate a section in the output file at the absolute
 address given by @var{org}.  You may use this option as many
 times as necessary to locate multiple sections in the command
@@ -1732,18 +1747,18 @@ for compatibility with other linkers, yo
 should be no white space between @var{sectionname}, the equals
 sign (``@key{=}''), and @var{org}.
 
-@kindex -Tbss @var{org}
-@kindex -Tdata @var{org}
-@kindex -Ttext @var{org}
+@kindex -Tbss=@var{org}
+@kindex -Tdata=@var{org}
+@kindex -Ttext=@var{org}
 @cindex segment origins, cmd line
-@item -Tbss @var{org}
-@itemx -Tdata @var{org}
-@itemx -Ttext @var{org}
-Same as --section-start, with @code{.bss}, @code{.data} or
+@item -Tbss=@var{org}
+@itemx -Tdata=@var{org}
+@itemx -Ttext=@var{org}
+Same as @option{--section-start}, with @code{.bss}, @code{.data} or
 @code{.text} as the @var{sectionname}.
 
-@kindex -Ttext-segment @var{org}
-@itemx -Ttext-segment @var{org}
+@kindex -Ttext-segment=@var{org}
+@item -Ttext-segment=@var{org}
 @cindex text segment origin, cmd line
 When creating an ELF executable or shared object, it will set the address
 of the first byte of the text segment.
@@ -1789,7 +1804,7 @@ the linker script being used by the link
 
 @kindex --version-script=@var{version-scriptfile}
 @cindex version script, symbol versions
-@itemx --version-script=@var{version-scriptfile}
+@item --version-script=@var{version-scriptfile}
 Specify the name of a version script to the linker.  This is typically
 used when creating shared libraries to specify additional information
 about the version hierarchy for the library being created.  This option
@@ -1949,8 +1964,8 @@ Second, don't forget to use @option{-Wl,
 list of archives, because gcc will add its own list of archives to
 your link and you may not want this flag to affect those as well.
 
-@kindex --wrap
-@item --wrap @var{symbol}
+@kindex --wrap=@var{symbol}
+@item --wrap=@var{symbol}
 Use a wrapper function for @var{symbol}.  Any undefined reference to
 @var{symbol} will be resolved to @code{__wrap_@var{symbol}}.  Any
 undefined reference to @code{__real_@var{symbol}} will be resolved to
@@ -2054,6 +2069,18 @@ string identifying the original linked f
 
 Passing @code{none} for @var{style} disables the setting from any
 @code{--build-id} options earlier on the command line.
+
+@kindex --no-poison-system-directories
+@item --no-poison-system-directories
+Do not warn for @option{-L} options using system directories such as
+@file{/usr/lib} when cross linking.  This option is intended for use
+in chroot environments when such directories contain the correct
+libraries for the target system rather than the host.
+
+@kindex --error-poison-system-directories
+@item --error-poison-system-directories
+Give an error instead of a warning for @option{-L} options using
+system directories when cross linking.
 @end table
 
 @c man end
@@ -5743,12 +5770,12 @@ intervening instructions if vector mode 
 full-compliance floating-point mode: you do not need this workaround if
 you are using "runfast" mode. Please contact ARM for further details.
 
-If you know you are using buggy VFP11 hardware, you can
-enable this workaround by specifying the linker option
-@samp{--vfp-denorm-fix=scalar} if you are using the VFP11 scalar
-mode only, or @samp{--vfp-denorm-fix=vector} if you are using
-vector mode (the latter also works for scalar code). The default is
-@samp{--vfp-denorm-fix=none}.
+This workaround is enabled for scalar code by default for
+pre-ARMv7 architectures, but disabled by default for later
+architectures. If you know you are not using buggy VFP11 hardware,
+you can disable the workaround by specifying the linker option
+@samp{--vfp-denorm-fix=none}. If you are using VFP vector mode, you
+should specify @samp{--vfp-denorm-fix=vector}.
 
 If the workaround is enabled, instructions are scanned for
 potentially-troublesome sequences, and a veneer is created for each
@@ -5797,7 +5824,7 @@ where they should be placed.
 
 The value of @samp{N}, the parameter to the
 @option{--stub-group-size=} option controls where the stub groups are
-placed.  If it is negative then all stubs are placed before the first
+placed.  If it is negative then all stubs are placed after the first
 branch that needs them.  If it is positive then the stubs can be
 placed either before or after the branches that need them.  If the
 value of @samp{N} is 1 (either +1 or -1) then the linker will choose
@@ -5813,6 +5840,30 @@ Farcalls stubs insertion is fully suppor
 only, because it relies on object files properties not present
 otherwise.
 
+@cindex FIX_JANUS_2CC
+@kindex --fix-janus-2cc
+The @samp{--fix-janus-2cc} switch enables a link-time workaround for
+an erratum in an early Janus 2CC chip revision, concerning ALU
+operations using register-specified shifter operands.  If you enable
+this option, the executable code of the linked program is scanned for
+problematic code sequences.  For most cases in code using the ARM
+instruction set, the linker inserts code veneers to correct the
+problem automatically.  If problematic sequences are detected in Thumb
+code, or if any unfixable ARM instructions are encountered, an error
+message is emitted to signal that code must be rewritten manually to
+avoid the erratum.
+
+This option should only be used when targeting the ARMv4t architecture.
+Do not use it unless you know your target CPU suffers from the erratum
+in question.
+
+@cindex Cortex-A8 erratum workaround
+@kindex --fix-cortex-a8
+@kindex --no-fix-cortex-a8
+The @samp{--fix-cortex-a8} switch enables a link-time workaround for an erratum in certain Cortex-A8 processors.  The workaround is enabled by default if you are targeting the ARM v7-A architecture profile.  It can be enabled otherwise by specifying @samp{--fix-cortex-a8}, or disabled unconditionally by specifying @samp{--no-fix-cortex-a8}.
+
+The erratum only affects Thumb-2 code.  Please contact ARM for further details.
+
 @ifclear GENERIC
 @lowersections
 @end ifclear
--- a/ld/ldexp.c
+++ b/ld/ldexp.c
@@ -815,6 +815,20 @@ exp_fold_tree_1 (etree_type *tree)
 	      h->u.def.section = expld.result.section;
 	      if (tree->type.node_class == etree_provide)
 		tree->type.node_class = etree_provided;
+
+	      /* Copy the symbol type if this is a simple assignment of
+	         one symbol to annother.  */
+	      if (tree->assign.src->type.node_class == etree_name)
+		{
+		  struct bfd_link_hash_entry *hsrc;
+
+		  hsrc = bfd_link_hash_lookup (link_info.hash,
+					       tree->assign.src->name.name,
+					       FALSE, FALSE, TRUE);
+		  if (hsrc)
+		    bfd_copy_link_hash_symbol_type (link_info.output_bfd, h,
+						    hsrc);
+		}
 	    }
 	}
       break;
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -120,6 +120,22 @@ ldfile_add_library_path (const char *nam
     {
       new->name = xstrdup (name);
       new->sysrooted = is_sysrooted_pathname (name, FALSE);
+
+#ifdef ENABLE_POISON_SYSTEM_DIRECTORIES
+      if (command_line.poison_system_directories
+	  && ((!strncmp (name, "/lib", 4))
+	      || (!strncmp (name, "/usr/lib", 8))
+	      || (!strncmp (name, "/usr/local/lib", 14))
+	      || (!strncmp (name, "/usr/X11R6/lib", 14))))
+	{
+	  if (command_line.error_poison_system_directories)
+	    einfo (_("%X%P: error: library search path \"%s\" is unsafe for "
+		     "cross-compilation\n"), name);
+	  else
+	    einfo (_("%P: warning: library search path \"%s\" is unsafe for "
+		     "cross-compilation\n"), name);
+	}
+#endif
     }
 }
 
@@ -542,22 +558,27 @@ find_scripts_dir (void)
   return NULL;
 }
 
-/* Try to open NAME; if that fails, look for it in the default script
-   directory, then in any directories specified with -L, without and
-   with EXTEND appended.  */
+/* If DEFAULT_ONLY is false, try to open NAME; if that fails, look for
+   it in directories specified with -L, then in the default script
+   directory, without and with EXTEND appended.  If DEFAULT_ONLY is
+   true, the search is restricted to the default script location.  */
 
 static FILE *
-ldfile_find_command_file (const char *name, const char *extend)
+ldfile_find_command_file (const char *name, const char *extend,
+			  bfd_boolean default_only)
 {
   search_dirs_type *search;
-  FILE *result;
+  FILE *result = NULL;
   char *buffer;
   static search_dirs_type *script_search;
 
-  /* First try raw name.  */
-  result = try_open (name, "");
-  if (result != NULL)
-    return result;
+  if (!default_only)
+    {
+      /* First try raw name.  */
+      result = try_open (name, "");
+      if (result != NULL)
+	return result;
+    }
 
   if (!script_search)
     {
@@ -569,16 +590,17 @@ ldfile_find_command_file (const char *na
 	  ldfile_add_library_path (script_dir, TRUE);
 	  search_tail_ptr = save_tail_ptr;
 	}
-      if (!script_search)
-	script_search = search_head;
-      else
-	script_search->next = search_head;
     }
 
+  /* Temporarily append script_search to the path list so that the
+     paths specified with -L will be searched first.  */
+  *search_tail_ptr = script_search;
+
   /* Try now prefixes.  */
-  for (search = script_search; search != NULL; search = search->next)
+  for (search = default_only ? script_search : search_head;
+       search != NULL;
+       search = search->next)
     {
-
       buffer = concat (search->name, slash, name, (const char *) NULL);
       result = try_open (buffer, extend);
       free (buffer);
@@ -586,14 +608,19 @@ ldfile_find_command_file (const char *na
 	break;
     }
 
+  /* Restore the original path list.  */
+  *search_tail_ptr = NULL;
+
   return result;
 }
 
-void
-ldfile_open_command_file (const char *name)
+/* Open command file NAME.  */
+
+static void
+ldfile_open_command_file_1 (const char *name, bfd_boolean default_only)
 {
   FILE *ldlex_input_stack;
-  ldlex_input_stack = ldfile_find_command_file (name, "");
+  ldlex_input_stack = ldfile_find_command_file (name, "", default_only);
 
   if (ldlex_input_stack == NULL)
     {
@@ -609,6 +636,23 @@ ldfile_open_command_file (const char *na
   saved_script_handle = ldlex_input_stack;
 }
 
+/* Open command file NAME in the current directory, -L directories,
+   the default script location, in that order.  */
+
+void
+ldfile_open_command_file (const char *name)
+{
+  ldfile_open_command_file_1 (name, FALSE);
+}
+
+/* Open command file NAME at the default script location.  */
+
+void
+ldfile_open_default_command_file (const char *name)
+{
+  ldfile_open_command_file_1 (name, TRUE);
+}
+
 void
 ldfile_add_arch (const char *in_name)
 {
--- a/ld/ldfile.h
+++ b/ld/ldfile.h
@@ -50,6 +50,8 @@ extern void ldfile_add_library_path
   (const char *, bfd_boolean cmdline);
 extern void ldfile_open_command_file
   (const char *name);
+extern void ldfile_open_default_command_file
+  (const char *name);
 extern void ldfile_open_file
   (struct lang_input_statement_struct *);
 extern bfd_boolean ldfile_try_open_bfd
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -20,6 +20,8 @@
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
    MA 02110-1301, USA.  */
 
+#include "config.h"
+
 #include <limits.h>
 
 #include "sysdep.h"
@@ -6467,6 +6469,15 @@ lang_leave_output_section_statement (fil
 		    memspec, lma_memspec,
 		    current_section->load_base != NULL,
 		    current_section->addr_tree != NULL);
+
+  /* If this section has no load region or base, but has the same
+     region as the previous section, then propagate the previous
+     section's load region.  */
+
+  if (!current_section->lma_region && !current_section->load_base
+      && current_section->region == current_section->prev->region)
+    current_section->lma_region = current_section->prev->lma_region;
+  
   current_section->fill = fill;
   current_section->phdrs = phdrs;
   stat_ptr = &statement_list;
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -252,6 +252,8 @@ main (int argc, char **argv)
   command_line.warn_mismatch = TRUE;
   command_line.warn_search_mismatch = TRUE;
   command_line.check_section_addresses = -1;
+  command_line.poison_system_directories = TRUE;
+  command_line.error_poison_system_directories = FALSE;
 
   /* We initialize DEMANGLING based on the environment variable
      COLLECT_NO_DEMANGLE.  The gcc collect2 program will demangle the
@@ -376,7 +378,7 @@ main (int argc, char **argv)
       char *s = ldemul_get_script (&isfile);
 
       if (isfile)
-	ldfile_open_command_file (s);
+	ldfile_open_default_command_file (s);
       else
 	{
 	  lex_string = s;
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -164,7 +164,9 @@ enum option_values
   OPTION_ERROR_UNRESOLVED_SYMBOLS,
   OPTION_WARN_SHARED_TEXTREL,
   OPTION_REDUCE_MEMORY_OVERHEADS,
-  OPTION_DEFAULT_SCRIPT
+  OPTION_DEFAULT_SCRIPT,
+  OPTION_NO_POISON_SYSTEM_DIRECTORIES,
+  OPTION_ERROR_POISON_SYSTEM_DIRECTORIES
 };
 
 /* The long options.  This structure is used for both the option
@@ -566,6 +568,14 @@ static const struct ld_option ld_options
     TWO_DASHES },
   { {"wrap", required_argument, NULL, OPTION_WRAP},
     '\0', N_("SYMBOL"), N_("Use wrapper functions for SYMBOL"), TWO_DASHES },
+  { {"no-poison-system-directories", no_argument, NULL,
+     OPTION_NO_POISON_SYSTEM_DIRECTORIES},
+    '\0', NULL, N_("Do not warn for -L options using system directories"),
+    TWO_DASHES },
+  { {"error-poison-system-directories", no_argument, NULL,
+     OPTION_ERROR_POISON_SYSTEM_DIRECTORIES},
+    '\0', NULL, N_("Give an error for -L options using system directories"),
+    TWO_DASHES },
 };
 
 #define OPTION_COUNT ARRAY_SIZE (ld_options)
@@ -1462,6 +1472,14 @@ parse_args (unsigned argc, char **argv)
               einfo (_("%P%X: --hash-size needs a numeric argument\n"));
           }
           break;
+
+	case OPTION_NO_POISON_SYSTEM_DIRECTORIES:
+	  command_line.poison_system_directories = FALSE;
+	  break;
+
+	case OPTION_ERROR_POISON_SYSTEM_DIRECTORIES:
+	  command_line.error_poison_system_directories = TRUE;
+	  break;
 	}
     }
 
--- a/ld/scripttempl/elf.sc
+++ b/ld/scripttempl/elf.sc
@@ -174,6 +174,9 @@ if test -z "${SDATA_GOT}"; then
     SDATA_GOT=" "
   fi
 fi
+if test -n "${DATA_GOT+set}"; then
+    DATA_GOTPLT=" "
+fi
 test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
 test "${LARGE_SECTIONS}" = "yes" && REL_LARGE="
   .rel.ldata    ${RELOCATING-0} : { *(.rel.ldata${RELOCATING+ .rel.ldata.* .rel.gnu.linkonce.l.*}) }
@@ -451,11 +454,11 @@ cat <<EOF
   ${OTHER_RELRO_SECTIONS}
   ${TEXT_DYNAMIC-${DYNAMIC}}
   ${DATA_GOT+${RELRO_NOW+${GOT}}}
-  ${DATA_GOT+${RELRO_NOW+${GOTPLT}}}
+  ${DATA_GOTPLT+${RELRO_NOW+${GOTPLT}}}
   ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}}}}
   ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
   ${DATA_GOT+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}}}}
-  ${DATA_GOT+${RELRO_NOW-${GOTPLT}}}
+  ${DATA_GOTPLT+${RELRO_NOW-${GOTPLT}}}
 
   ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
 
@@ -500,6 +503,7 @@ cat <<EOF
   ${RELOCATING+. = ALIGN(${ALIGNMENT});}
   ${RELOCATING+${OTHER_END_SYMBOLS}}
   ${RELOCATING+${END_SYMBOLS-${USER_LABEL_PREFIX}_end = .; PROVIDE (${USER_LABEL_PREFIX}end = .);}}
+  ${RELOCATING+${OCTEON_SPECIAL_SECTIONS}}
   ${RELOCATING+${DATA_SEGMENT_END}}
 EOF
 
--- a/ld/testsuite/ChangeLog
+++ b/ld/testsuite/ChangeLog
@@ -1,7 +1,3 @@
-2009-02-05  Joseph Myers  <joseph@codesourcery.com>
-
-	* ld-arm/arm-elf.exp (armeabitests): Restore thumb2-b-interwork.
-
 2009-02-03  Maxim Kuvyrkov  <maxim@codesourcery.com>
 
 	* ld-m68k/got-multigot-12-13-14-34-35-ok.d: Update.
--- a/ld/testsuite/ld-arm/arm-elf.exp
+++ b/ld/testsuite/ld-arm/arm-elf.exp
@@ -161,6 +161,50 @@ set armelftests {
      "-EL --vfp11-denorm-fix=scalar -Ttext=0x8000" "-EL -mfpu=vfpxd" {vfp11-fix-none.s}
      {{objdump -dr vfp11-fix-none.d}}
      "vfp11-fix-none"}
+    {"Cortex-A8 erratum fix, b.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-b.s}
+     {{objdump -dr cortex-a8-fix-b.d}}
+     "cortex-a8-fix-b"}
+    {"Cortex-A8 erratum fix, bl.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bl.s}
+     {{objdump -dr cortex-a8-fix-bl.d}}
+     "cortex-a8-fix-bl"}
+    {"Cortex-A8 erratum fix, bcc.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bcc.s}
+     {{objdump -dr cortex-a8-fix-bcc.d}}
+     "cortex-a8-fix-bcc"}
+    {"Cortex-A8 erratum fix, blx.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-blx.s}
+     {{objdump -dr cortex-a8-fix-blx.d}}
+     "cortex-a8-fix-blx"}
+    {"Cortex-A8 erratum fix, relocate b.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-b-rel.s}
+     {{objdump -dr cortex-a8-fix-b-rel-arm.d}}
+     "cortex-a8-fix-b-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate b.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-b-rel.s}
+     {{objdump -dr cortex-a8-fix-b-rel-thumb.d}}
+     "cortex-a8-fix-b-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate bl.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-bl-rel.s}
+     {{objdump -dr cortex-a8-fix-bl-rel-arm.d}}
+     "cortex-a8-fix-bl-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate bl.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bl-rel.s}
+     {{objdump -dr cortex-a8-fix-bl-rel-thumb.d}}
+     "cortex-a8-fix-bl-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate b<cond>.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bcc-rel.s}
+     {{objdump -dr cortex-a8-fix-bcc-rel-thumb.d}}
+     "cortex-a8-fix-bcc-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate blx.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-blx-rel.s}
+     {{objdump -dr cortex-a8-fix-blx-rel-arm.d}}
+     "cortex-a8-fix-blx-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate blx.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-blx-rel.s}
+     {{objdump -dr cortex-a8-fix-blx-rel-thumb.d}}
+     "cortex-a8-fix-blx-rel-thumb"}
     {"Unwinding and -gc-sections" "-gc-sections" "" {gc-unwind.s}
      {{objdump -sj.data gc-unwind.d}}
      "gc-unwind"}
@@ -174,6 +218,9 @@ set armelftests {
     {"jump19" "-static -T arm.ld" "" {jump19.s}
      {{objdump -dr jump19.d}}
      "jump19"}
+    {"script-type" "-static -T script-type.ld" "" {script-type.s}
+     {{readelf -s script-type.sym}}
+     "script-type"}
     {"callweak" "-static -T arm.ld" "" {callweak.s}
      {{objdump -dr callweak.d}}
      "callweak"}
@@ -190,10 +237,20 @@ run_dump_test "emit-relocs1"
 # Exclude non-ARM-EABI targets.
 
 if { ![istarget "arm*-*-*eabi"] } {
-    # Special variants of these tests, as no farcall stub is generated
-    # for a non-ARM-EABI target
-    run_dump_test "thumb2-bl-as-thumb1-bad-noeabi"
-    run_dump_test "thumb2-bl-bad-noeabi"
+    # Special variants of these tests, as a different farcall stub is
+    # generated for a non-ARM-EABI target: indeed in such a case,
+    # there are no attributes to indicate that blx can be used.
+
+    set arm_noeabi_tests {
+	{"Thumb-2-as-Thumb-1 BL" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-as-thumb1-bad.s}
+	    {{objdump -d thumb2-bl-as-thumb1-bad-noeabi.d}}
+	    "thumb2-bl-as-thumb1-bad"}
+	{"Thumb-2 BL bad" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-bad.s}
+	    {{objdump -d thumb2-bl-bad-noeabi.d}}
+	    "thumb2-bl-bad"}
+    }
+    run_ld_link_tests $arm_noeabi_tests
+
     return
 }
 
@@ -232,6 +289,9 @@ set armeabitests {
      {"Thumb-2 Interworked branch" "-T arm.ld" "" {thumb2-b-interwork.s}
       {{objdump -dr thumb2-b-interwork.d}}
       "thumb2-b-interwork"}
+    {"BL/BLX interworking" "-T arm.ld" "" {thumb2-bl-blx-interwork.s}
+     {{objdump -dr thumb2-bl-blx-interwork.d}}
+     "thumb2-bl-blx-interwork"}
     {"ARMv4 interworking" "-static -T arm.ld --fix-v4bx-interworking" "--fix-v4bx -meabi=4" {armv4-bx.s}
      {{objdump -d armv4-bx.d}}
      "armv4-bx"}
@@ -241,7 +301,7 @@ set armeabitests {
     {"MOVW/MOVT against shared libraries" "tmpdir/arm-lib.so" "" {arm-app-movw.s}
      {{objdump -Rw arm-app.r}}
      "arm-app-movw"}
-    {"Thumb-2-as-Thumb-1 BL" "-Ttext 0x1000 --section-start .foo=0x40100c" "" {thumb2-bl-as-thumb1-bad.s}
+    {"Thumb-2-as-Thumb-1 BL" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-as-thumb1-bad.s}
      {{objdump -d thumb2-bl-as-thumb1-bad.d}}
      "thumb2-bl-as-thumb1-bad"}
     {"Thumb-2 BL" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-bad.s}
@@ -257,6 +317,9 @@ set armeabitests {
     {"ARM-ARM farcall (BE8)" "-Ttext 0x1000 --section-start .foo=0x2001020 -EB --be8" "-EB" {farcall-arm-arm.s}
      {{objdump -d farcall-arm-arm-be8.d}}
      "farcall-arm-arm-be8"}
+    {"ARM-ARM farcall (BE)" "-Ttext 0x1000 --section-start .foo=0x2001020 -EB" "-EB" {farcall-arm-arm.s}
+     {{objdump -d farcall-arm-arm.d}}
+     "farcall-arm-arm-be"}
 
     {"ARM-Thumb farcall" "-Ttext 0x1000 --section-start .foo=0x2001014" "" {farcall-arm-thumb.s}
      {{objdump -d farcall-arm-thumb.d}}
@@ -277,6 +340,9 @@ set armeabitests {
     {"Thumb-Thumb farcall M profile" "-Ttext 0x1000 --section-start .foo=0x2001014" "-march=armv7m" {farcall-thumb-thumb.s}
      {{objdump -d farcall-thumb-thumb-m.d}}
      "farcall-thumb-thumb-m"}
+    {"Thumb-Thumb farcall" "-Ttext 0x1000 --section-start .foo=0x2001014" "-march=armv4t" {farcall-thumb-thumb.s}
+     {{objdump -d farcall-thumb-thumb.d}}
+     "farcall-thumb-thumb"}
     {"Thumb-Thumb farcall with BLX (PIC veneer)" "-Ttext 0x1000 --section-start .foo=0x2001014 --pic-veneer" "-march=armv5t" {farcall-thumb-thumb.s}
      {{objdump -d farcall-thumb-thumb-blx-pic-veneer.d}}
      "farcall-thumb-thumb-blx-pic-veneer"}
@@ -284,6 +350,12 @@ set armeabitests {
     {"Thumb-ARM farcall" "-Ttext 0x1000 --section-start .foo=0x2001014" "-W" {farcall-thumb-arm.s}
      {{objdump -d farcall-thumb-arm.d}}
      "farcall-thumb-arm"}
+    {"Thumb-ARM farcall (BE8)" "-Ttext 0x1000 --section-start .foo=0x2001014 -EB --be8" "-W -EB" {farcall-thumb-arm.s}
+     {{objdump -d farcall-thumb-arm-be8.d}}
+     "farcall-thumb-arm-be8"}
+    {"Thumb-ARM farcall (BE)" "-Ttext 0x1000 --section-start .foo=0x2001014 -EB" "-W -EB" {farcall-thumb-arm.s}
+     {{objdump -d farcall-thumb-arm.d}}
+     "farcall-thumb-arm-be"}
     {"Thumb-ARM (short) call" "-Ttext 0x1000 --section-start .foo=0x0002014" "-W" {farcall-thumb-arm-short.s}
      {{objdump -d farcall-thumb-arm-short.d}}
      "farcall-thumb-arm-short"}
@@ -328,7 +400,6 @@ run_dump_test "attr-merge-wchar-24-nowar
 run_dump_test "attr-merge-wchar-40-nowarn"
 run_dump_test "attr-merge-wchar-42-nowarn"
 run_dump_test "attr-merge-wchar-44-nowarn"
-run_dump_test "farcall-thumb-thumb"
 run_dump_test "farcall-thumb-thumb-pic-veneer"
 run_dump_test "farcall-thumb-thumb-m-pic-veneer"
 run_dump_test "farcall-thumb-arm-pic-veneer"
@@ -337,3 +408,7 @@ run_dump_test "attr-merge-unknown-1"
 run_dump_test "attr-merge-unknown-2"
 run_dump_test "attr-merge-unknown-2r"
 run_dump_test "attr-merge-unknown-3"
+run_dump_test "unwind-1"
+run_dump_test "unwind-2"
+run_dump_test "unwind-3"
+run_dump_test "unwind-4"
--- a/ld/testsuite/ld-arm/arm.ld
+++ b/ld/testsuite/ld-arm/arm.ld
@@ -10,9 +10,11 @@ SECTIONS
     *(.before)
     *(.text)
     *(.after)
+    *(.ARM.extab*)
     *(.glue_7)
     *(.v4_bx)
   } =0
+  .ARM.exidx : { *(.ARM.exidx*) }
   . = 0x9000;
   .got            : { *(.got) *(.got.plt)}
   . = 0x12340000;
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-arm-target.s
@@ -0,0 +1,9 @@
+	.syntax unified
+	.cpu cortex-a8
+	.text
+	.arm
+	.align 3
+	.global targetfn
+	.type targetfn, %function
+targetfn:
+	bx lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-b-rel-arm.d
@@ -0,0 +1,85 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	e12fff1e 	bx	lr
+    8f04:	e320f000 	nop	\{0\}
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f000 b87f 	b\.w	9010 <__targetfn_from_thumb>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f000 b87b 	b\.w	9010 <__targetfn_from_thumb>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f000 b877 	b\.w	9010 <__targetfn_from_thumb>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f000 b873 	b\.w	9010 <__targetfn_from_thumb>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f000 b86f 	b\.w	9010 <__targetfn_from_thumb>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f000 b86b 	b\.w	9010 <__targetfn_from_thumb>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f000 b867 	b\.w	9010 <__targetfn_from_thumb>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f000 b863 	b\.w	9010 <__targetfn_from_thumb>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f000 b85f 	b\.w	9010 <__targetfn_from_thumb>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f000 b85b 	b\.w	9010 <__targetfn_from_thumb>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f000 b857 	b\.w	9010 <__targetfn_from_thumb>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f000 b853 	b\.w	9010 <__targetfn_from_thumb>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f000 b84f 	b\.w	9010 <__targetfn_from_thumb>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f000 b84b 	b\.w	9010 <__targetfn_from_thumb>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f000 b847 	b\.w	9010 <__targetfn_from_thumb>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f000 b843 	b\.w	9010 <__targetfn_from_thumb>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f000 b83f 	b\.w	9010 <__targetfn_from_thumb>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f000 b83b 	b\.w	9010 <__targetfn_from_thumb>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f000 b837 	b\.w	9010 <__targetfn_from_thumb>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f000 b833 	b\.w	9010 <__targetfn_from_thumb>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f000 b82f 	b\.w	9010 <__targetfn_from_thumb>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f000 b82b 	b\.w	9010 <__targetfn_from_thumb>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f000 b827 	b\.w	9010 <__targetfn_from_thumb>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f000 b823 	b\.w	9010 <__targetfn_from_thumb>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f000 b81f 	b\.w	9010 <__targetfn_from_thumb>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f000 b81b 	b\.w	9010 <__targetfn_from_thumb>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f000 b817 	b\.w	9010 <__targetfn_from_thumb>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f000 b813 	b\.w	9010 <__targetfn_from_thumb>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f000 b80f 	b\.w	9010 <__targetfn_from_thumb>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f000 b80b 	b\.w	9010 <__targetfn_from_thumb>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 b807 	b\.w	9010 <__targetfn_from_thumb>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f000 b803 	b\.w	9010 <__targetfn_from_thumb>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+
+00009010 <__targetfn_from_thumb>:
+    9010:	4778      	bx	pc
+    9012:	46c0      	nop			\(mov r8, r8\)
+
+00009014 <__targetfn_change_to_arm>:
+    9014:	eaffffb9 	b	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-b-rel-thumb.d
@@ -0,0 +1,80 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	4770      	bx	lr
+    8f02:	bf00      	nop
+    8f04:	f3af 8000 	nop\.w
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff bff7 	b\.w	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff bff3 	b\.w	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff bfef 	b\.w	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff bfeb 	b\.w	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff bfe7 	b\.w	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff bfe3 	b\.w	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff bfdf 	b\.w	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff bfdb 	b\.w	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff bfd7 	b\.w	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff bfd3 	b\.w	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff bfcf 	b\.w	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff bfcb 	b\.w	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff bfc7 	b\.w	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff bfc3 	b\.w	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff bfbf 	b\.w	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff bfbb 	b\.w	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff bfb7 	b\.w	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff bfb3 	b\.w	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff bfaf 	b\.w	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff bfab 	b\.w	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff bfa7 	b\.w	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff bfa3 	b\.w	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff bf9f 	b\.w	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff bf9b 	b\.w	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff bf97 	b\.w	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff bf93 	b\.w	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff bf8f 	b\.w	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff bf8b 	b\.w	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff bf87 	b\.w	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff bf83 	b\.w	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 b807 	b\.w	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff bf7b 	b\.w	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	f7ff bf76 	b\.w	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-b-rel.s
@@ -0,0 +1,41 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        b.w targetfn
+        add.w r0, r1, r2
+        b.w targetfn
+        add.w r0, r1, r2
+        b.w targetfn
+        add.w r0, r1, r2
+        b.w targetfn
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+	nop
+
+	@ If branching to an ARM destination, we *don't* want to create a
+	@ Cortex-A8 stub: the Thumb-to-ARM stub will suffice (and we need it
+	@ to change mode).
+	bw2
+	bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-b.d
@@ -0,0 +1,75 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <_start>:
+    8f00:	bf00      	nop
+    8f02:	eb01 0002 	add\.w	r0, r1, r2
+    8f06:	f7ff bffc 	b\.w	8f02 <_start\+0x2>
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff bff8 	b\.w	8f02 <_start\+0x2>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff bff4 	b\.w	8f02 <_start\+0x2>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff bff0 	b\.w	8f02 <_start\+0x2>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff bffc 	b\.w	8f22 <_start\+0x22>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff bff8 	b\.w	8f22 <_start\+0x22>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff bff4 	b\.w	8f22 <_start\+0x22>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff bff0 	b\.w	8f22 <_start\+0x22>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff bffc 	b\.w	8f42 <_start\+0x42>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff bff8 	b\.w	8f42 <_start\+0x42>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff bff4 	b\.w	8f42 <_start\+0x42>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff bff0 	b\.w	8f42 <_start\+0x42>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff bffc 	b\.w	8f62 <_start\+0x62>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff bff8 	b\.w	8f62 <_start\+0x62>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff bff4 	b\.w	8f62 <_start\+0x62>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff bff0 	b\.w	8f62 <_start\+0x62>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff bffc 	b\.w	8f82 <_start\+0x82>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff bff8 	b\.w	8f82 <_start\+0x82>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff bff4 	b\.w	8f82 <_start\+0x82>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff bff0 	b\.w	8f82 <_start\+0x82>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff bffc 	b\.w	8fa2 <_start\+0xa2>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff bff8 	b\.w	8fa2 <_start\+0xa2>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff bff4 	b\.w	8fa2 <_start\+0xa2>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff bff0 	b\.w	8fa2 <_start\+0xa2>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff bffc 	b\.w	8fc2 <_start\+0xc2>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff bff8 	b\.w	8fc2 <_start\+0xc2>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff bff4 	b\.w	8fc2 <_start\+0xc2>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff bff0 	b\.w	8fc2 <_start\+0xc2>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff bffc 	b\.w	8fe2 <_start\+0xe2>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff bff8 	b\.w	8fe2 <_start\+0xe2>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff bff4 	b\.w	8fe2 <_start\+0xe2>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 b803 	b\.w	9008 <_start\+0x108>
+    9002:	4770      	bx	lr
+    9004:	f3af 8000 	nop\.w
+    9008:	f7ff bfeb 	b\.w	8fe2 <_start\+0xe2>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-b.s
@@ -0,0 +1,39 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+	
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        b.w 1b
+        add.w r0, r1, r2
+        b.w 1b
+        add.w r0, r1, r2
+        b.w 1b
+        add.w r0, r1, r2
+        b.w 1b
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+        nop
+
+	@ Trigger Cortex-A8 erratum workaround with b instructions.
+        bw2
+        bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bcc-rel-thumb.d
@@ -0,0 +1,82 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	4770      	bx	lr
+    8f02:	bf00      	nop
+    8f04:	f3af 8000 	nop\.w
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f53f aff7 	bmi\.w	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f53f aff3 	bmi\.w	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f53f afef 	bmi\.w	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f53f afeb 	bmi\.w	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f53f afe7 	bmi\.w	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f53f afe3 	bmi\.w	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f53f afdf 	bmi\.w	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f53f afdb 	bmi\.w	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f53f afd7 	bmi\.w	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f53f afd3 	bmi\.w	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f53f afcf 	bmi\.w	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f53f afcb 	bmi\.w	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f53f afc7 	bmi\.w	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f53f afc3 	bmi\.w	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f53f afbf 	bmi\.w	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f53f afbb 	bmi\.w	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f53f afb7 	bmi\.w	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f53f afb3 	bmi\.w	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f53f afaf 	bmi\.w	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f53f afab 	bmi\.w	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f53f afa7 	bmi\.w	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f53f afa3 	bmi\.w	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f53f af9f 	bmi\.w	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f53f af9b 	bmi\.w	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f53f af97 	bmi\.w	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f53f af93 	bmi\.w	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f53f af8f 	bmi\.w	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f53f af8b 	bmi\.w	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f53f af87 	bmi\.w	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f53f af83 	bmi\.w	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 b807 	b\.w	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f53f af7b 	bmi\.w	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	d401      	bmi\.n	9016 <_start\+0x10e>
+    9012:	f7ff bff6 	b\.w	9002 <_start\+0xfa>
+    9016:	f7ff bf73 	b\.w	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bcc-rel.s
@@ -0,0 +1,38 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        bmi.w targetfn
+        add.w r0, r1, r2
+        bmi.w targetfn
+        add.w r0, r1, r2
+        bmi.w targetfn
+        add.w r0, r1, r2
+        bmi.w targetfn
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+	nop
+
+	bw2
+	bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bcc.d
@@ -0,0 +1,77 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <_start>:
+    8f00:	bf00      	nop
+    8f02:	eb01 0002 	add\.w	r0, r1, r2
+    8f06:	f4ff affc 	bcc\.w	8f02 <_start\+0x2>
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f4ff aff8 	bcc\.w	8f02 <_start\+0x2>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f4ff aff4 	bcc\.w	8f02 <_start\+0x2>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f4ff aff0 	bcc\.w	8f02 <_start\+0x2>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f4ff affc 	bcc\.w	8f22 <_start\+0x22>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f4ff aff8 	bcc\.w	8f22 <_start\+0x22>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f4ff aff4 	bcc\.w	8f22 <_start\+0x22>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f4ff aff0 	bcc\.w	8f22 <_start\+0x22>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f4ff affc 	bcc\.w	8f42 <_start\+0x42>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f4ff aff8 	bcc\.w	8f42 <_start\+0x42>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f4ff aff4 	bcc\.w	8f42 <_start\+0x42>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f4ff aff0 	bcc\.w	8f42 <_start\+0x42>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f4ff affc 	bcc\.w	8f62 <_start\+0x62>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f4ff aff8 	bcc\.w	8f62 <_start\+0x62>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f4ff aff4 	bcc\.w	8f62 <_start\+0x62>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f4ff aff0 	bcc\.w	8f62 <_start\+0x62>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f4ff affc 	bcc\.w	8f82 <_start\+0x82>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f4ff aff8 	bcc\.w	8f82 <_start\+0x82>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f4ff aff4 	bcc\.w	8f82 <_start\+0x82>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f4ff aff0 	bcc\.w	8f82 <_start\+0x82>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f4ff affc 	bcc\.w	8fa2 <_start\+0xa2>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f4ff aff8 	bcc\.w	8fa2 <_start\+0xa2>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f4ff aff4 	bcc\.w	8fa2 <_start\+0xa2>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f4ff aff0 	bcc\.w	8fa2 <_start\+0xa2>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f4ff affc 	bcc\.w	8fc2 <_start\+0xc2>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f4ff aff8 	bcc\.w	8fc2 <_start\+0xc2>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f4ff aff4 	bcc\.w	8fc2 <_start\+0xc2>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f4ff aff0 	bcc\.w	8fc2 <_start\+0xc2>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f4ff affc 	bcc\.w	8fe2 <_start\+0xe2>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f4ff aff8 	bcc\.w	8fe2 <_start\+0xe2>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f4ff aff4 	bcc\.w	8fe2 <_start\+0xe2>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 b803 	b\.w	9008 <_start\+0x108>
+    9002:	4770      	bx	lr
+    9004:	f3af 8000 	nop\.w
+    9008:	d301      	bcc\.n	900e <_start\+0x10e>
+    900a:	f7ff bffa 	b\.w	9002 <_start\+0x102>
+    900e:	f7ff bfe8 	b\.w	8fe2 <_start\+0xe2>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bcc.s
@@ -0,0 +1,39 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+	
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        bcc.w 1b
+        add.w r0, r1, r2
+        bcc.w 1b
+        add.w r0, r1, r2
+        bcc.w 1b
+        add.w r0, r1, r2
+        bcc.w 1b
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+        nop
+
+	@ Trigger Cortex-A8 erratum workaround with conditional branches.
+        bw2
+        bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bl-rel-arm.d
@@ -0,0 +1,79 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	e12fff1e 	bx	lr
+    8f04:	e320f000 	nop	\{0\}
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff eff8 	blx	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff eff4 	blx	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff eff0 	blx	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff efec 	blx	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff efe8 	blx	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff efe4 	blx	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff efe0 	blx	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff efdc 	blx	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff efd8 	blx	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff efd4 	blx	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff efd0 	blx	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff efcc 	blx	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff efc8 	blx	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff efc4 	blx	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff efc0 	blx	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff efbc 	blx	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff efb8 	blx	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff efb4 	blx	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff efb0 	blx	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff efac 	blx	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff efa8 	blx	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff efa4 	blx	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff efa0 	blx	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff ef9c 	blx	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff ef98 	blx	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff ef94 	blx	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff ef90 	blx	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff ef8c 	blx	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff ef88 	blx	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff ef84 	blx	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 e808 	blx	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff ef7c 	blx	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	eaffffba 	b	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bl-rel-thumb.d
@@ -0,0 +1,80 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	4770      	bx	lr
+    8f02:	bf00      	nop
+    8f04:	f3af 8000 	nop\.w
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff fff7 	bl	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff fff3 	bl	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff ffef 	bl	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff ffeb 	bl	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff ffe7 	bl	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff ffe3 	bl	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff ffdf 	bl	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff ffdb 	bl	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff ffd7 	bl	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff ffd3 	bl	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff ffcf 	bl	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff ffcb 	bl	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff ffc7 	bl	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff ffc3 	bl	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff ffbf 	bl	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff ffbb 	bl	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff ffb7 	bl	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff ffb3 	bl	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff ffaf 	bl	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff ffab 	bl	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff ffa7 	bl	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff ffa3 	bl	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff ff9f 	bl	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff ff9b 	bl	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff ff97 	bl	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff ff93 	bl	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff ff8f 	bl	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff ff8b 	bl	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff ff87 	bl	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff ff83 	bl	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 f807 	bl	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff ff7b 	bl	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	f7ff bf76 	b\.w	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bl-rel.s
@@ -0,0 +1,40 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        bl.w targetfn
+        add.w r0, r1, r2
+        bl.w targetfn
+        add.w r0, r1, r2
+        bl.w targetfn
+        add.w r0, r1, r2
+        bl.w targetfn
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+	nop
+
+	@ If calling an ARM destination, we *don't* want to create a
+	@ Cortex-A8 stub: the Thumb-to-ARM stub will suffice.
+	bw2
+	bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bl.d
@@ -0,0 +1,75 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <_start>:
+    8f00:	bf00      	nop
+    8f02:	eb01 0002 	add\.w	r0, r1, r2
+    8f06:	f7ff fffc 	bl	8f02 <_start\+0x2>
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff fff8 	bl	8f02 <_start\+0x2>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff fff4 	bl	8f02 <_start\+0x2>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff fff0 	bl	8f02 <_start\+0x2>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff fffc 	bl	8f22 <_start\+0x22>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff fff8 	bl	8f22 <_start\+0x22>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff fff4 	bl	8f22 <_start\+0x22>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff fff0 	bl	8f22 <_start\+0x22>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff fffc 	bl	8f42 <_start\+0x42>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff fff8 	bl	8f42 <_start\+0x42>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff fff4 	bl	8f42 <_start\+0x42>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff fff0 	bl	8f42 <_start\+0x42>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff fffc 	bl	8f62 <_start\+0x62>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff fff8 	bl	8f62 <_start\+0x62>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff fff4 	bl	8f62 <_start\+0x62>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff fff0 	bl	8f62 <_start\+0x62>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff fffc 	bl	8f82 <_start\+0x82>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff fff8 	bl	8f82 <_start\+0x82>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff fff4 	bl	8f82 <_start\+0x82>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff fff0 	bl	8f82 <_start\+0x82>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff fffc 	bl	8fa2 <_start\+0xa2>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff fff8 	bl	8fa2 <_start\+0xa2>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff fff4 	bl	8fa2 <_start\+0xa2>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff fff0 	bl	8fa2 <_start\+0xa2>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff fffc 	bl	8fc2 <_start\+0xc2>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff fff8 	bl	8fc2 <_start\+0xc2>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff fff4 	bl	8fc2 <_start\+0xc2>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff fff0 	bl	8fc2 <_start\+0xc2>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff fffc 	bl	8fe2 <_start\+0xe2>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff fff8 	bl	8fe2 <_start\+0xe2>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff fff4 	bl	8fe2 <_start\+0xe2>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 f803 	bl	9008 <_start\+0x108>
+    9002:	4770      	bx	lr
+    9004:	f3af 8000 	nop\.w
+    9008:	f7ff bfeb 	b\.w	8fe2 <_start\+0xe2>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-bl.s
@@ -0,0 +1,39 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+	
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        bl.w 1b
+        add.w r0, r1, r2
+        bl.w 1b
+        add.w r0, r1, r2
+        bl.w 1b
+        add.w r0, r1, r2
+        bl.w 1b
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+        nop
+
+	@ Trigger Cortex-A8 erratum workaround with bl instructions.
+        bw2
+        bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-blx-rel-arm.d
@@ -0,0 +1,79 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	e12fff1e 	bx	lr
+    8f04:	e320f000 	nop	\{0\}
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff eff8 	blx	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff eff4 	blx	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff eff0 	blx	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff efec 	blx	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff efe8 	blx	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff efe4 	blx	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff efe0 	blx	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff efdc 	blx	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff efd8 	blx	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff efd4 	blx	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff efd0 	blx	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff efcc 	blx	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff efc8 	blx	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff efc4 	blx	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff efc0 	blx	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff efbc 	blx	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff efb8 	blx	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff efb4 	blx	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff efb0 	blx	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff efac 	blx	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff efa8 	blx	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff efa4 	blx	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff efa0 	blx	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff ef9c 	blx	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff ef98 	blx	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff ef94 	blx	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff ef90 	blx	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff ef8c 	blx	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff ef88 	blx	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff ef84 	blx	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 e808 	blx	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff ef7c 	blx	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	eaffffba 	b	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-blx-rel-thumb.d
@@ -0,0 +1,80 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <targetfn>:
+    8f00:	4770      	bx	lr
+    8f02:	bf00      	nop
+    8f04:	f3af 8000 	nop\.w
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff fff7 	bl	8f00 <targetfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff fff3 	bl	8f00 <targetfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff ffef 	bl	8f00 <targetfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff ffeb 	bl	8f00 <targetfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff ffe7 	bl	8f00 <targetfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff ffe3 	bl	8f00 <targetfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff ffdf 	bl	8f00 <targetfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff ffdb 	bl	8f00 <targetfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff ffd7 	bl	8f00 <targetfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff ffd3 	bl	8f00 <targetfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff ffcf 	bl	8f00 <targetfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff ffcb 	bl	8f00 <targetfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff ffc7 	bl	8f00 <targetfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff ffc3 	bl	8f00 <targetfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff ffbf 	bl	8f00 <targetfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff ffbb 	bl	8f00 <targetfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff ffb7 	bl	8f00 <targetfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff ffb3 	bl	8f00 <targetfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff ffaf 	bl	8f00 <targetfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff ffab 	bl	8f00 <targetfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff ffa7 	bl	8f00 <targetfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff ffa3 	bl	8f00 <targetfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff ff9f 	bl	8f00 <targetfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff ff9b 	bl	8f00 <targetfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff ff97 	bl	8f00 <targetfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff ff93 	bl	8f00 <targetfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff ff8f 	bl	8f00 <targetfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff ff8b 	bl	8f00 <targetfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff ff87 	bl	8f00 <targetfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff ff83 	bl	8f00 <targetfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 f807 	bl	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff ff7b 	bl	8f00 <targetfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	f7ff bf76 	b\.w	8f00 <targetfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-blx-rel.s
@@ -0,0 +1,38 @@
+	.syntax unified
+	.cpu cortex-a8
+	.thumb
+	.text
+
+	@ expansion 32 bytes
+        .macro bw1
+1:
+        add.w r0, r1, r2
+        blx.w targetfn
+        add.w r0, r1, r2
+        blx.w targetfn
+        add.w r0, r1, r2
+        blx.w targetfn
+        add.w r0, r1, r2
+        blx.w targetfn
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+        .align  3
+        .global _start
+        .thumb
+        .thumb_func
+        .type   _start, %function
+_start:
+	nop
+
+	bw2
+	bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-blx.d
@@ -0,0 +1,79 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008f00 <armfn>:
+    8f00:	e1a02413 	lsl	r2, r3, r4
+    8f04:	e12fff1e 	bx	lr
+
+00008f08 <_start>:
+    8f08:	bf00      	nop
+    8f0a:	eb01 0002 	add\.w	r0, r1, r2
+    8f0e:	f7ff eff8 	blx	8f00 <armfn>
+    8f12:	eb01 0002 	add\.w	r0, r1, r2
+    8f16:	f7ff eff4 	blx	8f00 <armfn>
+    8f1a:	eb01 0002 	add\.w	r0, r1, r2
+    8f1e:	f7ff eff0 	blx	8f00 <armfn>
+    8f22:	eb01 0002 	add\.w	r0, r1, r2
+    8f26:	f7ff efec 	blx	8f00 <armfn>
+    8f2a:	eb01 0002 	add\.w	r0, r1, r2
+    8f2e:	f7ff efe8 	blx	8f00 <armfn>
+    8f32:	eb01 0002 	add\.w	r0, r1, r2
+    8f36:	f7ff efe4 	blx	8f00 <armfn>
+    8f3a:	eb01 0002 	add\.w	r0, r1, r2
+    8f3e:	f7ff efe0 	blx	8f00 <armfn>
+    8f42:	eb01 0002 	add\.w	r0, r1, r2
+    8f46:	f7ff efdc 	blx	8f00 <armfn>
+    8f4a:	eb01 0002 	add\.w	r0, r1, r2
+    8f4e:	f7ff efd8 	blx	8f00 <armfn>
+    8f52:	eb01 0002 	add\.w	r0, r1, r2
+    8f56:	f7ff efd4 	blx	8f00 <armfn>
+    8f5a:	eb01 0002 	add\.w	r0, r1, r2
+    8f5e:	f7ff efd0 	blx	8f00 <armfn>
+    8f62:	eb01 0002 	add\.w	r0, r1, r2
+    8f66:	f7ff efcc 	blx	8f00 <armfn>
+    8f6a:	eb01 0002 	add\.w	r0, r1, r2
+    8f6e:	f7ff efc8 	blx	8f00 <armfn>
+    8f72:	eb01 0002 	add\.w	r0, r1, r2
+    8f76:	f7ff efc4 	blx	8f00 <armfn>
+    8f7a:	eb01 0002 	add\.w	r0, r1, r2
+    8f7e:	f7ff efc0 	blx	8f00 <armfn>
+    8f82:	eb01 0002 	add\.w	r0, r1, r2
+    8f86:	f7ff efbc 	blx	8f00 <armfn>
+    8f8a:	eb01 0002 	add\.w	r0, r1, r2
+    8f8e:	f7ff efb8 	blx	8f00 <armfn>
+    8f92:	eb01 0002 	add\.w	r0, r1, r2
+    8f96:	f7ff efb4 	blx	8f00 <armfn>
+    8f9a:	eb01 0002 	add\.w	r0, r1, r2
+    8f9e:	f7ff efb0 	blx	8f00 <armfn>
+    8fa2:	eb01 0002 	add\.w	r0, r1, r2
+    8fa6:	f7ff efac 	blx	8f00 <armfn>
+    8faa:	eb01 0002 	add\.w	r0, r1, r2
+    8fae:	f7ff efa8 	blx	8f00 <armfn>
+    8fb2:	eb01 0002 	add\.w	r0, r1, r2
+    8fb6:	f7ff efa4 	blx	8f00 <armfn>
+    8fba:	eb01 0002 	add\.w	r0, r1, r2
+    8fbe:	f7ff efa0 	blx	8f00 <armfn>
+    8fc2:	eb01 0002 	add\.w	r0, r1, r2
+    8fc6:	f7ff ef9c 	blx	8f00 <armfn>
+    8fca:	eb01 0002 	add\.w	r0, r1, r2
+    8fce:	f7ff ef98 	blx	8f00 <armfn>
+    8fd2:	eb01 0002 	add\.w	r0, r1, r2
+    8fd6:	f7ff ef94 	blx	8f00 <armfn>
+    8fda:	eb01 0002 	add\.w	r0, r1, r2
+    8fde:	f7ff ef90 	blx	8f00 <armfn>
+    8fe2:	eb01 0002 	add\.w	r0, r1, r2
+    8fe6:	f7ff ef8c 	blx	8f00 <armfn>
+    8fea:	eb01 0002 	add\.w	r0, r1, r2
+    8fee:	f7ff ef88 	blx	8f00 <armfn>
+    8ff2:	eb01 0002 	add\.w	r0, r1, r2
+    8ff6:	f7ff ef84 	blx	8f00 <armfn>
+    8ffa:	eb01 0002 	add\.w	r0, r1, r2
+    8ffe:	f000 e808 	blx	9010 <_start\+0x108>
+    9002:	eb01 0002 	add\.w	r0, r1, r2
+    9006:	f7ff ef7c 	blx	8f00 <armfn>
+    900a:	4770      	bx	lr
+    900c:	f3af 8000 	nop\.w
+    9010:	eaffffba 	b	8f00 <armfn>
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-fix-blx.s
@@ -0,0 +1,44 @@
+	.syntax unified
+	.cpu cortex-a8
+	.text
+	
+	@ expansion 32 bytes
+        .macro bw1
+        add.w r0, r1, r2
+        blx.w armfn
+        add.w r0, r1, r2
+        blx.w armfn
+        add.w r0, r1, r2
+        blx.w armfn
+        add.w r0, r1, r2
+        blx.w armfn
+        .endm
+
+        @ expansion 128 bytes
+        .macro bw2
+        bw1
+        bw1
+        bw1
+        bw1
+        .endm
+
+	.arm
+        .align  2
+armfn:
+	mov	r2, r3, asl r4
+	bx	lr
+
+        .global _start
+
+	.thumb
+        .thumb_func
+	.align 3
+        .type   _start, %function
+_start:
+        nop
+
+	@ Trigger Cortex-A8 erratum workaround with blx instructions.
+        bw2
+        bw2
+
+        bx      lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/cortex-a8-thumb-target.s
@@ -0,0 +1,10 @@
+	.syntax unified
+	.cpu cortex-a8
+	.text
+	.thumb
+	.thumb_func
+	.align 3
+	.global targetfn
+	.type targetfn, %function
+targetfn:
+	bx lr
--- a/ld/testsuite/ld-arm/farcall-arm-arm-be8.d
+++ b/ld/testsuite/ld-arm/farcall-arm-arm-be8.d
@@ -2,13 +2,14 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	04f01fe5 	.*
-    1004:	02001020 	.word	0x02001020
+00001000 <_start>:
+    1000:	000000eb 	bl	1008 <__bar_veneer>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001008 <_start>:
-    1008:	fcffffeb 	.*
+00001008 <__bar_veneer>:
+    1008:	04f01fe5 	ldr	pc, \[pc, #-4\]	; 100c <__bar_veneer\+0x4>
+    100c:	02001020 	.word	0x02001020
 Disassembly of section .foo:
 
 02001020 <bar>:
- 2001020:	1eff2fe1 	.*
+ 2001020:	1eff2fe1 	bx	lr
--- a/ld/testsuite/ld-arm/farcall-arm-arm-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-arm-arm-pic-veneer.d
@@ -2,14 +2,15 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_veneer\+0x8>
-    1004:	e08ff00c 	add	pc, pc, ip
-    1008:	02000018 	.word	0x02000018
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_veneer>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001010 <_start>:
-    1010:	ebfffffa 	bl	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_veneer\+0x8>
+    100c:	e08ff00c 	add	pc, pc, ip
+    1010:	0200000c 	.word	0x0200000c
+    1014:	00000000 	.word	0x00000000
 Disassembly of section .foo:
 
 02001020 <bar>:
--- a/ld/testsuite/ld-arm/farcall-arm-arm.d
+++ b/ld/testsuite/ld-arm/farcall-arm-arm.d
@@ -2,12 +2,13 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_veneer\+0x4>
-    1004:	02001020 	.word	0x02001020
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_veneer>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001008 <_start>:
-    1008:	ebfffffc 	bl	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_veneer\+0x4>
+    100c:	02001020 	.word	0x02001020
 Disassembly of section .foo:
 
 02001020 <bar>:
--- a/ld/testsuite/ld-arm/farcall-arm-thumb-blx-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-arm-thumb-blx-pic-veneer.d
@@ -2,14 +2,15 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_arm>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_from_arm\+0x8>
-    1004:	e08ff00c 	add	pc, pc, ip
-    1008:	0200000d 	.word	0x0200000d
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001010 <_start>:
-    1010:	ebfffffa 	bl	1000 <__bar_from_arm>
+00001008 <__bar_from_arm>:
+    1008:	e59fc004 	ldr	ip, \[pc, #4\]	; 1014 <__bar_from_arm\+0xc>
+    100c:	e08fc00c 	add	ip, pc, ip
+    1010:	e12fff1c 	bx	ip
+    1014:	02000001 	.word	0x02000001
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-arm-thumb-blx.d
+++ b/ld/testsuite/ld-arm/farcall-arm-thumb-blx.d
@@ -2,12 +2,13 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_arm>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_from_arm\+0x4>
-    1004:	02001015 	.word	0x02001015
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001008 <_start>:
-    1008:	ebfffffc 	bl	1000 <__bar_from_arm>
+00001008 <__bar_from_arm>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_from_arm\+0x4>
+    100c:	02001015 	.word	0x02001015
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-arm-thumb-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-arm-thumb-pic-veneer.d
@@ -2,14 +2,15 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_arm>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_from_arm\+0x8>
-    1004:	e08ff00c 	add	pc, pc, ip
-    1008:	0200000d 	.word	0x0200000d
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001010 <_start>:
-    1010:	ebfffffa 	bl	1000 <__bar_from_arm>
+00001008 <__bar_from_arm>:
+    1008:	e59fc004 	ldr	ip, \[pc, #4\]	; 1014 <__bar_from_arm\+0xc>
+    100c:	e08fc00c 	add	ip, pc, ip
+    1010:	e12fff1c 	bx	ip
+    1014:	02000001 	.word	0x02000001
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-arm-thumb.d
+++ b/ld/testsuite/ld-arm/farcall-arm-thumb.d
@@ -2,14 +2,15 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_arm>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_from_arm\+0x8>
-    1004:	e12fff1c 	bx	ip
-    1008:	02001015 	.word	0x02001015
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	00000000 	andeq	r0, r0, r0
 
-00001010 <_start>:
-    1010:	ebfffffa 	bl	1000 <__bar_from_arm>
+00001008 <__bar_from_arm>:
+    1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_arm\+0x8>
+    100c:	e12fff1c 	bx	ip
+    1010:	02001015 	.word	0x02001015
+    1014:	00000000 	.word	0x00000000
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-group-size2.d
+++ b/ld/testsuite/ld-arm/farcall-group-size2.d
@@ -3,35 +3,35 @@
 
 Disassembly of section .text:
 
-00001000 <__bar2_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar2_veneer\+0x4>
-    1004:	02003024 	.word	0x02003024
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	eb000002 	bl	1014 <__bar2_veneer>
 00001008 <__bar_from_arm>:
     1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_arm\+0x8>
     100c:	e12fff1c 	bx	ip
     1010:	02003021 	.word	0x02003021
-    1014:	00000000 	.word	0x00000000
-
-00001018 <_start>:
-    1018:	ebfffffa 	bl	1008 <__bar_from_arm>
-    101c:	ebfffff7 	bl	1000 <__bar2_veneer>
-00001020 <__bar3_veneer>:
-    1020:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1024 <__bar3_veneer\+0x4>
-    1024:	02003028 	.word	0x02003028
-00001028 <__bar5_from_arm>:
-    1028:	e59fc000 	ldr	ip, \[pc, #0\]	; 1030 <__bar5_from_arm\+0x8>
-    102c:	e12fff1c 	bx	ip
-    1030:	0200302f 	.word	0x0200302f
-00001034 <__bar4_from_arm>:
-    1034:	e59fc000 	ldr	ip, \[pc, #0\]	; 103c <__bar4_from_arm\+0x8>
-    1038:	e12fff1c 	bx	ip
-    103c:	0200302d 	.word	0x0200302d
+00001014 <__bar2_veneer>:
+    1014:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1018 <__bar2_veneer\+0x4>
+    1018:	02003024 	.word	0x02003024
+    101c:	00000000 	.word	0x00000000
+00001020 <myfunc>:
+    1020:	eb000008 	bl	1048 <__bar3_veneer>
+    1024:	eb000004 	bl	103c <__bar4_from_arm>
+    1028:	eb000000 	bl	1030 <__bar5_from_arm>
+    102c:	00000000 	andeq	r0, r0, r0
+00001030 <__bar5_from_arm>:
+    1030:	e59fc000 	ldr	ip, \[pc, #0\]	; 1038 <__bar5_from_arm\+0x8>
+    1034:	e12fff1c 	bx	ip
+    1038:	0200302f 	.word	0x0200302f
+0000103c <__bar4_from_arm>:
+    103c:	e59fc000 	ldr	ip, \[pc, #0\]	; 1044 <__bar4_from_arm\+0x8>
+    1040:	e12fff1c 	bx	ip
+    1044:	0200302d 	.word	0x0200302d
+00001048 <__bar3_veneer>:
+    1048:	e51ff004 	ldr	pc, \[pc, #-4\]	; 104c <__bar3_veneer\+0x4>
+    104c:	02003028 	.word	0x02003028
 	...
 
-00001048 <myfunc>:
-    1048:	ebfffff4 	bl	1020 <__bar3_veneer>
-    104c:	ebfffff8 	bl	1034 <__bar4_from_arm>
-    1050:	ebfffff4 	bl	1028 <__bar5_from_arm>
 Disassembly of section .foo:
 
 02003020 <bar>:
--- a/ld/testsuite/ld-arm/farcall-group.d
+++ b/ld/testsuite/ld-arm/farcall-group.d
@@ -3,34 +3,35 @@
 
 Disassembly of section .text:
 
-00001000 <__bar2_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar2_veneer\+0x4>
-    1004:	02003024 	.word	0x02003024
-00001008 <__bar_from_arm>:
-    1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_arm\+0x8>
-    100c:	e12fff1c 	bx	ip
-    1010:	02003021 	.word	0x02003021
-00001014 <__bar3_veneer>:
-    1014:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1018 <__bar3_veneer\+0x4>
-    1018:	02003028 	.word	0x02003028
-0000101c <__bar4_from_arm>:
-    101c:	e59fc000 	ldr	ip, \[pc, #0\]	; 1024 <__bar4_from_arm\+0x8>
-    1020:	e12fff1c 	bx	ip
-    1024:	0200302d 	.word	0x0200302d
-00001028 <__bar5_from_arm>:
-    1028:	e59fc000 	ldr	ip, \[pc, #0\]	; 1030 <__bar5_from_arm\+0x8>
-    102c:	e12fff1c 	bx	ip
-    1030:	0200302f 	.word	0x0200302f
+00001000 <_start>:
+    1000:	eb00000c 	bl	1038 <__bar_from_arm>
+    1004:	eb00000e 	bl	1044 <__bar2_veneer>
+
+00001008 <myfunc>:
+    1008:	eb000008 	bl	1030 <__bar3_veneer>
+    100c:	eb000004 	bl	1024 <__bar4_from_arm>
+    1010:	eb000000 	bl	1018 <__bar5_from_arm>
+    1014:	00000000 	andeq	r0, r0, r0
+
+00001018 <__bar5_from_arm>:
+    1018:	e59fc000 	ldr	ip, \[pc, #0\]	; 1020 <__bar5_from_arm\+0x8>
+    101c:	e12fff1c 	bx	ip
+    1020:	0200302f 	.word	0x0200302f
+00001024 <__bar4_from_arm>:
+    1024:	e59fc000 	ldr	ip, \[pc, #0\]	; 102c <__bar4_from_arm\+0x8>
+    1028:	e12fff1c 	bx	ip
+    102c:	0200302d 	.word	0x0200302d
+00001030 <__bar3_veneer>:
+    1030:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1034 <__bar3_veneer\+0x4>
+    1034:	02003028 	.word	0x02003028
+00001038 <__bar_from_arm>:
+    1038:	e59fc000 	ldr	ip, \[pc, #0\]	; 1040 <__bar_from_arm\+0x8>
+    103c:	e12fff1c 	bx	ip
+    1040:	02003021 	.word	0x02003021
+00001044 <__bar2_veneer>:
+    1044:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1048 <__bar2_veneer\+0x4>
+    1048:	02003024 	.word	0x02003024
 	...
-
-00001040 <_start>:
-    1040:	ebfffff0 	bl	1008 <__bar_from_arm>
-    1044:	ebffffed 	bl	1000 <__bar2_veneer>
-
-00001048 <myfunc>:
-    1048:	ebfffff1 	bl	1014 <__bar3_veneer>
-    104c:	ebfffff2 	bl	101c <__bar4_from_arm>
-    1050:	ebfffff4 	bl	1028 <__bar5_from_arm>
 Disassembly of section .foo:
 
 02003020 <bar>:
--- a/ld/testsuite/ld-arm/farcall-mix.d
+++ b/ld/testsuite/ld-arm/farcall-mix.d
@@ -3,32 +3,33 @@
 
 Disassembly of section .text:
 
-00001000 <__bar2_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar2_veneer\+0x4>
-    1004:	02002024 	.word	0x02002024
-00001008 <__bar_from_arm>:
-    1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_arm\+0x8>
-    100c:	e12fff1c 	bx	ip
-    1010:	02002021 	.word	0x02002021
-00001014 <__bar3_veneer>:
-    1014:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1018 <__bar3_veneer\+0x4>
-    1018:	02002028 	.word	0x02002028
-0000101c <__bar4_from_arm>:
-    101c:	e59fc000 	ldr	ip, \[pc, #0\]	; 1024 <__bar4_from_arm\+0x8>
-    1020:	e12fff1c 	bx	ip
-    1024:	0200202d 	.word	0x0200202d
-00001028 <__bar5_from_arm>:
-    1028:	e59fc000 	ldr	ip, \[pc, #0\]	; 1030 <__bar5_from_arm\+0x8>
-    102c:	e12fff1c 	bx	ip
-    1030:	0200202f 	.word	0x0200202f
+00001000 <_start>:
+    1000:	eb000009 	bl	102c <__bar_from_arm>
+    1004:	eb00000b 	bl	1038 <__bar2_veneer>
+    1008:	eb000005 	bl	1024 <__bar3_veneer>
+    100c:	eb00000b 	bl	1040 <__bar4_from_arm>
+    1010:	eb000000 	bl	1018 <__bar5_from_arm>
+    1014:	00000000 	andeq	r0, r0, r0
+
+00001018 <__bar5_from_arm>:
+    1018:	e59fc000 	ldr	ip, \[pc, #0\]	; 1020 <__bar5_from_arm\+0x8>
+    101c:	e12fff1c 	bx	ip
+    1020:	0200202f 	.word	0x0200202f
+00001024 <__bar3_veneer>:
+    1024:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1028 <__bar3_veneer\+0x4>
+    1028:	02002028 	.word	0x02002028
+0000102c <__bar_from_arm>:
+    102c:	e59fc000 	ldr	ip, \[pc, #0\]	; 1034 <__bar_from_arm\+0x8>
+    1030:	e12fff1c 	bx	ip
+    1034:	02002021 	.word	0x02002021
+00001038 <__bar2_veneer>:
+    1038:	e51ff004 	ldr	pc, \[pc, #-4\]	; 103c <__bar2_veneer\+0x4>
+    103c:	02002024 	.word	0x02002024
+00001040 <__bar4_from_arm>:
+    1040:	e59fc000 	ldr	ip, \[pc, #0\]	; 1048 <__bar4_from_arm\+0x8>
+    1044:	e12fff1c 	bx	ip
+    1048:	0200202d 	.word	0x0200202d
 	...
-
-00001040 <_start>:
-    1040:	ebfffff0 	bl	1008 <__bar_from_arm>
-    1044:	ebffffed 	bl	1000 <__bar2_veneer>
-    1048:	ebfffff1 	bl	1014 <__bar3_veneer>
-    104c:	ebfffff2 	bl	101c <__bar4_from_arm>
-    1050:	ebfffff4 	bl	1028 <__bar5_from_arm>
 Disassembly of section .foo:
 
 02002020 <bar>:
--- a/ld/testsuite/ld-arm/farcall-mix2.d
+++ b/ld/testsuite/ld-arm/farcall-mix2.d
@@ -3,35 +3,37 @@
 
 Disassembly of section .text:
 
-00001000 <__bar2_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar2_veneer\+0x4>
-    1004:	02003024 	.word	0x02003024
+00001000 <_start>:
+    1000:	eb000000 	bl	1008 <__bar_from_arm>
+    1004:	eb000002 	bl	1014 <__bar2_veneer>
+
 00001008 <__bar_from_arm>:
     1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_arm\+0x8>
     100c:	e12fff1c 	bx	ip
     1010:	02003021 	.word	0x02003021
-    1014:	00000000 	.word	0x00000000
-
-00001018 <_start>:
-    1018:	ebfffffa 	bl	1008 <__bar_from_arm>
-    101c:	ebfffff7 	bl	1000 <__bar2_veneer>
+00001014 <__bar2_veneer>:
+    1014:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1018 <__bar2_veneer\+0x4>
+    1018:	02003024 	.word	0x02003024
+    101c:	00000000 	.word	0x00000000
 Disassembly of section .mytext:
 
-00002000 <__bar5_from_arm>:
-    2000:	e59fc000 	ldr	ip, \[pc, #0\]	; 2008 <__bar5_from_arm\+0x8>
-    2004:	e12fff1c 	bx	ip
-    2008:	0200302f 	.word	0x0200302f
-0000200c <__bar3_veneer>:
-    200c:	e51ff004 	ldr	pc, \[pc, #-4\]	; 2010 <__bar3_veneer\+0x4>
-    2010:	02003028 	.word	0x02003028
-00002014 <__bar4_from_arm>:
-    2014:	e59fc000 	ldr	ip, \[pc, #0\]	; 201c <__bar4_from_arm\+0x8>
-    2018:	e12fff1c 	bx	ip
-    201c:	0200302d 	.word	0x0200302d
+00002000 <__bar5_from_arm-0x10>:
+    2000:	eb000008 	bl	2028 <__bar3_veneer>
+    2004:	eb000004 	bl	201c <__bar4_from_arm>
+    2008:	eb000000 	bl	2010 <__bar5_from_arm>
+    200c:	00000000 	andeq	r0, r0, r0
+00002010 <__bar5_from_arm>:
+    2010:	e59fc000 	ldr	ip, \[pc, #0\]	; 2018 <__bar5_from_arm\+0x8>
+    2014:	e12fff1c 	bx	ip
+    2018:	0200302f 	.word	0x0200302f
+0000201c <__bar4_from_arm>:
+    201c:	e59fc000 	ldr	ip, \[pc, #0\]	; 2024 <__bar4_from_arm\+0x8>
+    2020:	e12fff1c 	bx	ip
+    2024:	0200302d 	.word	0x0200302d
+00002028 <__bar3_veneer>:
+    2028:	e51ff004 	ldr	pc, \[pc, #-4\]	; 202c <__bar3_veneer\+0x4>
+    202c:	02003028 	.word	0x02003028
 	...
-    2028:	ebfffff7 	bl	200c <__bar3_veneer>
-    202c:	ebfffff8 	bl	2014 <__bar4_from_arm>
-    2030:	ebfffff2 	bl	2000 <__bar5_from_arm>
 Disassembly of section .foo:
 
 02003020 <bar>:
--- /dev/null
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm-be8.d
@@ -0,0 +1,19 @@
+.*:     file format .*
+
+Disassembly of section .text:
+
+00001000 <_start>:
+    1000:	00f0 02f8 	bl	1008 <__bar_from_thumb>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
+
+00001008 <__bar_from_thumb>:
+    1008:	7847      	bx	pc
+    100a:	c046      	nop.*
+    100c:	04f01fe5 	ldr	pc, \[pc, #-4\]	; 1010 <__bar_from_thumb\+0x8>
+    1010:	02001014 	.word	0x02001014
+    1014:	00000000 	.word	0x00000000
+Disassembly of section .foo:
+
+02001014 <bar>:
+ 2001014:	1eff2fe1 	bx	lr
--- a/ld/testsuite/ld-arm/farcall-thumb-arm-blx-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm-blx-pic-veneer.d
@@ -2,14 +2,16 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_thumb>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_from_thumb\+0x8>
-    1004:	e08ff00c 	add	pc, pc, ip
-    1008:	0200000c 	.word	0x0200000c
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_from_thumb>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001010 <_start>:
-    1010:	f7ff eff6 	blx	1000 <__bar_from_thumb>
+00001008 <__bar_from_thumb>:
+    1008:	e59fc000 	ldr	ip, \[pc, #0\]	; 1010 <__bar_from_thumb\+0x8>
+    100c:	e08ff00c 	add	pc, pc, ip
+    1010:	02000000 	.word	0x02000000
+    1014:	00000000 	.word	0x00000000
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-arm-blx.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm-blx.d
@@ -2,12 +2,14 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_thumb>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_from_thumb\+0x4>
-    1004:	02001014 	.word	0x02001014
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_from_thumb>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001008 <_start>:
-    1008:	f7ff effa 	blx	1000 <__bar_from_thumb>
+00001008 <__bar_from_thumb>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_from_thumb\+0x4>
+    100c:	02001014 	.word	0x02001014
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-arm-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm-pic-veneer.d
@@ -1,5 +1,5 @@
-#name: Thumb-Thumb farcall without BLX
-#source: farcall-thumb-thumb.s
-#as: -march=armv4t
-#ld: -Ttext 0x1000 --section-start .foo=0x2001014
+#name: Thumb-ARM farcall without BLX (PIC veneer)
+#source: farcall-thumb-arm.s
+#as: -march=armv4t -W
+#ld: -Ttext 0x1000 --section-start .foo=0x2001014 --pic-veneer
 #error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
--- a/ld/testsuite/ld-arm/farcall-thumb-arm-short.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm-short.d
@@ -2,12 +2,15 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_thumb>:
-    1000:	4778      	bx	pc
-    1002:	46c0      	nop			\(mov r8, r8\)
-    1004:	ea000402 	b	2014 <bar>
-00001008 <_start>:
-    1008:	f7ff fffa 	bl	1000 <__bar_from_thumb>
+00001000 <_start>:
+    1000:	f000 f802 	bl	1008 <__bar_from_thumb>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
+
+00001008 <__bar_from_thumb>:
+    1008:	4778      	bx	pc
+    100a:	46c0      	nop			\(mov r8, r8\)
+    100c:	ea000400 	b	2014 <bar>
 Disassembly of section .foo:
 
 00002014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-arm.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-arm.d
@@ -2,18 +2,17 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_from_thumb>:
-    1000:	b540      	push	{r6, lr}
-    1002:	4e03      	ldr	r6, \[pc, #12\]	\(1010 <__bar_from_thumb\+0x10>\)
-    1004:	46fe      	mov	lr, pc
-    1006:	4730      	bx	r6
-    1008:	e8bd4040 	pop	{r6, lr}
-    100c:	e12fff1e 	bx	lr
+00001000 <_start>:
+    1000:	f000 f802 	bl	1008 <__bar_from_thumb>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
+
+00001008 <__bar_from_thumb>:
+    1008:	4778      	bx	pc
+    100a:	46c0      	nop			\(mov r8, r8\)
+    100c:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1010 <__bar_from_thumb\+0x8>
     1010:	02001014 	.word	0x02001014
     1014:	00000000 	.word	0x00000000
-
-00001018 <_start>:
-    1018:	f7ff fff2 	bl	1000 <__bar_from_thumb>
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb-blx-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb-blx-pic-veneer.d
@@ -2,14 +2,16 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e59fc000 	ldr	ip, \[pc, #0\]	; 1008 <__bar_veneer\+0x8>
-    1004:	e08ff00c 	add	pc, pc, ip
-    1008:	0200000d 	.word	0x0200000d
-    100c:	00000000 	.word	0x00000000
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001010 <_start>:
-    1010:	f7ff eff6 	blx	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	e59fc004 	ldr	ip, \[pc, #4\]	; 1014 <__bar_veneer\+0xc>
+    100c:	e08fc00c 	add	ip, pc, ip
+    1010:	e12fff1c 	bx	ip
+    1014:	02000001 	.word	0x02000001
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb-blx.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb-blx.d
@@ -2,12 +2,14 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_veneer\+0x4>
-    1004:	02001015 	.word	0x02001015
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001008 <_start>:
-    1008:	f7ff effa 	blx	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_veneer\+0x4>
+    100c:	02001015 	.word	0x02001015
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb-m-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb-m-pic-veneer.d
@@ -1,5 +1,5 @@
-#name: Thumb-Thumb farcall without BLX
+#name: Thumb-Thumb farcall M profile (PIC veneer)
 #source: farcall-thumb-thumb.s
 #as: -march=armv4t
-#ld: -Ttext 0x1000 --section-start .foo=0x2001014
+#ld: -Ttext 0x1000 --section-start .foo=0x2001014 --pic-veneer
 #error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb-m.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb-m.d
@@ -2,17 +2,19 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	b540      	push	{r6, lr}
-    1002:	4e02      	ldr	r6, \[pc, #8\]	\(100c <__bar_veneer\+0xc>\)
-    1004:	46fe      	mov	lr, pc
-    1006:	4730      	bx	r6
-    1008:	bd40      	pop	{r6, pc}
-    100a:	bf00      	nop
-    100c:	02001015 	.word	0x02001015
+00001000 <_start>:
+    1000:	f000 f802 	bl	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001010 <_start>:
-    1010:	f7ff fff6 	bl	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	b401      	push	{r0}
+    100a:	4802      	ldr	r0, \[pc, #8\]	\(1014 <__bar_veneer\+0xc>\)
+    100c:	4684      	mov	ip, r0
+    100e:	bc01      	pop	{r0}
+    1010:	4760      	bx	ip
+    1012:	bf00      	nop
+    1014:	02001015 	.word	0x02001015
 Disassembly of section .foo:
 
 02001014 <bar>:
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb-pic-veneer.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb-pic-veneer.d
@@ -1,5 +1,5 @@
-#name: Thumb-Thumb farcall without BLX
+#name: Thumb-Thumb farcall without BLX (PIC veneer)
 #source: farcall-thumb-thumb.s
 #as: -march=armv4t
-#ld: -Ttext 0x1000 --section-start .foo=0x2001014
+#ld: -Ttext 0x1000 --section-start .foo=0x2001014 --pic-veneer
 #error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
--- a/ld/testsuite/ld-arm/farcall-thumb-thumb.d
+++ b/ld/testsuite/ld-arm/farcall-thumb-thumb.d
@@ -1,5 +1,21 @@
-#name: Thumb-Thumb farcall without BLX
-#source: farcall-thumb-thumb.s
-#as: -march=armv4t
-#ld: -Ttext 0x1000 --section-start .foo=0x2001014
-#error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
+.*:     file format .*
+
+Disassembly of section .text:
+
+00001000 <_start>:
+    1000:	f000 f802 	bl	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
+
+00001008 <__bar_veneer>:
+    1008:	b401      	push	{r0}
+    100a:	4802      	ldr	r0, \[pc, #8\]	\(1014 <__bar_veneer\+0xc>\)
+    100c:	4684      	mov	ip, r0
+    100e:	bc01      	pop	{r0}
+    1010:	4760      	bx	ip
+    1012:	bf00      	nop
+    1014:	02001015 	.word	0x02001015
+Disassembly of section .foo:
+
+02001014 <bar>:
+ 2001014:	4770      	bx	lr
--- /dev/null
+++ b/ld/testsuite/ld-arm/script-type.ld
@@ -0,0 +1,7 @@
+SECTIONS {
+  foo_a = bar_a;
+  foo_t = bar_t;
+  foo_o = bar_o;
+  .text : { *(.text) }
+  .ARM.attribues 0 : { *(.ARM.attributes) }
+}
--- /dev/null
+++ b/ld/testsuite/ld-arm/script-type.s
@@ -0,0 +1,20 @@
+.syntax unified
+.text
+.global bar_a
+.type bar_a %function
+bar_a:
+bx lr
+
+.p2align 4
+.global bar_o
+.type bar_o %object
+bar_o:
+.word 0
+
+.p2align 4
+.thumb
+.global bar_t
+.type bar_t %function
+bar_t:
+bx lr
+
--- /dev/null
+++ b/ld/testsuite/ld-arm/script-type.sym
@@ -0,0 +1,16 @@
+
+Symbol table '.symtab' contains 13 entries:
+   Num:    Value  Size Type    Bind   Vis      Ndx Name
+     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
+     1: 00000000     0 SECTION LOCAL  DEFAULT    1 
+     2: 00000000     0 SECTION LOCAL  DEFAULT    2 
+     3: 00000000     0 NOTYPE  LOCAL  DEFAULT    1 \$a
+     4: 00000010     0 NOTYPE  LOCAL  DEFAULT    1 \$d
+     5: 00000014     0 NOTYPE  LOCAL  DEFAULT    1 \$a
+     6: 00000020     0 NOTYPE  LOCAL  DEFAULT    1 \$t
+     7: 00000010     0 OBJECT  GLOBAL DEFAULT    1 bar_o
+     8: 00000021     0 FUNC    GLOBAL DEFAULT    1 bar_t
+     9: 00000000     0 FUNC    GLOBAL DEFAULT    1 foo_a
+    10: 00000021     0 FUNC    GLOBAL DEFAULT    1 foo_t
+    11: 00000010     0 OBJECT  GLOBAL DEFAULT    1 foo_o
+    12: 00000000     0 FUNC    GLOBAL DEFAULT    1 bar_a
--- a/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d
+++ b/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d
@@ -1,4 +1,19 @@
-#name: Thumb-2-as-Thumb-1 BL failure test
-#source: thumb2-bl-as-thumb1-bad.s
-#ld: -Ttext 0x1000 --section-start .foo=0x401004
-#error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
+.*:     file format .*
+
+Disassembly of section .text:
+
+00001000 <__bar_veneer>:
+    1000:	b401      	push	{r0}
+    1002:	4802      	ldr	r0, \[pc, #8\]	\(100c <__bar_veneer\+0xc>\)
+    1004:	4684      	mov	ip, r0
+    1006:	bc01      	pop	{r0}
+    1008:	4760      	bx	ip
+    100a:	bf00      	nop
+    100c:	0100100d 	.word	0x0100100d
+
+00001010 <_start>:
+    1010:	f7ff fff6 	bl	1000 <__bar_veneer>
+Disassembly of section .foo:
+
+0100100c <bar>:
+ 100100c:	4770      	bx	lr
--- a/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad.d
+++ b/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad.d
@@ -2,13 +2,16 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_veneer\+0x4>
-    1004:	0040100d 	.word	0x0040100d
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
+
+00001008 <__bar_veneer>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_veneer\+0x4>
+    100c:	0100100d 	.word	0x0100100d
 
-00001008 <_start>:
-    1008:	f7ff effa 	blx	1000 <__bar_veneer>
 Disassembly of section .foo:
 
-0040100c <bar>:
-  40100c:	4770      	bx	lr
+0100100c <bar>:
+ 100100c:	4770      	bx	lr
--- a/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad.s
+++ b/ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad.s
@@ -12,7 +12,7 @@
 _start:
 	bl bar
 
-@ We will place the section .foo at 0x40100c.
+@ We will place the section .foo at 0x100100c.
 
 	.section .foo, "xa"
 	.thumb_func
--- a/ld/testsuite/ld-arm/thumb2-bl-bad-noeabi.d
+++ b/ld/testsuite/ld-arm/thumb2-bl-bad-noeabi.d
@@ -1,4 +1,19 @@
-#name: Thumb-2 BL failure test
-#source: thumb2-bl-bad.s
-#ld: -Ttext 0x1000 --section-start .foo=0x1001004
-#error: .*\(.text\+0x0\): relocation truncated to fit: R_ARM_THM_CALL against `bar'
+.*:     file format .*
+
+Disassembly of section .text:
+
+00001000 <__bar_veneer>:
+    1000:	b401      	push	{r0}
+    1002:	4802      	ldr	r0, \[pc, #8\]	\(100c <__bar_veneer\+0xc>\)
+    1004:	4684      	mov	ip, r0
+    1006:	bc01      	pop	{r0}
+    1008:	4760      	bx	ip
+    100a:	bf00      	nop
+    100c:	0100100d 	.word	0x0100100d
+
+00001010 <_start>:
+    1010:	f7ff fff6 	bl	1000 <__bar_veneer>
+Disassembly of section .foo:
+
+0100100c <bar>:
+ 100100c:	4770      	bx	lr
--- a/ld/testsuite/ld-arm/thumb2-bl-bad.d
+++ b/ld/testsuite/ld-arm/thumb2-bl-bad.d
@@ -2,12 +2,14 @@
 
 Disassembly of section .text:
 
-00001000 <__bar_veneer>:
-    1000:	e51ff004 	ldr	pc, \[pc, #-4\]	; 1004 <__bar_veneer\+0x4>
-    1004:	0100100d 	.word	0x0100100d
+00001000 <_start>:
+    1000:	f000 e802 	blx	1008 <__bar_veneer>
+    1004:	0000      	lsls	r0, r0, #0
+	\.\.\.
 
-00001008 <_start>:
-    1008:	f7ff effa 	blx	1000 <__bar_veneer>
+00001008 <__bar_veneer>:
+    1008:	e51ff004 	ldr	pc, \[pc, #-4\]	; 100c <__bar_veneer\+0x4>
+    100c:	0100100d 	.word	0x0100100d
 Disassembly of section .foo:
 
 0100100c <bar>:
--- /dev/null
+++ b/ld/testsuite/ld-arm/thumb2-bl-blx-interwork.d
@@ -0,0 +1,93 @@
+
+.*:     file format .*
+
+
+Disassembly of section \.text:
+
+00008000 <_start>:
+    8000:	.*
+    8004:	.*
+    8008:	bf00      	nop
+    800a:	.*
+    800e:	.*
+    8012:	bf00      	nop
+    8014:	f000 e81c 	blx	8050 <arm0>
+    8018:	f000 e820 	blx	805c <arm4>
+    801c:	bf00      	nop
+    801e:	f000 e818 	blx	8050 <arm0>
+    8022:	f000 e81c 	blx	805c <arm4>
+    8026:	bf00      	nop
+    8028:	f000 f81e 	bl	8068 <thumb0>
+    802c:	f000 f821 	bl	8072 <thumb2>
+    8030:	f000 f824 	bl	807c <thumb4>
+    8034:	f000 f827 	bl	8086 <thumb6>
+    8038:	bf00      	nop
+    803a:	f000 f815 	bl	8068 <thumb0>
+    803e:	f000 f818 	bl	8072 <thumb2>
+    8042:	f000 f81b 	bl	807c <thumb4>
+    8046:	f000 f81e 	bl	8086 <thumb6>
+    804a:	bf00      	nop
+    804c:	e320f000 	nop	\{0\}
+
+00008050 <arm0>:
+    8050:	e12fff1e 	bx	lr
+
+00008054 <\.real_start_ofarm0>:
+    8054:	4770      	bx	lr
+    8056:	0000      	.short	0x0000
+    8058:	e320f000 	nop	\{0\}
+
+0000805c <arm4>:
+    805c:	e12fff1e 	bx	lr
+
+00008060 <\.real_start_ofarm4>:
+    8060:	4770      	bx	lr
+    8062:	0000      	.short	0x0000
+    8064:	f3af 8000 	nop\.w
+
+00008068 <thumb0>:
+    8068:	4770      	bx	lr
+    806a:	bf00      	nop
+    806c:	f3af 8000 	nop\.w
+    8070:	bf00      	nop
+
+00008072 <thumb2>:
+    8072:	4770      	bx	lr
+    8074:	f3af 8000 	nop\.w
+    8078:	bf00      	nop
+    807a:	bf00      	nop
+
+0000807c <thumb4>:
+    807c:	4770      	bx	lr
+    807e:	bf00      	nop
+    8080:	bf00      	nop
+    8082:	bf00      	nop
+    8084:	bf00      	nop
+
+00008086 <thumb6>:
+    8086:	4770      	bx	lr
+
+00008088 <backwards>:
+    8088:	f7ff ffe4 	bl	8054 <\.real_start_ofarm0>
+    808c:	f7ff ffe8 	bl	8060 <\.real_start_ofarm4>
+    8090:	bf00      	nop
+    8092:	f7ff ffdf 	bl	8054 <\.real_start_ofarm0>
+    8096:	f7ff ffe3 	bl	8060 <\.real_start_ofarm4>
+    809a:	bf00      	nop
+    809c:	f7ff efd8 	blx	8050 <arm0>
+    80a0:	f7ff efdc 	blx	805c <arm4>
+    80a4:	bf00      	nop
+    80a6:	f7ff efd4 	blx	8050 <arm0>
+    80aa:	f7ff efd8 	blx	805c <arm4>
+    80ae:	bf00      	nop
+    80b0:	f7ff ffda 	bl	8068 <thumb0>
+    80b4:	f7ff ffdd 	bl	8072 <thumb2>
+    80b8:	f7ff ffe0 	bl	807c <thumb4>
+    80bc:	f7ff ffe3 	bl	8086 <thumb6>
+    80c0:	bf00      	nop
+    80c2:	f7ff ffd1 	bl	8068 <thumb0>
+    80c6:	f7ff ffd4 	bl	8072 <thumb2>
+    80ca:	f7ff ffd7 	bl	807c <thumb4>
+    80ce:	f7ff ffda 	bl	8086 <thumb6>
+    80d2:	bf00      	nop
+    80d4:	f3af 8000 	nop\.w
--- /dev/null
+++ b/ld/testsuite/ld-arm/thumb2-bl-blx-interwork.s
@@ -0,0 +1,99 @@
+	.arch armv7-a
+	.global _start
+	.syntax unified
+	.text
+	.thumb
+
+	.macro do_calls
+	@ These four instructions interwork (by calling a ".real_start_of"
+	@ Thumb entry point for a function), but only for backward references.
+	bl.w arm0
+	bl.w arm4
+	nop
+	bl.w arm0
+	bl.w arm4
+	nop
+	blx.w arm0
+	blx.w arm4
+	nop
+	blx.w arm0
+	blx.w arm4
+	nop
+	bl.w thumb0
+	bl.w thumb2
+	bl.w thumb4
+	bl.w thumb6
+	nop
+	bl.w thumb0
+	bl.w thumb2
+	bl.w thumb4
+	bl.w thumb6
+	nop
+	@ These eight are all accepted with current gas, but generate bad code.
+	@blx.w thumb0
+	@blx.w thumb2
+	@blx.w thumb4
+	@blx.w thumb6
+	@nop
+	@blx.w thumb0
+	@blx.w thumb2
+	@blx.w thumb4
+	@blx.w thumb6
+	.endm
+
+	.thumb_func
+	.align 3
+_start:
+	do_calls
+
+	.arm
+	.global offset0
+	.align 3
+arm0:
+	bx lr
+
+	.thumb
+.real_start_ofarm0:
+	bx lr
+	.arm
+
+	.global offset4
+	.align 3
+	nop
+arm4:
+	bx lr
+
+	.thumb
+.real_start_ofarm4:
+	bx lr
+	.arm
+
+	.thumb
+	.thumb_func
+	.align 3
+thumb0:
+	bx lr
+
+	.thumb_func
+	.align 3
+	nop
+thumb2:
+	bx lr
+
+	.thumb_func
+	.align 3
+	nop
+	nop
+thumb4:
+	bx lr
+
+	.thumb_func
+	.align 3
+	nop
+	nop
+	nop
+thumb6:
+	bx lr
+
+backwards:
+	do_calls
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-1.d
@@ -0,0 +1,10 @@
+#ld: -T arm.ld
+#objdump: -s
+
+.*:     file format.*
+
+#...
+Contents of section .ARM.exidx:
+ 8008 (f8ffff7f b0b0a880 f4ffff7f 01000000|7ffffff8 80a8b0b0 7ffffff4 00000001)  .*
+Contents of section .far:
+#...
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-1.s
@@ -0,0 +1,19 @@
+	.syntax unified
+	.text
+	.global _start
+	.type _start, %function
+_start:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	@ Section with no unwinding information.  Linker should insert a cantunwind entry.
+	.section .after, "xa"
+	.global __aeabi_unwind_cpp_pr0
+	.type __aeabi_unwind_cpp_pr0, %function
+__aeabi_unwind_cpp_pr0:
+	bx lr
+
+	.section .far
+	.word 0
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-2.d
@@ -0,0 +1,10 @@
+#ld: -T arm.ld
+#objdump: -s
+
+.*:     file format.*
+
+#...
+Contents of section .ARM.exidx:
+ 8004 (fcffff7f b0b0a880 f8ffff7f 01000000|7ffffffc 80a8b0b0 7ffffff8 00000001)  .*
+Contents of section .far:
+#...
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-2.s
@@ -0,0 +1,19 @@
+	.syntax unified
+	.text
+
+	.global __aeabi_unwind_cpp_pr0
+	.type __aeabi_unwind_cpp_pr0, %function
+__aeabi_unwind_cpp_pr0:
+	.global _start
+	.type _start, %function
+_start:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	@ last text section has unwind information. Linker should append a
+	@ terminating cantunwind entry.
+
+	.section .far
+	.word 0
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-3.d
@@ -0,0 +1,11 @@
+#ld: -T arm.ld
+#objdump: -s
+
+.*:     file format.*
+
+#...
+Contents of section .ARM.exidx:
+ 800c (f4ffff7f b0b0a880 f0ffff7f 01000000|7ffffff4 80a8b0b0 7ffffff0 00000001)  .*
+ 801c (ecffff7f b0b0a880 e8ffff7f 01000000|7fffffec 80a8b0b0 7fffffe8 00000001)  .*
+Contents of section .far:
+#...
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-3.s
@@ -0,0 +1,29 @@
+	.syntax unified
+	.text
+	@ section without unwind info
+	.global _start
+	.type _start, %function
+_start:
+	bl _before
+
+	@ Section that will be placed first
+	.section .before, "xa"
+	.type _before, %function
+_before:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	@ section that will be placed last
+	.section .after, "xa"
+	.global __aeabi_unwind_cpp_pr0
+	.type __aeabi_unwind_cpp_pr0, %function
+__aeabi_unwind_cpp_pr0:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	.section .far
+	.word 0
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-4.d
@@ -0,0 +1,11 @@
+#ld: -T arm.ld
+#objdump: -s
+
+.*:     file format.*
+
+#...
+Contents of section .ARM.exidx:
+ 8020 (e0ffff7f b0b0a880 dcffff7f e8ffff7f|7fffffe0 80a8b0b0 7fffffdc 7fffffe8)  .*
+ 8030 (d8ffff7f b0b0a880 d8ffff7f 01000000|7fffffd8 80a8b0b0 7fffffd8 00000001)  .*
+Contents of section .far:
+#...
--- /dev/null
+++ b/ld/testsuite/ld-arm/unwind-4.s
@@ -0,0 +1,49 @@
+	.syntax unified
+	.text
+	@ out of line table entry
+	.global _start
+	.type _start, %function
+_start:
+	.fnstart
+	.save {r4, lr}
+	.vsave {d0}
+	.vsave {d4}
+	bl _before
+	.fnend
+
+	@ entry that can be merged
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	@ Section that will be placed first
+	.section .before, "xa"
+	.type _before, %function
+_before:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+
+	@ section that will be placed last
+	.section .after, "xa"
+	.global __aeabi_unwind_cpp_pr0
+	.type __aeabi_unwind_cpp_pr0, %function
+__aeabi_unwind_cpp_pr0:
+	.fnstart
+	.save {r4, lr}
+	bx lr
+	.fnend
+	@ final function is cantunwind, so output table size is smaller
+	@ than sum of input sections
+	.global __aeabi_unwind_cpp_pr1
+	.type __aeabi_unwind_cpp_pr1, %function
+__aeabi_unwind_cpp_pr1:
+	.fnstart
+	.cantunwind
+	bx lr
+	.fnend
+
+	.section .far
+	.word 0
--- a/ld/testsuite/ld-elf/eh5.d
+++ b/ld/testsuite/ld-elf/eh5.d
@@ -14,7 +14,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     1b
+  Augmentation data:     (0|1)b
 
   DW_CFA_nop
   DW_CFA_nop
@@ -33,7 +33,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     03 .. .. .. .. 1b
+  Augmentation data:     03 .. .. .. .. (0|1)b
 
   DW_CFA_nop
 
@@ -57,7 +57,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     03 .. .. .. .. 0c 1b
+  Augmentation data:     03 .. .. .. .. 0c (0|1)b
 
   DW_CFA_nop
   DW_CFA_nop
@@ -78,7 +78,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     1b
+  Augmentation data:     (0|1)b
 
   DW_CFA_def_cfa: r0( \([er]ax\)|) ofs 16
 #...
@@ -93,7 +93,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     03 .. .. .. .. 1b
+  Augmentation data:     03 .. .. .. .. (0|1)b
 
   DW_CFA_nop
 
@@ -115,7 +115,7 @@ Contents of the .eh_frame section:
   Code alignment factor: .*
   Data alignment factor: .*
   Return address column: .*
-  Augmentation data:     03 .. .. .. .. 0c 1b
+  Augmentation data:     03 .. .. .. .. 0c (0|1)b
 
   DW_CFA_nop
   DW_CFA_nop
--- a/ld/testsuite/ld-elfcomm/elfcomm.exp
+++ b/ld/testsuite/ld-elfcomm/elfcomm.exp
@@ -175,9 +175,10 @@ proc assembler_generates_commons {} {
     return 1
 }
 
-
-if {   ![ld_compile "$CC $CFLAGS" $srcdir/$subdir/common1a.c tmpdir/common1a.o]
-    || ![ld_compile "$CC $CFLAGS" $srcdir/$subdir/common1b.c tmpdir/common1b.o] } {
+# Explicitly use "-fcommon" so that even if $CFLAGS includes
+# "-fno-common", these tests are compiled as expected.
+if {   ![ld_compile "$CC $CFLAGS -fcommon" $srcdir/$subdir/common1a.c tmpdir/common1a.o]
+    || ![ld_compile "$CC $CFLAGS -fcommon" $srcdir/$subdir/common1b.c tmpdir/common1b.o] } {
     unresolved $test1
     return
 }
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at.exp
@@ -0,0 +1,33 @@
+# Test for proper diagnosis of overflowed memory regions.
+# Copyright 2009 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+if ![is_elf_format] {
+    return
+}
+
+load_lib ld-lib.exp
+
+set test_list [lsort [glob -nocomplain $srcdir/$subdir/rgn-at*.d]]
+foreach test_file $test_list {
+    set test_name [file rootname $test_file]
+    set map_file "tmpdir/[file tail $test_name].map"
+    verbose $test_name
+    run_dump_test $test_name
+}
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at.s
@@ -0,0 +1,6 @@
+	.section .text
+	.long 0x12345678
+	.section .data
+	.long 0x9abcdef0
+	.section .bss
+	.long 0
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at1.d
@@ -0,0 +1,12 @@
+# name: rgn-at1
+# source: rgn-at.s
+# ld: -T rgn-at1.t
+# objdump: -w -h
+
+.*:     file format .*
+
+Sections:
+Idx +Name +Size +VMA +LMA +File off +Algn +Flags
+  0 .text +0+[0-9a-f][0-9a-f] +0+0010000 +0+0020000 +.*
+  1 .data +0+[0-9a-f][0-9a-f] +0+00100[0-9a-f]+ +0+00200[0-9a-f]+ +.*
+  2 .bss +0+[0-9a-f][0-9a-f] +0+00100[0-9a-f]+ +0+00200[0-9a-f]+ +.*
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at1.t
@@ -0,0 +1,13 @@
+/* Memory region at test, >AT should propagate by default */
+
+MEMORY {
+  ram : ORIGIN = 0x10000, LENGTH = 0x100
+  rom : ORIGIN = 0x20000, LENGTH = 0x200
+}
+_start = 0x1000;
+SECTIONS {
+  .text : { *(.text) } >ram AT>rom
+  .data : { *(.data) } >ram /* default AT>rom */
+  .bss : { *(.bss) } >ram
+  /DISCARD/ : { *(*) }
+}
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at2.d
@@ -0,0 +1,12 @@
+# name: rgn-at2
+# source: rgn-at.s
+# ld: -T rgn-at2.t
+# objdump: -w -h
+
+.*:     file format .*
+
+Sections:
+Idx +Name +Size +VMA +LMA +File off +Algn +Flags
+  0 .text +0+[0-9a-f][0-9a-f] +0+0010000 +0+0020000 +.*
+  1 .data +0+[0-9a-f][0-9a-f] +0+0030000 +0+0030000 +.*
+  2 .bss +0+[0-9a-f][0-9a-f] +0+00300[0-9a-f]+ +0+00300[0-9a-f]+ +.*
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at2.t
@@ -0,0 +1,14 @@
+/* Memory region at test, >AT should propagate by default */
+
+MEMORY {
+  ram : ORIGIN = 0x10000, LENGTH = 0x100
+  rom : ORIGIN = 0x20000, LENGTH = 0x200
+  other : ORIGIN = 0x30000, LENGTH = 0x200
+}
+_start = 0x1000;
+SECTIONS {
+  .text : { *(.text) } >ram AT>rom
+  .data : { *(.data) } >other /* No default AT>rom */
+  .bss : { *(.bss) } >other
+  /DISCARD/ : { *(*) }
+}
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at3.d
@@ -0,0 +1,12 @@
+# name: rgn-at3
+# source: rgn-at.s
+# ld: -T rgn-at3.t
+# objdump: -w -h
+
+.*:     file format .*
+
+Sections:
+Idx +Name +Size +VMA +LMA +File off +Algn +Flags
+  0 .text +0+[0-9a-f][0-9a-f] +0+0010000 +0+0020000 +.*
+  1 .data +0+[0-9a-f][0-9a-f] +0+00100[0-9a-f]+ +0+0030000 +.*
+  2 .bss +0+[0-9a-f][0-9a-f] +0+00100[0-9a-f]+ +0+00300[0-9a-f]+ +.*
--- /dev/null
+++ b/ld/testsuite/ld-scripts/rgn-at3.t
@@ -0,0 +1,13 @@
+/* Memory region at test, >AT should propagate by default */
+
+MEMORY {
+  ram : ORIGIN = 0x10000, LENGTH = 0x100
+  rom : ORIGIN = 0x20000, LENGTH = 0x200
+}
+_start = 0x1000;
+SECTIONS {
+  .text : { *(.text) } >ram AT>rom
+  .data : AT (0x30000) { *(.data) } >ram /* NO default AT>rom */
+  .bss : { *(.bss) } >ram /* NO default AT>rom */
+  /DISCARD/ : { *(*) }
+}
--- a/ld/testsuite/lib/ld-lib.exp
+++ b/ld/testsuite/lib/ld-lib.exp
@@ -1592,7 +1592,8 @@ proc check_gc_sections_available { } {
 	# advertised by ld's options.
 	if { [istarget alpha*-*-*]
 	     || [istarget mep-*-*]
-	     || [istarget ia64-*-*] } {
+	     || [istarget ia64-*-*]
+	     || [istarget *-*-mingw*] } {
 	    set gc_sections_available_saved 0
 	    return 0
 	}
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -124,7 +124,7 @@ COMPILE.c = $(CC) -c @DEFS@ $(CFLAGS) $(
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c					\
+	 cp-demint.c cplus-dem.c cygpath.c				\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -182,7 +182,7 @@ REQUIRED_OFILES =							\
 # maint-missing" and "make check".
 CONFIGURED_OFILES = ./asprintf.o ./atexit.o				\
 	./basename.o ./bcmp.o ./bcopy.o ./bsearch.o ./bzero.o		\
-	./calloc.o ./clock.o ./copysign.o				\
+	./calloc.o ./clock.o ./copysign.o ./cygpath.o			\
 	./_doprnt.o							\
 	./ffs.o								\
 	./getcwd.o ./getpagesize.o ./gettimeofday.o			\
@@ -619,6 +619,12 @@ $(CONFIGURED_OFILES): stamp-picdir
 	else true; fi
 	$(COMPILE.c) $(srcdir)/cplus-dem.c $(OUTPUT_OPTION)
 
+./cygpath.o: $(srcdir)/cygpath.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.o: $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -8891,6 +8891,20 @@ case "${host}" in
 esac
 
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	case $LIBOBJS in
+    "cygpath.$ac_objext"   | \
+  *" cygpath.$ac_objext"   | \
+    "cygpath.$ac_objext "* | \
+  *" cygpath.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS cygpath.$ac_objext" ;;
+esac
+
+	;;
+esac
+
 if test x$gcc_no_link = xyes; then
   if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
     ac_cv_func_mmap_fixed_mapped=no
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -663,6 +663,13 @@ case "${host}" in
 esac
 AC_SUBST(pexecute)
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	AC_LIBOBJ([cygpath])
+	;;
+esac
+
 libiberty_AC_FUNC_STRNCMP
 
 # Install a library built with a cross compiler in $(tooldir) rather
--- /dev/null
+++ b/libiberty/cygpath.c
@@ -0,0 +1,591 @@
+/* Support Cygwin paths under MinGW.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   Written by CodeSourcery.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or modify it
+under the terms of the GNU Library General Public License as published
+by the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not, write
+to the Free Software Foundation, Inc., 51 Franklin Street - Fifth
+Floor, Boston, MA 02110-1301, USA.  */
+
+#include <windows.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <io.h>
+#include <process.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "libiberty.h"
+
+/* If non-zero, we have attempted to use cygpath.  CYGPATH_PEX may
+   still be NULL, if cygpath is unavailable.  */
+static int cygpath_initialized;
+
+/* If non-NULL, an instance of cygpath connected via a pipe.  */
+static struct pex_obj *cygpath_pex;
+
+/* The input to cygpath.  */
+static FILE *cygpath_in;
+
+/* The output from cygpath.  */
+static FILE *cygpath_out;
+
+/* If non-NULL, a file to which path translations are logged.  */
+static FILE *cygpath_log;
+
+/* Record MESSAGE in the CYGPATH_LOG.  MESSAGE is a format string,
+   which is expected to have a single "%s" field, to be replaced by
+   ARG.  */
+static void
+cygpath_log_msg_arg (const char *message, const char *arg)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: ", _getpid ());
+  fprintf (cygpath_log, message, arg);
+  fprintf (cygpath_log, "\n");
+  fflush (cygpath_log);
+}
+
+/* Record MESSAGE in the CYGPATH_LOG.  */
+static void
+cygpath_log_msg (const char *message)
+{
+  cygpath_log_msg_arg ("%s", message);
+}
+
+/* An error has occured.  Add the MESSAGE to the CYGPATH_LOG, noting
+   the cause of the error based on errno.  */
+static void
+cygpath_perror (const char *message)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: error: %s: %s\n",
+	   _getpid(), message, strerror (errno));
+  fflush (cygpath_log);
+}
+
+/* Closes CYGPATH_PEX and frees all associated
+   resoures.  */
+static void
+cygpath_close (void)
+{
+  /* Free resources.  */
+  if (cygpath_out)
+    {
+      fclose (cygpath_out);
+      cygpath_out = NULL;
+    }
+  if (cygpath_in)
+    {
+      fclose (cygpath_in);
+      cygpath_in = NULL;
+    }
+  if (cygpath_pex)
+    {
+      pex_free (cygpath_pex);
+      cygpath_pex = NULL;
+    }
+  if (cygpath_log)
+    {
+      cygpath_log_msg ("end");
+      cygpath_log = NULL;
+    }
+}
+
+/* CYG_PATH is a pointer to a Cygwin path.  This function converts the
+   Cygwin path to a Windows path, storing the result in
+   WIN32_PATH.  Returns true if the conversion was successful; false
+   otherwise.  */
+int
+cygpath (const char *cyg_path, char win32_path[MAX_PATH + 1])
+{
+  bool ok;
+  bool retrying;
+  
+  /* Special-case the empty path.  cygpath cannot handle the empty
+     path correctly.  It ignores the empty line, waiting for a
+     non-empty line, which in turn causes an application using this
+     function to appear stuck.  */
+  if (cyg_path[0] == '\0')
+    {
+      win32_path[0] = '\0';
+      return true;
+    }
+  
+  retrying = false;
+
+ retry:
+  if (!cygpath_initialized) 
+    {
+      const char *argv[] = { "cygpath", "-w", "-f", "-", NULL };
+      const char *cygpath_path;
+      const char *log;
+      int err;
+
+      /* If we are unable to invoke cygpath, we do not want to try
+	 again.  So, we set the initialized flag at this point; if
+	 errors occur during the invocation, it will remain set.  */
+      cygpath_initialized = 1;
+      /* Check to see if the user wants cygpath support.  */
+      cygpath_path = getenv ("CYGPATH");
+      if (!cygpath_path)
+	/* The user doesn't need to support Cygwin paths.  */
+	goto error;
+      /* If debugging, open the log file.  */
+      log = getenv ("CSL_DEBUG_CYGPATH");
+      if (log && log[0])
+	{
+	  /* The log file is opened for "append" so that multiple
+	     processes (perhaps invoked from "make") can share it.  */
+	  cygpath_log = fopen (log, "a");
+	  if (cygpath_log)
+	    cygpath_log_msg ("begin");
+	}
+      /* If the environment variable is set to a non-empty string, use
+	 that string as the path to cygpath.  */ 
+      if (cygpath_path[0] != '\0')
+	argv[0] = cygpath_path;
+      /* Create the pex object.  */
+      cygpath_pex = pex_init (PEX_SEARCH | PEX_USE_PIPES, 
+			      "cygpath", NULL);
+      if (!cygpath_pex)
+	goto error;
+      /* Get the FILE we will use to write to the child.  */
+      cygpath_in = pex_input_pipe (cygpath_pex, /*binary=*/0);
+      if (!cygpath_in)
+	goto error;
+      /* Start the child process.  */
+      if (pex_run (cygpath_pex, PEX_SEARCH | PEX_USE_PIPES, 
+		   argv[0], (char**) argv, 
+		   NULL, NULL,
+		   &err) != NULL)
+	goto error;
+      /* Get the FILE we will use to read from the child.  */
+      cygpath_out = pex_read_output (cygpath_pex, /*binary=*/1);
+      if (!cygpath_out)
+	goto error;
+    }
+  else if (!cygpath_pex) 
+    /* We previously tried to use cygpath, but something went wrong.  */
+    return false;
+
+  /* Write CYG_PATH to the child, on a line by itself.  */
+  cygpath_log_msg_arg ("-> %s", cyg_path);
+  if (fprintf (cygpath_in, "%s\n", cyg_path) < 0)
+    {
+      cygpath_perror ("write failed");
+      goto error;
+    }
+  /* Flush the output.  (We cannot set the stream into line-buffered
+     mode with setvbuf because Windows treats _IOLBF as a synonym for
+     _IOFBF.)  */
+  if (fflush (cygpath_in))
+    cygpath_perror ("flush failed");
+  /* Read the output.  */
+  ok = true;
+  while (1)
+    {
+      size_t pathlen;
+      if (!fgets (win32_path, MAX_PATH, cygpath_out))
+	{
+	  if (ferror (cygpath_out))
+	    cygpath_perror ("read failed");
+	  else
+	    {
+	      cygpath_log_msg ("error: EOF");
+	      /* Unfortunately, cygpath sometimes crashes for no
+		 apparent reason.  We give it two chances... */
+	      if (!retrying)
+		{
+		  retrying = true;
+		  cygpath_log_msg ("retrying");
+		  cygpath_close ();
+		  cygpath_initialized = 0;
+		  goto retry;
+		}
+	    }
+	  goto error;
+	}
+      pathlen = strlen (win32_path);
+      if (pathlen == 0 && ok)
+	/* This isn't a well-formed response from cygpath.  */
+	goto error;
+      if (win32_path[pathlen - 1] == '\n')
+	{
+	  win32_path[pathlen - 1] = '\0';
+	  cygpath_log_msg_arg ("<- %s", win32_path);
+	  break;
+	}
+      /* We didn't reach the end of the line.  There's no point in
+	 trying to use this output, since we know the length of
+	 paths are limited to MAX_PATH characters, but we read the
+	 entire line so that we are still in sync with
+	 cygpath.  */
+      ok = false;
+      if (cygpath_log)
+	cygpath_log_msg_arg ("error: invalid response: %s",
+			     win32_path);
+    }
+  
+  return ok;
+  
+ error:
+  cygpath_close();
+  return false;
+}
+
+/* Returns the handle for the MVCRT DLL, or NULL if it is not
+   available.  */
+static HMODULE
+msvcrt_dll (void)
+{
+  static HMODULE dll = (HMODULE)(-1);
+
+  /* After we call LoadLibrary, DLL will be either a valid handle or
+     NULL, so this check ensures that we only try to load the library
+     once.  */
+  if (dll == (HMODULE)(-1))
+    dll = LoadLibrary ("msvcrt.dll");
+
+  return dll;
+}
+
+/* Call the underlying MSVCRT fopen with PATH and MODE, and return
+   what it returns.  */
+static FILE *
+msvcrt_fopen (const char *path, const char *mode)
+{
+  typedef FILE *(fopen_type)(const char *path, 
+			     const char *mode);
+
+  static fopen_type *f = NULL;
+
+  /* Get the address of "fopen".  */
+  if (!f) 
+    {
+      HMODULE dll = msvcrt_dll ();
+      if (!dll)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+      f = (fopen_type *) GetProcAddress (dll, "fopen");
+      if (!f)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+    }
+
+  /* Call fopen.  */
+  return (*f)(path, mode);
+}
+
+FILE *
+fopen (const char *path, const char *mode)
+{
+  FILE *f;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  f = msvcrt_fopen (path, mode);
+  if (f || errno != ENOENT)
+    return f;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    f = msvcrt_fopen (win32_path, mode);
+  return f;
+}
+
+int 
+open (const char *path, int oflag, ...)
+{
+  int fd;
+  char win32_path[MAX_PATH + 1];
+  int pmode = 0;
+
+  if ((oflag & _O_CREAT))
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      pmode = va_arg (ap, int); 
+      va_end (ap);
+    }
+
+  /* Assume PATH is a Windows path.  */
+  fd = _open (path, oflag, pmode);
+  if (fd != -1 || errno != ENOENT)
+    return fd;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    fd = _open (win32_path, oflag, pmode);
+  return fd;
+}
+
+int
+stat (const char *path, struct stat *buffer)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  r = _stat (path, (struct _stat *) buffer);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = _stat (win32_path, (struct _stat *) buffer);
+  return r;
+}
+
+int
+access (const char *path, int mode)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+#ifdef _WIN32
+  /* Some GNU tools mistakenly defined X_OK to 1 on Windows.  */
+  mode = mode & ~1;
+#endif
+  /* Assume PATH is a Windows path.  */
+  r = _access (path, mode);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = _access (win32_path, mode);
+  return r;
+}
+
+/* Given the WINDOWS_CODE (typically the result of GetLastError), set
+   ERRNO to the corresponding error code.  If there is no obvious
+   correspondence, ERRNO will be set to EACCES.  */
+static void
+set_errno_from_windows_code (DWORD windows_code)
+{
+  int mapping[][2] = {
+    {ERROR_ACCESS_DENIED, EACCES},
+    {ERROR_ACCOUNT_DISABLED, EACCES},
+    {ERROR_ACCOUNT_RESTRICTION, EACCES},
+    {ERROR_ALREADY_ASSIGNED, EBUSY},
+    {ERROR_ALREADY_EXISTS, EEXIST},
+    {ERROR_ARITHMETIC_OVERFLOW, ERANGE},
+    {ERROR_BAD_COMMAND, EIO},
+    {ERROR_BAD_DEVICE, ENODEV},
+    {ERROR_BAD_DRIVER_LEVEL, ENXIO},
+    {ERROR_BAD_EXE_FORMAT, ENOEXEC},
+    {ERROR_BAD_FORMAT, ENOEXEC},
+    {ERROR_BAD_LENGTH, EINVAL},
+    {ERROR_BAD_PATHNAME, ENOENT},
+    {ERROR_BAD_PIPE, EPIPE},
+    {ERROR_BAD_UNIT, ENODEV},
+    {ERROR_BAD_USERNAME, EINVAL},
+    {ERROR_BROKEN_PIPE, EPIPE},
+    {ERROR_BUFFER_OVERFLOW, ENOMEM},
+    {ERROR_BUSY, EBUSY},
+    {ERROR_BUSY_DRIVE, EBUSY},
+    {ERROR_CALL_NOT_IMPLEMENTED, ENOSYS},
+    {ERROR_CRC, EIO},
+    {ERROR_CURRENT_DIRECTORY, EINVAL},
+    {ERROR_DEVICE_IN_USE, EBUSY},
+    {ERROR_DIR_NOT_EMPTY, EEXIST},
+    {ERROR_DIRECTORY, ENOENT},
+    {ERROR_DISK_CHANGE, EIO},
+    {ERROR_DISK_FULL, ENOSPC},
+    {ERROR_DRIVE_LOCKED, EBUSY},
+    {ERROR_ENVVAR_NOT_FOUND, EINVAL},
+    {ERROR_EXE_MARKED_INVALID, ENOEXEC},
+    {ERROR_FILE_EXISTS, EEXIST},
+    {ERROR_FILE_INVALID, ENODEV},
+    {ERROR_FILE_NOT_FOUND, ENOENT},
+    {ERROR_FILENAME_EXCED_RANGE, ENAMETOOLONG},
+    {ERROR_GEN_FAILURE, EIO},
+    {ERROR_HANDLE_DISK_FULL, ENOSPC},
+    {ERROR_INSUFFICIENT_BUFFER,  ENOMEM},
+    {ERROR_INVALID_ACCESS, EINVAL},
+    {ERROR_INVALID_ADDRESS, EFAULT},
+    {ERROR_INVALID_BLOCK, EFAULT},
+    {ERROR_INVALID_DATA, EINVAL},
+    {ERROR_INVALID_DRIVE, ENODEV},
+    {ERROR_INVALID_EXE_SIGNATURE,  ENOEXEC},
+    {ERROR_INVALID_FLAGS, EINVAL},
+    {ERROR_INVALID_FUNCTION,  ENOSYS},
+    {ERROR_INVALID_HANDLE, EBADF},
+    {ERROR_INVALID_LOGON_HOURS,  EACCES},
+    {ERROR_INVALID_NAME, ENOENT},
+    {ERROR_INVALID_OWNER, EINVAL},
+    {ERROR_INVALID_PARAMETER, EINVAL},
+    {ERROR_INVALID_PASSWORD, EPERM},
+    {ERROR_INVALID_PRIMARY_GROUP, EINVAL},
+    {ERROR_INVALID_SIGNAL_NUMBER, EINVAL},
+    {ERROR_INVALID_TARGET_HANDLE, EIO},
+    {ERROR_INVALID_WORKSTATION, EACCES},
+    {ERROR_IO_DEVICE, EIO},
+    {ERROR_IO_INCOMPLETE, EINTR},
+    {ERROR_LOCKED, EBUSY},
+    {ERROR_LOGON_FAILURE, EACCES},
+    {ERROR_MAPPED_ALIGNMENT, EINVAL},
+    {ERROR_META_EXPANSION_TOO_LONG, E2BIG},
+    {ERROR_MORE_DATA, EPIPE},
+    {ERROR_NEGATIVE_SEEK, ESPIPE},
+    {ERROR_NO_DATA, EPIPE},
+    {ERROR_NO_MORE_SEARCH_HANDLES, EIO},
+    {ERROR_NO_PROC_SLOTS, EAGAIN},
+    {ERROR_NO_SUCH_PRIVILEGE, EACCES},
+    {ERROR_NOACCESS, EFAULT},
+    {ERROR_NONE_MAPPED, EINVAL},
+    {ERROR_NOT_ENOUGH_MEMORY, ENOMEM},
+    {ERROR_NOT_READY, ENODEV},
+    {ERROR_NOT_SAME_DEVICE, EXDEV},
+    {ERROR_OPEN_FAILED, EIO},
+    {ERROR_OPERATION_ABORTED, EINTR},
+    {ERROR_OUTOFMEMORY,  ENOMEM},
+    {ERROR_PASSWORD_EXPIRED, EACCES},
+    {ERROR_PATH_BUSY,  EBUSY},
+    {ERROR_PATH_NOT_FOUND, ENOTDIR},
+    {ERROR_PIPE_BUSY, EBUSY},
+    {ERROR_PIPE_CONNECTED, EPIPE},
+    {ERROR_PIPE_LISTENING, EPIPE},
+    {ERROR_PIPE_NOT_CONNECTED, EPIPE},
+    {ERROR_PRIVILEGE_NOT_HELD, EACCES},
+    {ERROR_READ_FAULT, EIO},
+    {ERROR_SEEK, ESPIPE},
+    {ERROR_SEEK_ON_DEVICE, ESPIPE},
+    {ERROR_SHARING_BUFFER_EXCEEDED, ENFILE},
+    {ERROR_STACK_OVERFLOW, ENOMEM},
+    {ERROR_SWAPERROR, ENOENT},
+    {ERROR_TOO_MANY_MODULES, EMFILE},
+    {ERROR_TOO_MANY_OPEN_FILES, EMFILE},
+    {ERROR_UNRECOGNIZED_MEDIA,  ENXIO},
+    {ERROR_UNRECOGNIZED_VOLUME,  ENODEV},
+    {ERROR_WAIT_NO_CHILDREN,  ECHILD},
+    {ERROR_WRITE_FAULT, EIO},
+    {ERROR_WRITE_PROTECT, EROFS}
+/*  MinGW does not define ETXTBSY as yet.  
+    {ERROR_LOCK_VIOLATION, ETXTBSY},
+    {ERROR_SHARING_VIOLATION, ETXTBSY}, 
+*/
+  };
+
+  size_t i;
+
+  for (i = 0; i < sizeof (mapping)/sizeof (mapping[0]); ++i)
+    if (mapping[i][0] == windows_code)
+      {
+	errno = mapping[i][1];
+	return;
+      }
+
+  /* Unrecognized error. Use EACCESS to have some error code,
+     not misleading "No error" thing.  */
+  errno = EACCES;      
+}
+
+int rename (const char *oldpath, const char *newpath)
+{
+  BOOL r;
+  int oldpath_converted = 0;
+  char win32_oldpath[MAX_PATH + 1];
+  char win32_newpath[MAX_PATH + 1];
+
+  /* Older versions of the cygpath program called FindFirstFile, but
+     not FindClose.  As a result, a long-running cygpath program ends
+     up leaking these handles, and, as a result, the Windows kernel
+     will not let us remove or rename things in directories.  Therefore,
+     we kill the child cygpath program now.
+
+     The defect in cygpath was corrected by this patch:
+
+       http://cygwin.com/ml/cygwin-patches/2007-q1/msg00033.html
+
+     but older versions of cygpath will be in use for the forseeable
+     future.  */
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume all paths are Windows paths.  */
+  r = MoveFileEx (oldpath, newpath, MOVEFILE_REPLACE_EXISTING);
+  if (r)
+      return 0;
+  else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+    goto error;
+
+  /* Perhaps the old path is a cygwin path?  */
+  if (cygpath (oldpath, win32_oldpath))
+    {
+      oldpath_converted = 1;
+      r = MoveFileEx (win32_oldpath, newpath, MOVEFILE_REPLACE_EXISTING);      
+      if (r)
+          return 0;
+      else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+          goto error;
+    }
+
+  /* Perhaps the new path is a cygwin path?  */
+  if (cygpath (newpath, win32_newpath))
+    {
+      r = MoveFileEx (oldpath_converted ? win32_oldpath : oldpath,
+		      win32_newpath, MOVEFILE_REPLACE_EXISTING);
+      if (r == TRUE)
+	return 0;
+    }
+error:
+  set_errno_from_windows_code (GetLastError ());
+  return -1;      
+}
+
+int remove (const char *pathname)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume PATH is a Windows path.  */
+  r = _unlink (pathname);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (pathname, win32_path))
+    r = _unlink (win32_path);
+  return r;
+}
+
+int unlink(const char *pathname)
+{
+    return remove (pathname);
+}
+
+int
+chdir (const char *path)
+{
+  int ret;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  ret = _chdir (path);
+  if (ret != -1 || errno != ENOENT)
+    return ret;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    ret = _chdir (win32_path);
+  return ret;
+}
--- a/libiberty/make-temp-file.c
+++ b/libiberty/make-temp-file.c
@@ -36,6 +36,9 @@ Boston, MA 02110-1301, USA.  */
 #ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
 #endif
+#if defined(_WIN32) && !defined(__CYGWIN__)
+#include <windows.h>
+#endif
 
 #ifndef R_OK
 #define R_OK 4
@@ -56,6 +59,8 @@ extern int mkstemps (char *, int);
 #define TEMP_FILE "ccXXXXXX"
 #define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)
 
+#if !defined(_WIN32) || defined(__CYGWIN__)
+
 /* Subroutine of choose_tmpdir.
    If BASE is non-NULL, return it.
    Otherwise it checks if DIR is a usable directory.
@@ -81,6 +86,8 @@ static const char usrtmp[] =
 static const char vartmp[] =
 { DIR_SEPARATOR, 'v', 'a', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };
 
+#endif
+
 static char *memoized_tmpdir;
 
 /*
@@ -97,40 +104,58 @@ files in.
 char *
 choose_tmpdir (void)
 {
-  const char *base = 0;
-  char *tmpdir;
-  unsigned int len;
-
-  if (memoized_tmpdir)
-    return memoized_tmpdir;
-
-  base = try_dir (getenv ("TMPDIR"), base);
-  base = try_dir (getenv ("TMP"), base);
-  base = try_dir (getenv ("TEMP"), base);
-
+  if (!memoized_tmpdir)
+    {
+#if !defined(_WIN32) || defined(__CYGWIN__)
+      const char *base = 0;
+      char *tmpdir;
+      unsigned int len;
+      
+      base = try_dir (getenv ("TMPDIR"), base);
+      base = try_dir (getenv ("TMP"), base);
+      base = try_dir (getenv ("TEMP"), base);
+      
 #ifdef P_tmpdir
-  base = try_dir (P_tmpdir, base);
+      base = try_dir (P_tmpdir, base);
 #endif
 
-  /* Try /var/tmp, /usr/tmp, then /tmp.  */
-  base = try_dir (vartmp, base);
-  base = try_dir (usrtmp, base);
-  base = try_dir (tmp, base);
- 
-  /* If all else fails, use the current directory!  */
-  if (base == 0)
-    base = ".";
-
-  /* Append DIR_SEPARATOR to the directory we've chosen
-     and return it.  */
-  len = strlen (base);
-  tmpdir = XNEWVEC (char, len + 2);
-  strcpy (tmpdir, base);
-  tmpdir[len] = DIR_SEPARATOR;
-  tmpdir[len+1] = '\0';
+      /* Try /var/tmp, /usr/tmp, then /tmp.  */
+      base = try_dir (vartmp, base);
+      base = try_dir (usrtmp, base);
+      base = try_dir (tmp, base);
+      
+      /* If all else fails, use the current directory!  */
+      if (base == 0)
+	base = ".";
+      /* Append DIR_SEPARATOR to the directory we've chosen
+	 and return it.  */
+      len = strlen (base);
+      tmpdir = XNEWVEC (char, len + 2);
+      strcpy (tmpdir, base);
+      tmpdir[len] = DIR_SEPARATOR;
+      tmpdir[len+1] = '\0';
+      memoized_tmpdir = tmpdir;
+#else /* defined(_WIN32) && !defined(__CYGWIN__) */
+      DWORD len;
+
+      /* Figure out how much space we need.  */
+      len = GetTempPath(0, NULL);
+      if (len)
+	{
+	  memoized_tmpdir = XNEWVEC (char, len);
+	  if (!GetTempPath(len, memoized_tmpdir))
+	    {
+	      XDELETEVEC (memoized_tmpdir);
+	      memoized_tmpdir = NULL;
+	    }
+	}
+      if (!memoized_tmpdir)
+	/* If all else fails, use the current directory.  */
+	memoized_tmpdir = xstrdup (".\\");
+#endif /* defined(_WIN32) && !defined(__CYGWIN__) */
+    }
 
-  memoized_tmpdir = tmpdir;
-  return tmpdir;
+  return memoized_tmpdir;
 }
 
 /*
--- a/libiberty/pex-win32.c
+++ b/libiberty/pex-win32.c
@@ -119,7 +119,7 @@ static int
 pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
 		     int binary)
 {
-  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
+  return open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
 }
 
 /* Open a file for writing.  */
@@ -130,10 +130,10 @@ pex_win32_open_write (struct pex_obj *ob
 {
   /* Note that we can't use O_EXCL here because gcc may have already
      created the temporary file via make_temp_file.  */
-  return _open (name,
-		(_O_WRONLY | _O_CREAT | _O_TRUNC
-		 | (binary ? _O_BINARY : _O_TEXT)),
-		_S_IREAD | _S_IWRITE);
+  return open (name,
+	       (_O_WRONLY | _O_CREAT | _O_TRUNC
+		| (binary ? _O_BINARY : _O_TEXT)),
+	       _S_IREAD | _S_IWRITE);
 }
 
 /* Close a file.  */
--- a/opcodes/arm-dis.c
+++ b/opcodes/arm-dis.c
@@ -4041,7 +4041,9 @@ print_insn (bfd_vma pc, struct disassemb
 	     for a preceeding one.  */
 	  for (; n >= 0; n--)
 	    {
-	      if (get_sym_code_type (info, n, &type))
+	      if ((info->section == NULL
+		   || info->section == info->symtab[n]->section)
+		  && get_sym_code_type (info, n, &type))
 		{
 		  last_sym = n;
 		  found = TRUE;
--- a/opcodes/m68k-opc.c
+++ b/opcodes/m68k-opc.c
@@ -2025,7 +2025,9 @@ const struct m68k_opcode m68k_opcodes[] 
 
 {"sbcd", 2,	one(0100400),		one(0170770), "DsDd", m68000up },
 {"sbcd", 2,	one(0100410),		one(0170770), "-s-d", m68000up },
-
+  
+{"stldsr", 6,   two(0x40e7, 0x46fc),    two(0xffff, 0xffff), "#w", mcfisa_c },
+  
   /* Traps have to come before conditional sets, as they have a more
      specific opcode.  */
 {"trapcc", 2,	one(0052374),	one(0177777), "", m68020up | cpu32 | fido_a },
--- a/opcodes/mips-dis.c
+++ b/opcodes/mips-dis.c
@@ -38,6 +38,9 @@
 #include "elf/mips.h"
 #endif
 
+/* Generate Octeon unaligned load and store instructions. */
+int octeon_use_unalign = 1;
+
 /* Mips instructions are at maximum this many bytes long.  */
 #define INSNLEN 4
 
@@ -319,6 +322,36 @@ static const struct mips_cp0sel_name mip
   { 29, 3, "c0_datahi_d"	},
 };
 
+static const char * const mips_cp0_names_octeon[32] = {
+  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
+  "c0_context",   "c0_pagemask",  "c0_wired",     "c0_hwrena",
+  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
+  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
+  "c0_config",    "$17",          "c0_watchlo",   "c0_watchhi",
+  "c0_xcontext",  "$21",          "c0_mdebug",    "c0_debug",
+  "c0_depc",      "c0_perfcnt",   "$26",          "c0_cacheerr",
+  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave", 
+};
+
+static const struct mips_cp0sel_name mips_cp0sel_names_octeon[] = {
+  { 5,  1, "c0_pagegrain"		},
+  { 9,  6, "c0_cvmcount"		},
+  { 9,  7, "c0_cvmctl"			},
+  { 11, 7, "c0_cvmmemctl"		},
+  { 12, 1, "c0_intctl"			},
+  { 12, 2, "c0_srsctl"			},
+  { 15, 1, "c0_ebase"			},
+  { 16, 1, "c0_config1",		},
+  { 16, 2, "c0_config2",		},
+  { 16, 3, "c0_config3",		},
+  { 18, 1, "c0_watchlo,1"		},
+  { 19, 1, "c0_watchhi,1"		},
+  { 25, 2, "c0_perfcnt,2"		},
+  { 27, 1, "c0_cacheerr,1"		},
+  { 28, 3, "c0_datalo"			},
+  { 29, 3, "c0_datahi"			},
+};
+
 /* Xlr cop0 register names.  */
 static const char * const mips_cp0_names_xlr[32] = {
   "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
@@ -513,8 +546,9 @@ const struct mips_arch_choice mips_arch_
     NULL, 0, mips_hwr_names_numeric },
 
   { "octeon",   1, bfd_mach_mips_octeon, CPU_OCTEON,
-    ISA_MIPS64R2 | INSN_OCTEON, mips_cp0_names_numeric, NULL, 0,
-    mips_hwr_names_numeric },
+    ISA_MIPS64R2 | INSN_OCTEON, mips_cp0_names_octeon, 
+    mips_cp0sel_names_octeon, ARRAY_SIZE (mips_cp0sel_names_octeon), 
+    mips_hwr_names_numeric }, 
 
   { "xlr", 1, bfd_mach_mips_xlr, CPU_XLR,
     ISA_MIPS64 | INSN_XLR,
@@ -676,7 +710,17 @@ parse_mips_dis_option (const char *optio
       no_aliases = 1;
       return;
     }
-  
+  if (strcmp ("octeon-useun", option) == 0)
+    {
+      octeon_use_unalign = 1;
+      return;
+    }
+  if (strcmp ("no-octeon-useun", option) == 0)
+    {
+      octeon_use_unalign = 0;
+      return;
+    }
+
   /* Look for the = that delimits the end of the option name.  */
   for (i = 0; i < len; i++)
     if (option[i] == '=')
@@ -1401,6 +1445,27 @@ print_insn_mips (bfd_vma memaddr,
 		  && strcmp (op->name, "jalx"))
 		continue;
 
+	      if (info->mach == CPU_OCTEON && octeon_use_unalign)
+	        {
+	          if (strcmp (op->name, "lwl") == 0
+	              || strcmp (op->name, "ldl") == 0
+	              || strcmp (op->name, "swl") == 0
+	              || strcmp (op->name, "sdl") == 0
+		      || strcmp (op->name, "lcache") == 0
+		      || strcmp (op->name, "scache") == 0
+		      || strcmp (op->name, "flush") == 0)
+		    continue;
+
+	          if (strcmp (op->name, "ldr") == 0
+		       || strcmp (op->name, "lwr") == 0
+		       || strcmp (op->name, "swr") == 0
+		       || strcmp (op->name, "sdr") == 0)
+		    {
+	      	      (*info->fprintf_func) (info->stream, "nop");
+		      return INSNLEN;
+		    }
+	        }
+
 	      /* Figure out instruction type and branch delay information.  */
 	      if ((op->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
 	        {
@@ -2175,6 +2240,12 @@ The following MIPS specific disassembler
 with the -M switch (multiple options should be separated by commas):\n"));
 
   fprintf (stream, _("\n\
+  octeon-useun             Disassemble Octeon unaligned load/store instructions.\n"));
+
+  fprintf (stream, _("\n\
+  no-octeon-useun          Disassemble mips unaligned load/store instructions.\n"));
+
+  fprintf (stream, _("\n\
   gpr-names=ABI            Print GPR names according to  specified ABI.\n\
                            Default: based on binary being disassembled.\n"));
 
--- a/opcodes/mips-opc.c
+++ b/opcodes/mips-opc.c
@@ -188,8 +188,8 @@ const struct mips_opcode mips_builtin_op
 {"pref",    "k,o(b)",   0xcc000000, 0xfc000000, RD_b,           	0,		I4_32|G3	},
 {"prefx",   "h,t(b)",	0x4c00000f, 0xfc0007ff, RD_b|RD_t|FP_S,		0,		I4_33	},
 {"nop",     "",         0x00000000, 0xffffffff, 0,              	INSN2_ALIAS,	I1      }, /* sll */
-{"ssnop",   "",         0x00000040, 0xffffffff, 0,              	INSN2_ALIAS,	I32|N55	}, /* sll */
-{"ehb",     "",         0x000000c0, 0xffffffff, 0,              	INSN2_ALIAS,	I33	}, /* sll */
+{"ssnop",   "",         0x00000040, 0xffffffff, 0,              	INSN2_ALIAS,	I1	}, /* sll */
+{"ehb",     "",         0x000000c0, 0xffffffff, 0,              	INSN2_ALIAS,	I32	}, /* sll */
 {"li",      "t,j",      0x24000000, 0xffe00000, WR_t,			INSN2_ALIAS,	I1	}, /* addiu */
 {"li",	    "t,i",	0x34000000, 0xffe00000, WR_t,			INSN2_ALIAS,	I1	}, /* ori */
 {"li",      "t,I",	0,    (int) M_LI,	INSN_MACRO,		0,		I1	},
@@ -739,7 +739,7 @@ const struct mips_opcode mips_builtin_op
    assembler, but will never match user input (because the line above
    will match first).  */
 {"jal",     "a",	0x0c000000, 0xfc000000,	UBD|WR_31,		0,		I1	},
-{"jalx",    "a",	0x74000000, 0xfc000000, UBD|WR_31,		0,		I16     },
+{"jalx",    "a",	0x74000000, 0xfc000000, UBD|WR_31,		0,		I1      },
 {"la",      "t,A(b)",	0,    (int) M_LA_AB,	INSN_MACRO,		0,		I1	},
 {"lb",      "t,o(b)",	0x80000000, 0xfc000000,	LDD|RD_b|WR_t,		0,		I1	},
 {"lb",      "t,A(b)",	0,    (int) M_LB_AB,	INSN_MACRO,		0,		I1	},
@@ -1170,6 +1170,11 @@ const struct mips_opcode mips_builtin_op
 {"rzu.ob",  "X,Q",	0x78000020, 0xfc20f83f,	WR_D|RD_T|FP_D,		RD_MACC,	MX|SB1	},
 {"rzu.ob",  "D,k",	0x4bc00020, 0xffe0f83f,	WR_D|RD_S|RD_T,		0,		N54	},
 {"rzu.qh",  "X,Q",	0x78200020, 0xfc20f83f,	WR_D|RD_T|FP_D,		RD_MACC,	MX	},
+/* 58xx specific instructions.  */
+{"saa",	   "t,(b)",     0x70000018, 0xfc00ffff, SM|RD_t|RD_b,		0,		IOCT	},
+{"saa",	   "t,A(b)",     0,    (int) M_SAA_AB,   INSN_MACRO,		0,		IOCT	},
+{"saad",   "t,(b)",     0x70000019, 0xfc00ffff, SM|RD_t|RD_b,		0,		IOCT	},
+{"saad",   "t,A(b)",     0,    (int) M_SAAD_AB,  INSN_MACRO,		0,		IOCT	},
 {"sb",      "t,o(b)",	0xa0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I1	},
 {"sb",      "t,A(b)",	0,    (int) M_SB_AB,	INSN_MACRO,		0,		I1	},
 {"sc",	    "t,o(b)",	0xe0000000, 0xfc000000, SM|RD_t|WR_t|RD_b,	0,		I2	},
@@ -1334,7 +1339,9 @@ const struct mips_opcode mips_builtin_op
 {"invalidate", "t,o(b)",0xb8000000, 0xfc000000,	RD_t|RD_b,		0,		I2	}, /* same */
 {"invalidate", "t,A(b)",0,    (int) M_SWR_AB,	INSN_MACRO,		0,		I2	}, /* as swr */
 {"swxc1",   "S,t(b)",   0x4c000008, 0xfc0007ff, SM|RD_S|RD_t|RD_b|FP_S,	0,		I4_33	},
+{"syncio",  "",         0x0000004f, 0xffffffff, INSN_SYNC,		0,		IOCT	},
 {"synciobdma", "",	0x0000008f, 0xffffffff,	INSN_SYNC,		0,		IOCT	},
+{"syncioall", "",       0x000000cf, 0xffffffff, INSN_SYNC,		0,		IOCT	},
 {"syncs",   "",		0x0000018f, 0xffffffff,	INSN_SYNC,		0,		IOCT	},
 {"syncw",   "",		0x0000010f, 0xffffffff,	INSN_SYNC,		0,		IOCT	},
 {"syncws",  "",		0x0000014f, 0xffffffff,	INSN_SYNC,		0,		IOCT	},
@@ -1387,18 +1394,22 @@ const struct mips_opcode mips_builtin_op
 {"trunc.w.s", "D,S",	0x4600000d, 0xffff003f,	WR_D|RD_S|FP_S,		0,		I2	},
 {"trunc.w.s", "D,S,x",	0x4600000d, 0xffff003f,	WR_D|RD_S|FP_S,		0,		I2	},
 {"trunc.w.s", "D,S,t",	0,    (int) M_TRUNCWS,	INSN_MACRO,		INSN2_M_FP_S,	I1	},
+{"uld",     "t,o(b)",   0x68000000, 0xfc000000, LDD|WR_t|RD_b,		0,		IOCT	},
 {"uld",     "t,o(b)",	0,    (int) M_ULD,	INSN_MACRO,		0,		I3	},
 {"uld",     "t,A(b)",	0,    (int) M_ULD_A,	INSN_MACRO,		0,		I3	},
 {"ulh",     "t,o(b)",	0,    (int) M_ULH,	INSN_MACRO,		0,		I1	},
 {"ulh",     "t,A(b)",	0,    (int) M_ULH_A,	INSN_MACRO,		0,		I1	},
 {"ulhu",    "t,o(b)",	0,    (int) M_ULHU,	INSN_MACRO,		0,		I1	},
 {"ulhu",    "t,A(b)",	0,    (int) M_ULHU_A,	INSN_MACRO,		0,		I1	},
+{"ulw",     "t,o(b)",   0x88000000, 0xfc000000, LDD|RD_b|WR_t,		0,		IOCT	},
 {"ulw",     "t,o(b)",	0,    (int) M_ULW,	INSN_MACRO,		0,		I1	},
 {"ulw",     "t,A(b)",	0,    (int) M_ULW_A,	INSN_MACRO,		0,		I1	},
+{"usd",     "t,o(b)",   0xb0000000, 0xfc000000, SM|RD_t|RD_b,		0,		IOCT	},
 {"usd",     "t,o(b)",	0,    (int) M_USD,	INSN_MACRO,		0,		I3	},
 {"usd",     "t,A(b)",	0,    (int) M_USD_A,	INSN_MACRO,		0,		I3	},
 {"ush",     "t,o(b)",	0,    (int) M_USH,	INSN_MACRO,		0,		I1	},
 {"ush",     "t,A(b)",	0,    (int) M_USH_A,	INSN_MACRO,		0,		I1	},
+{"usw",     "t,o(b)",   0xa8000000, 0xfc000000, SM|RD_t|RD_b,		0,		IOCT	},
 {"usw",     "t,o(b)",	0,    (int) M_USW,	INSN_MACRO,		0,		I1	},
 {"usw",     "t,A(b)",	0,    (int) M_USW_A,	INSN_MACRO,		0,		I1	},
 {"v3mulu",  "d,v,t",	0x70000011, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		IOCT	},
--- a/opcodes/ppc-opc.c
+++ b/opcodes/ppc-opc.c
@@ -3377,6 +3377,11 @@ const struct powerpc_opcode powerpc_opco
 
 {"isellt",	X(31,15),	X_MASK,      PPCISEL,	PPCNONE,	{RT, RA, RB}},
 
+{"tlbilxlpid",	XTO(31,18,0),	XTO_MASK,    E500MC,	PPCNONE,	{0}},
+{"tlbilxpid",	XTO(31,18,1),	XTO_MASK,    E500MC,	PPCNONE,	{0}},
+{"tlbilxva",	XTO(31,18,3),	XTO_MASK,    E500MC,	PPCNONE,	{RA0, RB}},
+{"tlbilx",	X(31,18),	X_MASK,      E500MC,	PPCNONE,	{T, RA0, RB}},
+
 {"mfcr",	XFXM(31,19,0,0), XRARB_MASK, COM,	POWER4,		{RT}},
 {"mfcr",	XFXM(31,19,0,0), XFXFXM_MASK, POWER4,	PPCNONE,	{RT, FXM4}},
 {"mfocrf",	XFXM(31,19,0,1), XFXFXM_MASK, COM,	PPCNONE,	{RT, FXM}},
@@ -4416,10 +4421,6 @@ const struct powerpc_opcode powerpc_opco
 {"caxo.",	XO(31,266,1,1),	XO_MASK,     PWRCOM,	PPCNONE,	{RT, RA, RB}},
 
 {"tlbivax",	X(31,786),	XRT_MASK,    BOOKE,	PPCNONE,	{RA, RB}},
-{"tlbilx",	X(31,787),	X_MASK,      E500MC,	PPCNONE,	{T, RA0, RB}},
-{"tlbilxlpid",	XTO(31,787,0),	XTO_MASK,    E500MC,	PPCNONE,	{0}},
-{"tlbilxpid",	XTO(31,787,1),	XTO_MASK,    E500MC,	PPCNONE,	{0}},
-{"tlbilxva",	XTO(31,787,3),	XTO_MASK,    E500MC,	PPCNONE,	{RA0, RB}},
 
 {"lwzcix",	X(31,789),	X_MASK,      POWER6,	PPCNONE,	{RT, RA0, RB}},
 
